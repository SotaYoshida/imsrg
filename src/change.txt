diff --git a/src/Commutator.cc b/src/Commutator.cc
index 3bc00c5..f5551e7 100644
--- a/src/Commutator.cc
+++ b/src/Commutator.cc
@@ -19,50 +19,54 @@
 /// Commutator expressions for second-quantized operators
 namespace Commutator {
 
-bool use_goose_tank_correction = false;
-bool use_brueckner_bch = false;
-bool use_imsrg3 = false;
-bool only_2b_omega = false;
-bool perturbative_triples = false;
-double bch_transform_threshold = 1e-9;
-double bch_product_threshold = 1e-4;
+  bool use_goose_tank_correction = false;
+  bool use_brueckner_bch = false;
+  bool use_imsrg3 = false;
+  bool use_imsrg3_n7 = false;
+  bool only_2b_omega = false;
+  bool perturbative_triples = false;
+  double bch_transform_threshold = 1e-9;
+  double bch_product_threshold = 1e-4;
 
 
-void Set_BCH_Transform_Threshold(double x)
-{bch_transform_threshold=x;}
+  void Set_BCH_Transform_Threshold(double x)
+  {bch_transform_threshold=x;}
 
-void Set_BCH_Product_Threshold(double x)
-{bch_product_threshold=x;}
+  void Set_BCH_Product_Threshold(double x)
+  {bch_product_threshold=x;}
 
-void SetUseBruecknerBCH(bool tf)
-{use_brueckner_bch = tf;}
+  void SetUseBruecknerBCH(bool tf)
+  {use_brueckner_bch = tf;}
 
-void SetUseGooseTank(bool tf)
-{use_goose_tank_correction = tf;}
+  void SetUseGooseTank(bool tf)
+  {use_goose_tank_correction = tf;}
 
-void SetUseIMSRG3(bool tf)
-{use_imsrg3 = tf;}
+  void SetUseIMSRG3(bool tf)
+  {use_imsrg3 = tf;}
 
-void SetOnly2bOmega(bool tf)
-{only_2b_omega = tf;}
+  void SetUseIMSRG3N7(bool tf)
+  {use_imsrg3_n7 = tf;}
 
-//Operator Operator::Commutator( Operator& opright)
-/// Returns \f$ Z = [X,Y] \f$
-Operator Commutator( const Operator& X, const Operator& Y)
-{
-//  int jrank = std::max(X.rank_J,Y.rank_J);
-//  int trank = std::max(X.rank_T,Y.rank_T);
-//  int parity = (X.parity+Y.parity)%2;
-//  int particlerank = std::max(X.particle_rank,Y.particle_rank);
-  int xrank = X.rank_J + X.rank_T + X.parity;
-  int yrank = Y.rank_J + Y.rank_T + Y.parity;
-  int xlegs = X.GetNumberLegs();
-  int ylegs = Y.GetNumberLegs();
-
-  X.modelspace->PreCalculateSixJ();
-
-  if (xrank==0)
-   {
+  void SetOnly2bOmega(bool tf)
+  {only_2b_omega = tf;}
+
+  //Operator Operator::Commutator( Operator& opright)
+  /// Returns \f$ Z = [X,Y] \f$
+  Operator Commutator( const Operator& X, const Operator& Y)
+  {
+    //  int jrank = std::max(X.rank_J,Y.rank_J);
+    //  int trank = std::max(X.rank_T,Y.rank_T);
+    //  int parity = (X.parity+Y.parity)%2;
+    //  int particlerank = std::max(X.particle_rank,Y.particle_rank);
+    int xrank = X.rank_J + X.rank_T + X.parity;
+    int yrank = Y.rank_J + Y.rank_T + Y.parity;
+    int xlegs = X.GetNumberLegs();
+    int ylegs = Y.GetNumberLegs();
+
+    X.modelspace->PreCalculateSixJ();
+
+    if (xrank==0)
+    {
       if ( (xlegs%2==0) and (ylegs%2==1) )
       {
         return CommutatorScalarDagger(X,Y);
@@ -74,504 +78,459 @@ Operator Commutator( const Operator& X, const Operator& Y)
       if ( (xlegs%2==1) and (ylegs%2==1) )
       {
         std::cout << "TROUBLE!!!! Called commutator with two Dagger operators. This isn't implemented. Dying..." << std::endl;
-	std::exit(EXIT_FAILURE);
+        std::exit(EXIT_FAILURE);
       }
       if (yrank==0)
       {
-         return CommutatorScalarScalar(X,Y); // [S,S]
+        return CommutatorScalarScalar(X,Y); // [S,S]
       }
       else
       {
-         return CommutatorScalarTensor(X,Y); // [S,T]
+        return CommutatorScalarTensor(X,Y); // [S,T]
       }
-   }
-   else if(yrank==0)
-   {
+    }
+    else if(yrank==0)
+    {
       return -CommutatorScalarTensor(Y,X); // [T,S]
-   }
-   else
-   {
+    }
+    else
+    {
       std::cout << "In Tensor-Tensor because X.rank_J = " << X.rank_J << "  X.rank_T = " << X.rank_T << "  X.parity = " << X.parity << "   ";
       std::cout <<                        "  Y.rank_J = " << Y.rank_J << "  Y.rank_T = " << Y.rank_T << "  Y.parity = " << Y.parity << std::endl;
       std::cout << " Tensor-Tensor commutator not yet implemented." << std::endl;
-   }
-   return  0*Y;
-}
+    }
+    return  0*Y;
+  }
 
 
 
 
-/// Commutator where \f$ X \f$ and \f$Y\f$ are scalar operators.
-/// Should be called through Commutator()
-Operator CommutatorScalarScalar( const Operator& X, const Operator& Y) 
-{
-//   std::cout << "Calling CommutatorScalarScalar..." << std::endl;
-   X.profiler.counter["N_ScalarCommutators"] += 1;
-   double t_css = omp_get_wtime();
-   int z_Jrank = std::max( X.GetJRank(),Y.GetJRank());
-   int z_Trank = std::max( X.GetTRank(),Y.GetTRank());
-   int z_parity = (X.GetParity()+Y.GetParity())%2;
-   int z_particlerank = std::max(X.GetParticleRank(),Y.GetParticleRank());
-   if ( use_imsrg3 )  z_particlerank = std::max(z_particlerank, 3);
-   ModelSpace& ms = *(Y.GetModelSpace());
-   Operator Z( ms, z_Jrank, z_Trank, z_parity, z_particlerank );
-//   Operator Z( *(Y.GetModelSpace()), std::max(X.GetJRank(),Y.GetJRank()), std::max(X.GetTRank(),Y.GetTRank()), (X.GetParity()+Y.GetParity())%2, std::max(X.GetParticleRank(),Y.GetParticleRank()) );
-
-   if ( (X.IsHermitian() and Y.IsHermitian()) or (X.IsAntiHermitian() and Y.IsAntiHermitian()) ) Z.SetAntiHermitian();
-   else if ( (X.IsHermitian() and Y.IsAntiHermitian()) or (X.IsAntiHermitian() and Y.IsHermitian()) ) Z.SetHermitian();
-   else Z.SetNonHermitian();
-
-
-   if ( Z.GetParticleRank() > 2 )
-   {
-     Z.ThreeBody.SwitchToPN_and_discard();
-   }
+  /// Commutator where \f$ X \f$ and \f$Y\f$ are scalar operators.
+  /// Should be called through Commutator()
+  Operator CommutatorScalarScalar( const Operator& X, const Operator& Y)
+  {
+    //   std::cout << "Calling CommutatorScalarScalar..." << std::endl;
+    X.profiler.counter["N_ScalarCommutators"] += 1;
+    double t_css = omp_get_wtime();
+    int z_Jrank = std::max( X.GetJRank(),Y.GetJRank());
+    int z_Trank = std::max( X.GetTRank(),Y.GetTRank());
+    int z_parity = (X.GetParity()+Y.GetParity())%2;
+    int z_particlerank = std::max(X.GetParticleRank(),Y.GetParticleRank());
+    if ( use_imsrg3 )  z_particlerank = std::max(z_particlerank, 3);
+    ModelSpace& ms = *(Y.GetModelSpace());
+    Operator Z( ms, z_Jrank, z_Trank, z_parity, z_particlerank );
+    //   Operator Z( *(Y.GetModelSpace()), std::max(X.GetJRank(),Y.GetJRank()), std::max(X.GetTRank(),Y.GetTRank()), (X.GetParity()+Y.GetParity())%2, std::max(X.GetParticleRank(),Y.GetParticleRank()) );
+
+    if ( (X.IsHermitian() and Y.IsHermitian()) or (X.IsAntiHermitian() and Y.IsAntiHermitian()) ) Z.SetAntiHermitian();
+    else if ( (X.IsHermitian() and Y.IsAntiHermitian()) or (X.IsAntiHermitian() and Y.IsHermitian()) ) Z.SetHermitian();
+    else Z.SetNonHermitian();
+
+
+    if ( Z.GetParticleRank() > 2 )
+    {
+      Z.ThreeBody.SwitchToPN_and_discard();
+    }
 
-   if ( not Z.IsAntiHermitian() )
-   {
+    if ( not Z.IsAntiHermitian() )
+    {
       comm110ss(X, Y, Z);
       if (X.particle_rank>1 and Y.particle_rank>1)
         comm220ss(X, Y, Z) ;
-   }
+    }
 
-   double t_start = omp_get_wtime();
-   comm111ss(X, Y, Z);
-   X.profiler.timer["comm111ss"] += omp_get_wtime() - t_start;
+    double t_start = omp_get_wtime();
+    comm111ss(X, Y, Z);
+    X.profiler.timer["comm111ss"] += omp_get_wtime() - t_start;
 
     t_start = omp_get_wtime();
-   comm121ss(X, Y, Z);
-   X.profiler.timer["comm121ss"] += omp_get_wtime() - t_start;
+    comm121ss(X, Y, Z);
+    X.profiler.timer["comm121ss"] += omp_get_wtime() - t_start;
 
     t_start = omp_get_wtime();
-   comm122ss(X, Y, Z); 
-   X.profiler.timer["comm122ss"] += omp_get_wtime() - t_start;
-
+    comm122ss(X, Y, Z);
+    X.profiler.timer["comm122ss"] += omp_get_wtime() - t_start;
 
-   if (X.particle_rank>1 and Y.particle_rank>1)
-   {
-     t_start = omp_get_wtime();
-     comm222_pp_hh_221ss(X, Y, Z);
-     X.profiler.timer["comm222_pp_hh_221ss"] += omp_get_wtime() - t_start;
-      
-     t_start = omp_get_wtime();
-     comm222_phss(X, Y, Z);
-     X.profiler.timer["comm222_phss"] += omp_get_wtime() - t_start;
-   }
-
-//   std::cout << "Made it here. About to check if use_imsrg3 is true" << std::endl;
-//   std::cout << "  scalar3b_transform_first_pass = " << X.modelspace->scalar3b_transform_first_pass << std::endl;
-
-   if (use_imsrg3)
-   {
-       X.profiler.counter["N_ScalarCommutators_3b"] += 1;
-
-       // This gets the perturbative energy from the induced 3 body
-       std::cout << " comm330 " << std::endl;
-       comm330ss(X, Y, Z); // scales as n^6
-
-//     Maybe not so important, but I think relatively cheap
-       std::cout << " comm331 " << std::endl;
-       comm331ss(X, Y, Z); // scales as n^7
-
-//     This one is essential. If it's not here, then there are no induced 3 body terms
-       std::cout << " comm223 " << std::endl;
-       comm223ss(X, Y, Z); // scales as n^7
-//       comm223ss_debug(X, Y, Z); // scales as n^7
-
-//     if (X.GetParticleRank()>2 or Y.GetParticleRank()>2)
-//     {
-       // Demonstrated that this can have some effect
-       std::cout << " comm231 " << std::endl;
-       comm231ss(X, Y, Z);  // scales as n^6
-
-//     no demonstrated effect yet, but it's cheap
-       std::cout << " comm132 " << std::endl;
-       comm132ss(X, Y, Z); // scales as n^6
-
-//     one of the two most important IMSRG(3) terms
-       std::cout << " comm232 " << std::endl;
-       comm232ss(X, Y, Z);   // this is the slowest n^7 term
-//       comm232ss_debug(X, Y, Z);   // this is the slowest n^7 term
-
-//     important for suppressing off-diagonal H3
-       std::cout << " comm133 " << std::endl;
-       comm133ss(X, Y, Z);  // scales as n^7, but really more like n^6
-
-////    Not too bad, though naively n^8
-       std::cout << " comm233_pp_hh " << std::endl;
-       comm233_pp_hhss(X, Y, Z);
-//       comm233_pp_hhss_debug(X, Y, Z);
-//       X.profiler.timer["comm233_pp_hhss"] += omp_get_wtime() - t_start;
-
-//     This one is super slow too. It involves 9js
-//     mat mult makes everything better!
-       std::cout << " comm233_ph " << std::endl;
-       comm233_phss(X, Y, Z);
-//       comm233_phss_debug(X, Y, Z);
-
-//       not too bad, though naively n^8
-       std::cout << " comm332_ppph_hhhp " << std::endl;
-       comm332_ppph_hhhpss(X, Y, Z);
-
-//      naively n^8, but reasonably fast when implemented as a mat mult
-       std::cout << " comm332_pphh " << std::endl;
-       comm332_pphhss(X, Y, Z);
-//       comm332_pphhss_debug(X, Y, Z);
-
-//       naively n^9 but pretty fast as a mat mult
-       std::cout << " comm333_ppp_hhhss " << std::endl;
-       comm333_ppp_hhhss(X, Y, Z);
-
-//     This one works, but it's incredibly slow.  naively n^9.
-//     Much improvement by going to mat mult
-       std::cout << " comm333_pph_hhpss " << std::endl;
-       comm333_pph_hhpss(X, Y, Z);
-//       comm333_pph_hhpss_debug(X, Y, Z);
-
-
-     // after going through once, we've stored all the 6js (and maybe 9js), so we can run in OMP loops from now on
-     X.modelspace->scalar3b_transform_first_pass = false;
-   }
-
-
-   if ( Z.IsHermitian() )
-      Z.Symmetrize();
-   else if (Z.IsAntiHermitian() )
-      Z.AntiSymmetrize();
 
-   X.profiler.timer["CommutatorScalarScalar"] += omp_get_wtime() - t_css;
-   return Z;
+    if (X.particle_rank>1 and Y.particle_rank>1)
+    {
+      t_start = omp_get_wtime();
+      comm222_pp_hh_221ss(X, Y, Z);
+      X.profiler.timer["comm222_pp_hh_221ss"] += omp_get_wtime() - t_start;
 
-}
+      t_start = omp_get_wtime();
+      comm222_phss(X, Y, Z);
+      X.profiler.timer["comm222_phss"] += omp_get_wtime() - t_start;
+    }
 
+    //   std::cout << "Made it here. About to check if use_imsrg3 is true" << std::endl;
+    //   std::cout << "  scalar3b_transform_first_pass = " << X.modelspace->scalar3b_transform_first_pass << std::endl;
 
-/// Commutator \f$[X,Y]\f$ where \f$ X \f$ is a scalar operator and \f$Y\f$ is a tensor operator.
-/// Should be called through Commutator()
-Operator CommutatorScalarTensor( const Operator& X, const Operator& Y) 
-{
-   X.profiler.counter["N_TensorCommutators"] += 1;
-   double t_cst = omp_get_wtime();
-   Operator Z = Y; // This ensures the commutator has the same tensor rank as Y
-   Z.EraseZeroBody();
-   Z.EraseOneBody();
-   Z.EraseTwoBody();
-
-   if ( (X.IsHermitian() and Y.IsHermitian()) or (X.IsAntiHermitian() and Y.IsAntiHermitian()) ) Z.SetAntiHermitian();
-   else if ( (X.IsHermitian() and Y.IsAntiHermitian()) or (X.IsAntiHermitian() and Y.IsHermitian()) ) Z.SetHermitian();
-   else Z.SetNonHermitian();
-
-   double t_start = omp_get_wtime();
-   comm111st(X, Y, Z);
-   X.profiler.timer["comm111st"] += omp_get_wtime() - t_start;
-   t_start = omp_get_wtime();
-   comm121st(X, Y, Z);
-   X.profiler.timer["comm121st"] += omp_get_wtime() - t_start;
-
-   t_start = omp_get_wtime();
-   comm122st(X, Y, Z);
-   X.profiler.timer["comm122st"] += omp_get_wtime() - t_start;
-   t_start = omp_get_wtime();
-   comm222_pp_hh_221st(X, Y, Z);
-   X.profiler.timer["comm222_pp_hh_221st"] += omp_get_wtime() - t_start;
-   t_start = omp_get_wtime();
-   comm222_phst(X, Y, Z);
-   X.profiler.timer["comm222_phst"] += omp_get_wtime() - t_start;
-
-  if (use_imsrg3 and X.GetJRank()==0 and Y.GetJRank()==0 and Z.GetJRank()==0 )
-  {
-    if ( Z.GetParticleRank()<3 )
+    if (use_imsrg3)
     {
-      Z.ThreeBody.SwitchToPN_and_discard();
+      X.profiler.counter["N_ScalarCommutators_3b"] += 1;
+
+      // This gets the perturbative energy from the induced 3 body
+      std::cout << " comm330 " << std::endl;
+      comm330ss(X, Y, Z); // scales as n^6
+
+      //     Maybe not so important, but I think relatively cheap
+      std::cout << " comm331 " << std::endl;
+      comm331ss(X, Y, Z); // scales as n^7
+
+      //     This one is essential. If it's not here, then there are no induced 3 body terms
+      std::cout << " comm223 " << std::endl;
+      comm223ss(X, Y, Z); // scales as n^7
+      //       comm223ss_debug(X, Y, Z); // scales as n^7
+
+      //     if (X.GetParticleRank()>2 or Y.GetParticleRank()>2)
+      //     {
+      // Demonstrated that this can have some effect
+      std::cout << " comm231 " << std::endl;
+      comm231ss(X, Y, Z);  // scales as n^6
+
+      //     no demonstrated effect yet, but it's cheap
+      std::cout << " comm132 " << std::endl;
+      comm132ss(X, Y, Z); // scales as n^6
+
+      //     one of the two most important IMSRG(3) terms
+      std::cout << " comm232 " << std::endl;
+      comm232ss(X, Y, Z);   // this is the slowest n^7 term
+      //       comm232ss_debug(X, Y, Z);   // this is the slowest n^7 term
+
+      //     important for suppressing off-diagonal H3
+      std::cout << " comm133 " << std::endl;
+      comm133ss(X, Y, Z);  // scales as n^7, but really more like n^6
+
+      if ( not use_imsrg3_n7 )
+      {
+        ////    Not too bad, though naively n^8
+        std::cout << " comm233_pp_hh " << std::endl;
+        comm233_pp_hhss(X, Y, Z);
+        //       comm233_pp_hhss_debug(X, Y, Z);
+        //       X.profiler.timer["comm233_pp_hhss"] += omp_get_wtime() - t_start;
+
+        //     This one is super slow too. It involves 9js
+        //     mat mult makes everything better!
+        std::cout << " comm233_ph " << std::endl;
+        comm233_phss(X, Y, Z);
+        //       comm233_phss_debug(X, Y, Z);
+
+        //       not too bad, though naively n^8
+        std::cout << " comm332_ppph_hhhp " << std::endl;
+        comm332_ppph_hhhpss(X, Y, Z);
+
+        //      naively n^8, but reasonably fast when implemented as a mat mult
+        std::cout << " comm332_pphh " << std::endl;
+        comm332_pphhss(X, Y, Z);
+        //       comm332_pphhss_debug(X, Y, Z);
+
+        //       naively n^9 but pretty fast as a mat mult
+        std::cout << " comm333_ppp_hhhss " << std::endl;
+        comm333_ppp_hhhss(X, Y, Z);
+
+        //     This one works, but it's incredibly slow.  naively n^9.
+        //     Much improvement by going to mat mult
+        std::cout << " comm333_pph_hhpss " << std::endl;
+        comm333_pph_hhpss(X, Y, Z);
+        //       comm333_pph_hhpss_debug(X, Y, Z);
+
+      } // if not use_imsrg3_n7
+
+      // after going through once, we've stored all the 6js (and maybe 9js), so we can run in OMP loops from now on
+      X.modelspace->scalar3b_transform_first_pass = false;
     }
-    std::cout << "tensor comm223ss" << std::endl;
-    comm223ss(X,Y,Z);
-    std::cout << "tensor comm232ss" << std::endl;
-    comm232ss_slow(X,Y,Z);
-    std::cout << "tensor comm231ss" << std::endl;
-    comm231ss_slow(X,Y,Z);
-  }
 
 
-   if ( Z.IsHermitian() )
+    if ( Z.IsHermitian() )
       Z.Symmetrize();
-   else if (Z.IsAntiHermitian() )
+    else if (Z.IsAntiHermitian() )
       Z.AntiSymmetrize();
-   X.profiler.timer["CommutatorScalarTensor"] += omp_get_wtime() - t_cst;
-   return Z;
-}
 
+    X.profiler.timer["CommutatorScalarScalar"] += omp_get_wtime() - t_css;
+    return Z;
 
+    }
 
 
-/// Commutator where \f$ X \f$ is a scalar and \f$Y\f$ is a dagger (i.e. it creates an additional particle).
-/// Should be called through Commutator()
-Operator CommutatorScalarDagger( const Operator& X, const Operator& Y) 
-{
-//   std::cout << "Call " << __func__ << std::endl;
-   X.profiler.counter["N_DaggerCommutators"] += 1;
-   double t_css = omp_get_wtime();
-   Operator Z = Y;
-   Z.EraseZeroBody();
-   Z.EraseOneBody();
-   Z.EraseThreeLeg();
-
-//   if ( (X.IsHermitian() and Y.IsHermitian()) or (X.IsAntiHermitian() and Y.IsAntiHermitian()) ) Z.SetAntiHermitian();
-//   else if ( (X.IsHermitian() and Y.IsAntiHermitian()) or (X.IsAntiHermitian() and Y.IsHermitian()) ) Z.SetHermitian();
-//   else Z.SetNonHermitian();
-
-   comm211sd( X, Y, Z ) ; 
-   comm231sd( X, Y, Z ) ;
-   comm413_233sd( X, Y, Z ) ; 
-   comm433_pp_hh_431sd( X, Y, Z ) ; 
-   comm433sd_ph( X, Y, Z ) ; 
-
-   X.profiler.timer["CommutatorScalarDagger"] += omp_get_wtime() - t_css;
-//   std::cout << __func__ <<  " done." << std::endl;
-   return Z;
+    /// Commutator \f$[X,Y]\f$ where \f$ X \f$ is a scalar operator and \f$Y\f$ is a tensor operator.
+    /// Should be called through Commutator()
+    Operator CommutatorScalarTensor( const Operator& X, const Operator& Y)
+    {
+      X.profiler.counter["N_TensorCommutators"] += 1;
+      double t_cst = omp_get_wtime();
+      Operator Z = Y; // This ensures the commutator has the same tensor rank as Y
+      Z.EraseZeroBody();
+      Z.EraseOneBody();
+      Z.EraseTwoBody();
+
+      if ( (X.IsHermitian() and Y.IsHermitian()) or (X.IsAntiHermitian() and Y.IsAntiHermitian()) ) Z.SetAntiHermitian();
+      else if ( (X.IsHermitian() and Y.IsAntiHermitian()) or (X.IsAntiHermitian() and Y.IsHermitian()) ) Z.SetHermitian();
+      else Z.SetNonHermitian();
+
+      double t_start = omp_get_wtime();
+      comm111st(X, Y, Z);
+      X.profiler.timer["comm111st"] += omp_get_wtime() - t_start;
+      t_start = omp_get_wtime();
+      comm121st(X, Y, Z);
+      X.profiler.timer["comm121st"] += omp_get_wtime() - t_start;
+
+      t_start = omp_get_wtime();
+      comm122st(X, Y, Z);
+      X.profiler.timer["comm122st"] += omp_get_wtime() - t_start;
+      t_start = omp_get_wtime();
+      comm222_pp_hh_221st(X, Y, Z);
+      X.profiler.timer["comm222_pp_hh_221st"] += omp_get_wtime() - t_start;
+      t_start = omp_get_wtime();
+      comm222_phst(X, Y, Z);
+      X.profiler.timer["comm222_phst"] += omp_get_wtime() - t_start;
+
+      if (use_imsrg3 and X.GetJRank()==0 and Y.GetJRank()==0 and Z.GetJRank()==0 )
+      {
+        if ( Z.GetParticleRank()<3 )
+        {
+          Z.ThreeBody.SwitchToPN_and_discard();
+        }
+        std::cout << "tensor comm223ss" << std::endl;
+        comm223ss(X,Y,Z);
+        std::cout << "tensor comm232ss" << std::endl;
+        comm232ss_slow(X,Y,Z);
+        std::cout << "tensor comm231ss" << std::endl;
+        comm231ss_slow(X,Y,Z);
+      }
 
-}
 
+      if ( Z.IsHermitian() )
+        Z.Symmetrize();
+      else if (Z.IsAntiHermitian() )
+        Z.AntiSymmetrize();
+      X.profiler.timer["CommutatorScalarTensor"] += omp_get_wtime() - t_cst;
+      return Z;
+    }
 
 
 
 
+    /// Commutator where \f$ X \f$ is a scalar and \f$Y\f$ is a dagger (i.e. it creates an additional particle).
+    /// Should be called through Commutator()
+    Operator CommutatorScalarDagger( const Operator& X, const Operator& Y)
+    {
+      //   std::cout << "Call " << __func__ << std::endl;
+      X.profiler.counter["N_DaggerCommutators"] += 1;
+      double t_css = omp_get_wtime();
+      Operator Z = Y;
+      Z.EraseZeroBody();
+      Z.EraseOneBody();
+      Z.EraseThreeLeg();
+
+      //   if ( (X.IsHermitian() and Y.IsHermitian()) or (X.IsAntiHermitian() and Y.IsAntiHermitian()) ) Z.SetAntiHermitian();
+      //   else if ( (X.IsHermitian() and Y.IsAntiHermitian()) or (X.IsAntiHermitian() and Y.IsHermitian()) ) Z.SetHermitian();
+      //   else Z.SetNonHermitian();
+
+      comm211sd( X, Y, Z ) ;
+      comm231sd( X, Y, Z ) ;
+      comm413_233sd( X, Y, Z ) ;
+      comm433_pp_hh_431sd( X, Y, Z ) ;
+      comm433sd_ph( X, Y, Z ) ;
+
+      X.profiler.timer["CommutatorScalarDagger"] += omp_get_wtime() - t_css;
+      //   std::cout << __func__ <<  " done." << std::endl;
+      return Z;
 
+    }
 
-//*****************************************************************************************
-/// BCH_Transform(X,Y) returns \f$ Z = e^{Y} X e^{-Y} \f$.
-/// We use the [Baker-Campbell-Hausdorff formula](http://en.wikipedia.org/wiki/Baker-Campbell-Hausdorff_formula)
-/// \f[ Z = X + [Y,X] + \frac{1}{2!}[Y,[Y,X]] + \frac{1}{3!}[Y,[Y,[Y,X]]] + \ldots \f]
-/// with all commutators truncated at the two-body level.
-Operator BCH_Transform(  const Operator& OpIn, const Operator& Omega)
-{
-   return use_brueckner_bch ? Brueckner_BCH_Transform( OpIn, Omega ) :  Standard_BCH_Transform( OpIn, Omega );
-}
 
-/// X.BCH_Transform(Y) returns \f$ Z = e^{Y} X e^{-Y} \f$.
-/// We use the [Baker-Campbell-Hausdorff formula](http://en.wikipedia.org/wiki/Baker-Campbell-Hausdorff_formula)
-/// \f[ Z = X + [Y,X] + \frac{1}{2!}[Y,[Y,X]] + \frac{1}{3!}[Y,[Y,[Y,X]]] + \ldots \f]
-/// with all commutators truncated at the two-body level.
-Operator Standard_BCH_Transform( const Operator& OpIn, const Operator &Omega)
-{
-//   std::cout << "!!! " << __func__ << " !!!   particles ranks are " << OpIn.GetParticleRank() << "  and  " << Omega.GetParticleRank() 
-//             << "  PN mode is " << OpIn.ThreeBody.PN_mode << "   and  " << Omega.ThreeBody.PN_mode  << std::endl;
-   double t_start = omp_get_wtime();
-   int max_iter = 40;
-   int warn_iter = 12;
-   double nx = OpIn.Norm();
-   double ny = Omega.Norm();
-   Operator OpOut = OpIn;
-   if (use_imsrg3 and not OpOut.ThreeBody.is_allocated )
-   {
-     OpOut.ThreeBody.Allocate_PN();
-   }
-   double factorial_denom = 1.0;
-   Operator goosetank_chi;  // auxiliary one-body operator used to recover 4th-order quadruples.
-   if (use_goose_tank_correction)
-   {
-     goosetank_chi = OpIn;
-     goosetank_chi.SetParticleRank(1);
-     goosetank_chi.Erase();
-   }
-   if (nx>bch_transform_threshold)
-   {
-     Operator OpNested = OpIn;
-     double epsilon = nx * exp(-2*ny) * bch_transform_threshold / (2*ny);
-     for (int i=1; i<=max_iter; ++i)
-     {
 
-        if (use_goose_tank_correction  )
-        {
-          auto chi_last = goosetank_chi.OneBody;
-          goosetank_chi = GooseTankUpdate( Omega, OpNested);
-          OpNested.OneBody += chi_last;  // add the chi from the previous step to OpNested.
-        }
-        
 
-        OpNested = Commutator(Omega,OpNested); // the ith nested commutator
-        factorial_denom /= i;
-        OpOut += factorial_denom * OpNested;
-  
-        if (OpOut.rank_J > 0)
-        {
-            std::cout << "Tensor BCH, i=" << i << "  Norm = " << std::setw(12) << std::setprecision(8) << std::fixed << OpNested.OneBodyNorm() << " " 
-                                                              << std::setw(12) << std::setprecision(8) << std::fixed << OpNested.TwoBodyNorm() << " "
-                                                              << std::setw(12) << std::setprecision(8) << std::fixed << OpNested.Norm() << std::endl;
-        }
-        epsilon *= i+1;
-        if (OpNested.Norm() < epsilon)  break;
-        if (i == warn_iter)  std::cout << "Warning: BCH_Transform not converged after " << warn_iter << " nested commutators" << std::endl;
-        else if (i == max_iter)   std::cout << "Warning: BCH_Transform didn't coverge after "<< max_iter << " nested commutators" << std::endl;
-     }
-   }
-//   std::cout << "Done with BCH_Transform, 3-body norm of OpOut = " << OpOut.ThreeBodyNorm() << std::endl;
-   OpIn.profiler.timer["BCH_Transform"] += omp_get_wtime() - t_start;
-   return OpOut;
-}
 
 
-//  Update the auxiliary one-body operator chi, using Omega and the ith nested commutator
-//  This has not been tested for tensor commutators, but it *should* work.
-// 
-Operator GooseTankUpdate( const Operator& Omega, const Operator& OpNested)
-{
-   double t_start = omp_get_wtime();
-   Operator goosetank_chi = Operator( *(OpNested.modelspace), OpNested.rank_J, OpNested.rank_T, OpNested.parity, 1) ;
-   goosetank_chi.EraseOneBody();
-   if (goosetank_chi.rank_J==0 )
-   {
-     comm221ss( Omega, OpNested, goosetank_chi );  // update chi.
-   }
-   else
-   {
-     comm222_pp_hh_221st( Omega, OpNested, goosetank_chi );  // update chi.
-   }
-   goosetank_chi.Symmetrize(); // the commutator call only does half the matrix, so we symmetrize
-//   int norbits = OpNested.modelspace->GetNumberOrbits();
-//   for (int i=0;i<norbits;++i)  // enforce n_in_j + nbar_i nbar_j
-   for (auto i : OpNested.modelspace->all_orbits )  // enforce n_in_j + nbar_i nbar_j
-   {
-     Orbit &oi = OpNested.modelspace->GetOrbit(i);
-//     for (int j=0;j<norbits;++j)
-     for ( auto j : OpNested.modelspace->all_orbits )
-     {
-      Orbit &oj = OpNested.modelspace->GetOrbit(j);
-      goosetank_chi.OneBody(i,j) *=  oi.occ*oj.occ + (1.0-oi.occ)*(1.0-oj.occ) ;
-      }
-   }
-   OpNested.profiler.timer["GooseTankUpdate"] += omp_get_wtime() - t_start;
-   return goosetank_chi;
-}
 
+    //*****************************************************************************************
+    /// BCH_Transform(X,Y) returns \f$ Z = e^{Y} X e^{-Y} \f$.
+    /// We use the [Baker-Campbell-Hausdorff formula](http://en.wikipedia.org/wiki/Baker-Campbell-Hausdorff_formula)
+    /// \f[ Z = X + [Y,X] + \frac{1}{2!}[Y,[Y,X]] + \frac{1}{3!}[Y,[Y,[Y,X]]] + \ldots \f]
+    /// with all commutators truncated at the two-body level.
+    Operator BCH_Transform(  const Operator& OpIn, const Operator& Omega)
+    {
+      return use_brueckner_bch ? Brueckner_BCH_Transform( OpIn, Omega ) :  Standard_BCH_Transform( OpIn, Omega );
+    }
 
+    /// X.BCH_Transform(Y) returns \f$ Z = e^{Y} X e^{-Y} \f$.
+    /// We use the [Baker-Campbell-Hausdorff formula](http://en.wikipedia.org/wiki/Baker-Campbell-Hausdorff_formula)
+    /// \f[ Z = X + [Y,X] + \frac{1}{2!}[Y,[Y,X]] + \frac{1}{3!}[Y,[Y,[Y,X]]] + \ldots \f]
+    /// with all commutators truncated at the two-body level.
+    Operator Standard_BCH_Transform( const Operator& OpIn, const Operator &Omega)
+    {
+      //   std::cout << "!!! " << __func__ << " !!!   particles ranks are " << OpIn.GetParticleRank() << "  and  " << Omega.GetParticleRank()
+      //             << "  PN mode is " << OpIn.ThreeBody.PN_mode << "   and  " << Omega.ThreeBody.PN_mode  << std::endl;
+      double t_start = omp_get_wtime();
+      int max_iter = 40;
+      int warn_iter = 12;
+      double nx = OpIn.Norm();
+      double ny = Omega.Norm();
+      Operator OpOut = OpIn;
+      if (use_imsrg3 and not OpOut.ThreeBody.is_allocated )
+      {
+        OpOut.ThreeBody.Allocate_PN();
+      }
+      double factorial_denom = 1.0;
+      Operator goosetank_chi;  // auxiliary one-body operator used to recover 4th-order quadruples.
+      if (use_goose_tank_correction)
+      {
+        goosetank_chi = OpIn;
+        goosetank_chi.SetParticleRank(1);
+        goosetank_chi.Erase();
+      }
+      if (nx>bch_transform_threshold)
+      {
+        Operator OpNested = OpIn;
+        double epsilon = nx * exp(-2*ny) * bch_transform_threshold / (2*ny);
+        for (int i=1; i<=max_iter; ++i)
+        {
 
+          if (use_goose_tank_correction  )
+          {
+            auto chi_last = goosetank_chi.OneBody;
+            goosetank_chi = GooseTankUpdate( Omega, OpNested);
+            OpNested.OneBody += chi_last;  // add the chi from the previous step to OpNested.
+          }
 
-/// Variation of the BCH transformation procedure
-/// requested by a one Dr. T.D. Morris
-/// \f[ e^{\Omega_1 + \Omega_2} X e^{-\Omega_1 - \Omega_2}
-///    \rightarrow 
-///  e^{\Omega_2} e^{\Omega_1}  X e^{-\Omega_1} e^{-\Omega_2} \f]
-Operator Brueckner_BCH_Transform( const Operator& OpIn, const Operator& Omega)
-{
-   Operator Omega1 = Omega;
-   Operator Omega2 = Omega;
-   Omega1.SetParticleRank(1);
-   Omega1.EraseTwoBody();
-   Omega2.EraseOneBody();
-   Operator OpOut = Standard_BCH_Transform(OpIn, Omega1);
-   OpOut = Standard_BCH_Transform(OpOut, Omega2);
-   return OpOut;
-}
 
+          OpNested = Commutator(Omega,OpNested); // the ith nested commutator
+          factorial_denom /= i;
+          OpOut += factorial_denom * OpNested;
 
-//*****************************************************************************************
-// Baker-Campbell-Hausdorff formula
-//  returns Z, where
-//  exp(Z) = exp(X) * exp(Y).
-//  Z = X + Y + 1/2[X, Y]
-//     + 1/12 [X,[X,Y]] + 1/12 [Y,[Y,X]]
-//     - 1/24 [Y,[X,[X,Y]]]
-//     - 1/720 [Y,[Y,[Y,[Y,X]]]] - 1/720 [X,[X,[X,[X,Y]]]]
-//     + ...
-//*****************************************************************************************
-/// X.BCH_Product(Y) returns \f$Z\f$ such that \f$ e^{Z} = e^{X}e^{Y}\f$
-/// by employing the [Baker-Campbell-Hausdorff formula](http://en.wikipedia.org/wiki/Baker-Campbell-Hausdorff_formula)
-/// \f[ Z = X + Y + \frac{1}{2}[X,Y] + \frac{1}{12}([X,[X,Y]]+[Y,[Y,X]]) + \ldots \f]
-//*****************************************************************************************
-Operator BCH_Product(  Operator& X, Operator& Y)
-{
-//   std::cout << "!!! " << __func__ << " !!! " << std::endl;
-   double tstart = omp_get_wtime();
-   double nx = X.Norm();
-   std::vector<double> bernoulli = {1.0, -0.5, 1./6, 0.0, -1./30,  0.0 ,  1./42,     0,  -1./30};
-   std::vector<double> factorial = {1.0,  1.0,  2.0, 6.0,    24.,  120.,   720., 5040.,  40320.};
+          if (OpOut.rank_J > 0)
+          {
+            std::cout << "Tensor BCH, i=" << i << "  Norm = " << std::setw(12) << std::setprecision(8) << std::fixed << OpNested.OneBodyNorm() << " "
+              << std::setw(12) << std::setprecision(8) << std::fixed << OpNested.TwoBodyNorm() << " "
+              << std::setw(12) << std::setprecision(8) << std::fixed << OpNested.Norm() << std::endl;
+          }
+          epsilon *= i+1;
+          if (OpNested.Norm() < epsilon)  break;
+          if (i == warn_iter)  std::cout << "Warning: BCH_Transform not converged after " << warn_iter << " nested commutators" << std::endl;
+          else if (i == max_iter)   std::cout << "Warning: BCH_Transform didn't coverge after "<< max_iter << " nested commutators" << std::endl;
+        }
+      }
+      //   std::cout << "Done with BCH_Transform, 3-body norm of OpOut = " << OpOut.ThreeBodyNorm() << std::endl;
+      OpIn.profiler.timer["BCH_Transform"] += omp_get_wtime() - t_start;
+      return OpOut;
+    }
 
 
-   Operator Z = X + Y;
+    //  Update the auxiliary one-body operator chi, using Omega and the ith nested commutator
+    //  This has not been tested for tensor commutators, but it *should* work.
+    //
+    Operator GooseTankUpdate( const Operator& Omega, const Operator& OpNested)
+    {
+      double t_start = omp_get_wtime();
+      Operator goosetank_chi = Operator( *(OpNested.modelspace), OpNested.rank_J, OpNested.rank_T, OpNested.parity, 1) ;
+      goosetank_chi.EraseOneBody();
+      if (goosetank_chi.rank_J==0 )
+      {
+        comm221ss( Omega, OpNested, goosetank_chi );  // update chi.
+      }
+      else
+      {
+        comm222_pp_hh_221st( Omega, OpNested, goosetank_chi );  // update chi.
+      }
+      goosetank_chi.Symmetrize(); // the commutator call only does half the matrix, so we symmetrize
+      //   int norbits = OpNested.modelspace->GetNumberOrbits();
+      //   for (int i=0;i<norbits;++i)  // enforce n_in_j + nbar_i nbar_j
+      for (auto i : OpNested.modelspace->all_orbits )  // enforce n_in_j + nbar_i nbar_j
+      {
+        Orbit &oi = OpNested.modelspace->GetOrbit(i);
+        //     for (int j=0;j<norbits;++j)
+        for ( auto j : OpNested.modelspace->all_orbits )
+        {
+          Orbit &oj = OpNested.modelspace->GetOrbit(j);
+          goosetank_chi.OneBody(i,j) *=  oi.occ*oj.occ + (1.0-oi.occ)*(1.0-oj.occ) ;
+        }
+      }
+      OpNested.profiler.timer["GooseTankUpdate"] += omp_get_wtime() - t_start;
+      return goosetank_chi;
+    }
 
-   // if we set the option only_2b_omega
-   // then temporarily switch to imsrg2 for updating Omega
-   bool _save_imsrg3 = use_imsrg3;
-   if (only_2b_omega)
-   {
-     Z.ThreeBody.Erase();
-     use_imsrg3 = false;
-   }
 
-   Operator Nested = Commutator(Y,X);  // [Y,X]
 
 
-   double nxy = Nested.Norm();
-   // We assume X is small, but just in case, we check if we should include the [X,[X,Y]] term.
-   if ( nxy*nx > bch_product_threshold)
-   {
-     Z += (1./12) * Commutator(Nested,X);
-   }
-   
-   int k = 1;
-   // k=1 adds 1/2[X,Y],  k=2 adds 1/12 [Y,[Y,X]], k=4 adds -1/720 [Y,[Y,[Y,[Y,X]]]], and so on.
-   while( Nested.Norm() > bch_product_threshold and k<9)
-   {
-     if ((k<2) or (k%2==0))
-        Z += (bernoulli[k]/factorial[k]) * Nested;
+    /// Variation of the BCH transformation procedure
+    /// requested by a one Dr. T.D. Morris
+    /// \f[ e^{\Omega_1 + \Omega_2} X e^{-\Omega_1 - \Omega_2}
+    ///    \rightarrow
+    ///  e^{\Omega_2} e^{\Omega_1}  X e^{-\Omega_1} e^{-\Omega_2} \f]
+    Operator Brueckner_BCH_Transform( const Operator& OpIn, const Operator& Omega)
+    {
+      Operator Omega1 = Omega;
+      Operator Omega2 = Omega;
+      Omega1.SetParticleRank(1);
+      Omega1.EraseTwoBody();
+      Omega2.EraseOneBody();
+      Operator OpOut = Standard_BCH_Transform(OpIn, Omega1);
+      OpOut = Standard_BCH_Transform(OpOut, Omega2);
+      return OpOut;
+    }
 
-     Nested = Commutator(Y,Nested);
-     k++;
-   }
 
-   use_imsrg3 = _save_imsrg3;// set it back to how it was.
+    //*****************************************************************************************
+    // Baker-Campbell-Hausdorff formula
+    //  returns Z, where
+    //  exp(Z) = exp(X) * exp(Y).
+    //  Z = X + Y + 1/2[X, Y]
+    //     + 1/12 [X,[X,Y]] + 1/12 [Y,[Y,X]]
+    //     - 1/24 [Y,[X,[X,Y]]]
+    //     - 1/720 [Y,[Y,[Y,[Y,X]]]] - 1/720 [X,[X,[X,[X,Y]]]]
+    //     + ...
+    //*****************************************************************************************
+    /// X.BCH_Product(Y) returns \f$Z\f$ such that \f$ e^{Z} = e^{X}e^{Y}\f$
+    /// by employing the [Baker-Campbell-Hausdorff formula](http://en.wikipedia.org/wiki/Baker-Campbell-Hausdorff_formula)
+    /// \f[ Z = X + Y + \frac{1}{2}[X,Y] + \frac{1}{12}([X,[X,Y]]+[Y,[Y,X]]) + \ldots \f]
+    //*****************************************************************************************
+    Operator BCH_Product(  Operator& X, Operator& Y)
+    {
+      //   std::cout << "!!! " << __func__ << " !!! " << std::endl;
+      double tstart = omp_get_wtime();
+      double nx = X.Norm();
+      std::vector<double> bernoulli = {1.0, -0.5, 1./6, 0.0, -1./30,  0.0 ,  1./42,     0,  -1./30};
+      std::vector<double> factorial = {1.0,  1.0,  2.0, 6.0,    24.,  120.,   720., 5040.,  40320.};
 
-   X.profiler.timer["BCH_Product"] += omp_get_wtime() - tstart;
-   return Z;
-}
 
+      Operator Z = X + Y;
 
+      // if we set the option only_2b_omega
+      // then temporarily switch to imsrg2 for updating Omega
+      bool _save_imsrg3 = use_imsrg3;
+      if (only_2b_omega)
+      {
+        Z.ThreeBody.Erase();
+        use_imsrg3 = false;
+      }
 
+      Operator Nested = Commutator(Y,X);  // [Y,X]
 
 
+      double nxy = Nested.Norm();
+      // We assume X is small, but just in case, we check if we should include the [X,[X,Y]] term.
+      if ( nxy*nx > bch_product_threshold)
+      {
+        Z += (1./12) * Commutator(Nested,X);
+      }
 
+      int k = 1;
+      // k=1 adds 1/2[X,Y],  k=2 adds 1/12 [Y,[Y,X]], k=4 adds -1/720 [Y,[Y,[Y,[Y,X]]]], and so on.
+      while( Nested.Norm() > bch_product_threshold and k<9)
+      {
+        if ((k<2) or (k%2==0))
+          Z += (bernoulli[k]/factorial[k]) * Nested;
 
-double EstimateBCHError( Operator& Omega, Operator H)
-{
+        Nested = Commutator(Y,Nested);
+        k++;
+      }
 
-  double normOmega = Omega.Norm();
-  double normOmega2 = Omega.TwoBodyNorm();
-  double normH2 = H.TwoBodyNorm();
-  Operator H223 = H;
-  H223.Erase();
-  comm222_phss( Omega, H, H223 ) ;
-  comm222_pp_hh_221ss( Omega, H, H223 ) ;
-  if ( H223.GetParticleRank()<3) H223.SetParticleRank(3);
-  if ( not H223.ThreeBody.IsAllocated() )  H223.ThreeBody.SwitchToPN_and_discard();
-  
-  comm223ss(Omega, H, H223 );
-  comm220ss(Omega,H, H223);
-
-  double Norm220 = H223.ZeroBody;
-  
-
-  double Norm223 = H223.ThreeBodyNorm();
-  Operator H2223 = H223;
-  H2223.Erase();
-  comm223ss(Omega, H223,H2223);
-  double Norm2223 = H2223.ThreeBodyNorm();
-
-  // now 4 nested commutators
-  H223.Erase();
-  H2223.Erase();
-  H223 = Commutator(Omega,H); // 1 nested
-  H2223 = Commutator(Omega,H223); // 2 nested
-  H223 = Commutator(Omega,H2223); // 3 nested
-  H2223 = Commutator(Omega,H223);
-  double Norm4nested = H2223.Norm();
-
-  double est_err = 2./3*normOmega*normOmega * Norm223  +  1./6 * normOmega*normOmega * Norm2223 + exp(2.*normOmega)/24 * Norm4nested;
-  std::cout << "Contributions to err " << 2./3*normOmega*normOmega * Norm223 << "  " << 1./6 * normOmega*normOmega * Norm2223
-            << "  " << exp(2.*normOmega)/24 * Norm4nested << "    220 = " << Norm220 << "  ||H2|| ,||Omega2|| = " << normH2 << " " << normOmega2 << std::endl;
-
-  return est_err;
+      use_imsrg3 = _save_imsrg3;// set it back to how it was.
 
-}
+      X.profiler.timer["BCH_Product"] += omp_get_wtime() - tstart;
+      return Z;
+    }
 
 
 
@@ -579,776 +538,894 @@ double EstimateBCHError( Operator& Omega, Operator H)
 
 
 
+    double EstimateBCHError( Operator& Omega, Operator H)
+    {
 
+      double normOmega = Omega.Norm();
+      double normOmega2 = Omega.TwoBodyNorm();
+      double normH2 = H.TwoBodyNorm();
+      Operator H223 = H;
+      H223.Erase();
+      comm222_phss( Omega, H, H223 ) ;
+      comm222_pp_hh_221ss( Omega, H, H223 ) ;
+      if ( H223.GetParticleRank()<3) H223.SetParticleRank(3);
+      if ( not H223.ThreeBody.IsAllocated() )  H223.ThreeBody.SwitchToPN_and_discard();
 
-///////////////////////////////////////////////////////////////////////////////////////////
-///////////////////////////////////////////////////////////////////////////////////////////
-// Below is the implementation of the commutators in the various channels
-///////////////////////////////////////////////////////////////////////////////////////////
+      comm223ss(Omega, H, H223 );
+      comm220ss(Omega,H, H223);
 
-//*****************************************************************************************
-//                ____Y    __         ____X
-//          X ___(_)             Y___(_) 
-//
-//  [X1,Y1](0) = Sum_ab (2j_a+1) x_ab y_ba  (n_a-n_b) 
-//             = Sum_a  (2j_a+1)  (xy-yx)_aa n_a
-//
-// -- AGREES WITH NATHAN'S RESULTS
-/// \f[
-///  [X_{1)},Y_{(1)}]_{(0)} = \sum_{a} n_a (2j_a+1) \left(X_{(1)}Y_{(1)}-Y_{(1)}X_{(1)}\right)_{aa}
-/// \f]
-//void Operator::comm110ss( const Operator& X, const Operator& Y) 
-void comm110ss( const Operator& X, const Operator& Y, Operator& Z) 
-{
-  if (X.IsHermitian() and Y.IsHermitian()) return ; // I think this is the case
-  if (X.IsAntiHermitian() and Y.IsAntiHermitian()) return ; // I think this is the case
+      double Norm220 = H223.ZeroBody;
 
-   arma::mat xyyx = X.OneBody*Y.OneBody - Y.OneBody*X.OneBody;
-   for ( auto& a : Z.modelspace->holes) 
-   {
-      Orbit& oa = Z.modelspace->GetOrbit(a);
-      Z.ZeroBody += (oa.j2+1) * oa.occ * xyyx(a,a);
-   }
-}
 
+      double Norm223 = H223.ThreeBodyNorm();
+      Operator H2223 = H223;
+      H2223.Erase();
+      comm223ss(Omega, H223,H2223);
+      double Norm2223 = H2223.ThreeBodyNorm();
 
-//*****************************************************************************************
-//         __Y__       __X__
-//        ()_ _()  -  ()_ _()
-//           X           Y
-//
-//  [ X^(2), Y^(2) ]^(0) = 1/2 Sum_abcd  Sum_J (2J+1) x_abcd y_cdab (n_a n_b nbar_c nbar_d)
-//                       = 1/2 Sum_J (2J+1) Sum_abcd x_abcd y_cdab (n_a n_b nbar_c nbar_d)  
-//                       = 1/2 Sum_J (2J+1) Sum_ab  (X*P_pp*Y)_abab  P_hh
-//
-//  -- AGREES WITH NATHAN'S RESULTS (within < 1%)
-/// \f[
-/// [X_{(2)},Y_{(2)}]_{(0)} = \frac{1}{2} \sum_{J} (2J+1) \sum_{abcd} (n_a n_b \bar{n}_c \bar{n}_d) \tilde{X}_{abcd}^{J} \tilde{Y}_{cdab}^{J}
-/// \f]
-/// may be rewritten as
-/// \f[
-/// [X_{(2)},Y_{(2)}]_{(0)} = 2 \sum_{J} (2J+1) Tr(X_{hh'pp'}^{J} Y_{pp'hh'}^{J})
-/// \f] where we obtain a factor of four from converting two unrestricted sums to restricted sums, i.e. \f$\sum_{ab} \rightarrow \sum_{a\leq b} \f$,
-/// and using the normalized TBME.
-//void Operator::comm220ss( const Operator& X, const Operator& Y) 
-void comm220ss( const Operator& X, const Operator& Y, Operator& Z) 
-{
-   if (X.IsHermitian() and Y.IsHermitian()) return; // I think this is the case
-   if (X.IsAntiHermitian() and Y.IsAntiHermitian()) return; // I think this is the case
+      // now 4 nested commutators
+      H223.Erase();
+      H2223.Erase();
+      H223 = Commutator(Omega,H); // 1 nested
+      H2223 = Commutator(Omega,H223); // 2 nested
+      H223 = Commutator(Omega,H2223); // 3 nested
+      H2223 = Commutator(Omega,H223);
+      double Norm4nested = H2223.Norm();
 
-   for (int ch=0;ch<Z.nChannels;++ch)
-   {
-      TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
-      auto hh = tbc.GetKetIndex_hh();
-      auto ph = tbc.GetKetIndex_ph();
-      auto pp = tbc.GetKetIndex_pp();
-      arma::uvec nbar_indices = arma::join_cols(hh,ph);
-      nbar_indices = arma::join_cols(nbar_indices,pp);
-      if (hh.size()==0 ) continue;
-      auto nn = tbc.Ket_occ_hh;
-      arma::vec nbarnbar = arma::join_cols(tbc.Ket_unocc_hh, tbc.Ket_unocc_ph);
-      auto & X2 = X.TwoBody.GetMatrix(ch).submat(hh,nbar_indices);
-      arma::mat Y2 = Y.TwoBody.GetMatrix(ch).submat(nbar_indices,hh);
-      Y2.head_rows(nbarnbar.size()).each_col() %= nbarnbar;
-      Z.ZeroBody += 2 * (2*tbc.J+1) * arma::sum(arma::diagvec( X2 * Y2 ) % nn); // This could be made more efficient, but who cares?
-   }
-}
+      double est_err = 2./3*normOmega*normOmega * Norm223  +  1./6 * normOmega*normOmega * Norm2223 + exp(2.*normOmega)/24 * Norm4nested;
+      std::cout << "Contributions to err " << 2./3*normOmega*normOmega * Norm223 << "  " << 1./6 * normOmega*normOmega * Norm2223
+        << "  " << exp(2.*normOmega)/24 * Norm4nested << "    220 = " << Norm220 << "  ||H2|| ,||Omega2|| = " << normH2 << " " << normOmega2 << std::endl;
 
-//*****************************************************************************************
-//
-//        |____. Y          |___.X
-//        |        _        |
-//  X .___|            Y.___|              [X1,Y1](1)  =  XY - YX
-//        |                 |
-//
-// -- AGREES WITH NATHAN'S RESULTS
-/// \f[
-/// [X_{(1)},Y_{(1)}]_{(1)} = X_{(1)}Y_{(1)} - Y_{(1)}X_{(1)}
-/// \f]
-//void Operator::comm111ss( Operator & Y, Operator& Z) 
-//void Operator::comm111ss( const Operator & X, const Operator& Y) 
-void comm111ss( const Operator & X, const Operator& Y, Operator& Z) 
-{
-   Z.OneBody += X.OneBody*Y.OneBody - Y.OneBody*X.OneBody;
-}
+      return est_err;
 
-//*****************************************************************************************
-//                                       |
-//      i |              i |             |
-//        |    ___.Y       |__X__        |
-//        |___(_)    _     |   (_)__.    |  [X2,Y1](1)  =  1/(2j_i+1) sum_ab(n_a-n_b)y_ab 
-//      j | X            j |        Y    |        * sum_J (2J+1) x_biaj^(J)  
-//                                       |      
-//---------------------------------------*        = 1/(2j+1) sum_a n_a sum_J (2J+1)
-//                                                  * sum_b y_ab x_biaj - yba x_aibj
-//
-//                     (note: I think this should actually be)
-//                                                = sum_ab (n_a nbar_b) sum_J (2J+1)/(2j_i+1)
-//                                                      * y_ab xbiaj - yba x_aibj
-//
-// -- AGREES WITH NATHAN'S RESULTS 
-/// Returns \f$ [X_{(1)},Y_{(2)}] - [Y_{(1)},X_{(2)}] \f$, where
-/// \f[
-/// [X_{(1)},Y_{(2)}]_{ij} = \frac{1}{2j_i+1}\sum_{ab} (n_a \bar{n}_b) \sum_{J} (2J+1) (X_{ab} Y^J_{biaj} - X_{ba} Y^J_{aibj})
-/// \f]
-//void Operator::comm121ss( const Operator& X, const Operator& Y) 
-void comm121ss( const Operator& X, const Operator& Y, Operator& Z) 
-{
-//   index_t norbits = Z.modelspace->GetNumberOrbits();
-   index_t norbits = Z.modelspace->all_orbits.size();
-  
-   #pragma omp parallel for 
-   for (index_t indexi=0;indexi<norbits;++indexi)
-//   for (index_t i=0;i<norbits;++i)
-   {
-//      auto i = Z.modelspace->all_orbits[indexi];
-      auto i = indexi;
-      Orbit &oi = Z.modelspace->GetOrbit(i);
-      index_t jmin = Z.IsNonHermitian() ? 0 : i;
-      for (auto j : Z.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) ) 
-      {
-          if (j<jmin) continue; // only calculate upper triangle
-          for (auto& a : Z.modelspace->holes)  // C++11 syntax
-          {
-             Orbit &oa = Z.modelspace->GetOrbit(a);
-//             for (index_t b=0; b<norbits; ++b)
-//             for (auto b : Z.modelspace->all_orbits)
-             if (Y.particle_rank>1)
-             {
-               for (auto b : X.OneBodyChannels.at({oa.l,oa.j2,oa.tz2} ))
-               {
-                  Orbit &ob = Z.modelspace->GetOrbit(b);
-                  double nanb = oa.occ * (1-ob.occ);
-                  if (std::abs(nanb)<ModelSpace::OCC_CUT) continue;
-                  Z.OneBody(i,j) += (ob.j2+1) * nanb *  X.OneBody(a,b) * Y.TwoBody.GetTBMEmonopole(b,i,a,j) ;
-                  Z.OneBody(i,j) -= (oa.j2+1) * nanb *  X.OneBody(b,a) * Y.TwoBody.GetTBMEmonopole(a,i,b,j) ;
-                }
-             }
-//             for (index_t b=0; b<norbits; ++b)
-//             for (auto b : Z.modelspace->all_orbits)
-             if (X.particle_rank>1)
-             {
-                for (auto b : Y.OneBodyChannels.at({oa.l,oa.j2,oa.tz2} ))
-                {
-                  // comm211 part
-                  Orbit &ob = Z.modelspace->GetOrbit(b);
-                  double nanb = oa.occ * (1-ob.occ);
-                  if (std::abs(nanb)<ModelSpace::OCC_CUT) continue;
-                  Z.OneBody(i,j) -= (ob.j2+1) * nanb * Y.OneBody(a,b) * X.TwoBody.GetTBMEmonopole(b,i,a,j) ;
-                  Z.OneBody(i,j) += (oa.j2+1) * nanb * Y.OneBody(b,a) * X.TwoBody.GetTBMEmonopole(a,i,b,j) ;
-                }
-             }
-          }
-      }
-   }
-}
+    }
 
 
 
-//*****************************************************************************************
-//
-//      i |              i |            [X2,Y2](1)  =  1/(2(2j_i+1)) sum_J (2J+1) 
-//        |__Y__           |__X__           * sum_abc (nbar_a*nbar_b*n_c + n_a*n_b*nbar_c)
-//        |    /\          |    /\          * (x_ciab y_abcj - y_ciab xabcj)
-//        |   (  )   _     |   (  )                                                                                      
-//        |____\/          |____\/       = 1/(2(2j+1)) sum_J (2J+1)
-//      j | X            j |  Y            *  sum_c ( Pp*X*Phh*Y*Pp - Pp*Y*Phh*X*Pp)  - (Ph*X*Ppp*Y*Ph - Ph*Y*Ppp*X*Ph)_cicj
-//                                     
-//
-// -- AGREES WITH NATHAN'S RESULTS 
-//   No factor of 1/2 because the matrix multiplication corresponds to a restricted sum (a<=b) 
-// \f[
-// [X_{(2)},Y_{(2)}]_{ij} = \frac{1}{2(2j_i+1)}\sum_{J}(2J+1)\sum_{c}
-// \left( \mathcal{P}_{pp} (X \mathcal{P}_{hh} Y^{J} 
-// - Y^{J} \mathcal{P}_{hh} X^{J}) \mathcal{P}_{pp}
-//  - \mathcal{P}_{hh} (X^{J} \mathcal{P}_{pp} Y^{J} 
-//  -  Y^{J} \mathcal{P}_{pp} X^{J}) \mathcal{P}_{hh} \right)_{cicj}
-// \f]
-/// \f[
-/// [X_{(2)},Y_{(2)}]_{ij} = \frac{1}{2(2j_i+1)}\sum_{J}(2J+1)\sum_{abc} (\bar{n}_a\bar{n}_bn_c + n_an_b\bar{n}_c)
-///  (X^{J}_{ciab} Y^{J}_{abcj} - Y^{J}_{ciab}X^{J}_{abcj})
-/// \f]
-/// This may be rewritten as
-/// \f[
-/// [X_{(2)},Y_{(2)}]_{ij} = \frac{1}{2j_i+1} \sum_{c} \sum_{J} (2J+1) \left( n_c \mathcal{M}^{J}_{pp,icjc} + \bar{n}_c\mathcal{M}^{J}_{hh,icjc} \right)
-/// \f]
-/// With the intermediate matrix \f[ \mathcal{M}^{J}_{pp} \equiv \frac{1}{2} (X^{J}\mathcal{P}_{pp} Y^{J} - Y^{J}\mathcal{P}_{pp}X^{J}) \f]
-/// and likewise for \f$ \mathcal{M}^{J}_{hh} \f$
-//void Operator::comm221ss( const Operator& X, const Operator& Y) 
-void comm221ss( const Operator& X, const Operator& Y, Operator& Z) 
-{
 
-   double t_start = omp_get_wtime();
 
-   static TwoBodyME Mpp = Y.TwoBody;
-   static TwoBodyME Mhh = Y.TwoBody;
 
-   // Don't use omp, because the matrix multiplication is already
-   // parallelized by armadillo.
-   int nch = Z.modelspace->SortedTwoBodyChannels.size();
-   #ifndef OPENBLAS_NOUSEOMP
-   #pragma omp parallel for schedule(dynamic,1)
-   #endif
-   for (int ich=0; ich<nch; ++ich)
-   {
-      int ch = Z.modelspace->SortedTwoBodyChannels[ich];
-      TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
 
-      auto& LHS = X.TwoBody.GetMatrix(ch,ch);
-      auto& RHS = Y.TwoBody.GetMatrix(ch,ch);
 
-      auto& Matrixpp = Mpp.GetMatrix(ch,ch);
-      auto& Matrixhh = Mhh.GetMatrix(ch,ch);
 
-      auto& kets_pp = tbc.GetKetIndex_pp();
-      auto& kets_hh = tbc.GetKetIndex_hh();
-      auto& kets_ph = tbc.GetKetIndex_ph();
-      auto& nanb = tbc.Ket_occ_hh;
-      auto& nbarnbar_hh = tbc.Ket_unocc_hh;
-      auto& nbarnbar_ph = tbc.Ket_unocc_ph;
-      
-      Matrixpp =  LHS.cols(kets_pp) * RHS.rows(kets_pp);
-      Matrixhh =  LHS.cols(kets_hh) * arma::diagmat(nanb) *  RHS.rows(kets_hh) ;
-      if (kets_hh.size()>0)
-        Matrixpp +=  LHS.cols(kets_hh) * arma::diagmat(nbarnbar_hh) *  RHS.rows(kets_hh); 
-      if (kets_ph.size()>0)
-        Matrixpp += LHS.cols(kets_ph) * arma::diagmat(nbarnbar_ph) *  RHS.rows(kets_ph) ;
+    ///////////////////////////////////////////////////////////////////////////////////////////
+    ///////////////////////////////////////////////////////////////////////////////////////////
+    // Below is the implementation of the commutators in the various channels
+    ///////////////////////////////////////////////////////////////////////////////////////////
 
+    //*****************************************************************************************
+    //                ____Y    __         ____X
+    //          X ___(_)             Y___(_)
+    //
+    //  [X1,Y1](0) = Sum_ab (2j_a+1) x_ab y_ba  (n_a-n_b)
+    //             = Sum_a  (2j_a+1)  (xy-yx)_aa n_a
+    //
+    // -- AGREES WITH NATHAN'S RESULTS
+    /// \f[
+    ///  [X_{1)},Y_{(1)}]_{(0)} = \sum_{a} n_a (2j_a+1) \left(X_{(1)}Y_{(1)}-Y_{(1)}X_{(1)}\right)_{aa}
+    /// \f]
+    //void Operator::comm110ss( const Operator& X, const Operator& Y)
+    void comm110ss( const Operator& X, const Operator& Y, Operator& Z)
+    {
+      if (X.IsHermitian() and Y.IsHermitian()) return ; // I think this is the case
+      if (X.IsAntiHermitian() and Y.IsAntiHermitian()) return ; // I think this is the case
 
-      if (Z.IsHermitian())
+      arma::mat xyyx = X.OneBody*Y.OneBody - Y.OneBody*X.OneBody;
+      for ( auto& a : Z.modelspace->holes)
       {
-         Matrixpp +=  Matrixpp.t();
-         Matrixhh +=  Matrixhh.t();
-      }
-      else if (Z.IsAntiHermitian()) // i.e. LHS and RHS are both hermitian or ant-hermitian
-      {
-         Matrixpp -=  Matrixpp.t();
-         Matrixhh -=  Matrixhh.t();
+        Orbit& oa = Z.modelspace->GetOrbit(a);
+        Z.ZeroBody += (oa.j2+1) * oa.occ * xyyx(a,a);
       }
-      else
+    }
+
+
+    //*****************************************************************************************
+    //         __Y__       __X__
+    //        ()_ _()  -  ()_ _()
+    //           X           Y
+    //
+    //  [ X^(2), Y^(2) ]^(0) = 1/2 Sum_abcd  Sum_J (2J+1) x_abcd y_cdab (n_a n_b nbar_c nbar_d)
+    //                       = 1/2 Sum_J (2J+1) Sum_abcd x_abcd y_cdab (n_a n_b nbar_c nbar_d)
+    //                       = 1/2 Sum_J (2J+1) Sum_ab  (X*P_pp*Y)_abab  P_hh
+    //
+    //  -- AGREES WITH NATHAN'S RESULTS (within < 1%)
+    /// \f[
+    /// [X_{(2)},Y_{(2)}]_{(0)} = \frac{1}{2} \sum_{J} (2J+1) \sum_{abcd} (n_a n_b \bar{n}_c \bar{n}_d) \tilde{X}_{abcd}^{J} \tilde{Y}_{cdab}^{J}
+    /// \f]
+    /// may be rewritten as
+    /// \f[
+    /// [X_{(2)},Y_{(2)}]_{(0)} = 2 \sum_{J} (2J+1) Tr(X_{hh'pp'}^{J} Y_{pp'hh'}^{J})
+    /// \f] where we obtain a factor of four from converting two unrestricted sums to restricted sums, i.e. \f$\sum_{ab} \rightarrow \sum_{a\leq b} \f$,
+    /// and using the normalized TBME.
+    //void Operator::comm220ss( const Operator& X, const Operator& Y)
+    void comm220ss( const Operator& X, const Operator& Y, Operator& Z)
+    {
+      if (X.IsHermitian() and Y.IsHermitian()) return; // I think this is the case
+      if (X.IsAntiHermitian() and Y.IsAntiHermitian()) return; // I think this is the case
+
+      for (int ch=0;ch<Z.nChannels;++ch)
       {
-        Matrixpp -=  RHS.cols(kets_pp) * LHS.rows(kets_pp);
-        Matrixhh -=  RHS.cols(kets_hh) * arma::diagmat(nanb) *  LHS.rows(kets_hh) ;
-        Matrixpp -=  RHS.cols(kets_hh) * arma::diagmat(nbarnbar_hh) *  LHS.rows(kets_hh) ;
-        if (kets_ph.size()>0)
-          Matrixpp -=  RHS.cols(kets_ph) * arma::diagmat(nbarnbar_ph) *  LHS.rows(kets_ph) ;
+        TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
+        auto hh = tbc.GetKetIndex_hh();
+        auto ph = tbc.GetKetIndex_ph();
+        auto pp = tbc.GetKetIndex_pp();
+        arma::uvec nbar_indices = arma::join_cols(hh,ph);
+        nbar_indices = arma::join_cols(nbar_indices,pp);
+        if (hh.size()==0 ) continue;
+        auto nn = tbc.Ket_occ_hh;
+        arma::vec nbarnbar = arma::join_cols(tbc.Ket_unocc_hh, tbc.Ket_unocc_ph);
+        auto & X2 = X.TwoBody.GetMatrix(ch).submat(hh,nbar_indices);
+        arma::mat Y2 = Y.TwoBody.GetMatrix(ch).submat(nbar_indices,hh);
+        Y2.head_rows(nbarnbar.size()).each_col() %= nbarnbar;
+        Z.ZeroBody += 2 * (2*tbc.J+1) * arma::sum(arma::diagvec( X2 * Y2 ) % nn); // This could be made more efficient, but who cares?
       }
+    }
 
+    //*****************************************************************************************
+    //
+    //        |____. Y          |___.X
+    //        |        _        |
+    //  X .___|            Y.___|              [X1,Y1](1)  =  XY - YX
+    //        |                 |
+    //
+    // -- AGREES WITH NATHAN'S RESULTS
+    /// \f[
+    /// [X_{(1)},Y_{(1)}]_{(1)} = X_{(1)}Y_{(1)} - Y_{(1)}X_{(1)}
+    /// \f]
+    //void Operator::comm111ss( Operator & Y, Operator& Z)
+    //void Operator::comm111ss( const Operator & X, const Operator& Y)
+    void comm111ss( const Operator & X, const Operator& Y, Operator& Z)
+    {
+      Z.OneBody += X.OneBody*Y.OneBody - Y.OneBody*X.OneBody;
+    }
 
-   } //for ch
+    //*****************************************************************************************
+    //                                       |
+    //      i |              i |             |
+    //        |    ___.Y       |__X__        |
+    //        |___(_)    _     |   (_)__.    |  [X2,Y1](1)  =  1/(2j_i+1) sum_ab(n_a-n_b)y_ab
+    //      j | X            j |        Y    |        * sum_J (2J+1) x_biaj^(J)
+    //                                       |
+    //---------------------------------------*        = 1/(2j+1) sum_a n_a sum_J (2J+1)
+    //                                                  * sum_b y_ab x_biaj - yba x_aibj
+    //
+    //                     (note: I think this should actually be)
+    //                                                = sum_ab (n_a nbar_b) sum_J (2J+1)/(2j_i+1)
+    //                                                      * y_ab xbiaj - yba x_aibj
+    //
+    // -- AGREES WITH NATHAN'S RESULTS
+    /// Returns \f$ [X_{(1)},Y_{(2)}] - [Y_{(1)},X_{(2)}] \f$, where
+    /// \f[
+    /// [X_{(1)},Y_{(2)}]_{ij} = \frac{1}{2j_i+1}\sum_{ab} (n_a \bar{n}_b) \sum_{J} (2J+1) (X_{ab} Y^J_{biaj} - X_{ba} Y^J_{aibj})
+    /// \f]
+    //void Operator::comm121ss( const Operator& X, const Operator& Y)
+    void comm121ss( const Operator& X, const Operator& Y, Operator& Z)
+    {
+      //   index_t norbits = Z.modelspace->GetNumberOrbits();
+      index_t norbits = Z.modelspace->all_orbits.size();
 
-//   int norbits = Z.modelspace->GetNumberOrbits();
-   int norbits = Z.modelspace->all_orbits.size();
-   std::vector<index_t> allorb_vec( Z.modelspace->all_orbits.begin(), Z.modelspace->all_orbits.end());
-   #pragma omp parallel for schedule(dynamic,1)
-//   for (int i=0;i<norbits;++i)
-   for (int indexi=0;indexi<norbits;++indexi)
-   {
-//      auto i = Z.modelspace->all_orbits[indexi];
-      auto i = allorb_vec[indexi];
-      Orbit &oi = Z.modelspace->GetOrbit(i);
-      int jmin = Z.IsNonHermitian() ? 0 : i;
-      for (int j : Z.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) )
+#pragma omp parallel for
+      for (index_t indexi=0;indexi<norbits;++indexi)
+        //   for (index_t i=0;i<norbits;++i)
       {
-         if (j<jmin) continue;
-         double cijJ = 0;
-         for (int ch=0;ch<Z.nChannels;++ch)
-         {
-            TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
-            double Jfactor = (2*tbc.J+1.0);
-            // Sum c over holes and include the nbar_a * nbar_b terms
-            for (auto& c : Z.modelspace->holes)
+        //      auto i = Z.modelspace->all_orbits[indexi];
+        auto i = indexi;
+        Orbit &oi = Z.modelspace->GetOrbit(i);
+        index_t jmin = Z.IsNonHermitian() ? 0 : i;
+        for (auto j : Z.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) )
+        {
+          if (j<jmin) continue; // only calculate upper triangle
+          for (auto& a : Z.modelspace->holes)  // C++11 syntax
+          {
+            Orbit &oa = Z.modelspace->GetOrbit(a);
+            //             for (index_t b=0; b<norbits; ++b)
+            //             for (auto b : Z.modelspace->all_orbits)
+            if (Y.particle_rank>1)
             {
-               Orbit& oc = Z.modelspace->GetOrbit(c);
-               cijJ += Jfactor * oc.occ     * Mpp.GetTBME(ch,c,i,c,j);
-               cijJ += Jfactor * (1-oc.occ) * Mhh.GetTBME(ch,c,i,c,j);
-            // Sum c over particles and include the n_a * n_b terms
+              for (auto b : X.OneBodyChannels.at({oa.l,oa.j2,oa.tz2} ))
+              {
+                Orbit &ob = Z.modelspace->GetOrbit(b);
+                double nanb = oa.occ * (1-ob.occ);
+                if (std::abs(nanb)<ModelSpace::OCC_CUT) continue;
+                Z.OneBody(i,j) += (ob.j2+1) * nanb *  X.OneBody(a,b) * Y.TwoBody.GetTBMEmonopole(b,i,a,j) ;
+                Z.OneBody(i,j) -= (oa.j2+1) * nanb *  X.OneBody(b,a) * Y.TwoBody.GetTBMEmonopole(a,i,b,j) ;
+              }
             }
-            for (auto& c : Z.modelspace->particles)
+            //             for (index_t b=0; b<norbits; ++b)
+            //             for (auto b : Z.modelspace->all_orbits)
+            if (X.particle_rank>1)
             {
-               cijJ += Jfactor * Mhh.GetTBME(ch,c,i,c,j);
+              for (auto b : Y.OneBodyChannels.at({oa.l,oa.j2,oa.tz2} ))
+              {
+                // comm211 part
+                Orbit &ob = Z.modelspace->GetOrbit(b);
+                double nanb = oa.occ * (1-ob.occ);
+                if (std::abs(nanb)<ModelSpace::OCC_CUT) continue;
+                Z.OneBody(i,j) -= (ob.j2+1) * nanb * Y.OneBody(a,b) * X.TwoBody.GetTBMEmonopole(b,i,a,j) ;
+                Z.OneBody(i,j) += (oa.j2+1) * nanb * Y.OneBody(b,a) * X.TwoBody.GetTBMEmonopole(a,i,b,j) ;
+              }
             }
-         }
-         Z.OneBody(i,j) += cijJ /(oi.j2+1.0);
-      } // for j
-   }
+          }
+        }
+      }
+    }
 
-   X.profiler.timer["comm221ss"] += omp_get_wtime() - t_start;
 
-}
 
+    //*****************************************************************************************
+    //
+    //      i |              i |            [X2,Y2](1)  =  1/(2(2j_i+1)) sum_J (2J+1)
+    //        |__Y__           |__X__           * sum_abc (nbar_a*nbar_b*n_c + n_a*n_b*nbar_c)
+    //        |    /\          |    /\          * (x_ciab y_abcj - y_ciab xabcj)
+    //        |   (  )   _     |   (  )
+    //        |____\/          |____\/       = 1/(2(2j+1)) sum_J (2J+1)
+    //      j | X            j |  Y            *  sum_c ( Pp*X*Phh*Y*Pp - Pp*Y*Phh*X*Pp)  - (Ph*X*Ppp*Y*Ph - Ph*Y*Ppp*X*Ph)_cicj
+    //
+    //
+    // -- AGREES WITH NATHAN'S RESULTS
+    //   No factor of 1/2 because the matrix multiplication corresponds to a restricted sum (a<=b)
+    // \f[
+    // [X_{(2)},Y_{(2)}]_{ij} = \frac{1}{2(2j_i+1)}\sum_{J}(2J+1)\sum_{c}
+    // \left( \mathcal{P}_{pp} (X \mathcal{P}_{hh} Y^{J}
+    // - Y^{J} \mathcal{P}_{hh} X^{J}) \mathcal{P}_{pp}
+    //  - \mathcal{P}_{hh} (X^{J} \mathcal{P}_{pp} Y^{J}
+    //  -  Y^{J} \mathcal{P}_{pp} X^{J}) \mathcal{P}_{hh} \right)_{cicj}
+    // \f]
+    /// \f[
+    /// [X_{(2)},Y_{(2)}]_{ij} = \frac{1}{2(2j_i+1)}\sum_{J}(2J+1)\sum_{abc} (\bar{n}_a\bar{n}_bn_c + n_an_b\bar{n}_c)
+    ///  (X^{J}_{ciab} Y^{J}_{abcj} - Y^{J}_{ciab}X^{J}_{abcj})
+    /// \f]
+    /// This may be rewritten as
+    /// \f[
+    /// [X_{(2)},Y_{(2)}]_{ij} = \frac{1}{2j_i+1} \sum_{c} \sum_{J} (2J+1) \left( n_c \mathcal{M}^{J}_{pp,icjc} + \bar{n}_c\mathcal{M}^{J}_{hh,icjc} \right)
+    /// \f]
+    /// With the intermediate matrix \f[ \mathcal{M}^{J}_{pp} \equiv \frac{1}{2} (X^{J}\mathcal{P}_{pp} Y^{J} - Y^{J}\mathcal{P}_{pp}X^{J}) \f]
+    /// and likewise for \f$ \mathcal{M}^{J}_{hh} \f$
+    //void Operator::comm221ss( const Operator& X, const Operator& Y)
+    void comm221ss( const Operator& X, const Operator& Y, Operator& Z)
+    {
 
+      double t_start = omp_get_wtime();
 
+      static TwoBodyME Mpp = Y.TwoBody;
+      static TwoBodyME Mhh = Y.TwoBody;
 
+      // Don't use omp, because the matrix multiplication is already
+      // parallelized by armadillo.
+      int nch = Z.modelspace->SortedTwoBodyChannels.size();
+#ifndef OPENBLAS_NOUSEOMP
+#pragma omp parallel for schedule(dynamic,1)
+#endif
+      for (int ich=0; ich<nch; ++ich)
+      {
+        int ch = Z.modelspace->SortedTwoBodyChannels[ich];
+        TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
+
+        auto& LHS = X.TwoBody.GetMatrix(ch,ch);
+        auto& RHS = Y.TwoBody.GetMatrix(ch,ch);
+
+        auto& Matrixpp = Mpp.GetMatrix(ch,ch);
+        auto& Matrixhh = Mhh.GetMatrix(ch,ch);
+
+        auto& kets_pp = tbc.GetKetIndex_pp();
+        auto& kets_hh = tbc.GetKetIndex_hh();
+        auto& kets_ph = tbc.GetKetIndex_ph();
+        auto& nanb = tbc.Ket_occ_hh;
+        auto& nbarnbar_hh = tbc.Ket_unocc_hh;
+        auto& nbarnbar_ph = tbc.Ket_unocc_ph;
+
+        Matrixpp =  LHS.cols(kets_pp) * RHS.rows(kets_pp);
+        Matrixhh =  LHS.cols(kets_hh) * arma::diagmat(nanb) *  RHS.rows(kets_hh) ;
+        if (kets_hh.size()>0)
+          Matrixpp +=  LHS.cols(kets_hh) * arma::diagmat(nbarnbar_hh) *  RHS.rows(kets_hh);
+        if (kets_ph.size()>0)
+          Matrixpp += LHS.cols(kets_ph) * arma::diagmat(nbarnbar_ph) *  RHS.rows(kets_ph) ;
+
+
+        if (Z.IsHermitian())
+        {
+          Matrixpp +=  Matrixpp.t();
+          Matrixhh +=  Matrixhh.t();
+        }
+        else if (Z.IsAntiHermitian()) // i.e. LHS and RHS are both hermitian or ant-hermitian
+        {
+          Matrixpp -=  Matrixpp.t();
+          Matrixhh -=  Matrixhh.t();
+        }
+        else
+        {
+          Matrixpp -=  RHS.cols(kets_pp) * LHS.rows(kets_pp);
+          Matrixhh -=  RHS.cols(kets_hh) * arma::diagmat(nanb) *  LHS.rows(kets_hh) ;
+          Matrixpp -=  RHS.cols(kets_hh) * arma::diagmat(nbarnbar_hh) *  LHS.rows(kets_hh) ;
+          if (kets_ph.size()>0)
+            Matrixpp -=  RHS.cols(kets_ph) * arma::diagmat(nbarnbar_ph) *  LHS.rows(kets_ph) ;
+        }
+
+
+      } //for ch
+
+      //   int norbits = Z.modelspace->GetNumberOrbits();
+      int norbits = Z.modelspace->all_orbits.size();
+      std::vector<index_t> allorb_vec( Z.modelspace->all_orbits.begin(), Z.modelspace->all_orbits.end());
+#pragma omp parallel for schedule(dynamic,1)
+      //   for (int i=0;i<norbits;++i)
+      for (int indexi=0;indexi<norbits;++indexi)
+      {
+        //      auto i = Z.modelspace->all_orbits[indexi];
+        auto i = allorb_vec[indexi];
+        Orbit &oi = Z.modelspace->GetOrbit(i);
+        int jmin = Z.IsNonHermitian() ? 0 : i;
+        for (int j : Z.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) )
+        {
+          if (j<jmin) continue;
+          double cijJ = 0;
+          for (int ch=0;ch<Z.nChannels;++ch)
+          {
+            TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
+            double Jfactor = (2*tbc.J+1.0);
+            // Sum c over holes and include the nbar_a * nbar_b terms
+            for (auto& c : Z.modelspace->holes)
+            {
+              Orbit& oc = Z.modelspace->GetOrbit(c);
+              cijJ += Jfactor * oc.occ     * Mpp.GetTBME(ch,c,i,c,j);
+              cijJ += Jfactor * (1-oc.occ) * Mhh.GetTBME(ch,c,i,c,j);
+              // Sum c over particles and include the n_a * n_b terms
+            }
+            for (auto& c : Z.modelspace->particles)
+            {
+              cijJ += Jfactor * Mhh.GetTBME(ch,c,i,c,j);
+            }
+          }
+          Z.OneBody(i,j) += cijJ /(oi.j2+1.0);
+        } // for j
+      }
+
+      X.profiler.timer["comm221ss"] += omp_get_wtime() - t_start;
+
+    }
 
-//*****************************************************************************************
-//
-//    |     |               |      |           [X2,Y1](2) = sum_a ( Y_ia X_ajkl + Y_ja X_iakl - Y_ak X_ijal - Y_al X_ijka )
-//    |     |___.Y          |__X___|         
-//    |     |         _     |      |          
-//    |_____|               |      |_____.Y        
-//    |  X  |               |      |            
-//
-// -- AGREES WITH NATHAN'S RESULTS
-/// Returns \f$ [X_{(1)},Y_{(2)}]_{(2)} - [Y_{(1)},X_{(2)}]_{(2)} \f$, where
-/// \f[
-/// [X_{(1)},Y_{(2)}]^{J}_{ijkl} = \sum_{a} ( X_{ia}Y^{J}_{ajkl} + X_{ja}Y^{J}_{iakl} - X_{ak} Y^{J}_{ijal} - X_{al} Y^{J}_{ijka} )
-/// \f]
-/// here, all TBME are unnormalized, i.e. they should have a tilde.
-// This is still too slow...
-//void Operator::comm122ss( Operator& Y, Operator& Z ) 
-//void Operator::comm122ss( const Operator& X, const Operator& Y ) 
-void comm122ss( const Operator& X, const Operator& Y, Operator& Z ) 
-{
-   auto& X1 = X.OneBody;
-   auto& Y1 = Y.OneBody;
-   int hZ = Z.IsHermitian() ? 1 : -1;
 
-   int n_nonzero = Z.modelspace->SortedTwoBodyChannels.size();
-   #pragma omp parallel for schedule(dynamic,1)
-   for (int ich=0; ich<n_nonzero; ++ich)
-   {
-      int ch = Z.modelspace->SortedTwoBodyChannels[ich];
-      TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
-      auto& X2 = X.TwoBody.GetMatrix(ch,ch);
-      auto& Y2 = Y.TwoBody.GetMatrix(ch,ch);
-      auto& Z2 = Z.TwoBody.GetMatrix(ch,ch);
-      arma::mat W2(size(Z2),arma::fill::zeros); // temporary intermediate matrix
 
-      int npq = tbc.GetNumberKets();
-      for (int indx_ij = 0;indx_ij<npq; ++indx_ij)
+
+
+    //*****************************************************************************************
+    //
+    //    |     |               |      |           [X2,Y1](2) = sum_a ( Y_ia X_ajkl + Y_ja X_iakl - Y_ak X_ijal - Y_al X_ijka )
+    //    |     |___.Y          |__X___|
+    //    |     |         _     |      |
+    //    |_____|               |      |_____.Y
+    //    |  X  |               |      |
+    //
+    // -- AGREES WITH NATHAN'S RESULTS
+    /// Returns \f$ [X_{(1)},Y_{(2)}]_{(2)} - [Y_{(1)},X_{(2)}]_{(2)} \f$, where
+    /// \f[
+    /// [X_{(1)},Y_{(2)}]^{J}_{ijkl} = \sum_{a} ( X_{ia}Y^{J}_{ajkl} + X_{ja}Y^{J}_{iakl} - X_{ak} Y^{J}_{ijal} - X_{al} Y^{J}_{ijka} )
+    /// \f]
+    /// here, all TBME are unnormalized, i.e. they should have a tilde.
+    // This is still too slow...
+    //void Operator::comm122ss( Operator& Y, Operator& Z )
+    //void Operator::comm122ss( const Operator& X, const Operator& Y )
+    void comm122ss( const Operator& X, const Operator& Y, Operator& Z )
+    {
+      auto& X1 = X.OneBody;
+      auto& Y1 = Y.OneBody;
+      int hZ = Z.IsHermitian() ? 1 : -1;
+
+      int n_nonzero = Z.modelspace->SortedTwoBodyChannels.size();
+#pragma omp parallel for schedule(dynamic,1)
+      for (int ich=0; ich<n_nonzero; ++ich)
       {
-         Ket & bra = tbc.GetKet(indx_ij);
-         int i = bra.p;
-         int j = bra.q;
-         Orbit& oi = Z.modelspace->GetOrbit(i);
-         Orbit& oj = Z.modelspace->GetOrbit(j);
-         int flipphaseij = - Z.modelspace->phase((oi.j2+oj.j2)/2-tbc.J);
-
-         // make lists of the indices we want, then do matrix multiplication.
-         // there may be a more efficient way to find these
-         std::vector<index_t> ind1_ia, ind1_ja,ind2_aj,ind2_ai;
-         std::vector<double> factor_ia,factor_ja;
-         for (int a : Z.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) )
-         {
+        int ch = Z.modelspace->SortedTwoBodyChannels[ich];
+        TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
+        auto& X2 = X.TwoBody.GetMatrix(ch,ch);
+        auto& Y2 = Y.TwoBody.GetMatrix(ch,ch);
+        auto& Z2 = Z.TwoBody.GetMatrix(ch,ch);
+        arma::mat W2(size(Z2),arma::fill::zeros); // temporary intermediate matrix
+
+        int npq = tbc.GetNumberKets();
+        for (int indx_ij = 0;indx_ij<npq; ++indx_ij)
+        {
+          Ket & bra = tbc.GetKet(indx_ij);
+          int i = bra.p;
+          int j = bra.q;
+          Orbit& oi = Z.modelspace->GetOrbit(i);
+          Orbit& oj = Z.modelspace->GetOrbit(j);
+          int flipphaseij = - Z.modelspace->phase((oi.j2+oj.j2)/2-tbc.J);
+
+          // make lists of the indices we want, then do matrix multiplication.
+          // there may be a more efficient way to find these
+          std::vector<index_t> ind1_ia, ind1_ja,ind2_aj,ind2_ai;
+          std::vector<double> factor_ia,factor_ja;
+          for (int a : Z.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) )
+          {
             size_t ind2 = tbc.GetLocalIndex( std::min(a,j), std::max(a,j) );
             if (ind2<0 or ind2>=tbc.GetNumberKets()) continue;
             ind1_ia.push_back(a);
             ind2_aj.push_back(ind2);
             factor_ia.push_back( a>j ? flipphaseij : (a==j ? PhysConst::SQRT2 : 1));
-         }
-         if (i!=j)
-         {
-           for (int a : Z.OneBodyChannels.at({oj.l,oj.j2,oj.tz2}) )
-           {
+          }
+          if (i!=j)
+          {
+            for (int a : Z.OneBodyChannels.at({oj.l,oj.j2,oj.tz2}) )
+            {
               size_t ind2 = tbc.GetLocalIndex( std::min(a,i), std::max(a,i) );
               if (ind2<0 or ind2>=tbc.GetNumberKets()) continue;
               ind1_ja.push_back(a);
               ind2_ai.push_back(ind2);
               factor_ja.push_back( i>a ? flipphaseij : (i==a ? PhysConst::SQRT2 : 1));
-           }
-
-         }
-
-         arma::uvec u_ind1_ia(ind1_ia);
-         arma::uvec u_ind1_ja(ind1_ja);
-         arma::uvec u_ind2_aj(ind2_aj);
-         arma::uvec u_ind2_ai(ind2_ai);
-         arma::vec  v_factor_ia(factor_ia);
-         arma::vec  v_factor_ja(factor_ja);
-         if (i==j)
-         {
-           v_factor_ia /= PhysConst::SQRT2;
-           v_factor_ja /= PhysConst::SQRT2;
-         }
-
-         // This is fairly obfuscated, but hopefully faster for bigger calculations
-         if (X.particle_rank>1 and Y.particle_rank>1)
-         {
+            }
+
+          }
+
+          arma::uvec u_ind1_ia(ind1_ia);
+          arma::uvec u_ind1_ja(ind1_ja);
+          arma::uvec u_ind2_aj(ind2_aj);
+          arma::uvec u_ind2_ai(ind2_ai);
+          arma::vec  v_factor_ia(factor_ia);
+          arma::vec  v_factor_ja(factor_ja);
+          if (i==j)
+          {
+            v_factor_ia /= PhysConst::SQRT2;
+            v_factor_ja /= PhysConst::SQRT2;
+          }
+
+          // This is fairly obfuscated, but hopefully faster for bigger calculations
+          if (X.particle_rank>1 and Y.particle_rank>1)
+          {
             W2.col(indx_ij) = join_horiz(    Y2.cols(join_vert( u_ind2_aj,u_ind2_ai))  , X2.cols(join_vert(u_ind2_aj,u_ind2_ai) ) )
-                             * join_vert(  join_vert( X1.unsafe_col(i).rows(u_ind1_ia)%v_factor_ia, X1.unsafe_col(j).rows(u_ind1_ja)%v_factor_ja ),
-                                          -join_vert( Y1.unsafe_col(i).rows(u_ind1_ia)%v_factor_ia, Y1.unsafe_col(j).rows(u_ind1_ja)%v_factor_ja ));
-         }
-         else if (X.particle_rank<2 and Y.particle_rank>1)
-         {
-            W2.col(indx_ij) =     Y2.cols(join_vert( u_ind2_aj,u_ind2_ai))    
-                             *   join_vert( X1.unsafe_col(i).rows(u_ind1_ia)%v_factor_ia, X1.unsafe_col(j).rows(u_ind1_ja)%v_factor_ja );
-         }
-         else if (X.particle_rank>1 and Y.particle_rank<2)
-         {
-            W2.col(indx_ij) =      -X2.cols(join_vert(u_ind2_aj,u_ind2_ai) ) 
-                                      *    join_vert( Y1.unsafe_col(i).rows(u_ind1_ia)%v_factor_ia, Y1.unsafe_col(j).rows(u_ind1_ja)%v_factor_ja );
-         }
-
-      if (i==j) W2.col(indx_ij) *= 2;
+              * join_vert(  join_vert( X1.unsafe_col(i).rows(u_ind1_ia)%v_factor_ia, X1.unsafe_col(j).rows(u_ind1_ja)%v_factor_ja ),
+                  -join_vert( Y1.unsafe_col(i).rows(u_ind1_ia)%v_factor_ia, Y1.unsafe_col(j).rows(u_ind1_ja)%v_factor_ja ));
+          }
+          else if (X.particle_rank<2 and Y.particle_rank>1)
+          {
+            W2.col(indx_ij) =     Y2.cols(join_vert( u_ind2_aj,u_ind2_ai))
+              *   join_vert( X1.unsafe_col(i).rows(u_ind1_ia)%v_factor_ia, X1.unsafe_col(j).rows(u_ind1_ja)%v_factor_ja );
+          }
+          else if (X.particle_rank>1 and Y.particle_rank<2)
+          {
+            W2.col(indx_ij) =      -X2.cols(join_vert(u_ind2_aj,u_ind2_ai) )
+              *    join_vert( Y1.unsafe_col(i).rows(u_ind1_ia)%v_factor_ia, Y1.unsafe_col(j).rows(u_ind1_ja)%v_factor_ja );
+          }
 
-      }
-      Z2 -= W2 + hZ*W2.t();
-   }
+          if (i==j) W2.col(indx_ij) *= 2;
 
-}
+        }
+        Z2 -= W2 + hZ*W2.t();
+      }
 
+    }
 
 
 
 
-//*****************************************************************************************
-//
-//  |     |      |     |   
-//  |__Y__|      |__x__|   [X2,Y2](2)_pp(hh) = 1/2 sum_ab (X_ijab Y_abkl - Y_ijab X_abkl)(1 - n_a - n_b)
-//  |     |  _   |     |                = 1/2 [ X*(P_pp-P_hh)*Y - Y*(P_pp-P_hh)*X ]
-//  |__X__|      |__Y__|   
-//  |     |      |     |   
-//
-// -- AGREES WITH NATHAN'S RESULTS
-//   No factor of 1/2 because the matrix multiplication corresponds to a restricted sum (a<=b) 
-/// Calculates the part of the commutator \f$ [X_{(2)},Y_{(2)}]_{(2)} \f$ which involves particle-particle
-/// or hole-hole intermediate states.
-/// \f[
-/// [X_{(2)},Y_{(2)}]^{J}_{ijkl} = \frac{1}{2} \sum_{ab} (\bar{n}_a\bar{n}_b - n_an_b) (X^{J}_{ijab}Y^{J}_{ablk} - Y^{J}_{ijab}X^{J}_{abkl})
-/// \f]
-/// This may be written as
-/// \f[
-/// [X_{(2)},Y_{(2)}]^{J} = \mathcal{M}^{J}_{pp} - \mathcal{M}^{J}_{hh}
-/// \f]
-/// With the intermediate matrices
-/// \f[
-/// \mathcal{M}^{J}_{pp} \equiv \frac{1}{2}(X^{J} \mathcal{P}_{pp} Y^{J} - Y^{J} \mathcal{P}_{pp} X^{J})
-/// \f]
-/// and likewise for \f$ \mathcal{M}^{J}_{hh} \f$.
-//void Operator::comm222_pp_hhss( Operator& opright, Operator& opout ) 
-//void Operator::comm222_pp_hhss( const Operator& X, const Operator& Y ) 
-void comm222_pp_hhss( const Operator& X, const Operator& Y, Operator& Z ) 
-{
 
-   static TwoBodyME Mpp = Z.TwoBody;
-   static TwoBodyME Mhh = Z.TwoBody;
-
-   double t = omp_get_wtime();
-   // Don't use omp, because the matrix multiplication is already
-   // parallelized by armadillo.
-   int nch = Z.modelspace->SortedTwoBodyChannels.size();
-   #ifndef OPENBLAS_NOUSEOMP
-   #pragma omp parallel for schedule(dynamic,1)
-   #endif
-   for (int ich=0; ich<nch; ++ich)
-   {
-      int ch = Z.modelspace->SortedTwoBodyChannels[ich];
-      TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
+    //*****************************************************************************************
+    //
+    //  |     |      |     |
+    //  |__Y__|      |__x__|   [X2,Y2](2)_pp(hh) = 1/2 sum_ab (X_ijab Y_abkl - Y_ijab X_abkl)(1 - n_a - n_b)
+    //  |     |  _   |     |                = 1/2 [ X*(P_pp-P_hh)*Y - Y*(P_pp-P_hh)*X ]
+    //  |__X__|      |__Y__|
+    //  |     |      |     |
+    //
+    // -- AGREES WITH NATHAN'S RESULTS
+    //   No factor of 1/2 because the matrix multiplication corresponds to a restricted sum (a<=b)
+    /// Calculates the part of the commutator \f$ [X_{(2)},Y_{(2)}]_{(2)} \f$ which involves particle-particle
+    /// or hole-hole intermediate states.
+    /// \f[
+    /// [X_{(2)},Y_{(2)}]^{J}_{ijkl} = \frac{1}{2} \sum_{ab} (\bar{n}_a\bar{n}_b - n_an_b) (X^{J}_{ijab}Y^{J}_{ablk} - Y^{J}_{ijab}X^{J}_{abkl})
+    /// \f]
+    /// This may be written as
+    /// \f[
+    /// [X_{(2)},Y_{(2)}]^{J} = \mathcal{M}^{J}_{pp} - \mathcal{M}^{J}_{hh}
+    /// \f]
+    /// With the intermediate matrices
+    /// \f[
+    /// \mathcal{M}^{J}_{pp} \equiv \frac{1}{2}(X^{J} \mathcal{P}_{pp} Y^{J} - Y^{J} \mathcal{P}_{pp} X^{J})
+    /// \f]
+    /// and likewise for \f$ \mathcal{M}^{J}_{hh} \f$.
+    //void Operator::comm222_pp_hhss( Operator& opright, Operator& opout )
+    //void Operator::comm222_pp_hhss( const Operator& X, const Operator& Y )
+    void comm222_pp_hhss( const Operator& X, const Operator& Y, Operator& Z )
+    {
 
-      auto& LHS = X.TwoBody.GetMatrix(ch,ch);
-      auto& RHS = Y.TwoBody.GetMatrix(ch,ch);
-      auto& OUT = Z.TwoBody.GetMatrix(ch,ch);
-
-      auto& Matrixpp = Mpp.GetMatrix(ch,ch);
-      auto& Matrixhh = Mhh.GetMatrix(ch,ch);
-
-      auto& kets_pp = tbc.GetKetIndex_pp();
-      auto& kets_hh = tbc.GetKetIndex_hh();
-      auto& kets_ph = tbc.GetKetIndex_ph();
-      auto& nanb = tbc.Ket_occ_hh;
-//      auto& nabar_nbbar = tbc.Ket_unocc_hh;
-      auto& nbarnbar_hh = tbc.Ket_unocc_hh;
-      auto& nbarnbar_ph = tbc.Ket_unocc_ph;
-      
-      Matrixpp =  LHS.cols(kets_pp) * RHS.rows(kets_pp);
-      Matrixhh =  LHS.cols(kets_hh) * arma::diagmat(nanb) *  RHS.rows(kets_hh) ;
-      if (kets_hh.size()>0)
-        Matrixpp +=  LHS.cols(kets_hh) * arma::diagmat(nbarnbar_hh) *  RHS.rows(kets_hh); 
-      if (kets_ph.size()>0)
-        Matrixpp += LHS.cols(kets_ph) * arma::diagmat(nbarnbar_ph) *  RHS.rows(kets_ph) ;
-
-
-      if (Z.IsHermitian())
+      static TwoBodyME Mpp = Z.TwoBody;
+      static TwoBodyME Mhh = Z.TwoBody;
+
+      double t = omp_get_wtime();
+      // Don't use omp, because the matrix multiplication is already
+      // parallelized by armadillo.
+      int nch = Z.modelspace->SortedTwoBodyChannels.size();
+#ifndef OPENBLAS_NOUSEOMP
+#pragma omp parallel for schedule(dynamic,1)
+#endif
+      for (int ich=0; ich<nch; ++ich)
       {
-         Matrixpp +=  Matrixpp.t();
-         Matrixhh +=  Matrixhh.t();
-      }
-      else if (Z.IsAntiHermitian()) // i.e. LHS and RHS are both hermitian or ant-hermitian
-      {
-         Matrixpp -=  Matrixpp.t();
-         Matrixhh -=  Matrixhh.t();
-      }
-      else
-      {
-        Matrixpp -=  RHS.cols(kets_pp) * LHS.rows(kets_pp);
-        Matrixhh -=  RHS.cols(kets_hh) * arma::diagmat(nanb) *  LHS.rows(kets_hh) ;
-        Matrixpp -=  RHS.cols(kets_hh) * arma::diagmat(nbarnbar_hh) *  LHS.rows(kets_hh) ;
+        int ch = Z.modelspace->SortedTwoBodyChannels[ich];
+        TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
+
+        auto& LHS = X.TwoBody.GetMatrix(ch,ch);
+        auto& RHS = Y.TwoBody.GetMatrix(ch,ch);
+        auto& OUT = Z.TwoBody.GetMatrix(ch,ch);
+
+        auto& Matrixpp = Mpp.GetMatrix(ch,ch);
+        auto& Matrixhh = Mhh.GetMatrix(ch,ch);
+
+        auto& kets_pp = tbc.GetKetIndex_pp();
+        auto& kets_hh = tbc.GetKetIndex_hh();
+        auto& kets_ph = tbc.GetKetIndex_ph();
+        auto& nanb = tbc.Ket_occ_hh;
+        //      auto& nabar_nbbar = tbc.Ket_unocc_hh;
+        auto& nbarnbar_hh = tbc.Ket_unocc_hh;
+        auto& nbarnbar_ph = tbc.Ket_unocc_ph;
+
+        Matrixpp =  LHS.cols(kets_pp) * RHS.rows(kets_pp);
+        Matrixhh =  LHS.cols(kets_hh) * arma::diagmat(nanb) *  RHS.rows(kets_hh) ;
+        if (kets_hh.size()>0)
+          Matrixpp +=  LHS.cols(kets_hh) * arma::diagmat(nbarnbar_hh) *  RHS.rows(kets_hh);
         if (kets_ph.size()>0)
-          Matrixpp -=  RHS.cols(kets_ph) * arma::diagmat(nbarnbar_ph) *  LHS.rows(kets_ph) ;
-      }
+          Matrixpp += LHS.cols(kets_ph) * arma::diagmat(nbarnbar_ph) *  RHS.rows(kets_ph) ;
 
 
-      // The two body part
-      OUT += Matrixpp - Matrixhh;
-   } //for ch
-   X.profiler.timer[__func__] += omp_get_wtime() - t;
-}
+        if (Z.IsHermitian())
+        {
+          Matrixpp +=  Matrixpp.t();
+          Matrixhh +=  Matrixhh.t();
+        }
+        else if (Z.IsAntiHermitian()) // i.e. LHS and RHS are both hermitian or ant-hermitian
+        {
+          Matrixpp -=  Matrixpp.t();
+          Matrixhh -=  Matrixhh.t();
+        }
+        else
+        {
+          Matrixpp -=  RHS.cols(kets_pp) * LHS.rows(kets_pp);
+          Matrixhh -=  RHS.cols(kets_hh) * arma::diagmat(nanb) *  LHS.rows(kets_hh) ;
+          Matrixpp -=  RHS.cols(kets_hh) * arma::diagmat(nbarnbar_hh) *  LHS.rows(kets_hh) ;
+          if (kets_ph.size()>0)
+            Matrixpp -=  RHS.cols(kets_ph) * arma::diagmat(nbarnbar_ph) *  LHS.rows(kets_ph) ;
+        }
 
 
+        // The two body part
+        OUT += Matrixpp - Matrixhh;
+      } //for ch
+      X.profiler.timer[__func__] += omp_get_wtime() - t;
+    }
 
 
 
 
 
 
-void ConstructScalarMpp_Mhh(const Operator& X, const Operator& Y, const Operator& Z, TwoBodyME& Mpp, TwoBodyME& Mhh)
-{
-   int nch = Z.modelspace->SortedTwoBodyChannels.size();
-   bool z_is_hermitian = Z.IsHermitian();
-   bool z_is_antihermitian = Z.IsAntiHermitian();
-   #ifndef OPENBLAS_NOUSEOMP
-   #pragma omp parallel for schedule(dynamic,1)
-   #endif
-   for (int ich=0; ich<nch; ++ich)
-   {
-      int ch = Z.modelspace->SortedTwoBodyChannels[ich];
-      TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
 
-      auto& LHS = X.TwoBody.GetMatrix(ch,ch);
-      auto& RHS = Y.TwoBody.GetMatrix(ch,ch);
-//      auto& OUT = Z.TwoBody.GetMatrix(ch,ch);
-
-      auto& Matrixpp = Mpp.GetMatrix(ch,ch);
-      auto& Matrixhh = Mhh.GetMatrix(ch,ch);
-
-      auto& kets_pp = tbc.GetKetIndex_pp();
-      auto& kets_hh = tbc.GetKetIndex_hh();
-      auto& kets_ph = tbc.GetKetIndex_ph();
-      auto& nanb = tbc.Ket_occ_hh;
-      auto& nbarnbar_hh = tbc.Ket_unocc_hh;
-      auto& nbarnbar_ph = tbc.Ket_unocc_ph;
-      
-      Matrixpp =  LHS.cols(kets_pp) * RHS.rows(kets_pp);
-      Matrixhh =  LHS.cols(kets_hh) * arma::diagmat(nanb) *  RHS.rows(kets_hh) ;
-      if (kets_hh.size()>0)
-        Matrixpp +=  LHS.cols(kets_hh) * arma::diagmat(nbarnbar_hh) *  RHS.rows(kets_hh); 
-      if (kets_ph.size()>0)
-        Matrixpp += LHS.cols(kets_ph) * arma::diagmat(nbarnbar_ph) *  RHS.rows(kets_ph) ;
-
-
-      if (z_is_hermitian)
-      {
-         Matrixpp +=  Matrixpp.t();
-         Matrixhh +=  Matrixhh.t();
-      }
-      else if (z_is_antihermitian) // i.e. LHS and RHS are both hermitian or ant-hermitian
-      {
-         Matrixpp -=  Matrixpp.t();
-         Matrixhh -=  Matrixhh.t();
-      }
-      else
+
+    void ConstructScalarMpp_Mhh(const Operator& X, const Operator& Y, const Operator& Z, TwoBodyME& Mpp, TwoBodyME& Mhh)
+    {
+      int nch = Z.modelspace->SortedTwoBodyChannels.size();
+      bool z_is_hermitian = Z.IsHermitian();
+      bool z_is_antihermitian = Z.IsAntiHermitian();
+#ifndef OPENBLAS_NOUSEOMP
+#pragma omp parallel for schedule(dynamic,1)
+#endif
+      for (int ich=0; ich<nch; ++ich)
       {
-        Matrixpp -=  RHS.cols(kets_pp) * LHS.rows(kets_pp);
-        Matrixhh -=  RHS.cols(kets_hh) * arma::diagmat(nanb) *  LHS.rows(kets_hh) ;
-        Matrixpp -=  RHS.cols(kets_hh) * arma::diagmat(nbarnbar_hh) *  LHS.rows(kets_hh) ;
+        int ch = Z.modelspace->SortedTwoBodyChannels[ich];
+        TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
+
+        auto& LHS = X.TwoBody.GetMatrix(ch,ch);
+        auto& RHS = Y.TwoBody.GetMatrix(ch,ch);
+        //      auto& OUT = Z.TwoBody.GetMatrix(ch,ch);
+
+        auto& Matrixpp = Mpp.GetMatrix(ch,ch);
+        auto& Matrixhh = Mhh.GetMatrix(ch,ch);
+
+        auto& kets_pp = tbc.GetKetIndex_pp();
+        auto& kets_hh = tbc.GetKetIndex_hh();
+        auto& kets_ph = tbc.GetKetIndex_ph();
+        auto& nanb = tbc.Ket_occ_hh;
+        auto& nbarnbar_hh = tbc.Ket_unocc_hh;
+        auto& nbarnbar_ph = tbc.Ket_unocc_ph;
+
+        Matrixpp =  LHS.cols(kets_pp) * RHS.rows(kets_pp);
+        Matrixhh =  LHS.cols(kets_hh) * arma::diagmat(nanb) *  RHS.rows(kets_hh) ;
+        if (kets_hh.size()>0)
+          Matrixpp +=  LHS.cols(kets_hh) * arma::diagmat(nbarnbar_hh) *  RHS.rows(kets_hh);
         if (kets_ph.size()>0)
-          Matrixpp -=  RHS.cols(kets_ph) * arma::diagmat(nbarnbar_ph) *  LHS.rows(kets_ph) ;
-      }
+          Matrixpp += LHS.cols(kets_ph) * arma::diagmat(nbarnbar_ph) *  RHS.rows(kets_ph) ;
 
 
-   } //for ch
+        if (z_is_hermitian)
+        {
+          Matrixpp +=  Matrixpp.t();
+          Matrixhh +=  Matrixhh.t();
+        }
+        else if (z_is_antihermitian) // i.e. LHS and RHS are both hermitian or ant-hermitian
+        {
+          Matrixpp -=  Matrixpp.t();
+          Matrixhh -=  Matrixhh.t();
+        }
+        else
+        {
+          Matrixpp -=  RHS.cols(kets_pp) * LHS.rows(kets_pp);
+          Matrixhh -=  RHS.cols(kets_hh) * arma::diagmat(nanb) *  LHS.rows(kets_hh) ;
+          Matrixpp -=  RHS.cols(kets_hh) * arma::diagmat(nbarnbar_hh) *  LHS.rows(kets_hh) ;
+          if (kets_ph.size()>0)
+            Matrixpp -=  RHS.cols(kets_ph) * arma::diagmat(nbarnbar_ph) *  LHS.rows(kets_ph) ;
+        }
 
-}
 
+      } //for ch
 
-/// Since comm222_pp_hhss() and comm221ss() both require the construction of 
-/// the intermediate matrices \f$\mathcal{M}_{pp} \f$ and \f$ \mathcal{M}_{hh} \f$, we can combine them and
-/// only calculate the intermediates once.
-void comm222_pp_hh_221ss( const Operator& X, const Operator& Y, Operator& Z )  
-{
+    }
 
-//   int herm = Z.IsHermitian() ? 1 : -1;
-//   Operator& Z = *this;
-
-   static TwoBodyME Mpp = Z.TwoBody;
-   static TwoBodyME Mhh = Z.TwoBody;
-
-   double t = omp_get_wtime();
-   ConstructScalarMpp_Mhh( X, Y, Z, Mpp, Mhh);
-
-//   Z.TwoBody += (Mpp - Mhh);
-   Z.TwoBody += Mpp;
-   Z.TwoBody -= Mhh;
-//   OUT += Matrixpp - Matrixhh;
-   X.profiler.timer["pphh TwoBody bit"] += omp_get_wtime() - t;
-
-   t = omp_get_wtime();
-//   int norbits = Z.modelspace->GetNumberOrbits();
-   int norbits = Z.modelspace->all_orbits.size();
-   // The one body part
-   std::vector<index_t> allorb_vec( Z.modelspace->all_orbits.begin(), Z.modelspace->all_orbits.end());
-   #pragma omp parallel for schedule(dynamic,1)
-//   for (int i=0;i<norbits;++i)
-   for (int indexi=0;indexi<norbits;++indexi)
-   {
-//      auto i = Z.modelspace->all_orbits[indexi];
-      auto i = allorb_vec[indexi];
-      Orbit &oi = Z.modelspace->GetOrbit(i);
-      int jmin = Z.IsNonHermitian() ? 0 : i;
-      for (int j : Z.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) )
+
+    /// Since comm222_pp_hhss() and comm221ss() both require the construction of
+    /// the intermediate matrices \f$\mathcal{M}_{pp} \f$ and \f$ \mathcal{M}_{hh} \f$, we can combine them and
+    /// only calculate the intermediates once.
+    void comm222_pp_hh_221ss( const Operator& X, const Operator& Y, Operator& Z )
+    {
+
+      //   int herm = Z.IsHermitian() ? 1 : -1;
+      //   Operator& Z = *this;
+
+      static TwoBodyME Mpp = Z.TwoBody;
+      static TwoBodyME Mhh = Z.TwoBody;
+
+      double t = omp_get_wtime();
+      ConstructScalarMpp_Mhh( X, Y, Z, Mpp, Mhh);
+
+      //   Z.TwoBody += (Mpp - Mhh);
+      Z.TwoBody += Mpp;
+      Z.TwoBody -= Mhh;
+      //   OUT += Matrixpp - Matrixhh;
+      X.profiler.timer["pphh TwoBody bit"] += omp_get_wtime() - t;
+
+      t = omp_get_wtime();
+      //   int norbits = Z.modelspace->GetNumberOrbits();
+      int norbits = Z.modelspace->all_orbits.size();
+      // The one body part
+      std::vector<index_t> allorb_vec( Z.modelspace->all_orbits.begin(), Z.modelspace->all_orbits.end());
+#pragma omp parallel for schedule(dynamic,1)
+      //   for (int i=0;i<norbits;++i)
+      for (int indexi=0;indexi<norbits;++indexi)
       {
-         if (j<jmin) continue;
-         double cijJ = 0;
-         for (int ch=0;ch<Z.nChannels;++ch)
-         {
+        //      auto i = Z.modelspace->all_orbits[indexi];
+        auto i = allorb_vec[indexi];
+        Orbit &oi = Z.modelspace->GetOrbit(i);
+        int jmin = Z.IsNonHermitian() ? 0 : i;
+        for (int j : Z.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) )
+        {
+          if (j<jmin) continue;
+          double cijJ = 0;
+          for (int ch=0;ch<Z.nChannels;++ch)
+          {
             TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
             double Jfactor = (2*tbc.J+1.0);
             // Sum c over holes and include the nbar_a * nbar_b terms
             for (auto& c : Z.modelspace->holes)
             {
-               Orbit& oc = Z.modelspace->GetOrbit(c);
-               cijJ += Jfactor * oc.occ * Mpp.GetTBME(ch,c,i,c,j); 
-               cijJ += Jfactor * (1-oc.occ) * Mhh.GetTBME(ch,c,i,c,j); 
+              Orbit& oc = Z.modelspace->GetOrbit(c);
+              cijJ += Jfactor * oc.occ * Mpp.GetTBME(ch,c,i,c,j);
+              cijJ += Jfactor * (1-oc.occ) * Mhh.GetTBME(ch,c,i,c,j);
             }
             // Sum c over particles and include the n_a * n_b terms
             for (auto& c : Z.modelspace->particles)
             {
-               cijJ += Jfactor * Mhh.GetTBME(ch,c,i,c,j);
+              cijJ += Jfactor * Mhh.GetTBME(ch,c,i,c,j);
             }
-         }
-         Z.OneBody(i,j) += cijJ /(oi.j2+1.0);
-      } // for j
-   } // for i
-   X.profiler.timer["pphh One Body bit"] += omp_get_wtime() - t;
-}
+          }
+          Z.OneBody(i,j) += cijJ /(oi.j2+1.0);
+        } // for j
+      } // for i
+      X.profiler.timer["pphh One Body bit"] += omp_get_wtime() - t;
+    }
 
 
 
-//**************************************************************************
-//
-//  X^J_ij`kl` = - sum_J' { i j J } (2J'+1) X^J'_ilkj
-//                        { k l J'}
-// SCALAR VARIETY
-/// The scalar Pandya transformation is defined as
-/// \f[
-///  \bar{X}^{J}_{i\bar{j}k\bar{l}} = - \sum_{J'} (2J'+1)
-///  \left\{ \begin{array}{lll}
-///  j_i  &  j_j  &  J \\
-///  j_k  &  j_l  &  J' \\
-///  \end{array} \right\}
-///  X^{J}_{ilkj}
-/// \f]
-/// where the overbar indicates time-reversed orbits.
-//void Operator::DoPandyaTransformation_SingleChannel(arma::mat& TwoBody_CC_ph, int ch_cc, std::string orientation="normal") const
-void DoPandyaTransformation_SingleChannel(const Operator& Z, arma::mat& TwoBody_CC_ph, int ch_cc, std::string orientation="normal")
-{
-   int herm = Z.IsHermitian() ? 1 : -1;
-   TwoBodyChannel& tbc_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_cc);
-   int nKets_cc = tbc_cc.GetNumberKets();
-   arma::uvec kets_ph = arma::join_cols(tbc_cc.GetKetIndex_hh(), tbc_cc.GetKetIndex_ph() );
-   int nph_kets = kets_ph.n_rows;
-   int J_cc = tbc_cc.J;
-
-   if (orientation=="normal") TwoBody_CC_ph.zeros( 2*nph_kets, nKets_cc);
-   else if (orientation=="transpose") TwoBody_CC_ph.zeros( nKets_cc, 2*nph_kets);
-   else
-   {
-     std::cout << __PRETTY_FUNCTION__ << " =>  Unknown orientation input  " << orientation << ". Don't know what to do with this." << std::endl;
-     return;
-   }
+    //**************************************************************************
+    //
+    //  X^J_ij`kl` = - sum_J' { i j J } (2J'+1) X^J'_ilkj
+    //                        { k l J'}
+    // SCALAR VARIETY
+    /// The scalar Pandya transformation is defined as
+    /// \f[
+    ///  \bar{X}^{J}_{i\bar{j}k\bar{l}} = - \sum_{J'} (2J'+1)
+    ///  \left\{ \begin{array}{lll}
+    ///  j_i  &  j_j  &  J \\
+    ///  j_k  &  j_l  &  J' \\
+    ///  \end{array} \right\}
+    ///  X^{J}_{ilkj}
+    /// \f]
+    /// where the overbar indicates time-reversed orbits.
+    //void Operator::DoPandyaTransformation_SingleChannel(arma::mat& TwoBody_CC_ph, int ch_cc, std::string orientation="normal") const
+    void DoPandyaTransformation_SingleChannel(const Operator& Z, arma::mat& TwoBody_CC_ph, int ch_cc, std::string orientation="normal")
+    {
+      int herm = Z.IsHermitian() ? 1 : -1;
+      TwoBodyChannel& tbc_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_cc);
+      int nKets_cc = tbc_cc.GetNumberKets();
+      arma::uvec kets_ph = arma::join_cols(tbc_cc.GetKetIndex_hh(), tbc_cc.GetKetIndex_ph() );
+      int nph_kets = kets_ph.n_rows;
+      int J_cc = tbc_cc.J;
 
-   // loop over cross-coupled ph bras <ab| in this channel
-   // (this is the side that gets summed over in the matrix multiplication)
-   for (int ibra=0; ibra<nph_kets; ++ibra)
-   {
-      Ket & bra_cc = tbc_cc.GetKet( kets_ph[ibra] );
-      // we want to evaluate a<=b and a>=b, so to avoid code duplication, we turn this into a loop over the two orderings
-      std::vector<size_t> ab_switcheroo = { bra_cc.p, bra_cc.q };
-      for ( int ab_case=0; ab_case<=1; ab_case++)
+      if (orientation=="normal") TwoBody_CC_ph.zeros( 2*nph_kets, nKets_cc);
+      else if (orientation=="transpose") TwoBody_CC_ph.zeros( nKets_cc, 2*nph_kets);
+      else
       {
-        int a = ab_switcheroo[ab_case];   // this little bit gives us a,b if ab_case=0 and b,a if ab_case=1
-        int b = ab_switcheroo[1-ab_case];
-        size_t bra_shift = ab_case*nph_kets;  // if we switch a<->b, we offset the bra index by nph_kets
-
-        Orbit & oa = Z.modelspace->GetOrbit(a);
-        Orbit & ob = Z.modelspace->GetOrbit(b);
-        double ja = oa.j2*0.5;
-        double jb = ob.j2*0.5;
-        double na_nb_factor = oa.occ - ob.occ;
+        std::cout << __PRETTY_FUNCTION__ << " =>  Unknown orientation input  " << orientation << ". Don't know what to do with this." << std::endl;
+        return;
+      }
 
-        // loop over cross-coupled kets |cd> in this channel
-        for (int iket_cc=0; iket_cc<nKets_cc; ++iket_cc)
+      // loop over cross-coupled ph bras <ab| in this channel
+      // (this is the side that gets summed over in the matrix multiplication)
+      for (int ibra=0; ibra<nph_kets; ++ibra)
+      {
+        Ket & bra_cc = tbc_cc.GetKet( kets_ph[ibra] );
+        // we want to evaluate a<=b and a>=b, so to avoid code duplication, we turn this into a loop over the two orderings
+        std::vector<size_t> ab_switcheroo = { bra_cc.p, bra_cc.q };
+        for ( int ab_case=0; ab_case<=1; ab_case++)
         {
-           Ket & ket_cc = tbc_cc.GetKet(iket_cc%nKets_cc);
-           int c = iket_cc < nKets_cc ? ket_cc.p : ket_cc.q;
-           int d = iket_cc < nKets_cc ? ket_cc.q : ket_cc.p;
-           Orbit & oc = Z.modelspace->GetOrbit(c);
-           Orbit & od = Z.modelspace->GetOrbit(d);
-           double jc = oc.j2*0.5;
-           double jd = od.j2*0.5;
-
-           int jmin = std::max(std::abs(ja-jd),std::abs(jc-jb));
-           int jmax = std::min(ja+jd,jc+jb);
-           double Xbar = 0;
-           for (int J_std=jmin; J_std<=jmax; ++J_std)
-           {
+          int a = ab_switcheroo[ab_case];   // this little bit gives us a,b if ab_case=0 and b,a if ab_case=1
+          int b = ab_switcheroo[1-ab_case];
+          size_t bra_shift = ab_case*nph_kets;  // if we switch a<->b, we offset the bra index by nph_kets
+
+          Orbit & oa = Z.modelspace->GetOrbit(a);
+          Orbit & ob = Z.modelspace->GetOrbit(b);
+          double ja = oa.j2*0.5;
+          double jb = ob.j2*0.5;
+          double na_nb_factor = oa.occ - ob.occ;
+
+          // loop over cross-coupled kets |cd> in this channel
+          for (int iket_cc=0; iket_cc<nKets_cc; ++iket_cc)
+          {
+            Ket & ket_cc = tbc_cc.GetKet(iket_cc%nKets_cc);
+            int c = iket_cc < nKets_cc ? ket_cc.p : ket_cc.q;
+            int d = iket_cc < nKets_cc ? ket_cc.q : ket_cc.p;
+            Orbit & oc = Z.modelspace->GetOrbit(c);
+            Orbit & od = Z.modelspace->GetOrbit(d);
+            double jc = oc.j2*0.5;
+            double jd = od.j2*0.5;
+
+            int jmin = std::max(std::abs(ja-jd),std::abs(jc-jb));
+            int jmax = std::min(ja+jd,jc+jb);
+            double Xbar = 0;
+            for (int J_std=jmin; J_std<=jmax; ++J_std)
+            {
               double sixj = Z.modelspace->GetSixJ(ja,jb,J_cc,jc,jd,J_std);
               if (std::abs(sixj) < 1e-8) continue;
               double tbme = Z.TwoBody.GetTBME_J(J_std,a,d,c,b);
               Xbar -= (2*J_std+1) * sixj * tbme ;
-           }
-           if (orientation=="normal")
-           {
-             TwoBody_CC_ph(ibra+bra_shift, iket_cc) = Xbar;
-           }
-           else // "transpose"
-           {
-             TwoBody_CC_ph(iket_cc,ibra+bra_shift) = herm * Xbar * na_nb_factor;  // we slap the (na-nb) on the transposed one.
-           }
+            }
+            if (orientation=="normal")
+            {
+              TwoBody_CC_ph(ibra+bra_shift, iket_cc) = Xbar;
+            }
+            else // "transpose"
+            {
+              TwoBody_CC_ph(iket_cc,ibra+bra_shift) = herm * Xbar * na_nb_factor;  // we slap the (na-nb) on the transposed one.
+            }
 
+          }
         }
       }
-   }
-}
+    }
 
+    void DoPandyaTransformation_SingleChannel_XandY(const Operator& X, const Operator& Y, arma::mat& X2_CC_ph, arma::mat& Y2_CC_ph, int ch_cc)
+    {
+      //   int hX = X.IsHermitian() ? 1 : -1;
+      //   int hY = X.IsHermitian() ? 1 : -1;
+      TwoBodyChannel& tbc_cc = X.modelspace->GetTwoBodyChannel_CC(ch_cc);
+      int nKets_cc = tbc_cc.GetNumberKets();
+      arma::uvec kets_ph = arma::join_cols(tbc_cc.GetKetIndex_hh(), tbc_cc.GetKetIndex_ph() );
+      int nph_kets = kets_ph.n_rows;
+      int J_cc = tbc_cc.J;
 
-//void Operator::DoPandyaTransformation(deque<arma::mat>& TwoBody_CC_ph, std::string orientation="normal") const
-void DoPandyaTransformation(const Operator& Z, std::deque<arma::mat>& TwoBody_CC_ph, std::string orientation="normal")
-{
-   // loop over cross-coupled channels
-   int n_nonzero = Z.modelspace->SortedTwoBodyChannels_CC.size();
-   #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar_transform_first_pass)
-   for (int ich=0; ich<n_nonzero; ++ich)
-   {
-      int ch_cc = Z.modelspace->SortedTwoBodyChannels_CC[ich];
-      DoPandyaTransformation_SingleChannel(Z, TwoBody_CC_ph[ch_cc] , ch_cc, orientation);
-   }
-}
+      X2_CC_ph.zeros( nKets_cc, 2*nph_kets );
+      Y2_CC_ph.zeros( 2*nph_kets, nKets_cc);
+
+
+      // loop over cross-coupled ph bras <ab| in this channel
+      // (this is the side that gets summed over in the matrix multiplication)
+      for (int ibra=0; ibra<nph_kets; ++ibra)
+      {
+        Ket & bra_cc = tbc_cc.GetKet( kets_ph[ibra] );
+        // we want to evaluate a<=b and a>=b, so to avoid code duplication, we turn this into a loop over the two orderings
+        std::vector<size_t> ab_switcheroo = { bra_cc.p, bra_cc.q };
+        for ( int ab_case=0; ab_case<=1; ab_case++)
+        {
+          int a = ab_switcheroo[ab_case];   // this little bit gives us a,b if ab_case=0 and b,a if ab_case=1
+          int b = ab_switcheroo[1-ab_case];
+          size_t bra_shift = ab_case*nph_kets;  // if we switch a<->b, we offset the bra index by nph_kets
+
+          Orbit & oa = X.modelspace->GetOrbit(a);
+          Orbit & ob = X.modelspace->GetOrbit(b);
+          double ja = oa.j2*0.5;
+          double jb = ob.j2*0.5;
+          double na_nb_factor = oa.occ - ob.occ;
+
+          // loop over cross-coupled kets |cd> in this channel
+          for (int iket_cc=0; iket_cc<nKets_cc; ++iket_cc)
+          {
+            Ket & ket_cc = tbc_cc.GetKet(iket_cc%nKets_cc);
+            int c = iket_cc < nKets_cc ? ket_cc.p : ket_cc.q;
+            int d = iket_cc < nKets_cc ? ket_cc.q : ket_cc.p;
+            Orbit & oc = X.modelspace->GetOrbit(c);
+            Orbit & od = X.modelspace->GetOrbit(d);
+            double jc = oc.j2*0.5;
+            double jd = od.j2*0.5;
+
+            int jmin = std::max(std::abs(ja-jd),std::abs(jc-jb));
+            int jmax = std::min(ja+jd,jc+jb);
+            double Xbar = 0;
+            double Ybar = 0;
+            for (int J_std=jmin; J_std<=jmax; ++J_std)
+            {
+              double sixj = X.modelspace->GetSixJ(ja,jb,J_cc,jc,jd,J_std);
+              if (std::abs(sixj) < 1e-8) continue;
+              //              double tbme = Z.TwoBody.GetTBME_J(J_std,a,d,c,b);
+              double xcbad = X.TwoBody.GetTBME_J(J_std,c,b,a,d);
+              double yadcb = Y.TwoBody.GetTBME_J(J_std,a,d,c,b);
+              Xbar -= (2*J_std+1) * sixj * xcbad ;
+              Ybar -= (2*J_std+1) * sixj * yadcb ;
+            }
+            X2_CC_ph( iket_cc, ibra+bra_shift ) = Xbar * na_nb_factor;
+            Y2_CC_ph( ibra+bra_shift, iket_cc ) = Ybar;
 
+          }// for iket_cc
+        }// for ab_case
+      }// for ibra
+    }
 
 
-void AddInversePandyaTransformation_SingleChannel( Operator& Z,  arma::mat& Zbar, int ch_cc)
-{
-    // Only go parallel if we've previously calculated the SixJ's. Otherwise, it's not thread safe.
-   TwoBodyChannel_CC& tbc_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_cc);
-   int Jcc = tbc_cc.J;
-   int Jhat2 = 2*Jcc+1;
-   int parity_cc = tbc_cc.parity;
-   int Tz_cc = tbc_cc.Tz;
-   int nkets_cc = tbc_cc.GetNumberKets();
-   int n_nonzeroChannels = Z.modelspace->SortedTwoBodyChannels.size();
-//   #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar_transform_first_pass)
-   for (int ich = 0; ich < n_nonzeroChannels; ++ich)
-   {
-      int ch = Z.modelspace->SortedTwoBodyChannels[ich];
-      TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
-      int J = tbc.J;
-      int nKets = tbc.GetNumberKets();
-      auto& Zmat = Z.TwoBody.GetMatrix(ch,ch);
 
-      for (int ibra=0; ibra<nKets; ++ibra)
+
+
+
+    //void Operator::DoPandyaTransformation(deque<arma::mat>& TwoBody_CC_ph, std::string orientation="normal") const
+    void DoPandyaTransformation(const Operator& Z, std::deque<arma::mat>& TwoBody_CC_ph, std::string orientation="normal")
+    {
+      // loop over cross-coupled channels
+      int n_nonzero = Z.modelspace->SortedTwoBodyChannels_CC.size();
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar_transform_first_pass)
+      for (int ich=0; ich<n_nonzero; ++ich)
+      {
+        int ch_cc = Z.modelspace->SortedTwoBodyChannels_CC[ich];
+        DoPandyaTransformation_SingleChannel(Z, TwoBody_CC_ph[ch_cc] , ch_cc, orientation);
+      }
+    }
+
+
+
+    void AddInversePandyaTransformation_SingleChannel( Operator& Z,  arma::mat& Zbar, int ch_cc)
+    {
+      // Only go parallel if we've previously calculated the SixJ's. Otherwise, it's not thread safe.
+      TwoBodyChannel_CC& tbc_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_cc);
+      int Jcc = tbc_cc.J;
+      int Jhat2 = 2*Jcc+1;
+      int parity_cc = tbc_cc.parity;
+      int Tz_cc = tbc_cc.Tz;
+      int nkets_cc = tbc_cc.GetNumberKets();
+      int n_nonzeroChannels = Z.modelspace->SortedTwoBodyChannels.size();
+      //   #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar_transform_first_pass)
+      for (int ich = 0; ich < n_nonzeroChannels; ++ich)
       {
-         Ket & bra = tbc.GetKet(ibra);
-         int i = bra.p;
-         int j = bra.q;
-         Orbit & oi = Z.modelspace->GetOrbit(i);
-         Orbit & oj = Z.modelspace->GetOrbit(j);
-         double ji = 0.5*oi.j2;
-         double jj = 0.5*oj.j2;
-         int ketmin = Z.IsHermitian() ? ibra : ibra+1;
-         for (int iket=ketmin; iket<nKets; ++iket)
-         {
+        int ch = Z.modelspace->SortedTwoBodyChannels[ich];
+        TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
+        int J = tbc.J;
+        int nKets = tbc.GetNumberKets();
+        auto& Zmat = Z.TwoBody.GetMatrix(ch,ch);
+
+        for (int ibra=0; ibra<nKets; ++ibra)
+        {
+          Ket & bra = tbc.GetKet(ibra);
+          int i = bra.p;
+          int j = bra.q;
+          Orbit & oi = Z.modelspace->GetOrbit(i);
+          Orbit & oj = Z.modelspace->GetOrbit(j);
+          double ji = 0.5*oi.j2;
+          double jj = 0.5*oj.j2;
+          int ketmin = Z.IsHermitian() ? ibra : ibra+1;
+          for (int iket=ketmin; iket<nKets; ++iket)
+          {
             Ket & ket = tbc.GetKet(iket);
             int k = ket.p;
             int l = ket.q;
@@ -1362,13 +1439,13 @@ void AddInversePandyaTransformation_SingleChannel( Operator& Z,  arma::mat& Zbar
 
             int jmin = std::max(std::abs(int(ji-jl)),std::abs(int(jk-jj)));
             int jmax = std::min(int(ji+jl),int(jk+jj));
-//            if ( ((oi.l+ol.l)%2==parity_cc)  and  (std::abs(oi.tz2+ol.tz2)==Tz_cc*2) and (Jcc>=jmin) and (Jcc<=jmax) )
+            //            if ( ((oi.l+ol.l)%2==parity_cc)  and  (std::abs(oi.tz2+ol.tz2)==Tz_cc*2) and (Jcc>=jmin) and (Jcc<=jmax) )
             if ( ((oi.l+ol.l)%2==parity_cc)  and  (std::abs(oi.tz2-ol.tz2)==Tz_cc*2) and (Jcc>=jmin) and (Jcc<=jmax) )
             {
-               double sixj = Z.modelspace->GetSixJ(ji,jj,J,jk,jl,Jcc);
-               int indx_il = tbc_cc.GetLocalIndex(i,l) ;
-               int indx_kj = tbc_cc.GetLocalIndex( std::min(j,k), std::max(j,k) ) +(k>j?nkets_cc:0);
-               commij -= Jhat2 * sixj * Zbar(indx_il,indx_kj) ;
+              double sixj = Z.modelspace->GetSixJ(ji,jj,J,jk,jl,Jcc);
+              int indx_il = tbc_cc.GetLocalIndex(i,l) ;
+              int indx_kj = tbc_cc.GetLocalIndex( std::min(j,k), std::max(j,k) ) +(k>j?nkets_cc:0);
+              commij -= Jhat2 * sixj * Zbar(indx_il,indx_kj) ;
 
             }
 
@@ -1385,56 +1462,56 @@ void AddInversePandyaTransformation_SingleChannel( Operator& Z,  arma::mat& Zbar
               // now loop over the cross coupled TBME's
               jmin = std::max(std::abs(int(jj-jl)),std::abs(int(jk-ji)));
               jmax = std::min(int(jj+jl),int(jk+ji));
-//              if ( (oi.l+ok.l)%2==parity_cc  and  std::abs(oi.tz2+ok.tz2)==Tz_cc*2 and Jcc>=jmin and Jcc<=jmax)
+              //              if ( (oi.l+ok.l)%2==parity_cc  and  std::abs(oi.tz2+ok.tz2)==Tz_cc*2 and Jcc>=jmin and Jcc<=jmax)
               if ( (oi.l+ok.l)%2==parity_cc  and  std::abs(oi.tz2-ok.tz2)==Tz_cc*2 and Jcc>=jmin and Jcc<=jmax)
               {
-                 double sixj = Z.modelspace->GetSixJ(jj,ji,J,jk,jl,Jcc);
-                 int indx_ik = tbc_cc.GetLocalIndex(i,k) ;
-                 int indx_lj = tbc_cc.GetLocalIndex(std::min(l,j),std::max(l,j)) +(l>j?nkets_cc:0);
-                 // we always have i<=k so we should always flip Z_jlki = (-1)^{i+j+k+l} Z_iklj
-                 // the phase we get from that flip combines with the phase from Pij, to give the phase included below
-                 commji -= Jhat2 *  sixj *  Zbar(indx_ik, indx_lj) ;
+                double sixj = Z.modelspace->GetSixJ(jj,ji,J,jk,jl,Jcc);
+                int indx_ik = tbc_cc.GetLocalIndex(i,k) ;
+                int indx_lj = tbc_cc.GetLocalIndex(std::min(l,j),std::max(l,j)) +(l>j?nkets_cc:0);
+                // we always have i<=k so we should always flip Z_jlki = (-1)^{i+j+k+l} Z_iklj
+                // the phase we get from that flip combines with the phase from Pij, to give the phase included below
+                commji -= Jhat2 *  sixj *  Zbar(indx_ik, indx_lj) ;
 
 
               }
             }
             double norm = bra.delta_pq()==ket.delta_pq() ? 1+bra.delta_pq() : PhysConst::SQRT2;
-            #pragma omp atomic
+#pragma omp atomic
             Zmat(ibra,iket) -= (commij - Z.modelspace->phase(jk+jl-J ) * commji) / norm;
-         }
+          }
+        }
       }
-   }
-}
-
+    }
 
 
-//void Operator::AddInversePandyaTransformation(const deque<arma::mat>& Zbar)
-void AddInversePandyaTransformation(const std::deque<arma::mat>& Zbar, Operator& Z)
-{
-    // Do the inverse Pandya transform
-    // Only go parallel if we've previously calculated the SixJ's. Otherwise, it's not thread safe.
-   int n_nonzeroChannels = Z.modelspace->SortedTwoBodyChannels.size();
 
-   #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar_transform_first_pass)
-   for (int ich = 0; ich < n_nonzeroChannels; ++ich)
-   {
-      int ch = Z.modelspace->SortedTwoBodyChannels[ich];
-      TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
-      int J = tbc.J;
-      int nKets = tbc.GetNumberKets();
+    //void Operator::AddInversePandyaTransformation(const deque<arma::mat>& Zbar)
+    void AddInversePandyaTransformation(const std::deque<arma::mat>& Zbar, Operator& Z)
+    {
+      // Do the inverse Pandya transform
+      // Only go parallel if we've previously calculated the SixJ's. Otherwise, it's not thread safe.
+      int n_nonzeroChannels = Z.modelspace->SortedTwoBodyChannels.size();
 
-      for (int ibra=0; ibra<nKets; ++ibra)
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar_transform_first_pass)
+      for (int ich = 0; ich < n_nonzeroChannels; ++ich)
       {
-         Ket & bra = tbc.GetKet(ibra);
-         int i = bra.p;
-         int j = bra.q;
-         Orbit & oi = Z.modelspace->GetOrbit(i);
-         Orbit & oj = Z.modelspace->GetOrbit(j);
-         double ji = oi.j2/2.;
-         double jj = oj.j2/2.;
-         int ketmin = Z.IsHermitian() ? ibra : ibra+1;
-         for (int iket=ketmin; iket<nKets; ++iket)
-         {
+        int ch = Z.modelspace->SortedTwoBodyChannels[ich];
+        TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
+        int J = tbc.J;
+        int nKets = tbc.GetNumberKets();
+
+        for (int ibra=0; ibra<nKets; ++ibra)
+        {
+          Ket & bra = tbc.GetKet(ibra);
+          int i = bra.p;
+          int j = bra.q;
+          Orbit & oi = Z.modelspace->GetOrbit(i);
+          Orbit & oj = Z.modelspace->GetOrbit(j);
+          double ji = oi.j2/2.;
+          double jj = oj.j2/2.;
+          int ketmin = Z.IsHermitian() ? ibra : ibra+1;
+          for (int iket=ketmin; iket<nKets; ++iket)
+          {
             Ket & ket = tbc.GetKet(iket);
             int k = ket.p;
             int l = ket.q;
@@ -1447,21 +1524,21 @@ void AddInversePandyaTransformation(const std::deque<arma::mat>& Zbar, Operator&
             double commji = 0;
 
             int parity_cc = (oi.l+ol.l)%2;
-//            int Tz_cc = std::abs(oi.tz2+ol.tz2)/2;
+            //            int Tz_cc = std::abs(oi.tz2+ol.tz2)/2;
             int Tz_cc = std::abs(oi.tz2-ol.tz2)/2;
             int Jpmin = std::max(std::abs(int(ji-jl)),std::abs(int(jk-jj)));
             int Jpmax = std::min(int(ji+jl),int(jk+jj));
             for (int Jprime=Jpmin; Jprime<=Jpmax; ++Jprime)
             {
-               double sixj = Z.modelspace->GetSixJ(ji,jj,J,jk,jl,Jprime);
-               if (std::abs(sixj)<1e-8) continue;
-               int ch_cc = Z.modelspace->GetTwoBodyChannelIndex(Jprime,parity_cc,Tz_cc);
-               TwoBodyChannel_CC& tbc_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_cc);
-               int nkets_cc = tbc_cc.GetNumberKets();
-               int indx_il = tbc_cc.GetLocalIndex(std::min(i,l),std::max(i,l)) +(i>l?nkets_cc:0);
-               int indx_kj = tbc_cc.GetLocalIndex(std::min(j,k),std::max(j,k)) +(k>j?nkets_cc:0);
-               double me1 = Zbar.at(ch_cc)(indx_il,indx_kj);
-               commij -= (2*Jprime+1) * sixj * me1;
+              double sixj = Z.modelspace->GetSixJ(ji,jj,J,jk,jl,Jprime);
+              if (std::abs(sixj)<1e-8) continue;
+              int ch_cc = Z.modelspace->GetTwoBodyChannelIndex(Jprime,parity_cc,Tz_cc);
+              TwoBodyChannel_CC& tbc_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_cc);
+              int nkets_cc = tbc_cc.GetNumberKets();
+              int indx_il = tbc_cc.GetLocalIndex(std::min(i,l),std::max(i,l)) +(i>l?nkets_cc:0);
+              int indx_kj = tbc_cc.GetLocalIndex(std::min(j,k),std::max(j,k)) +(k>j?nkets_cc:0);
+              double me1 = Zbar.at(ch_cc)(indx_il,indx_kj);
+              commij -= (2*Jprime+1) * sixj * me1;
             }
 
             if (k==l)
@@ -1477,416 +1554,560 @@ void AddInversePandyaTransformation(const std::deque<arma::mat>& Zbar, Operator&
               // now loop over the cross coupled TBME's
               parity_cc = (oi.l+ok.l)%2;
               Tz_cc = std::abs(oi.tz2-ok.tz2)/2;
-//              Tz_cc = std::abs(oi.tz2+ok.tz2)/2;
+              //              Tz_cc = std::abs(oi.tz2+ok.tz2)/2;
               Jpmin = std::max(std::abs(int(jj-jl)),std::abs(int(jk-ji)));
               Jpmax = std::min(int(jj+jl),int(jk+ji));
               for (int Jprime=Jpmin; Jprime<=Jpmax; ++Jprime)
               {
-                 double sixj = Z.modelspace->GetSixJ(jj,ji,J,jk,jl,Jprime);
-                 if (std::abs(sixj)<1e-8) continue;
-                 int ch_cc = Z.modelspace->GetTwoBodyChannelIndex(Jprime,parity_cc,Tz_cc);
-                 TwoBodyChannel_CC& tbc_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_cc);
-                 int nkets_cc = tbc_cc.GetNumberKets();
-                 int indx_ik = tbc_cc.GetLocalIndex(std::min(i,k),std::max(i,k)) +(i>k?nkets_cc:0);
-                 int indx_lj = tbc_cc.GetLocalIndex(std::min(l,j),std::max(l,j)) +(l>j?nkets_cc:0);
-                 // we always have i<=k so we should always flip Z_jlki = (-1)^{i+j+k+l} Z_iklj
-                 // the phase we get from that flip combines with the phase from Pij, to give the phase included below
-                 double me1 = Zbar.at(ch_cc)(indx_ik, indx_lj) ;
-                 commji -= (2*Jprime+1) *  sixj * me1;
+                double sixj = Z.modelspace->GetSixJ(jj,ji,J,jk,jl,Jprime);
+                if (std::abs(sixj)<1e-8) continue;
+                int ch_cc = Z.modelspace->GetTwoBodyChannelIndex(Jprime,parity_cc,Tz_cc);
+                TwoBodyChannel_CC& tbc_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_cc);
+                int nkets_cc = tbc_cc.GetNumberKets();
+                int indx_ik = tbc_cc.GetLocalIndex(std::min(i,k),std::max(i,k)) +(i>k?nkets_cc:0);
+                int indx_lj = tbc_cc.GetLocalIndex(std::min(l,j),std::max(l,j)) +(l>j?nkets_cc:0);
+                // we always have i<=k so we should always flip Z_jlki = (-1)^{i+j+k+l} Z_iklj
+                // the phase we get from that flip combines with the phase from Pij, to give the phase included below
+                double me1 = Zbar.at(ch_cc)(indx_ik, indx_lj) ;
+                commji -= (2*Jprime+1) *  sixj * me1;
 
               }
             }
 
             double norm = bra.delta_pq()==ket.delta_pq() ? 1+bra.delta_pq() : PhysConst::SQRT2;
             Z.TwoBody.GetMatrix(ch,ch)(ibra,iket) -= (commij - Z.modelspace->phase(jk+jl-J ) * commji) / norm;
-         }
+          }
+        }
       }
-   }
-}
+    }
 
-///*************************************
-/// convenience function
-/// called by comm222_phss
-///*************************************
-//deque<arma::mat> Operator::InitializePandya(size_t nch, std::string orientation="normal")
-std::deque<arma::mat> InitializePandya(Operator& Z, size_t nch, std::string orientation="normal")
-{
-   std::deque<arma::mat> X(nch);
-   int n_nonzero = Z.modelspace->SortedTwoBodyChannels_CC.size();
-   for (int ich=0; ich<n_nonzero; ++ich)
-   {
-      int ch_cc = Z.modelspace->SortedTwoBodyChannels_CC[ich];
-      TwoBodyChannel& tbc_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_cc);
-      int nKets_cc = tbc_cc.GetNumberKets();
-      int nph_kets = tbc_cc.GetKetIndex_hh().size() + tbc_cc.GetKetIndex_ph().size();
-      if (orientation=="normal")
-         X[ch_cc] = arma::mat(2*nph_kets,   nKets_cc, arma::fill::zeros);
-      else if (orientation=="transpose")
-         X[ch_cc] = arma::mat(nKets_cc, 2*nph_kets,   arma::fill::zeros);
-   }
-   return X;
-}
+    ///*************************************
+    /// convenience function
+    /// called by comm222_phss
+    ///*************************************
+    //deque<arma::mat> Operator::InitializePandya(size_t nch, std::string orientation="normal")
+    std::deque<arma::mat> InitializePandya(Operator& Z, size_t nch, std::string orientation="normal")
+    {
+      std::deque<arma::mat> X(nch);
+      int n_nonzero = Z.modelspace->SortedTwoBodyChannels_CC.size();
+      for (int ich=0; ich<n_nonzero; ++ich)
+      {
+        int ch_cc = Z.modelspace->SortedTwoBodyChannels_CC[ich];
+        TwoBodyChannel& tbc_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_cc);
+        int nKets_cc = tbc_cc.GetNumberKets();
+        int nph_kets = tbc_cc.GetKetIndex_hh().size() + tbc_cc.GetKetIndex_ph().size();
+        if (orientation=="normal")
+          X[ch_cc] = arma::mat(2*nph_kets,   nKets_cc, arma::fill::zeros);
+        else if (orientation=="transpose")
+          X[ch_cc] = arma::mat(nKets_cc, 2*nph_kets,   arma::fill::zeros);
+      }
+      return X;
+    }
 
-//*****************************************************************************************
-//
-//  THIS IS THE BIG UGLY ONE.     
-//                                             
-//   |          |      |          |           
-//   |     __Y__|      |     __X__|            
-//   |    /\    |      |    /\    |
-//   |   (  )   |  _   |   (  )   |            
-//   |____\/    |      |____\/    |            
-//   |  X       |      |  Y       |            
-//           
-//            
-// -- This appears to agree with Nathan's results
-//
-/// Calculates the part of \f$ [X_{(2)},Y_{(2)}]_{ijkl} \f$ which involves ph intermediate states, here indicated by \f$ Z^{J}_{ijkl} \f$
-/// \f[
-/// Z^{J}_{ijkl} = \sum_{ab}(n_a\bar{n}_b-\bar{n}_an_b)\sum_{J'} (2J'+1)
-/// \left[
-///  \left\{ \begin{array}{lll}
-///  j_i  &  j_j  &  J \\
-///  j_k  &  j_l  &  J' \\
-///  \end{array} \right\}
-/// \left( \bar{X}^{J'}_{i\bar{l}a\bar{b}}\bar{Y}^{J'}_{a\bar{b}k\bar{j}} - 
-///   \bar{Y}^{J'}_{i\bar{l}a\bar{b}}\bar{X}^{J'}_{a\bar{b}k\bar{j}} \right)
-///  -(-1)^{j_i+j_j-J}
-///  \left\{ \begin{array}{lll}
-///  j_j  &  j_i  &  J \\
-///  j_k  &  j_l  &  J' \\
-///  \end{array} \right\}
-/// \left( \bar{X}^{J'}_{j\bar{l}a\bar{b}}\bar{Y}^{J'}_{a\bar{b}k\bar{i}} - 
-///   \bar{Y}^{J'}_{j\bar{l}a\bar{b}}\bar{X}^{J'}_{a\bar{b}k\bar{i}} \right)
-/// \right]
-/// \f]
-/// This is implemented by defining an intermediate matrix
-/// \f[
-/// \bar{Z}^{J}_{i\bar{l}k\bar{j}} \equiv \sum_{ab}(n_a\bar{n}_b)
-/// \left[ \left( \bar{X}^{J'}_{i\bar{l}a\bar{b}}\bar{Y}^{J'}_{a\bar{b}k\bar{j}} - 
-///   \bar{Y}^{J'}_{i\bar{l}a\bar{b}}\bar{X}^{J'}_{a\bar{b}k\bar{j}} \right)
-/// -\left( \bar{X}^{J'}_{i\bar{l}b\bar{a}}\bar{Y}^{J'}_{b\bar{a}k\bar{j}} - 
-///    \bar{Y}^{J'}_{i\bar{l}b\bar{a}}\bar{X}^{J'}_{b\bar{a}k\bar{j}} \right)\right]
-/// \f]
-/// The Pandya-transformed matrix elements are obtained with DoPandyaTransformation().
-/// The matrices \f$ \bar{X}^{J'}_{i\bar{l}a\bar{b}}\bar{Y}^{J'}_{a\bar{b}k\bar{j}} \f$
-/// and \f$ \bar{Y}^{J'}_{i\bar{l}a\bar{b}}\bar{X}^{J'}_{a\bar{b}k\bar{j}} \f$
-/// are related by a Hermitian conjugation, which saves two matrix multiplications.
-/// The commutator is then given by
-/// \f[
-/// Z^{J}_{ijkl} = \sum_{J'} (2J'+1)
-/// \left[
-///  \left\{ \begin{array}{lll}
-///  j_i  &  j_j  &  J \\
-///  j_k  &  j_l  &  J' \\
-///  \end{array} \right\}
-///  \bar{Z}^{J'}_{i\bar{l}k\bar{j}}
-///  -(-1)^{j_i+j_j-J}
-///  \left\{ \begin{array}{lll}
-///  j_j  &  j_i  &  J \\
-///  j_k  &  j_l  &  J' \\
-///  \end{array} \right\}
-///  \bar{Z}^{J'}_{j\bar{l}k\bar{i}}
-///  \right]
-///  \f]
-///
-//void Operator::comm222_phss( const Operator& X, const Operator& Y ) 
-void comm222_phss( const Operator& X, const Operator& Y, Operator& Z ) 
-{
+    //*****************************************************************************************
+    //
+    //  THIS IS THE BIG UGLY ONE.
+    //
+    //   |          |      |          |
+    //   |     __Y__|      |     __X__|
+    //   |    /\    |      |    /\    |
+    //   |   (  )   |  _   |   (  )   |
+    //   |____\/    |      |____\/    |
+    //   |  X       |      |  Y       |
+    //
+    //
+    // -- This appears to agree with Nathan's results
+    //
+    /// Calculates the part of \f$ [X_{(2)},Y_{(2)}]_{ijkl} \f$ which involves ph intermediate states, here indicated by \f$ Z^{J}_{ijkl} \f$
+    /// \f[
+    /// Z^{J}_{ijkl} = \sum_{ab}(n_a\bar{n}_b-\bar{n}_an_b)\sum_{J'} (2J'+1)
+    /// \left[
+    ///  \left\{ \begin{array}{lll}
+    ///  j_i  &  j_j  &  J \\
+    ///  j_k  &  j_l  &  J' \\
+    ///  \end{array} \right\}
+    /// \left( \bar{X}^{J'}_{i\bar{l}a\bar{b}}\bar{Y}^{J'}_{a\bar{b}k\bar{j}} -
+    ///   \bar{Y}^{J'}_{i\bar{l}a\bar{b}}\bar{X}^{J'}_{a\bar{b}k\bar{j}} \right)
+    ///  -(-1)^{j_i+j_j-J}
+    ///  \left\{ \begin{array}{lll}
+    ///  j_j  &  j_i  &  J \\
+    ///  j_k  &  j_l  &  J' \\
+    ///  \end{array} \right\}
+    /// \left( \bar{X}^{J'}_{j\bar{l}a\bar{b}}\bar{Y}^{J'}_{a\bar{b}k\bar{i}} -
+    ///   \bar{Y}^{J'}_{j\bar{l}a\bar{b}}\bar{X}^{J'}_{a\bar{b}k\bar{i}} \right)
+    /// \right]
+    /// \f]
+    /// This is implemented by defining an intermediate matrix
+    /// \f[
+    /// \bar{Z}^{J}_{i\bar{l}k\bar{j}} \equiv \sum_{ab}(n_a\bar{n}_b)
+    /// \left[ \left( \bar{X}^{J'}_{i\bar{l}a\bar{b}}\bar{Y}^{J'}_{a\bar{b}k\bar{j}} -
+    ///   \bar{Y}^{J'}_{i\bar{l}a\bar{b}}\bar{X}^{J'}_{a\bar{b}k\bar{j}} \right)
+    /// -\left( \bar{X}^{J'}_{i\bar{l}b\bar{a}}\bar{Y}^{J'}_{b\bar{a}k\bar{j}} -
+    ///    \bar{Y}^{J'}_{i\bar{l}b\bar{a}}\bar{X}^{J'}_{b\bar{a}k\bar{j}} \right)\right]
+    /// \f]
+    /// The Pandya-transformed matrix elements are obtained with DoPandyaTransformation().
+    /// The matrices \f$ \bar{X}^{J'}_{i\bar{l}a\bar{b}}\bar{Y}^{J'}_{a\bar{b}k\bar{j}} \f$
+    /// and \f$ \bar{Y}^{J'}_{i\bar{l}a\bar{b}}\bar{X}^{J'}_{a\bar{b}k\bar{j}} \f$
+    /// are related by a Hermitian conjugation, which saves two matrix multiplications.
+    /// The commutator is then given by
+    /// \f[
+    /// Z^{J}_{ijkl} = \sum_{J'} (2J'+1)
+    /// \left[
+    ///  \left\{ \begin{array}{lll}
+    ///  j_i  &  j_j  &  J \\
+    ///  j_k  &  j_l  &  J' \\
+    ///  \end{array} \right\}
+    ///  \bar{Z}^{J'}_{i\bar{l}k\bar{j}}
+    ///  -(-1)^{j_i+j_j-J}
+    ///  \left\{ \begin{array}{lll}
+    ///  j_j  &  j_i  &  J \\
+    ///  j_k  &  j_l  &  J' \\
+    ///  \end{array} \right\}
+    ///  \bar{Z}^{J'}_{j\bar{l}k\bar{i}}
+    ///  \right]
+    ///  \f]
+    ///
+    //void Operator::comm222_phss( const Operator& X, const Operator& Y )
+    void comm222_phss( const Operator& X, const Operator& Y, Operator& Z )
+    {
 
-   int hy = Y.IsHermitian() ? 1 : -1;
-   // Create Pandya-transformed hp and ph matrix elements
-   double t_start = omp_get_wtime();
-
-   // Construct the intermediate matrix Z_bar
-   const auto& pandya_lookup = Z.modelspace->GetPandyaLookup(Z.GetJRank(), Z.GetTRank(), Z.GetParity());
-   size_t nch = Z.modelspace->SortedTwoBodyChannels_CC.size();
-   t_start = omp_get_wtime();
-   std::deque<arma::mat> Z_bar ( Z.nChannels );
-//   std::vector<bool> lookup_empty(Z.nChannels,true);
-   std::vector<size_t> non_empty_channels;
-   for (size_t ich=0;ich<nch;++ich)
-   {
-      size_t ch = Z.modelspace->SortedTwoBodyChannels_CC[ich];
-      index_t nKets_cc = Z.modelspace->GetTwoBodyChannel_CC(ch).GetNumberKets();
-      Z_bar[ch].zeros( nKets_cc, 2*nKets_cc );
-//      if ( pandya_lookup.at({ch,ch})[0].size()>0 ) lookup_empty[ich] = false;
-      if ( pandya_lookup.at({ch,ch})[0].size()>0 ) non_empty_channels.push_back(ch);
-   }
-   size_t nch_nonempty = non_empty_channels.size();
-
-   #ifndef OPENBLAS_NOUSEOMP
-//   #pragma omp parallel for schedule(dynamic,1)
-   #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar_transform_first_pass)
-   #endif
-//   for (size_t ich=0; ich<nch; ++ich )
-   for (size_t ich=0; ich<nch_nonempty; ++ich )
-   {
-//      if (lookup_empty.at(ich)) continue;
-//      size_t ch = Z.modelspace->SortedTwoBodyChannels_CC.at(ich);
-      size_t ch = non_empty_channels[ich];
-      const TwoBodyChannel& tbc_cc = Z.modelspace->GetTwoBodyChannel_CC(ch);
-      index_t nKets_cc = tbc_cc.GetNumberKets();
-      size_t nph_kets = tbc_cc.GetKetIndex_hh().size() + tbc_cc.GetKetIndex_ph().size();
+      int hy = Y.IsHermitian() ? 1 : -1;
+      // Create Pandya-transformed hp and ph matrix elements
+      double t_start = omp_get_wtime();
+
+      // Construct the intermediate matrix Z_bar
+      const auto& pandya_lookup = Z.modelspace->GetPandyaLookup(Z.GetJRank(), Z.GetTRank(), Z.GetParity());
+      size_t nch = Z.modelspace->SortedTwoBodyChannels_CC.size();
+      t_start = omp_get_wtime();
+      std::deque<arma::mat> Z_bar ( Z.nChannels );
+      //   std::vector<bool> lookup_empty(Z.nChannels,true);
+      std::vector<size_t> non_empty_channels;
+      for (size_t ich=0;ich<nch;++ich)
+      {
+        size_t ch = Z.modelspace->SortedTwoBodyChannels_CC[ich];
+        index_t nKets_cc = Z.modelspace->GetTwoBodyChannel_CC(ch).GetNumberKets();
+        Z_bar[ch].zeros( nKets_cc, 2*nKets_cc );
+        //      if ( pandya_lookup.at({ch,ch})[0].size()>0 ) lookup_empty[ich] = false;
+        if ( pandya_lookup.at({ch,ch})[0].size()>0 ) non_empty_channels.push_back(ch);
+      }
+      size_t nch_nonempty = non_empty_channels.size();
+
+#ifndef OPENBLAS_NOUSEOMP
+      //   #pragma omp parallel for schedule(dynamic,1)
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar_transform_first_pass)
+#endif
+      //   for (size_t ich=0; ich<nch; ++ich )
+      for (size_t ich=0; ich<nch_nonempty; ++ich )
+      {
+        //      if (lookup_empty.at(ich)) continue;
+        //      size_t ch = Z.modelspace->SortedTwoBodyChannels_CC.at(ich);
+        size_t ch = non_empty_channels[ich];
+        const TwoBodyChannel& tbc_cc = Z.modelspace->GetTwoBodyChannel_CC(ch);
+        index_t nKets_cc = tbc_cc.GetNumberKets();
+        size_t nph_kets = tbc_cc.GetKetIndex_hh().size() + tbc_cc.GetKetIndex_ph().size();
 
-      arma::mat Y_bar_ph;
-      arma::mat Xt_bar_ph;
+        arma::mat Y_bar_ph;
+        arma::mat Xt_bar_ph;
 
-      DoPandyaTransformation_SingleChannel(Y,Y_bar_ph,ch,"normal");
-      DoPandyaTransformation_SingleChannel(X,Xt_bar_ph,ch,"transpose");
-      auto& Zbar_ch = Z_bar.at(ch);
+        // Y has dimension (2*nph , nKets_CC)
+        // X has dimension (nKets_CC, 2*nph )
+        //      DoPandyaTransformation_SingleChannel(Y,Y_bar_ph,ch,"normal");
+        //      DoPandyaTransformation_SingleChannel(X,Xt_bar_ph,ch,"transpose");
 
+        DoPandyaTransformation_SingleChannel_XandY( X,  Y, Xt_bar_ph, Y_bar_ph, ch);
 
-      if (Y_bar_ph.size()<1 or Xt_bar_ph.size()<1)
-      {
-        Zbar_ch = arma::zeros( Xt_bar_ph.n_rows, Y_bar_ph.n_cols*2);
-        continue;
-      }
+        auto& Zbar_ch = Z_bar.at(ch);
 
-      // get the phases for taking the transpose
-      arma::mat PhaseMat(nKets_cc, nKets_cc, arma::fill::ones );
-      for (index_t iket=0;iket<nKets_cc;iket++)
-      {
-         const Ket& ket = tbc_cc.GetKet(iket);
-         if ( Z.modelspace->phase( (ket.op->j2 + ket.oq->j2)/2 ) > 0) continue;
-         PhaseMat.col( iket ) *= -1;
-         PhaseMat.row( iket ) *= -1;
-      }
-      arma::uvec phkets = arma::join_cols(tbc_cc.GetKetIndex_hh(), tbc_cc.GetKetIndex_ph() );
-      auto PhaseMatY = PhaseMat.rows(phkets) * hy;
 
+        if (Y_bar_ph.size()<1 or Xt_bar_ph.size()<1)
+        {
+          Zbar_ch = arma::zeros( Xt_bar_ph.n_rows, Y_bar_ph.n_cols*2);
+          continue;
+        }
 
-//                                           [      |     ]
-//     create full Y matrix from the half:   [  Yhp | Y'ph]   where the prime indicates multiplication by (-1)^(i+j+k+l) h_y
-//                                           [      |     ]   Flipping hp <-> ph and multiplying by the phase is equivalent to
-//                                           [  Yph | Y'hp]   having kets |kj> with k>j.
+        // get the phases for taking the transpose
+        arma::mat PhaseMatZ(nKets_cc, nKets_cc, arma::fill::ones );
+        for (index_t iket=0;iket<nKets_cc;iket++)
+        {
+          const Ket& ket = tbc_cc.GetKet(iket);
+          if ( Z.modelspace->phase( (ket.op->j2 + ket.oq->j2)/2 ) > 0) continue;
+          PhaseMatZ.col( iket ) *= -1;
+          PhaseMatZ.row( iket ) *= -1;
+        }
+        arma::uvec phkets = arma::join_cols(tbc_cc.GetKetIndex_hh(), tbc_cc.GetKetIndex_ph() );
+        auto PhaseMatY = PhaseMatZ.rows(phkets) * hy;
 
-      Zbar_ch =  Xt_bar_ph * join_horiz(Y_bar_ph, join_vert(   Y_bar_ph.tail_rows(nph_kets)%PhaseMatY,
-                                                               Y_bar_ph.head_rows(nph_kets)%PhaseMatY) );
 
+        //                                           [      |     ]
+        //     create full Y matrix from the half:   [  Yhp | Y'ph]   where the prime indicates multiplication by (-1)^(i+j+k+l) h_y
+        //                                           [      |     ]   Flipping hp <-> ph and multiplying by the phase is equivalent to
+        //                                           [  Yph | Y'hp]   having kets |kj> with k>j.
+        //
+        //
+        //      so <il|Zbar|kj> =  <il|Xbar|hp><hp|Ybar|kj> + <il|Xbar|ph><ph|Ybar|kj>
+        //
+        arma::mat Y_bar_ph_flip = arma::join_vert ( Y_bar_ph.tail_rows(nph_kets)%PhaseMatY ,  Y_bar_ph.head_rows(nph_kets)%PhaseMatY ) ;
+        Zbar_ch =  Xt_bar_ph * arma::join_horiz( Y_bar_ph ,  Y_bar_ph_flip );
 
+        //      auto Y_bar_ph_flip = arma::join_vert ( Y_bar_ph.tail_rows(nph_kets)%PhaseMatY ,  Y_bar_ph.head_rows(nph_kets)%PhaseMatY ) ;
+        //      Zbar_ch.head_cols(nKets_cc) =  Xt_bar_ph * Y_bar_ph ;
+        //      Zbar_ch.tail_cols(nKets_cc) =  Xt_bar_ph * Y_bar_ph_flip;
+
+        //      Zbar_ch =  Xt_bar_ph * join_horiz(Y_bar_ph, join_vert(   Y_bar_ph.tail_rows(nph_kets)%PhaseMatY,
+        //                                                               Y_bar_ph.head_rows(nph_kets)%PhaseMatY) );
+
+
+
+        // If Z is hermitian, then XY is anti-hermitian, and so XY - YX = XY + (XY)^T
+        if ( Z.IsHermitian() )
+        {
+          Zbar_ch.head_cols(nKets_cc) += Zbar_ch.head_cols(nKets_cc).t();
+        }
+        else
+        {
+          Zbar_ch.head_cols(nKets_cc) -= Zbar_ch.head_cols(nKets_cc).t();
+        }
+        // By taking the transpose, we get <il|Zbar|kj> with i>l and k<j, and we want the opposite
+        // By the symmetries of the Pandya-transformed matrix element, that means we pick
+        // up a factor hZ * phase(i+j+k+l). The hZ cancels the hXhY we have for the "head" part of the matrix
+        // so we end up adding in either case.
+        Zbar_ch.tail_cols(nKets_cc) += Zbar_ch.tail_cols(nKets_cc).t()%PhaseMatZ;
 
-      // If Z is hermitian, then XY is anti-hermitian, and so XY - YX = XY + (XY)^T
-      if ( Z.IsHermitian() )
-      {
-         Zbar_ch.head_cols(nKets_cc) += Zbar_ch.head_cols(nKets_cc).t();
-      }
-      else
-      {
-         Zbar_ch.head_cols(nKets_cc) -= Zbar_ch.head_cols(nKets_cc).t();
       }
-      Zbar_ch.tail_cols(nKets_cc) += Zbar_ch.tail_cols(nKets_cc).t()%PhaseMat;
 
-   }
+      X.profiler.timer["Build Z_bar"] += omp_get_wtime() - t_start;
 
-   X.profiler.timer["Build Z_bar"] += omp_get_wtime() - t_start;
+      // Perform inverse Pandya transform on Z_bar to get Z
+      t_start = omp_get_wtime();
 
-   // Perform inverse Pandya transform on Z_bar to get Z
-   t_start = omp_get_wtime();
+      // Actually, the Pandya transform has a minus sign in the definition,
+      // and the ph commutator has an overall minus sign, so we're technically subtracting
+      // the inverse Pandya transformation. Also, the inverse Pandya transformation
+      // is just the regular Pandya transformation. The distinction in the code
+      // is because some other commutator-specific things are done at the same time.
+      AddInversePandyaTransformation(Z_bar, Z);
 
-   // Actually, the Pandya transform has a minus sign in the definition,
-   // and the ph commutator has an overall minus sign, so we're technically subtracting
-   // the inverse Pandya transformation. Also, the inverse Pandya transformation
-   // is just the regular Pandya transformation. The distinction in the code
-   // is because some other commutator-specific things are done at the same time.
-   AddInversePandyaTransformation(Z_bar, Z);
+      Z.modelspace->scalar_transform_first_pass = false;
+      X.profiler.timer["InversePandyaTransformation"] += omp_get_wtime() - t_start;
 
-   Z.modelspace->scalar_transform_first_pass = false;
-   X.profiler.timer["InversePandyaTransformation"] += omp_get_wtime() - t_start;
+    }
 
-}
 
+    /*
+       void comm222_phss_alternative( const Operator& X, const Operator& Y, Operator& Z )
+       {
+       auto& X2 = X.TwoBody;
+       auto& Y2 = Y.TwoBody;
+       auto& Z2 = Z.TwoBody;
 
+       size_t nch = Z.modelspace->GetNumberTwoBodyChannels();
+       size_t nch_CC = Z.modelspace->GetNumberTwoBodyChannels_CC();
+       std::deque<arma::mat> Z_bar ( nch_CC );
 
+       for (size_t ch_CC=0; ch_CC<nch_CC; ch_CC++)
+       {
+       TwoBodyChannel_CC& tbc_CC = Z.modelspace->GetTwoBodyChanel_CC(ch_CC);
+       size_t nkets_CC = tbc_CC.GetNumberKets();
+       int Jcc = tbc_CC.J;
+       std::vector<size_t> ph_kets;
+       std::vector<double> ph_occs;
+    // count how many ab states contribute
+    for ( size_t iket_CC=0; iket_CC<nkets_CC; iket_CC++)
+    {
+    Ket& ket_CC = tbc_CC.GetKet(iket_CC);
+    double occfactor = ket_CC.op->occ - ket_CC.oq->occ;
+    if ( std::abs(occfactor)<1e-8 ) continue;
+    ph_kets.push_back(iket_CC);
+    ph_occs.push_back(occfactor);
+    }
+    /// Allocate Xbar and Ybar
+    size_t nkets_ab = ph_kets.size();
+    arma::mat Xbar( nkets_CC,  2*nkets_ab );
+    arma::mat Ybar( 2*nkets_ab, nkets_CC );
+
+    /// Fill Xbar and Ybar    Xbar^Jcc_ijab  =  - sum_J  (2J+1) { i  j  Jcc } X^J_ibaj
+    ///                                                         { a  b  J   }
+    for ( size_t ibra_CC=0; ibra_CC<nkets_CC; ibra_CC++)
+    {
+    Ket& bra_CC = tbc_CC.GetKet(ibra_CC);
+    int j2i = bra_CC.op->j2;
+    int j2j = bra_CC.oq->j2;
+    double ji = 0.5*j2i;
+    double jj = 0.5*j2j;
+    for ( size_t index_ab=0; index_ab<nkets_ab; index_ab++)
+    {
+    size_t iket_ab = ph_kets[index_ab];
+    double occ_ab = ph_occs[index_ab];
+    Ket& ket_ab = tbc_CC.GetKet(iket_ab);
+    int j2a = ket_ab.op->j2;
+    int j2b = ket_ab.oq->j2;
+
+    double xbar_ijab = 0;
+    double ybar_abij = 0;
+    int Jmin = std::max( std::abs( oi.j2-ob.j2), std::abs( oj.j2-oa.j2) )/2;
+    int Jmax = std::max( ( oi.j2+ob.j2), ( oj.j2+oa.j2) )/2;
+    for (int J=Jmin; J<=Jmin; J++)
+    {
+    double sixj = Z.modelspace->GetSixJ(ja,jb,Jcc,ji,jj,J);
+    xbar_ijab -= (2*J+1) * sixj * X2.GetTBME_J(J,i,b,a,j);
+    ybar_abij -= (2*J+1) * sixj * X2.GetTBME_J(J,a,j,i,b);
+    }
+    Xbar(ibra_CC, index_ab) = xbar_ijab;
+    Ybar(index_ab, ibra_CC) = ybar_abij * occ_ab;
+
+    double xbar_ijba = 0;
+    double ybar_baij = 0;
+    int Jmin = std::max( std::abs( oi.j2-oa.j2), std::abs( oj.j2-ob.j2) )/2;
+    int Jmax = std::max( ( oi.j2+oa.j2), ( oj.j2+ob.j2) )/2;
+    for (int J=Jmin; J<=Jmin; J++)
+    {
+    double sixj = Z.modelspace->GetSixJ(jb,ja,Jcc,ji,jj,J);
+    xbar_ijab -= (2*J+1) * sixj * X2.GetTBME_J(J,i,a,b,j);
+    ybar_abij -= (2*J+1) * sixj * X2.GetTBME_J(J,b,j,i,a);
+  }
+  Xbar(ibra_CC, index_ab + nkets_ab) = xbar_ijba;
+  Ybar(index_ab + nkets_ab, ibra_CC) = ybar_baij * (-occ_ab_;
 
-//////////////////////////////////////////////////////////////////////////////////////////
-//////////////////////////////////////////////////////////////////////////////////////////
-////////////   BEGIN SCALAR-SCALAR COMMUTATORS WITH 3-body ///////////////////////////////
-//////////////////////////////////////////////////////////////////////////////////////////
-//////////////////////////////////////////////////////////////////////////////////////////
+      }// for index_ab
+      }// for ibra_CC
 
+      /// MatMult so Zbar = Xbar*Ybar
+      arma::mat zbar = Xbar*Ybar;
+      zbar -= zbar.t();
 
-//  For the three-body operators, we often encounter formulas involving the J-coupled
-//  permutation operator P(ij/k)^{J1,J}, which is defined as
-//
-//  P(ij/k)^{J1,J} = 1 - sum_J2 sqrt{(2J1+1)(2J2+1)} (-1)^2(ji+jj+jk)   {ji jk J1} P_ik
-//                                                                      {jk J  J2}
-//
-//                     - sum_J2 sqrt{(2J1+1)(2J2+1)} (-1)^{jj+jk+J1+J2) {jk ji J1} P_jk
-//                                                                      {jk J  J2}
-//
+      }// for ch_CC
+      /// Transform Zbar to Z
+      // Z^J_ijkl = -sum_Jcc (2*Jcc+1) { i j J   } Z^Jcc_ilkj
+      //                               { k l Jcc }
+      // and we need to do the four permutations (1-Pij)(1-Pkl)
+      for (size_t ch=0; ch<nch; ch++)
+      {
+      TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
+      int J = tbc.J;
+      size_t nkets = tbc.GetNumberKets();
+      for (size_t ibra=0; ibra<nkets; ibra++)
+      {
+        Ket& bra = tbc.GetKet(ibra);
+        size_t i = bra.p;
+        size_t j = bra.q;
+        int j2i = bra.op->j2
+          int j2j = bra.oq->j2
+          double ji = 0.5 * j2i;
+        double jj = 0.5 * j2j;
+        for (size_t iket=ibra; iket<nkets; iket++)
+        {
+          Ket& ket = tbc.GetKet(iket);
+          size_t k = ket.p;
+          size_t l = ket.q;
+          int j2k = ket.op->j2
+            int j2l = ket.oq->j2
+            double jk = 0.5 * j2k;
+          double jl = 0.5 * j2l;
+          int Jcc_min = std::max( std::abs(j2i-j2l), std::abs(j2j-j2k) )/2;
+          int Jcc_max = std::min( j2i+j2l, j2j+j2k )/2;
+          for (int Jcc=Jcc_min; Jcc<=Jcc_max; Jcc++)
+          {
+            double sixj = Z.modelspace->GetSixJ( ji, jj, J, jk, jl, Jcc );
 
+            double zbar_ilkj =
+          }//for Jcc
 
+        }// for iket
+      }// for ibra
+      }// for ch
+  }
+  */
 
-//*****************************************************************************************
-//
-//    ~~~~~~~~~~~~~~~~        Uncoupled expression: 
-//   /\      /\      /\         Z_0 = 1/36 sum_abcdef (nanbnc n`dn`en`f) (X_abcdef Y_defabc - Y_abcdef X_defabc)
-// a(  )d  b(  )e  c(  )f
-//   \/      \/      \/      Coupled expression:
-//    ~~~~~~~~~~~~~~~~        Z_0 = 1/36 sum_abcdef sum_J1,J2,J  (nanbnc n`dn`en`f)  (2J+1)
-//                                    (X^{J1J2J}_abcdef Y^{J1J2J}_defabc - Y^{J1J2J}_abcdef X^{J1J2J}_defabc)
-//    Verified with UnitTest
-//   
-void comm330ss( const Operator& X, const Operator& Y, Operator& Z )
-{
-  double tstart = omp_get_wtime();
-  double z0 = 0;
-  auto& X3 = X.ThreeBody;
-  auto& Y3 = Y.ThreeBody;
-  if (X3.Norm()<1e-6 or Y3.Norm()<1e-6 ) return;
 
-  std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
 
-  size_t nch3 = Z.modelspace->GetNumberThreeBodyChannels();
-  #pragma omp parallel for schedule(dynamic,1) reduction(+:z0)
-  for ( size_t ch3=0; ch3<nch3; ch3++)
-  {
-    auto& Tbc = Z.modelspace->GetThreeBodyChannel(ch3);
-    int twoJ = Tbc.twoJ;
-    size_t nkets = Tbc.GetNumberKets();
-    for (size_t ibra=0; ibra<nkets; ibra++)
+    //////////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////////
+    ////////////   BEGIN SCALAR-SCALAR COMMUTATORS WITH 3-body ///////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////////
+
+
+    //  For the three-body operators, we often encounter formulas involving the J-coupled
+    //  permutation operator P(ij/k)^{J1,J}, which is defined as
+    //
+    //  P(ij/k)^{J1,J} = 1 - sum_J2 sqrt{(2J1+1)(2J2+1)} (-1)^2(ji+jj+jk)   {ji jk J1} P_ik
+    //                                                                      {jk J  J2}
+    //
+    //                     - sum_J2 sqrt{(2J1+1)(2J2+1)} (-1)^{jj+jk+J1+J2) {jk ji J1} P_jk
+    //                                                                      {jk J  J2}
+    //
+
+
+
+    //*****************************************************************************************
+    //
+    //    ~~~~~~~~~~~~~~~~        Uncoupled expression:
+    //   /\      /\      /\         Z_0 = 1/36 sum_abcdef (nanbnc n`dn`en`f) (X_abcdef Y_defabc - Y_abcdef X_defabc)
+    // a(  )d  b(  )e  c(  )f
+    //   \/      \/      \/      Coupled expression:
+    //    ~~~~~~~~~~~~~~~~        Z_0 = 1/36 sum_abcdef sum_J1,J2,J  (nanbnc n`dn`en`f)  (2J+1)
+    //                                    (X^{J1J2J}_abcdef Y^{J1J2J}_defabc - Y^{J1J2J}_abcdef X^{J1J2J}_defabc)
+    //    Verified with UnitTest
+    //
+    void comm330ss( const Operator& X, const Operator& Y, Operator& Z )
     {
-      Ket3& bra = Tbc.GetKet(ibra);
-      int ea = 2*bra.op->n+bra.op->l;
-      int eb = 2*bra.oq->n+bra.oq->l;
-      int ec = 2*bra.oR->n+bra.oR->l;
-      int tza = bra.op->tz2;
-      int tzb = bra.oq->tz2;
-      int tzc = bra.oR->tz2;
-      double na = bra.op->occ;
-      double nb = bra.oq->occ;
-      double nc = bra.oR->occ;
-      double occnat_a = bra.op->occ_nat;
-      double occnat_b = bra.oq->occ_nat;
-      double occnat_c = bra.oR->occ_nat;
-      double abc_symm = 6;
-      if (bra.p==bra.q and bra.q==bra.r) abc_symm = 1;
-      else if (bra.p==bra.q or bra.q==bra.r) abc_symm = 3;
-      if ( (std::abs( ea-e_fermi[tza]) + std::abs(eb-e_fermi[tzb]) + std::abs(ec-e_fermi[tzc])) > Z.modelspace->GetdE3max() ) continue;
-      if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_c*(1-occnat_c)) < Z.modelspace->GetOccNat3Cut() ) continue;
-//      for (size_t iket=0;iket<nkets; iket++)
-//      for (size_t iket=ibra;iket<nkets; iket++)
-      for (size_t iket=0;iket<ibra; iket++)  // dont need iket=ibra because the commutator will be zero
+      double tstart = omp_get_wtime();
+      double z0 = 0;
+      auto& X3 = X.ThreeBody;
+      auto& Y3 = Y.ThreeBody;
+      if (X3.Norm()<1e-6 or Y3.Norm()<1e-6 ) return;
+
+      std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
+
+      size_t nch3 = Z.modelspace->GetNumberThreeBodyChannels();
+#pragma omp parallel for schedule(dynamic,1) reduction(+:z0)
+      for ( size_t ch3=0; ch3<nch3; ch3++)
       {
-        Ket3& ket = Tbc.GetKet(iket);
-        double nd = ket.op->occ;
-        double ne = ket.oq->occ;
-        double nf = ket.oR->occ;
-        double occnat_d = ket.op->occ_nat;
-        double occnat_e = ket.oq->occ_nat;
-        double occnat_f = ket.oR->occ_nat;
-        int ed = 2*ket.op->n+ket.op->l;
-        int ee = 2*ket.oq->n+ket.oq->l;
-        int ef = 2*ket.oR->n+ket.oR->l;
-        int tzd = ket.op->tz2;
-        int tze = ket.oq->tz2;
-        int tzf = ket.oR->tz2;
-        if ( (std::abs( ed-e_fermi[tzd]) + std::abs(ee-e_fermi[tze]) + std::abs(ef-e_fermi[tzf])) > Z.modelspace->GetdE3max() ) continue;
-        if ( (occnat_d*(1-occnat_d) * occnat_e*(1-occnat_e) * occnat_f*(1-occnat_f)) < Z.modelspace->GetOccNat3Cut() ) continue;
-        // account for the iket>ibra case, which we don't do explicitly
-        double occfactor = na*nb*nc*(1-nd)*(1-ne)*(1-nf) - (1-na)*(1-nb)*(1-nc)*nd*ne*nf  ;
-        if (std::abs(occfactor)<1e-6) continue;
-        double def_symm = 6;
-        if (ket.p==ket.q and ket.q==ket.r) def_symm = 1;
-        else if (ket.p==ket.q or ket.q==ket.r) def_symm = 3;
-
-        double xabcdef = X3.GetME_pn_PN_ch(ch3,ch3,ibra,iket);
-        double yabcdef = Y3.GetME_pn_PN_ch(ch3,ch3,ibra,iket);
-        double xdefabc = X3.GetME_pn_PN_ch(ch3,ch3,iket,ibra);
-        double ydefabc = Y3.GetME_pn_PN_ch(ch3,ch3,iket,ibra);
-
-        z0 += 1./36 * occfactor * abc_symm * def_symm * (twoJ+1) * (xabcdef * ydefabc  -  yabcdef*xdefabc);
+        auto& Tbc = Z.modelspace->GetThreeBodyChannel(ch3);
+        int twoJ = Tbc.twoJ;
+        size_t nkets = Tbc.GetNumberKets();
+        for (size_t ibra=0; ibra<nkets; ibra++)
+        {
+          Ket3& bra = Tbc.GetKet(ibra);
+          int ea = 2*bra.op->n+bra.op->l;
+          int eb = 2*bra.oq->n+bra.oq->l;
+          int ec = 2*bra.oR->n+bra.oR->l;
+          int tza = bra.op->tz2;
+          int tzb = bra.oq->tz2;
+          int tzc = bra.oR->tz2;
+          double na = bra.op->occ;
+          double nb = bra.oq->occ;
+          double nc = bra.oR->occ;
+          double occnat_a = bra.op->occ_nat;
+          double occnat_b = bra.oq->occ_nat;
+          double occnat_c = bra.oR->occ_nat;
+          double abc_symm = 6;
+          if (bra.p==bra.q and bra.q==bra.r) abc_symm = 1;
+          else if (bra.p==bra.q or bra.q==bra.r) abc_symm = 3;
+          if ( (std::abs( ea-e_fermi[tza]) + std::abs(eb-e_fermi[tzb]) + std::abs(ec-e_fermi[tzc])) > Z.modelspace->GetdE3max() ) continue;
+          if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_c*(1-occnat_c)) < Z.modelspace->GetOccNat3Cut() ) continue;
+          //      for (size_t iket=0;iket<nkets; iket++)
+          //      for (size_t iket=ibra;iket<nkets; iket++)
+          for (size_t iket=0;iket<ibra; iket++)  // dont need iket=ibra because the commutator will be zero
+          {
+            Ket3& ket = Tbc.GetKet(iket);
+            double nd = ket.op->occ;
+            double ne = ket.oq->occ;
+            double nf = ket.oR->occ;
+            double occnat_d = ket.op->occ_nat;
+            double occnat_e = ket.oq->occ_nat;
+            double occnat_f = ket.oR->occ_nat;
+            int ed = 2*ket.op->n+ket.op->l;
+            int ee = 2*ket.oq->n+ket.oq->l;
+            int ef = 2*ket.oR->n+ket.oR->l;
+            int tzd = ket.op->tz2;
+            int tze = ket.oq->tz2;
+            int tzf = ket.oR->tz2;
+            if ( (std::abs( ed-e_fermi[tzd]) + std::abs(ee-e_fermi[tze]) + std::abs(ef-e_fermi[tzf])) > Z.modelspace->GetdE3max() ) continue;
+            if ( (occnat_d*(1-occnat_d) * occnat_e*(1-occnat_e) * occnat_f*(1-occnat_f)) < Z.modelspace->GetOccNat3Cut() ) continue;
+            // account for the iket>ibra case, which we don't do explicitly
+            double occfactor = na*nb*nc*(1-nd)*(1-ne)*(1-nf) - (1-na)*(1-nb)*(1-nc)*nd*ne*nf  ;
+            if (std::abs(occfactor)<1e-6) continue;
+            double def_symm = 6;
+            if (ket.p==ket.q and ket.q==ket.r) def_symm = 1;
+            else if (ket.p==ket.q or ket.q==ket.r) def_symm = 3;
 
-      }// for iket
-    }// for ibra
-  }// for ch3
+            double xabcdef = X3.GetME_pn_PN_ch(ch3,ch3,ibra,iket);
+            double yabcdef = Y3.GetME_pn_PN_ch(ch3,ch3,ibra,iket);
+            double xdefabc = X3.GetME_pn_PN_ch(ch3,ch3,iket,ibra);
+            double ydefabc = Y3.GetME_pn_PN_ch(ch3,ch3,iket,ibra);
 
-  std::cout << "Adding " << z0 << "  to Zero Body" << std::endl;
-  Z.ZeroBody += z0;
-  Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
-}
+            z0 += 1./36 * occfactor * abc_symm * def_symm * (twoJ+1) * (xabcdef * ydefabc  -  yabcdef*xdefabc);
+
+          }// for iket
+        }// for ibra
+      }// for ch3
 
+      std::cout << "Adding " << z0 << "  to Zero Body" << std::endl;
+      Z.ZeroBody += z0;
+      Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
+    }
 
 
-//*****************************************************************************************
-//                   |i
-//    *~~~~~~~[X]~~~~*        Uncoupled expression: 
-//   / \      / \    |          Z_ij = 1/12 sum_abcde (nanb n`c n`dn`e) (X_abicde Y_cdeabj - Y_abicde X_cdeabj)
-// a(   )c  b(   )d  |e 
-//   \ /      \ /    |       Coupled expression:
-//    *~~~~~~~[Y]~~~~*        Z_ij = 1/12 sum_abcde sum_J1,J2,J  (nanb n`c n`dn`e)  (2J+1)/(2ji+1)
-//                   |j               (X^{J1J2J}_abicde Y^{J1J2J}_cdeabj - Y^{J1J2J}_abicde X^{J1J2J}_cdeabj)
-//
-//  Verfied with UnitTest
-//
-void comm331ss( const Operator& X, const Operator& Y, Operator& Z )
-{
-  double tstart = omp_get_wtime();
-  auto& X3 = X.ThreeBody;
-  auto& Y3 = Y.ThreeBody;
-  auto& Z1 = Z.OneBody;
-  int herm = Z.IsAntiHermitian() ? -1 : 1 ;
-  std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
 
-  size_t nch2 = Z.modelspace->GetNumberTwoBodyChannels();
-  size_t norb = Z.modelspace->GetNumberOrbits();
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
-  for (size_t i=0; i<norb; i++)
+  //*****************************************************************************************
+  //                   |i
+  //    *~~~~~~~[X]~~~~*        Uncoupled expression:
+  //   / \      / \    |          Z_ij = 1/12 sum_abcde (nanb n`c n`dn`e) (X_abicde Y_cdeabj - Y_abicde X_cdeabj)
+  // a(   )c  b(   )d  |e
+  //   \ /      \ /    |       Coupled expression:
+  //    *~~~~~~~[Y]~~~~*        Z_ij = 1/12 sum_abcde sum_J1,J2,J  (nanb n`c n`dn`e)  (2J+1)/(2ji+1)
+  //                   |j               (X^{J1J2J}_abicde Y^{J1J2J}_cdeabj - Y^{J1J2J}_abicde X^{J1J2J}_cdeabj)
+  //
+  //  Verfied with UnitTest
+  //
+  void comm331ss( const Operator& X, const Operator& Y, Operator& Z )
   {
-    Orbit& oi = Z.modelspace->GetOrbit(i);
-    int ei = 2*oi.n + oi.l;
-    double occnat_i = oi.occ_nat;
-    int tzi = oi.tz2;
-    for ( auto j : Z.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) )
+    double tstart = omp_get_wtime();
+    auto& X3 = X.ThreeBody;
+    auto& Y3 = Y.ThreeBody;
+    auto& Z1 = Z.OneBody;
+    int herm = Z.IsAntiHermitian() ? -1 : 1 ;
+    std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
+
+    size_t nch2 = Z.modelspace->GetNumberTwoBodyChannels();
+    size_t norb = Z.modelspace->GetNumberOrbits();
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+    for (size_t i=0; i<norb; i++)
     {
-      if (j>i) continue;
-      double zij=0;
-      Orbit& oj = Z.modelspace->GetOrbit(j);
-      double occnat_j = oj.occ_nat;
-      int ej = 2*oj.n + oj.l;
-      int tzj = oj.tz2;
-
-      for (size_t ch_ab=0; ch_ab<nch2; ch_ab++)
+      Orbit& oi = Z.modelspace->GetOrbit(i);
+      int ei = 2*oi.n + oi.l;
+      double occnat_i = oi.occ_nat;
+      int tzi = oi.tz2;
+      for ( auto j : Z.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) )
       {
-        auto& tbc_ab = Z.modelspace->GetTwoBodyChannel(ch_ab);
-        int Jab = tbc_ab.J;
-        size_t nkets_ab = tbc_ab.GetNumberKets();
-        int twoJ_min = std::abs(2*Jab - oi.j2);
-        int twoJ_max = 2*Jab+oi.j2;
-        
-        for (size_t iket_ab=0; iket_ab<nkets_ab; iket_ab++)
+        if (j>i) continue;
+        double zij=0;
+        Orbit& oj = Z.modelspace->GetOrbit(j);
+        double occnat_j = oj.occ_nat;
+        int ej = 2*oj.n + oj.l;
+        int tzj = oj.tz2;
+
+        for (size_t ch_ab=0; ch_ab<nch2; ch_ab++)
         {
-           Ket& ket_ab = tbc_ab.GetKet(iket_ab);
-           size_t a = ket_ab.p;
-           size_t b = ket_ab.q;
-           if (std::abs( ket_ab.op->occ * ket_ab.oq->occ )<1e-6 ) continue;
-           int ea = 2*ket_ab.op->n + ket_ab.op->l;
-           int eb = 2*ket_ab.oq->n + ket_ab.oq->l;
-           int tza = ket_ab.op->tz2;
-           int tzb = ket_ab.oq->tz2;
-           double occnat_a = ket_ab.op->occ_nat;
-           double occnat_b = ket_ab.oq->occ_nat;
-//      double occnat_c = bra.oR->occ_nat;
-           if ( (std::abs( ea-e_fermi[tza]) + std::abs(eb-e_fermi[tzb]) + std::abs(ei-e_fermi[tzi])) > Z.modelspace->GetdE3max() ) continue;
-           if ( (std::abs( ea-e_fermi[tza]) + std::abs(eb-e_fermi[tzb]) + std::abs(ej-e_fermi[tzj])) > Z.modelspace->GetdE3max() ) continue;
-           if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_i*(1-occnat_i)) < Z.modelspace->GetOccNat3Cut() ) continue;
-           if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_j*(1-occnat_j)) < Z.modelspace->GetOccNat3Cut() ) continue;
-
-           for (int twoJ=twoJ_min; twoJ<=twoJ_max; twoJ+=2)
-           {
-             size_t ch_abi = Z.modelspace->GetThreeBodyChannelIndex( twoJ, (tbc_ab.parity +oi.l)%2, tbc_ab.Tz*2 + oi.tz2 );
-             if (ch_abi==-1) continue; // maybe that channel doesn't exist
-             auto& Tbc = Z.modelspace->GetThreeBodyChannel(ch_abi);
-//             size_t index_abi = Tbc.GetLocalIndex(a,b,i,Jab);
-//             size_t index_abj = Tbc.GetLocalIndex(a,b,j,Jab);
-//             std::cout << "index_abi = " << index_abi << "   index_abj = " << index_abj << std::endl;
-//             if ((index_abi==-1) or (index_abj==-1)) continue;
-             double Jfactor = (twoJ+1.0)/(oi.j2+1);
-             double ab_symmetry_factor = (a==b) ?  1.0 : 2.0;
-             size_t nkets3 = Tbc.GetNumberKets();
-             for (size_t iket_cde=0; iket_cde<nkets3; iket_cde++)
-             {
+          auto& tbc_ab = Z.modelspace->GetTwoBodyChannel(ch_ab);
+          int Jab = tbc_ab.J;
+          size_t nkets_ab = tbc_ab.GetNumberKets();
+          int twoJ_min = std::abs(2*Jab - oi.j2);
+          int twoJ_max = 2*Jab+oi.j2;
+
+          for (size_t iket_ab=0; iket_ab<nkets_ab; iket_ab++)
+          {
+            Ket& ket_ab = tbc_ab.GetKet(iket_ab);
+            size_t a = ket_ab.p;
+            size_t b = ket_ab.q;
+            if (std::abs( ket_ab.op->occ * ket_ab.oq->occ )<1e-6 ) continue;
+            int ea = 2*ket_ab.op->n + ket_ab.op->l;
+            int eb = 2*ket_ab.oq->n + ket_ab.oq->l;
+            int tza = ket_ab.op->tz2;
+            int tzb = ket_ab.oq->tz2;
+            double occnat_a = ket_ab.op->occ_nat;
+            double occnat_b = ket_ab.oq->occ_nat;
+            //      double occnat_c = bra.oR->occ_nat;
+            if ( (std::abs( ea-e_fermi[tza]) + std::abs(eb-e_fermi[tzb]) + std::abs(ei-e_fermi[tzi])) > Z.modelspace->GetdE3max() ) continue;
+            if ( (std::abs( ea-e_fermi[tza]) + std::abs(eb-e_fermi[tzb]) + std::abs(ej-e_fermi[tzj])) > Z.modelspace->GetdE3max() ) continue;
+            if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_i*(1-occnat_i)) < Z.modelspace->GetOccNat3Cut() ) continue;
+            if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_j*(1-occnat_j)) < Z.modelspace->GetOccNat3Cut() ) continue;
+
+            for (int twoJ=twoJ_min; twoJ<=twoJ_max; twoJ+=2)
+            {
+              size_t ch_abi = Z.modelspace->GetThreeBodyChannelIndex( twoJ, (tbc_ab.parity +oi.l)%2, tbc_ab.Tz*2 + oi.tz2 );
+              if (ch_abi==-1) continue; // maybe that channel doesn't exist
+              auto& Tbc = Z.modelspace->GetThreeBodyChannel(ch_abi);
+              //             size_t index_abi = Tbc.GetLocalIndex(a,b,i,Jab);
+              //             size_t index_abj = Tbc.GetLocalIndex(a,b,j,Jab);
+              //             std::cout << "index_abi = " << index_abi << "   index_abj = " << index_abj << std::endl;
+              //             if ((index_abi==-1) or (index_abj==-1)) continue;
+              double Jfactor = (twoJ+1.0)/(oi.j2+1);
+              double ab_symmetry_factor = (a==b) ?  1.0 : 2.0;
+              size_t nkets3 = Tbc.GetNumberKets();
+              for (size_t iket_cde=0; iket_cde<nkets3; iket_cde++)
+              {
                 Ket3& ket_cde = Tbc.GetKet(iket_cde);
                 double occfactor = (ket_ab.op->occ * ket_ab.oq->occ) * (1-ket_cde.op->occ)*(1-ket_cde.oq->occ)*(1-ket_cde.oR->occ);
                 if (std::abs(occfactor)<1e-6) continue;
@@ -1908,552 +2129,552 @@ void comm331ss( const Operator& X, const Operator& Y, Operator& Z )
                 if (c==d and d==e) cde_symmetry_factor = 1;
                 else if (c==d or d==e) cde_symmetry_factor = 3;
                 int Jcd = ket_cde.Jpq;
-                 
-                zij += 1./12 * ab_symmetry_factor * cde_symmetry_factor * occfactor * Jfactor
-                             * (  X3.GetME_pn( Jab, Jcd, twoJ, a,b,i,c,d,e) * Y3.GetME_pn( Jcd, Jab, twoJ, c,d,e,a,b,j)  
-                                - Y3.GetME_pn( Jab, Jcd, twoJ, a,b,i,c,d,e) * X3.GetME_pn( Jcd, Jab, twoJ, c,d,e,a,b,j)  ); 
-             }// for iket_cde
-           }// for twoJ
-        }// for iket_ab
-      }// for ch_ab
 
-      Z1(i,j) += zij;
-      if ( i!=j ) Z1(j,i) += herm * zij;
-    }// for j
-  }// for i
+                zij += 1./12 * ab_symmetry_factor * cde_symmetry_factor * occfactor * Jfactor
+                  * (  X3.GetME_pn( Jab, Jcd, twoJ, a,b,i,c,d,e) * Y3.GetME_pn( Jcd, Jab, twoJ, c,d,e,a,b,j)
+                      - Y3.GetME_pn( Jab, Jcd, twoJ, a,b,i,c,d,e) * X3.GetME_pn( Jcd, Jab, twoJ, c,d,e,a,b,j)  );
+              }// for iket_cde
+            }// for twoJ
+          }// for iket_ab
+        }// for ch_ab
 
-  Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
-}
+        Z1(i,j) += zij;
+        if ( i!=j ) Z1(j,i) += herm * zij;
+      }// for j
+    }// for i
 
+    Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
+  }
 
 
 
-//*****************************************************************************************
-//                   |i
-//    *~~[X]~~*      |        Uncoupled expression: 
-//   / \      / \    |          Z_ij = 1/4 sum_abcd (nanb n`cn`d) (X_abcd Y_cdiabj - Y_abicdj X_cdab)
-// a(   )c  b(   )d  | 
-//   \ /      \ /    |       Coupled expression:
-//   *~~~~~~~[Y]~~~~~*        Z_ij = 1/4sum_abcd sum_J1J  (nanb n`c n`d)  (2J+1)/(2ji+1)
-//                   |j               (X^{J1}_abcd Y^{J1J1J}_cdiabj - Y^{J1J1J}_abicdj X^{J1}_cdab)
-//                   |
-//                              We only sum a<=b and c<=d, so we do not explicitly include the factor 1/4,
-//                              except for the a==b, or c==d case, where there is no double counting.
-//  Verfied with UnitTest
-//
-void comm231ss( const Operator& X, const Operator& Y, Operator& Z )
-{
-  double tstart = omp_get_wtime();
-  auto& X2 = X.TwoBody;
-  auto& X3 = X.ThreeBody;
-  auto& Y2 = Y.TwoBody;
-  auto& Y3 = Y.ThreeBody;
-  auto& Z1 = Z.OneBody;
-  std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
 
-  size_t norb = Z.modelspace->GetNumberOrbits();
-  int nch = Z.modelspace->GetNumberTwoBodyChannels();
-  for (size_t i=0; i<norb; i++)
+  //*****************************************************************************************
+  //                   |i
+  //    *~~[X]~~*      |        Uncoupled expression:
+  //   / \      / \    |          Z_ij = 1/4 sum_abcd (nanb n`cn`d) (X_abcd Y_cdiabj - Y_abicdj X_cdab)
+  // a(   )c  b(   )d  |
+  //   \ /      \ /    |       Coupled expression:
+  //   *~~~~~~~[Y]~~~~~*        Z_ij = 1/4sum_abcd sum_J1J  (nanb n`c n`d)  (2J+1)/(2ji+1)
+  //                   |j               (X^{J1}_abcd Y^{J1J1J}_cdiabj - Y^{J1J1J}_abicdj X^{J1}_cdab)
+  //                   |
+  //                              We only sum a<=b and c<=d, so we do not explicitly include the factor 1/4,
+  //                              except for the a==b, or c==d case, where there is no double counting.
+  //  Verfied with UnitTest
+  //
+  void comm231ss( const Operator& X, const Operator& Y, Operator& Z )
   {
-    Orbit& oi = Z.modelspace->GetOrbit(i);
-    int ei = 2*oi.n + oi.l;
-    double d_ei = std::abs( ei - e_fermi[oi.tz2]);
-    double occnat_i = oi.occ_nat;
-    for ( auto j : Z.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) )
+    double tstart = omp_get_wtime();
+    auto& X2 = X.TwoBody;
+    auto& X3 = X.ThreeBody;
+    auto& Y2 = Y.TwoBody;
+    auto& Y3 = Y.ThreeBody;
+    auto& Z1 = Z.OneBody;
+    std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
+
+    size_t norb = Z.modelspace->GetNumberOrbits();
+    int nch = Z.modelspace->GetNumberTwoBodyChannels();
+    for (size_t i=0; i<norb; i++)
     {
-      if (j>i) continue;
-      Orbit& oj = Z.modelspace->GetOrbit(j);
-      int ej = 2*oj.n + oj.l;
-      double d_ej = std::abs( ej - e_fermi[oj.tz2] );
-      double occnat_j = oj.occ_nat;
-      double zij=0;
-      for (int ch=0; ch<nch; ch++)
+      Orbit& oi = Z.modelspace->GetOrbit(i);
+      int ei = 2*oi.n + oi.l;
+      double d_ei = std::abs( ei - e_fermi[oi.tz2]);
+      double occnat_i = oi.occ_nat;
+      for ( auto j : Z.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) )
       {
-        auto tbc = Z.modelspace->GetTwoBodyChannel(ch);
-        int J = tbc.J;
-        size_t nkets = tbc.GetNumberKets();
-//        for ( auto ibra : tbc.KetIndex_hh )
-        for ( size_t ibra=0; ibra<nkets; ibra++ )
+        if (j>i) continue;
+        Orbit& oj = Z.modelspace->GetOrbit(j);
+        int ej = 2*oj.n + oj.l;
+        double d_ej = std::abs( ej - e_fermi[oj.tz2] );
+        double occnat_j = oj.occ_nat;
+        double zij=0;
+        for (int ch=0; ch<nch; ch++)
         {
-          Ket& bra = tbc.GetKet(ibra);
-          int a = bra.p;
-          int b = bra.q;
-          int ea = 2*bra.op->n + bra.op->l;
-          int eb = 2*bra.oq->n + bra.oq->l;
-          double occnat_a = bra.op->occ_nat;
-          double occnat_b = bra.oq->occ_nat;
-          double d_ea = std::abs( ea - e_fermi[bra.op->tz2]);
-          double d_eb = std::abs( eb - e_fermi[bra.oq->tz2]);
-          if (  (ea+eb+std::min(ei,ej))> Z.modelspace->E3max )  continue;
-          if (  (d_ea+d_eb+std::min(d_ei,d_ej))> Z.modelspace->dE3max )  continue;
-          if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * std::max( occnat_i*(1-occnat_i), occnat_j*(1-occnat_j)) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-          double na = bra.op->occ;
-          double nb = bra.oq->occ;
-          if ( (std::abs(na*nb) + std::abs( (1-na)*(1-nb))) < 1e-6 ) continue;
-//          for ( auto iket : tbc.KetIndex_pp )
-//          for ( size_t iket=0; iket<nkets; iket++ )
-          for ( size_t iket=0; iket<ibra; iket++ )
+          auto tbc = Z.modelspace->GetTwoBodyChannel(ch);
+          int J = tbc.J;
+          size_t nkets = tbc.GetNumberKets();
+          //        for ( auto ibra : tbc.KetIndex_hh )
+          for ( size_t ibra=0; ibra<nkets; ibra++ )
           {
-            Ket& ket = tbc.GetKet(iket);
-            int c = ket.p;
-            int d = ket.q;
-            int ec = 2*ket.op->n + ket.op->l;
-            int ed = 2*ket.oq->n + ket.oq->l;
-            double d_ec = std::abs( ec - e_fermi[ket.op->tz2]);
-            double d_ed = std::abs( ec - e_fermi[ket.oq->tz2]);
-            double occnat_c = bra.op->occ_nat;
-            double occnat_d = bra.oq->occ_nat;
-            if (  (ec+ed+std::min(ei,ej))> Z.modelspace->E3max )  continue;
-            if ( (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * std::max( occnat_i*(1-occnat_i), occnat_j*(1-occnat_j)) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-            if (  (d_ec+d_ed+std::min(d_ei,d_ej))> Z.modelspace->dE3max )  continue;
-            double nc = ket.op->occ;
-            double nd = ket.oq->occ;
-//            double prefactor = na*nb*(1-nc)*(1-nd);
-            double prefactor =  na*nb*(1-nc)*(1-nd) - (1-na)*(1-nb)*nc*nd;
-            if ( std::abs(prefactor)<1e-8) continue;
-            double Xabcd = X2.GetTBME(ch,bra,ket);
-            double Yabcd = Y2.GetTBME(ch,bra,ket);
-            double Xcdab = X2.GetTBME(ch,ket,bra);
-            double Ycdab = Y2.GetTBME(ch,ket,bra);
-            if (a==b) prefactor /= 2;
-            if (c==d) prefactor /= 2;
-            int twoJ_min = std::abs( 2*J - oi.j2);
-            int twoJ_max = 2*J + oi.j2;
-            for (int twoJ=twoJ_min; twoJ<=twoJ_max; twoJ+=2)
+            Ket& bra = tbc.GetKet(ibra);
+            int a = bra.p;
+            int b = bra.q;
+            int ea = 2*bra.op->n + bra.op->l;
+            int eb = 2*bra.oq->n + bra.oq->l;
+            double occnat_a = bra.op->occ_nat;
+            double occnat_b = bra.oq->occ_nat;
+            double d_ea = std::abs( ea - e_fermi[bra.op->tz2]);
+            double d_eb = std::abs( eb - e_fermi[bra.oq->tz2]);
+            if (  (ea+eb+std::min(ei,ej))> Z.modelspace->E3max )  continue;
+            if (  (d_ea+d_eb+std::min(d_ei,d_ej))> Z.modelspace->dE3max )  continue;
+            if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * std::max( occnat_i*(1-occnat_i), occnat_j*(1-occnat_j)) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+            double na = bra.op->occ;
+            double nb = bra.oq->occ;
+            if ( (std::abs(na*nb) + std::abs( (1-na)*(1-nb))) < 1e-6 ) continue;
+            //          for ( auto iket : tbc.KetIndex_pp )
+            //          for ( size_t iket=0; iket<nkets; iket++ )
+            for ( size_t iket=0; iket<ibra; iket++ )
             {
-              double xabicdj = 0;
-              double yabicdj = 0;
-              double xcdiabj = 0;
-              double ycdiabj = 0;
-              if ( ( std::max(ea+eb+ej,ec+ed+ei) <= Z.modelspace->E3max )
-               and ( std::max(d_ea+d_eb+d_ej,d_ec+d_ed+d_ei) <= Z.modelspace->E3max )
-               and (  (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_i*(1-occnat_i) ) < Z.modelspace->GetOccNat3Cut() )
-               and (  (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_j*(1-occnat_j) ) < Z.modelspace->GetOccNat3Cut() )   )
+              Ket& ket = tbc.GetKet(iket);
+              int c = ket.p;
+              int d = ket.q;
+              int ec = 2*ket.op->n + ket.op->l;
+              int ed = 2*ket.oq->n + ket.oq->l;
+              double d_ec = std::abs( ec - e_fermi[ket.op->tz2]);
+              double d_ed = std::abs( ec - e_fermi[ket.oq->tz2]);
+              double occnat_c = bra.op->occ_nat;
+              double occnat_d = bra.oq->occ_nat;
+              if (  (ec+ed+std::min(ei,ej))> Z.modelspace->E3max )  continue;
+              if ( (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * std::max( occnat_i*(1-occnat_i), occnat_j*(1-occnat_j)) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+              if (  (d_ec+d_ed+std::min(d_ei,d_ej))> Z.modelspace->dE3max )  continue;
+              double nc = ket.op->occ;
+              double nd = ket.oq->occ;
+              //            double prefactor = na*nb*(1-nc)*(1-nd);
+              double prefactor =  na*nb*(1-nc)*(1-nd) - (1-na)*(1-nb)*nc*nd;
+              if ( std::abs(prefactor)<1e-8) continue;
+              double Xabcd = X2.GetTBME(ch,bra,ket);
+              double Yabcd = Y2.GetTBME(ch,bra,ket);
+              double Xcdab = X2.GetTBME(ch,ket,bra);
+              double Ycdab = Y2.GetTBME(ch,ket,bra);
+              if (a==b) prefactor /= 2;
+              if (c==d) prefactor /= 2;
+              int twoJ_min = std::abs( 2*J - oi.j2);
+              int twoJ_max = 2*J + oi.j2;
+              for (int twoJ=twoJ_min; twoJ<=twoJ_max; twoJ+=2)
               {
-                xcdiabj = X3.GetME_pn(J,J,twoJ,c,d,i,a,b,j);
-                ycdiabj = Y3.GetME_pn(J,J,twoJ,c,d,i,a,b,j);
-              }
-              if ( (std::max(ea+eb+ei,ec+ed+ej) <= Z.modelspace->E3max )
-               and ( std::max(d_ea+d_eb+d_ei,d_ec+d_ed+d_ej) <= Z.modelspace->E3max ) 
-               and (  (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_j*(1-occnat_j) ) < Z.modelspace->GetOccNat3Cut() )
-               and (  (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_i*(1-occnat_i) ) < Z.modelspace->GetOccNat3Cut() )   )
-              {
-                xabicdj = X3.GetME_pn(J,J,twoJ,a,b,i,c,d,j);
-                yabicdj = Y3.GetME_pn(J,J,twoJ,a,b,i,c,d,j);
+                double xabicdj = 0;
+                double yabicdj = 0;
+                double xcdiabj = 0;
+                double ycdiabj = 0;
+                if ( ( std::max(ea+eb+ej,ec+ed+ei) <= Z.modelspace->E3max )
+                    and ( std::max(d_ea+d_eb+d_ej,d_ec+d_ed+d_ei) <= Z.modelspace->E3max )
+                    and (  (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_i*(1-occnat_i) ) < Z.modelspace->GetOccNat3Cut() )
+                    and (  (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_j*(1-occnat_j) ) < Z.modelspace->GetOccNat3Cut() )   )
+                {
+                  xcdiabj = X3.GetME_pn(J,J,twoJ,c,d,i,a,b,j);
+                  ycdiabj = Y3.GetME_pn(J,J,twoJ,c,d,i,a,b,j);
+                }
+                if ( (std::max(ea+eb+ei,ec+ed+ej) <= Z.modelspace->E3max )
+                    and ( std::max(d_ea+d_eb+d_ei,d_ec+d_ed+d_ej) <= Z.modelspace->E3max )
+                    and (  (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_j*(1-occnat_j) ) < Z.modelspace->GetOccNat3Cut() )
+                    and (  (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_i*(1-occnat_i) ) < Z.modelspace->GetOccNat3Cut() )   )
+                {
+                  xabicdj = X3.GetME_pn(J,J,twoJ,a,b,i,c,d,j);
+                  yabicdj = Y3.GetME_pn(J,J,twoJ,a,b,i,c,d,j);
+                }
+                zij += prefactor * (twoJ+1) * ( (Xabcd * ycdiabj - yabicdj * Xcdab)
+                    -  (Yabcd * xcdiabj - xabicdj * Ycdab) );
               }
-              zij += prefactor * (twoJ+1) * ( (Xabcd * ycdiabj - yabicdj * Xcdab)
-                                           -  (Yabcd * xcdiabj - xabicdj * Ycdab) );
             }
           }
         }
-      }
-      Z1(i,j) += zij / (oi.j2+1.0);
-      if (i!=j)
-      {
-         Z1(j,i) += zij / (oi.j2+1.0);
-      }
-    }// for j
-  }// for i
-
-  Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
-}
+        Z1(i,j) += zij / (oi.j2+1.0);
+        if (i!=j)
+        {
+          Z1(j,i) += zij / (oi.j2+1.0);
+        }
+      }// for j
+    }// for i
 
+    Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
+  }
 
 
 
 
 
-void comm231ss_slow( const Operator& X, const Operator& Y, Operator& Z )
-{
-  double tstart = omp_get_wtime();
-  auto& X2 = X.TwoBody;
-  auto& X3 = X.ThreeBody;
-  auto& Y2 = Y.TwoBody;
-  auto& Y3 = Y.ThreeBody;
-  auto& Z1 = Z.OneBody;
-  std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
 
-  size_t norb = Z.modelspace->GetNumberOrbits();
-  int nch = Z.modelspace->GetNumberTwoBodyChannels();
-  for (size_t i=0; i<norb; i++)
+  void comm231ss_slow( const Operator& X, const Operator& Y, Operator& Z )
   {
-    Orbit& oi = Z.modelspace->GetOrbit(i);
-    int ei = 2*oi.n + oi.l;
-    double d_ei = std::abs( ei - e_fermi[oi.tz2]);
-    double occnat_i = oi.occ_nat;
-    for ( auto j : Z.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) )
+    double tstart = omp_get_wtime();
+    auto& X2 = X.TwoBody;
+    auto& X3 = X.ThreeBody;
+    auto& Y2 = Y.TwoBody;
+    auto& Y3 = Y.ThreeBody;
+    auto& Z1 = Z.OneBody;
+    std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
+
+    size_t norb = Z.modelspace->GetNumberOrbits();
+    int nch = Z.modelspace->GetNumberTwoBodyChannels();
+    for (size_t i=0; i<norb; i++)
     {
-      if (j>i) continue;
-      Orbit& oj = Z.modelspace->GetOrbit(j);
-      int ej = 2*oj.n + oj.l;
-      double d_ej = std::abs( ej - e_fermi[oj.tz2]);
-      double occnat_j = oj.occ_nat;
-      double zij=0;
+      Orbit& oi = Z.modelspace->GetOrbit(i);
+      int ei = 2*oi.n + oi.l;
+      double d_ei = std::abs( ei - e_fermi[oi.tz2]);
+      double occnat_i = oi.occ_nat;
+      for ( auto j : Z.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) )
+      {
+        if (j>i) continue;
+        Orbit& oj = Z.modelspace->GetOrbit(j);
+        int ej = 2*oj.n + oj.l;
+        double d_ej = std::abs( ej - e_fermi[oj.tz2]);
+        double occnat_j = oj.occ_nat;
+        double zij=0;
 
-      std::vector<std::array<size_t,2>> Xchannels;
-      std::vector<std::array<size_t,2>> Ychannels;
-      for ( auto& iter : X.TwoBody.MatEl ) Xchannels.push_back(iter.first);
-      for ( auto& iter : Y.TwoBody.MatEl ) Ychannels.push_back(iter.first);
-      size_t nxchan = Xchannels.size();
-      size_t nychan = Ychannels.size();
+        std::vector<std::array<size_t,2>> Xchannels;
+        std::vector<std::array<size_t,2>> Ychannels;
+        for ( auto& iter : X.TwoBody.MatEl ) Xchannels.push_back(iter.first);
+        for ( auto& iter : Y.TwoBody.MatEl ) Ychannels.push_back(iter.first);
+        size_t nxchan = Xchannels.size();
+        size_t nychan = Ychannels.size();
 
-//      for (int ch=0; ch<nch; ch++)
-      for ( size_t ichan=0; ichan<nxchan; ichan++)
-      {
-        size_t ch_bra = Xchannels[ichan][0];
-        size_t ch_ket = Xchannels[ichan][1];
-        auto tbc_bra = Z.modelspace->GetTwoBodyChannel(ch_bra);
-        auto tbc_ket = Z.modelspace->GetTwoBodyChannel(ch_ket);
-        int J = tbc_bra.J;
-        size_t nbras = tbc_bra.GetNumberKets();
-        size_t nkets = tbc_ket.GetNumberKets();
-//        for ( auto ibra : tbc_bra.KetIndex_hh )
-        for ( size_t ibra=0; ibra<nbras; ibra++ )
+        //      for (int ch=0; ch<nch; ch++)
+        for ( size_t ichan=0; ichan<nxchan; ichan++)
         {
-          Ket& bra = tbc_bra.GetKet(ibra);
-          int a = bra.p;
-          int b = bra.q;
-          int ea = 2*bra.op->n + bra.op->l;
-          int eb = 2*bra.oq->n + bra.oq->l;
-          double d_ea = std::abs( ea - e_fermi[bra.op->tz2]);
-          double d_eb = std::abs( eb - e_fermi[bra.oq->tz2]);
-          double occnat_a = bra.op->occ_nat;
-          double occnat_b = bra.oq->occ_nat;
-          if (  (ea+eb+std::min(ei,ej))> Z.modelspace->E3max )  continue;
-          if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * std::max( occnat_i*(1-occnat_i), occnat_j*(1-occnat_j)) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-          double na = bra.op->occ;
-          double nb = bra.oq->occ;
-          if ( std::abs(na*nb)<1e-6) continue;
-//          for ( auto iket : tbc.KetIndex_pp )
-          for ( size_t iket=0; iket<nkets; iket++ )
+          size_t ch_bra = Xchannels[ichan][0];
+          size_t ch_ket = Xchannels[ichan][1];
+          auto tbc_bra = Z.modelspace->GetTwoBodyChannel(ch_bra);
+          auto tbc_ket = Z.modelspace->GetTwoBodyChannel(ch_ket);
+          int J = tbc_bra.J;
+          size_t nbras = tbc_bra.GetNumberKets();
+          size_t nkets = tbc_ket.GetNumberKets();
+          //        for ( auto ibra : tbc_bra.KetIndex_hh )
+          for ( size_t ibra=0; ibra<nbras; ibra++ )
           {
-            Ket& ket = tbc_ket.GetKet(iket);
-            int c = ket.p;
-            int d = ket.q;
-            int ec = 2*ket.op->n + ket.op->l;
-            int ed = 2*ket.oq->n + ket.oq->l;
-            double d_ec = std::abs( ec - e_fermi[ket.op->tz2]);
-            double d_ed = std::abs( ec - e_fermi[ket.oq->tz2]);
-            double occnat_c = bra.op->occ_nat;
-            double occnat_d = bra.oq->occ_nat;
-            if (  (ec+ed+std::min(ei,ej))> Z.modelspace->E3max )  continue;
-            if ( (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * std::max( occnat_i*(1-occnat_i), occnat_j*(1-occnat_j)) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-            double nc = ket.op->occ;
-            double nd = ket.oq->occ;
-            double prefactor = na*nb*(1-nc)*(1-nd);
-            if ( std::abs(prefactor)<1e-8) continue;
-            double Xabcd = X2.GetTBME(ch_bra,ch_ket,bra,ket);
-//            double Yabcd = Y2.GetTBME(ch,bra,ket);
-            double Xcdab = X2.GetTBME(ch_ket,ch_bra,ket,bra);
-//            double Ycdab = Y2.GetTBME(ch,ket,bra);
-            if (a==b) prefactor /= 2;
-            if (c==d) prefactor /= 2;
-            int twoJ_min = std::abs( 2*J - oi.j2);
-            int twoJ_max = 2*J + oi.j2;
-            for (int twoJ=twoJ_min; twoJ<=twoJ_max; twoJ+=2)
+            Ket& bra = tbc_bra.GetKet(ibra);
+            int a = bra.p;
+            int b = bra.q;
+            int ea = 2*bra.op->n + bra.op->l;
+            int eb = 2*bra.oq->n + bra.oq->l;
+            double d_ea = std::abs( ea - e_fermi[bra.op->tz2]);
+            double d_eb = std::abs( eb - e_fermi[bra.oq->tz2]);
+            double occnat_a = bra.op->occ_nat;
+            double occnat_b = bra.oq->occ_nat;
+            if (  (ea+eb+std::min(ei,ej))> Z.modelspace->E3max )  continue;
+            if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * std::max( occnat_i*(1-occnat_i), occnat_j*(1-occnat_j)) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+            double na = bra.op->occ;
+            double nb = bra.oq->occ;
+            if ( std::abs(na*nb)<1e-6) continue;
+            //          for ( auto iket : tbc.KetIndex_pp )
+            for ( size_t iket=0; iket<nkets; iket++ )
             {
-//              double xabicdj = 0;
-              double yabicdj = 0;
-//              double xcdiabj = 0;
-              double ycdiabj = 0;
-              if ( ( std::max(ea+eb+ej,ec+ed+ei) <= Z.modelspace->E3max )
-               and ( std::max(d_ea+d_eb+d_ej,d_ec+d_ed+d_ei) <= Z.modelspace->E3max ) 
-               and (  (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_i*(1-occnat_i) ) < Z.modelspace->GetOccNat3Cut() )
-               and (  (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_j*(1-occnat_j) ) < Z.modelspace->GetOccNat3Cut() )   )
-              {
-//                xcdiabj = X3.GetME_pn(J,J,twoJ,c,d,i,a,b,j);
-                ycdiabj = Y3.GetME_pn(J,J,twoJ,c,d,i,a,b,j);
-              }
-              if ( (std::max(ea+eb+ei,ec+ed+ej) <= Z.modelspace->E3max )
-               and ( std::max(d_ea+d_eb+d_ei,d_ec+d_ed+d_ej) <= Z.modelspace->E3max ) 
-               and (  (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_j*(1-occnat_j) ) < Z.modelspace->GetOccNat3Cut() )
-               and (  (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_i*(1-occnat_i) ) < Z.modelspace->GetOccNat3Cut() )   )
+              Ket& ket = tbc_ket.GetKet(iket);
+              int c = ket.p;
+              int d = ket.q;
+              int ec = 2*ket.op->n + ket.op->l;
+              int ed = 2*ket.oq->n + ket.oq->l;
+              double d_ec = std::abs( ec - e_fermi[ket.op->tz2]);
+              double d_ed = std::abs( ec - e_fermi[ket.oq->tz2]);
+              double occnat_c = bra.op->occ_nat;
+              double occnat_d = bra.oq->occ_nat;
+              if (  (ec+ed+std::min(ei,ej))> Z.modelspace->E3max )  continue;
+              if ( (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * std::max( occnat_i*(1-occnat_i), occnat_j*(1-occnat_j)) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+              double nc = ket.op->occ;
+              double nd = ket.oq->occ;
+              double prefactor = na*nb*(1-nc)*(1-nd);
+              if ( std::abs(prefactor)<1e-8) continue;
+              double Xabcd = X2.GetTBME(ch_bra,ch_ket,bra,ket);
+              //            double Yabcd = Y2.GetTBME(ch,bra,ket);
+              double Xcdab = X2.GetTBME(ch_ket,ch_bra,ket,bra);
+              //            double Ycdab = Y2.GetTBME(ch,ket,bra);
+              if (a==b) prefactor /= 2;
+              if (c==d) prefactor /= 2;
+              int twoJ_min = std::abs( 2*J - oi.j2);
+              int twoJ_max = 2*J + oi.j2;
+              for (int twoJ=twoJ_min; twoJ<=twoJ_max; twoJ+=2)
               {
-//                xabicdj = X3.GetME_pn(J,J,twoJ,a,b,i,c,d,j);
-                yabicdj = Y3.GetME_pn(J,J,twoJ,a,b,i,c,d,j);
-              }
-              zij += prefactor * (twoJ+1) * ( (Xabcd * ycdiabj - yabicdj * Xcdab) );
-//              zij += prefactor * (twoJ+1) * ( (Xabcd * ycdiabj - yabicdj * Xcdab)
-//                                           -  (Yabcd * xcdiabj - xabicdj * Ycdab) );
-              
-            }// for twoJ
-          }// for iket
-        }// for ibra
-      }// for ichan
+                //              double xabicdj = 0;
+                double yabicdj = 0;
+                //              double xcdiabj = 0;
+                double ycdiabj = 0;
+                if ( ( std::max(ea+eb+ej,ec+ed+ei) <= Z.modelspace->E3max )
+                    and ( std::max(d_ea+d_eb+d_ej,d_ec+d_ed+d_ei) <= Z.modelspace->E3max )
+                    and (  (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_i*(1-occnat_i) ) < Z.modelspace->GetOccNat3Cut() )
+                    and (  (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_j*(1-occnat_j) ) < Z.modelspace->GetOccNat3Cut() )   )
+                {
+                  //                xcdiabj = X3.GetME_pn(J,J,twoJ,c,d,i,a,b,j);
+                  ycdiabj = Y3.GetME_pn(J,J,twoJ,c,d,i,a,b,j);
+                }
+                if ( (std::max(ea+eb+ei,ec+ed+ej) <= Z.modelspace->E3max )
+                    and ( std::max(d_ea+d_eb+d_ei,d_ec+d_ed+d_ej) <= Z.modelspace->E3max )
+                    and (  (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_j*(1-occnat_j) ) < Z.modelspace->GetOccNat3Cut() )
+                    and (  (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_i*(1-occnat_i) ) < Z.modelspace->GetOccNat3Cut() )   )
+                {
+                  //                xabicdj = X3.GetME_pn(J,J,twoJ,a,b,i,c,d,j);
+                  yabicdj = Y3.GetME_pn(J,J,twoJ,a,b,i,c,d,j);
+                }
+                zij += prefactor * (twoJ+1) * ( (Xabcd * ycdiabj - yabicdj * Xcdab) );
+                //              zij += prefactor * (twoJ+1) * ( (Xabcd * ycdiabj - yabicdj * Xcdab)
+                //                                           -  (Yabcd * xcdiabj - xabicdj * Ycdab) );
 
-      for ( size_t ichan=0; ichan<nychan; ichan++)
-      {
-        size_t ch_bra = Ychannels[ichan][0];
-        size_t ch_ket = Ychannels[ichan][1];
-        auto tbc_bra = Z.modelspace->GetTwoBodyChannel(ch_bra);
-        auto tbc_ket = Z.modelspace->GetTwoBodyChannel(ch_ket);
-        int J = tbc_bra.J;
-        size_t nbras = tbc_bra.GetNumberKets();
-        size_t nkets = tbc_ket.GetNumberKets();
-        for ( auto ibra : tbc_bra.KetIndex_hh )
+              }// for twoJ
+            }// for iket
+          }// for ibra
+        }// for ichan
+
+        for ( size_t ichan=0; ichan<nychan; ichan++)
         {
-          Ket& bra = tbc_bra.GetKet(ibra);
-          int a = bra.p;
-          int b = bra.q;
-          int ea = 2*bra.op->n + bra.op->l;
-          int eb = 2*bra.oq->n + bra.oq->l;
-          double d_ea = std::abs(ea - e_fermi[bra.op->tz2]);
-          double d_eb = std::abs(eb - e_fermi[bra.oq->tz2]);
-          double occnat_a = bra.op->occ_nat;
-          double occnat_b = bra.oq->occ_nat;
-          if (  (ea+eb+std::min(ei,ej))> Z.modelspace->E3max )  continue;
-          if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * std::max( occnat_i*(1-occnat_i), occnat_j*(1-occnat_j)) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-          double na = bra.op->occ;
-          double nb = bra.oq->occ;
-//          for ( auto iket : tbc.KetIndex_pp )
-          for ( size_t iket=0; iket<nkets; iket++ )
+          size_t ch_bra = Ychannels[ichan][0];
+          size_t ch_ket = Ychannels[ichan][1];
+          auto tbc_bra = Z.modelspace->GetTwoBodyChannel(ch_bra);
+          auto tbc_ket = Z.modelspace->GetTwoBodyChannel(ch_ket);
+          int J = tbc_bra.J;
+          size_t nbras = tbc_bra.GetNumberKets();
+          size_t nkets = tbc_ket.GetNumberKets();
+          for ( auto ibra : tbc_bra.KetIndex_hh )
           {
-            Ket& ket = tbc_ket.GetKet(iket);
-            int c = ket.p;
-            int d = ket.q;
-            int ec = 2*ket.op->n + ket.op->l;
-            int ed = 2*ket.oq->n + ket.oq->l;
-            double d_ec = std::abs(ec - e_fermi[ket.op->tz2]);
-            double d_ed = std::abs(ec - e_fermi[ket.oq->tz2]);
-            double occnat_c = bra.op->occ_nat;
-            double occnat_d = bra.oq->occ_nat;
-            if (  (ec+ed+std::min(ei,ej))> Z.modelspace->E3max )  continue;
-            if ( (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * std::max( occnat_i*(1-occnat_i), occnat_j*(1-occnat_j)) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-            double nc = ket.op->occ;
-            double nd = ket.oq->occ;
-            double prefactor = na*nb*(1-nc)*(1-nd);
-            if ( std::abs(prefactor)<1e-8) continue;
-//            double Xabcd = X2.GetTBME(ch,bra,ket);
-            double Yabcd = Y2.GetTBME(ch_bra,ch_ket,bra,ket);
-//            double Xcdab = X2.GetTBME(ch,ket,bra);
-            double Ycdab = Y2.GetTBME(ch_ket,ch_bra,ket,bra);
-            if (a==b) prefactor /= 2;
-            if (c==d) prefactor /= 2;
-            int twoJ_min = std::abs( 2*J - oi.j2);
-            int twoJ_max = 2*J + oi.j2;
-            for (int twoJ=twoJ_min; twoJ<=twoJ_max; twoJ+=2)
+            Ket& bra = tbc_bra.GetKet(ibra);
+            int a = bra.p;
+            int b = bra.q;
+            int ea = 2*bra.op->n + bra.op->l;
+            int eb = 2*bra.oq->n + bra.oq->l;
+            double d_ea = std::abs(ea - e_fermi[bra.op->tz2]);
+            double d_eb = std::abs(eb - e_fermi[bra.oq->tz2]);
+            double occnat_a = bra.op->occ_nat;
+            double occnat_b = bra.oq->occ_nat;
+            if (  (ea+eb+std::min(ei,ej))> Z.modelspace->E3max )  continue;
+            if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * std::max( occnat_i*(1-occnat_i), occnat_j*(1-occnat_j)) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+            double na = bra.op->occ;
+            double nb = bra.oq->occ;
+            //          for ( auto iket : tbc.KetIndex_pp )
+            for ( size_t iket=0; iket<nkets; iket++ )
             {
-              double xabicdj = 0;
-//              double yabicdj = 0;
-              double xcdiabj = 0;
-//              double ycdiabj = 0;
-              if ( ( std::max(ea+eb+ej,ec+ed+ei) <= Z.modelspace->E3max )
-               and ( std::max(d_ea+d_eb+d_ej,d_ec+d_ed+d_ei) <= Z.modelspace->E3max ) 
-               and (  (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_i*(1-occnat_i) ) < Z.modelspace->GetOccNat3Cut() )
-               and (  (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_j*(1-occnat_j) ) < Z.modelspace->GetOccNat3Cut() )   )
+              Ket& ket = tbc_ket.GetKet(iket);
+              int c = ket.p;
+              int d = ket.q;
+              int ec = 2*ket.op->n + ket.op->l;
+              int ed = 2*ket.oq->n + ket.oq->l;
+              double d_ec = std::abs(ec - e_fermi[ket.op->tz2]);
+              double d_ed = std::abs(ec - e_fermi[ket.oq->tz2]);
+              double occnat_c = bra.op->occ_nat;
+              double occnat_d = bra.oq->occ_nat;
+              if (  (ec+ed+std::min(ei,ej))> Z.modelspace->E3max )  continue;
+              if ( (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * std::max( occnat_i*(1-occnat_i), occnat_j*(1-occnat_j)) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+              double nc = ket.op->occ;
+              double nd = ket.oq->occ;
+              double prefactor = na*nb*(1-nc)*(1-nd);
+              if ( std::abs(prefactor)<1e-8) continue;
+              //            double Xabcd = X2.GetTBME(ch,bra,ket);
+              double Yabcd = Y2.GetTBME(ch_bra,ch_ket,bra,ket);
+              //            double Xcdab = X2.GetTBME(ch,ket,bra);
+              double Ycdab = Y2.GetTBME(ch_ket,ch_bra,ket,bra);
+              if (a==b) prefactor /= 2;
+              if (c==d) prefactor /= 2;
+              int twoJ_min = std::abs( 2*J - oi.j2);
+              int twoJ_max = 2*J + oi.j2;
+              for (int twoJ=twoJ_min; twoJ<=twoJ_max; twoJ+=2)
               {
-                xcdiabj = X3.GetME_pn(J,J,twoJ,c,d,i,a,b,j);
-//                ycdiabj = Y3.GetME_pn(J,J,twoJ,c,d,i,a,b,j);
-              }
-              if ( (std::max(ea+eb+ei,ec+ed+ej) <= Z.modelspace->E3max )
-               and ( std::max(d_ea+d_eb+d_ei,d_ec+d_ed+d_ej) <= Z.modelspace->E3max ) 
-               and (  (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_j*(1-occnat_j) ) < Z.modelspace->GetOccNat3Cut() )
-               and (  (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_i*(1-occnat_i) ) < Z.modelspace->GetOccNat3Cut() )   )
-              {
-                xabicdj = X3.GetME_pn(J,J,twoJ,a,b,i,c,d,j);
-//                yabicdj = Y3.GetME_pn(J,J,twoJ,a,b,i,c,d,j);
-              }
-              zij -= prefactor * (twoJ+1) * ( (Yabcd * xcdiabj - xabicdj * Ycdab) );
-//              zij += prefactor * (twoJ+1) * ( (Xabcd * ycdiabj - yabicdj * Xcdab)
-//                                           -  (Yabcd * xcdiabj - xabicdj * Ycdab) );
-              
-            }// for twoJ
-          }// for iket
-        }// for ibra
-      }// for ichan
+                double xabicdj = 0;
+                //              double yabicdj = 0;
+                double xcdiabj = 0;
+                //              double ycdiabj = 0;
+                if ( ( std::max(ea+eb+ej,ec+ed+ei) <= Z.modelspace->E3max )
+                    and ( std::max(d_ea+d_eb+d_ej,d_ec+d_ed+d_ei) <= Z.modelspace->E3max )
+                    and (  (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_i*(1-occnat_i) ) < Z.modelspace->GetOccNat3Cut() )
+                    and (  (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_j*(1-occnat_j) ) < Z.modelspace->GetOccNat3Cut() )   )
+                {
+                  xcdiabj = X3.GetME_pn(J,J,twoJ,c,d,i,a,b,j);
+                  //                ycdiabj = Y3.GetME_pn(J,J,twoJ,c,d,i,a,b,j);
+                }
+                if ( (std::max(ea+eb+ei,ec+ed+ej) <= Z.modelspace->E3max )
+                    and ( std::max(d_ea+d_eb+d_ei,d_ec+d_ed+d_ej) <= Z.modelspace->E3max )
+                    and (  (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_j*(1-occnat_j) ) < Z.modelspace->GetOccNat3Cut() )
+                    and (  (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_i*(1-occnat_i) ) < Z.modelspace->GetOccNat3Cut() )   )
+                {
+                  xabicdj = X3.GetME_pn(J,J,twoJ,a,b,i,c,d,j);
+                  //                yabicdj = Y3.GetME_pn(J,J,twoJ,a,b,i,c,d,j);
+                }
+                zij -= prefactor * (twoJ+1) * ( (Yabcd * xcdiabj - xabicdj * Ycdab) );
+                //              zij += prefactor * (twoJ+1) * ( (Xabcd * ycdiabj - yabicdj * Xcdab)
+                //                                           -  (Yabcd * xcdiabj - xabicdj * Ycdab) );
 
+              }// for twoJ
+            }// for iket
+          }// for ibra
+        }// for ichan
 
 
-      Z1(i,j) += zij / (oi.j2+1.0);
-      if (i!=j)
-      {
-         Z1(j,i) += zij / (oi.j2+1.0);
-      }
-    }// for j
-  }// for i
 
-  Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
-}
+        Z1(i,j) += zij / (oi.j2+1.0);
+        if (i!=j)
+        {
+          Z1(j,i) += zij / (oi.j2+1.0);
+        }
+      }// for j
+    }// for i
 
+    Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
+  }
 
 
-//*****************************************************************************************
-//
-// i|  j|   *~~[X]  Uncoupled expression:
-//  |   |  / \          Z_ijkl = sum_ab (nan`b-n`anb) (X_ab * Y_ijbkla)
-//  |   | (a  )b
-//  |   |  \ /
-//  *~~[Y]~~*       Coupled expression:
-//  |   |              Z_{ijkl}^{J} = sum_ab (nan`b-n`anb) sum_J' (2J'+1)/(2J+1) ( X_ab * Y_{ijbkla}^{J,J,J'} )
-// k|  l|                                          
-//                           
-//                              
-//                 When we call Symmetrize, we copy the upper triangle <ibra|iket> with ibra<=iket onto the lower triangle.
-//                 Of course, calling AddToTBME updates both according to the symmetry, so we don't need to worry so much... 
-//
-//  Verfied with UnitTest
-//
-void comm132ss( const Operator& X, const Operator& Y, Operator& Z )
-{
-  double tstart = omp_get_wtime();
-  auto& X1 = X.OneBody;
-  auto& X3 = X.ThreeBody;
-  auto& Y1 = Y.OneBody;
-  auto& Y3 = Y.ThreeBody;
-  auto& Z2 = Z.TwoBody;
-  std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
-  
-  int norb = Z.modelspace->GetNumberOrbits();
-  size_t nch = Z.modelspace->GetNumberTwoBodyChannels();
 
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
-  for (size_t ch=0; ch<nch; ch++)
+  //*****************************************************************************************
+  //
+  // i|  j|   *~~[X]  Uncoupled expression:
+  //  |   |  / \          Z_ijkl = sum_ab (nan`b-n`anb) (X_ab * Y_ijbkla)
+  //  |   | (a  )b
+  //  |   |  \ /
+  //  *~~[Y]~~*       Coupled expression:
+  //  |   |              Z_{ijkl}^{J} = sum_ab (nan`b-n`anb) sum_J' (2J'+1)/(2J+1) ( X_ab * Y_{ijbkla}^{J,J,J'} )
+  // k|  l|
+  //
+  //
+  //                 When we call Symmetrize, we copy the upper triangle <ibra|iket> with ibra<=iket onto the lower triangle.
+  //                 Of course, calling AddToTBME updates both according to the symmetry, so we don't need to worry so much...
+  //
+  //  Verfied with UnitTest
+  //
+  void comm132ss( const Operator& X, const Operator& Y, Operator& Z )
   {
-    auto& tbc = Z.modelspace->GetTwoBodyChannel(ch);
-    int J = tbc.J;
-    int nkets = tbc.GetNumberKets();
-    for (int ibra=0;ibra<nkets;ibra++ ) // <ij| states
+    double tstart = omp_get_wtime();
+    auto& X1 = X.OneBody;
+    auto& X3 = X.ThreeBody;
+    auto& Y1 = Y.OneBody;
+    auto& Y3 = Y.ThreeBody;
+    auto& Z2 = Z.TwoBody;
+    std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
+
+    int norb = Z.modelspace->GetNumberOrbits();
+    size_t nch = Z.modelspace->GetNumberTwoBodyChannels();
+
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+    for (size_t ch=0; ch<nch; ch++)
     {
-      Ket& bra = tbc.GetKet(ibra);
-      int i = bra.p;
-      int j = bra.q;
-      int ei = 2*bra.op->n + bra.op->l;
-      int ej = 2*bra.oq->n + bra.oq->l;
-      double d_ei = std::abs(ei - e_fermi[bra.op->tz2]);
-      double d_ej = std::abs(ej - e_fermi[bra.oq->tz2]);
-      double occnat_i = bra.op->occ_nat;
-      double occnat_j = bra.oq->occ_nat;
-      for (int iket=ibra;iket<nkets;iket++ ) // |kl> states
+      auto& tbc = Z.modelspace->GetTwoBodyChannel(ch);
+      int J = tbc.J;
+      int nkets = tbc.GetNumberKets();
+      for (int ibra=0;ibra<nkets;ibra++ ) // <ij| states
       {
-        Ket& ket = tbc.GetKet(iket);
-        int k = ket.p;
-        int l = ket.q;
-        int ek = 2*ket.op->n + ket.op->l;
-        int el = 2*ket.oq->n + ket.oq->l;
-        double d_ek = std::abs( ek - e_fermi[ket.op->tz2]);
-        double d_el = std::abs( el - e_fermi[ket.oq->tz2]);
-        double occnat_k = ket.op->occ_nat;
-        double occnat_l = ket.oq->occ_nat;
-        double zijkl = 0;
-        for (int a=0;a<norb;a++)
+        Ket& bra = tbc.GetKet(ibra);
+        int i = bra.p;
+        int j = bra.q;
+        int ei = 2*bra.op->n + bra.op->l;
+        int ej = 2*bra.oq->n + bra.oq->l;
+        double d_ei = std::abs(ei - e_fermi[bra.op->tz2]);
+        double d_ej = std::abs(ej - e_fermi[bra.oq->tz2]);
+        double occnat_i = bra.op->occ_nat;
+        double occnat_j = bra.oq->occ_nat;
+        for (int iket=ibra;iket<nkets;iket++ ) // |kl> states
         {
-          Orbit& oa = Z.modelspace->GetOrbit(a);
-          int ea = 2*oa.n + oa.l;
-          double d_ea = std::abs( ea - e_fermi[oa.tz2]);
-          double occnat_a = oa.occ_nat;
-          if ( (ek+el+ea)>Z.modelspace->E3max) continue;
-          if ( (d_ek+d_el+d_ea)>Z.modelspace->dE3max) continue;
-          if ( (occnat_k*(1-occnat_k) * occnat_l*(1-occnat_l) * occnat_a*(1-occnat_a)) < Z.modelspace->GetOccNat3Cut() ) continue;
-          // this is less efficient than doing the loop twice, but less code
-          // and easily lets us treat the case of Y having nonzero Tz or odd parity
-          std::set<size_t> blist;
-          for ( auto b : X.OneBodyChannels.at({oa.l,oa.j2,oa.tz2})) blist.insert(b);
-          for ( auto b : Y.OneBodyChannels.at({oa.l,oa.j2,oa.tz2})) blist.insert(b);
-//          for ( auto b : Z.OneBodyChannels.at({oa.l,oa.j2,oa.tz2}) ) // TODO: We can make this a<=b or a>=b, I think. Just need to mind some factors of 2
-          for ( auto b : blist ) 
+          Ket& ket = tbc.GetKet(iket);
+          int k = ket.p;
+          int l = ket.q;
+          int ek = 2*ket.op->n + ket.op->l;
+          int el = 2*ket.oq->n + ket.oq->l;
+          double d_ek = std::abs( ek - e_fermi[ket.op->tz2]);
+          double d_el = std::abs( el - e_fermi[ket.oq->tz2]);
+          double occnat_k = ket.op->occ_nat;
+          double occnat_l = ket.oq->occ_nat;
+          double zijkl = 0;
+          for (int a=0;a<norb;a++)
           {
-            Orbit& ob = Z.modelspace->GetOrbit(b);
-            int eb = 2*ob.n + ob.l;
-            double d_eb = std::abs( eb - e_fermi[ob.tz2]);
-            double occnat_b = ob.occ_nat;
-            if ( (ei+ej+eb)>Z.modelspace->E3max) continue;
-            if ( (d_ei+d_ej+d_eb)>Z.modelspace->dE3max) continue;
-            if ( (occnat_i*(1-occnat_i) * occnat_j*(1-occnat_j) * occnat_b*(1-occnat_b) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-            double occfactor = oa.occ - ob.occ;
-            if (std::abs(occfactor)<1e-6) continue;
-            int twoJ_min = std::abs( oa.j2 - 2*J );
-            int twoJ_max = oa.j2 + 2*J;
-            for (int twoJ=twoJ_min; twoJ<=twoJ_max; twoJ+=2)
+            Orbit& oa = Z.modelspace->GetOrbit(a);
+            int ea = 2*oa.n + oa.l;
+            double d_ea = std::abs( ea - e_fermi[oa.tz2]);
+            double occnat_a = oa.occ_nat;
+            if ( (ek+el+ea)>Z.modelspace->E3max) continue;
+            if ( (d_ek+d_el+d_ea)>Z.modelspace->dE3max) continue;
+            if ( (occnat_k*(1-occnat_k) * occnat_l*(1-occnat_l) * occnat_a*(1-occnat_a)) < Z.modelspace->GetOccNat3Cut() ) continue;
+            // this is less efficient than doing the loop twice, but less code
+            // and easily lets us treat the case of Y having nonzero Tz or odd parity
+            std::set<size_t> blist;
+            for ( auto b : X.OneBodyChannels.at({oa.l,oa.j2,oa.tz2})) blist.insert(b);
+            for ( auto b : Y.OneBodyChannels.at({oa.l,oa.j2,oa.tz2})) blist.insert(b);
+            //          for ( auto b : Z.OneBodyChannels.at({oa.l,oa.j2,oa.tz2}) ) // TODO: We can make this a<=b or a>=b, I think. Just need to mind some factors of 2
+            for ( auto b : blist )
             {
-              double xijbkla = X3.GetME_pn(J,J,twoJ,i,j,b,k,l,a);
-              double yijbkla = Y3.GetME_pn(J,J,twoJ,i,j,b,k,l,a);
+              Orbit& ob = Z.modelspace->GetOrbit(b);
+              int eb = 2*ob.n + ob.l;
+              double d_eb = std::abs( eb - e_fermi[ob.tz2]);
+              double occnat_b = ob.occ_nat;
+              if ( (ei+ej+eb)>Z.modelspace->E3max) continue;
+              if ( (d_ei+d_ej+d_eb)>Z.modelspace->dE3max) continue;
+              if ( (occnat_i*(1-occnat_i) * occnat_j*(1-occnat_j) * occnat_b*(1-occnat_b) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+              double occfactor = oa.occ - ob.occ;
+              if (std::abs(occfactor)<1e-6) continue;
+              int twoJ_min = std::abs( oa.j2 - 2*J );
+              int twoJ_max = oa.j2 + 2*J;
+              for (int twoJ=twoJ_min; twoJ<=twoJ_max; twoJ+=2)
+              {
+                double xijbkla = X3.GetME_pn(J,J,twoJ,i,j,b,k,l,a);
+                double yijbkla = Y3.GetME_pn(J,J,twoJ,i,j,b,k,l,a);
 
-              zijkl += occfactor * (twoJ+1.)/(2*J+1) * ( X1(a,b) * yijbkla -  Y1(a,b) * xijbkla );
+                zijkl += occfactor * (twoJ+1.)/(2*J+1) * ( X1(a,b) * yijbkla -  Y1(a,b) * xijbkla );
 
+              }
             }
           }
+          // normalize the tbme
+          zijkl /= sqrt((1.+bra.delta_pq())*(1.+ket.delta_pq()));
+          Z2.AddToTBME(ch, ch, ibra, iket, zijkl );
         }
-        // normalize the tbme
-        zijkl /= sqrt((1.+bra.delta_pq())*(1.+ket.delta_pq()));
-        Z2.AddToTBME(ch, ch, ibra, iket, zijkl );
       }
     }
+
+    Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
   }
 
-  Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
-}
 
 
 
 
 
+  //*****************************************************************************************
+  //
+  //  |         |
+  // i|        j|     Uncoupled expression:
+  //  *~~[X]~*  |         Z_ijkl = -1/2 sum_abc (nanbn`c+n`an`bnc) ( (1-Pij) X_icab * Y_abjklc - (1-Pkl) Yijcabl * Xabkc )
+  // a|  b|  c\ |
+  //  |   |    \|
+  //  *~~[Y]~~~~*      Coupled expression:
+  //  |   |              Z_{ijkl}^{J} = -1/2 sum_abc (nanbn`c+n`an`bnc) sum_J'J" (2J'+1)(2J"+1)/sqrt(2J+1) (-1)^{2J"+J'-J}
+  // k|  l|                           *  [   (1 - (-1)^{i+j-J}Pij) (-1)^{j-c} { j  J" J' } X_icab^{J'} * Y_{abjklc}^{J'JJ"}
+  //                                                                          { c  i  J  }
+  //
+  //                                       -(1 - (-1)^{k+l-J}Pkl)  (-1)^{l-c} { l  J" J' } Y_{ijcabl}^{JJ'J"} * X_{abkc}^{J'}  ]
+  //                                                                          { c  k  J  }
+  //
+  //   The factor 1/2 out front is absorbed by the fact that we only do the ordering a<=b  (need to deal carefully with a==b)
+  //
+  //  Verified with UnitTest
+  //
+  // This is the time hog of the n^7 scaling terms   (seems to be doing better...)
 
-//*****************************************************************************************
-//
-//  |         |
-// i|        j|     Uncoupled expression:
-//  *~~[X]~*  |         Z_ijkl = -1/2 sum_abc (nanbn`c-n`an`bnc) ( (1-Pij) X_icab * Y_abjklc - (1-Pkl) Yijcabl * Xabkc )
-// a|  b|  c\ |
-//  |   |    \|
-//  *~~[Y]~~~~*      Coupled expression:
-//  |   |              Z_{ijkl}^{J} = -1/2 sum_abc (nanbn`c-n`an`bnc) sum_J'J" (2J'+1)(2J"+1)/sqrt(2J+1) (-1)^{2J"+J'-J}
-// k|  l|                           *  [   (1 - (-1)^{i+j-J}Pij) (-1)^{j-c} { j  J" J' } X_icab^{J'} * Y_{abjklc}^{J'JJ"}    
-//                                                                          { c  i  J  }
-//                           
-//                                       -(1 - (-1)^{k+l-J}Pkl)  (-1)^{l-c} { l  J" J' } Y_{ijcabl}^{JJ'J"} * X_{abkc}^{J'}  ]
-//                                                                          { c  k  J  }
-//
-//   The factor 1/2 out front is absorbed by the fact that we only do the ordering a<=b  (need to deal carefully with a==b)
-//
-//  Verified with UnitTest
-//
-// This is the time hog of the n^7 scaling terms   (seems to be doing better...)
+  size_t Hash_comm232_key( std::array<size_t,5>& kljJJ )
+  {
+    return kljJJ[0] + (kljJJ[1] << 8) + (kljJJ[2] << 16) + (kljJJ[3] << 24) + (kljJJ[4]<<32);
+  }
 
-size_t Hash_comm232_key( std::array<size_t,5>& kljJJ )
-{
-  return kljJJ[0] + (kljJJ[1] << 8) + (kljJJ[2] << 16) + (kljJJ[3] << 24) + (kljJJ[4]<<32);
-}
+  void comm232ss( const Operator& X, const Operator& Y, Operator& Z )
+  {
+    double tstart = omp_get_wtime();
+    auto& X2 = X.TwoBody;
+    auto& X3 = X.ThreeBody;
+    auto& Y2 = Y.TwoBody;
+    auto& Y3 = Y.ThreeBody;
+    auto& Z2 = Z.TwoBody;
 
-void comm232ss( const Operator& X, const Operator& Y, Operator& Z )
-{
-  double tstart = omp_get_wtime();
-  auto& X2 = X.TwoBody;
-  auto& X3 = X.ThreeBody;
-  auto& Y2 = Y.TwoBody;
-  auto& Y3 = Y.ThreeBody;
-  auto& Z2 = Z.TwoBody;
+    bool x_has_3 = X3.is_allocated;
+    bool y_has_3 = Y3.is_allocated;
 
-  bool x_has_3 = X3.is_allocated;
-  bool y_has_3 = Y3.is_allocated;
+    int hermX = X.IsHermitian() ? 1 : -1;
+    int hermY = Y.IsHermitian() ? 1 : -1;
 
-  int hermX = X.IsHermitian() ? 1 : -1;
-  int hermY = Y.IsHermitian() ? 1 : -1;
+    std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
 
-  std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
+    int nch = Z.modelspace->GetNumberTwoBodyChannels();
+    //  std::cout << __func__ << " begin" << std::endl;
 
-  int nch = Z.modelspace->GetNumberTwoBodyChannels();
-//  std::cout << __func__ << " begin" << std::endl;
+    // first, enumerate the one-body channels |i> => ji,parityi,tzi
+    std::map<std::array<int,3>,std::vector<size_t>> local_one_body_channels; //  maps {j,parity,tz} => vector of index_i
+    for ( auto i : Z.modelspace->all_orbits )
+    {
+      Orbit& oi = Z.modelspace->GetOrbit(i);
+      std::array<int,3> obc = {oi.j2,oi.l%2,oi.tz2};
+      if ( local_one_body_channels.find(obc) == local_one_body_channels.end() ) local_one_body_channels[obc] = {i};
+      else local_one_body_channels[obc].push_back(i);
+    }
 
-  // first, enumerate the one-body channels |i> => ji,parityi,tzi
-  std::map<std::array<int,3>,std::vector<size_t>> local_one_body_channels; //  maps {j,parity,tz} => vector of index_i 
-  for ( auto i : Z.modelspace->all_orbits )
-  {
-    Orbit& oi = Z.modelspace->GetOrbit(i);
-    std::array<int,3> obc = {oi.j2,oi.l%2,oi.tz2};
-    if ( local_one_body_channels.find(obc) == local_one_body_channels.end() ) local_one_body_channels[obc] = {i};
-    else local_one_body_channels[obc].push_back(i);
-  }
-  
-  // next, figure out which three-body states |klj`> and |abc`> exist, make a list, and give them an
-  // index for where they'll sit in the matrix
-  std::map<std::array<int,3>,std::vector<std::array<size_t,4>>> klj_list; //  maps {j,parity,tz} => {kljJ}
+    // next, figure out which three-body states |klj`> and |abc`> exist, make a list, and give them an
+    // index for where they'll sit in the matrix
+    std::map<std::array<int,3>,std::vector<std::array<size_t,4>>> klj_list; //  maps {j,parity,tz} => {kljJ}
   std::map<std::array<int,3>,arma::mat> ZMAT_list; //  maps {j,parity,tz} => matrix <i|Z|klj`>
 
   std::vector<std::array<int,3>> obc_keys;
   for ( auto& iter_i : local_one_body_channels) obc_keys.push_back(iter_i.first);
   size_t nkeys = obc_keys.size();
 
-  
+
   for ( size_t ikey=0; ikey<nkeys; ikey++ )
   {
     auto& obc_key = obc_keys[ikey];
@@ -2496,10 +2717,11 @@ void comm232ss( const Operator& X, const Operator& Y, Operator& Z )
             double occnat_j = oj.occ_nat;
             if ( (de_k + de_l) > Z.modelspace->GetdE3max() ) continue;
             if ( (occnat_k*(1-occnat_k) * occnat_l*(1-occnat_l) * occnat_j*(1-occnat_j) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-//            if ( (de_k + de_l + de_j) > Z.modelspace->GetdE3max() ) continue;
+            //            if ( (de_k + de_l + de_j) > Z.modelspace->GetdE3max() ) continue;
             double nj = oj.occ;
 
-            klj_list_i.push_back( { ket_kl.p, ket_kl.q, j, tbc_kl.J } );
+            //klj_list_i.push_back( { ket_kl.p, ket_kl.q, j, tbc_kl.J } );
+            klj_list_i.push_back( { ket_kl.p, ket_kl.q, j, (size_t)tbc_kl.J } );
 
           }// for j
         }// for iket_kl
@@ -2514,229 +2736,229 @@ void comm232ss( const Operator& X, const Operator& Y, Operator& Z )
 
   // This loop is what takes all the time.
   // Outer loop over one-body quantum numbers, which also label the three-body pph states |klj`> and |abc`>
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
   for ( size_t ikey=0; ikey<nkeys; ikey++ )
   {
 
     auto& obc_key = obc_keys[ikey]; // this is an array {j2,parity,tz2}
-    int j2i = obc_key[0];
-    std::vector<size_t>& obc_orbits = local_one_body_channels[obc_key]; // the orbits that have quantum numbers {j2,parity,tz2}
-    auto& klj_list_i = klj_list[obc_key]; // list of 3-body pph stats |klj`> with quantum numbers {j2,parity,tz2}
+  int j2i = obc_key[0];
+  std::vector<size_t>& obc_orbits = local_one_body_channels[obc_key]; // the orbits that have quantum numbers {j2,parity,tz2}
+  auto& klj_list_i = klj_list[obc_key]; // list of 3-body pph stats |klj`> with quantum numbers {j2,parity,tz2}
 
-    std::vector<size_t> abc_list; // keep track of which klj states should go in the abc loop
-    std::vector<double> abc_occ_list;
-    for (size_t i_kljJ=0; i_kljJ< klj_list[obc_key].size(); i_kljJ++ )
-    {
-      auto& kljJ = klj_list[obc_key][i_kljJ];
-      size_t a = kljJ[0];
-      size_t b = kljJ[1];
-      size_t c = kljJ[2];
-      Orbit& oa = Z.modelspace->GetOrbit(a);
-      Orbit& ob = Z.modelspace->GetOrbit(b);
-      Orbit& oc = Z.modelspace->GetOrbit(c);
-      double na = oa.occ;
-      double nb = ob.occ;
-      double nc = oc.occ;
-      double occupation_factor = na*nb*(1-nc) + (1-na)*(1-nb)*nc;
-      if (std::abs(occupation_factor)<1e-6) continue;
-      if (a==b) occupation_factor *=0.5;  // we sum a<=b, and drop the 1/2, but we still need the 1/2 for a==b
-      abc_list.push_back( i_kljJ );
-      abc_occ_list.push_back( occupation_factor );
-    }
+  std::vector<size_t> abc_list; // keep track of which klj states should go in the abc loop
+  std::vector<double> abc_occ_list;
+  for (size_t i_kljJ=0; i_kljJ< klj_list[obc_key].size(); i_kljJ++ )
+  {
+    auto& kljJ = klj_list[obc_key][i_kljJ];
+    size_t a = kljJ[0];
+    size_t b = kljJ[1];
+    size_t c = kljJ[2];
+    Orbit& oa = Z.modelspace->GetOrbit(a);
+    Orbit& ob = Z.modelspace->GetOrbit(b);
+    Orbit& oc = Z.modelspace->GetOrbit(c);
+    double na = oa.occ;
+    double nb = ob.occ;
+    double nc = oc.occ;
+    double occupation_factor = na*nb*(1-nc) + (1-na)*(1-nb)*nc;
+    if (std::abs(occupation_factor)<1e-6) continue;
+    if (a==b) occupation_factor *=0.5;  // we sum a<=b, and drop the 1/2, but we still need the 1/2 for a==b
+    abc_list.push_back( i_kljJ );
+    abc_occ_list.push_back( occupation_factor );
+  }
 
-    size_t dim_i   = obc_orbits.size(); // how many sp states are in this jpt channel
-    size_t dim_klj = klj_list[obc_key].size(); // how many 3-body pph states in this jpt channel
-    size_t dim_abc = abc_list.size(); // how many 3-body states which contribute to the |abc`> sum
-
-    // Now allocate the matrices in this channel
-    arma::mat X2MAT(dim_i,   dim_abc, arma::fill::zeros);
-    arma::mat Y2MAT(dim_i,   dim_abc, arma::fill::zeros);
-    arma::mat X3MAT(dim_abc, dim_klj, arma::fill::zeros);
-    arma::mat Y3MAT(dim_abc, dim_klj, arma::fill::zeros);
-
-   //figure out which recouplings we'll need when filling the matrices
-    std::set<std::array<size_t,5>> kljJJ_needed; // we use a set to avoid repeats
-    for (size_t ind_abc=0; ind_abc<dim_abc; ind_abc++) 
+  size_t dim_i   = obc_orbits.size(); // how many sp states are in this jpt channel
+  size_t dim_klj = klj_list[obc_key].size(); // how many 3-body pph states in this jpt channel
+  size_t dim_abc = abc_list.size(); // how many 3-body states which contribute to the |abc`> sum
+
+  // Now allocate the matrices in this channel
+  arma::mat X2MAT(dim_i,   dim_abc, arma::fill::zeros);
+  arma::mat Y2MAT(dim_i,   dim_abc, arma::fill::zeros);
+  arma::mat X3MAT(dim_abc, dim_klj, arma::fill::zeros);
+  arma::mat Y3MAT(dim_abc, dim_klj, arma::fill::zeros);
+
+  //figure out which recouplings we'll need when filling the matrices
+  std::set<std::array<size_t,5>> kljJJ_needed; // we use a set to avoid repeats
+  for (size_t ind_abc=0; ind_abc<dim_abc; ind_abc++)
+  {
+    auto& abcJ = klj_list_i[ abc_list[ind_abc] ];
+    size_t a = abcJ[0];
+    size_t b = abcJ[1];
+    size_t c = abcJ[2];
+    int Jab  = abcJ[3];
+    Orbit& oa = Z.modelspace->GetOrbit(a);
+    Orbit& ob = Z.modelspace->GetOrbit(b);
+    Orbit& oc = Z.modelspace->GetOrbit(c);
+    double de_a = std::abs( 2*oa.n + oa.l - e_fermi[oa.tz2]);
+    double de_b = std::abs( 2*ob.n + ob.l - e_fermi[ob.tz2]);
+    double de_c = std::abs( 2*oc.n + oc.l - e_fermi[oc.tz2]);
+    double occnat_a = oa.occ_nat;
+    double occnat_b = ob.occ_nat;
+    double occnat_c = oc.occ_nat;
+    int j2c = oc.j2;
+    for (size_t ind_klj=0; ind_klj<dim_klj; ind_klj++)
     {
-      auto& abcJ = klj_list_i[ abc_list[ind_abc] ];
-      size_t a = abcJ[0];
-      size_t b = abcJ[1];
-      size_t c = abcJ[2];
-      int Jab  = abcJ[3];
-      Orbit& oa = Z.modelspace->GetOrbit(a);
-      Orbit& ob = Z.modelspace->GetOrbit(b);
-      Orbit& oc = Z.modelspace->GetOrbit(c);
-      double de_a = std::abs( 2*oa.n + oa.l - e_fermi[oa.tz2]);
-      double de_b = std::abs( 2*ob.n + ob.l - e_fermi[ob.tz2]);
-      double de_c = std::abs( 2*oc.n + oc.l - e_fermi[oc.tz2]);
-      double occnat_a = oa.occ_nat;
-      double occnat_b = ob.occ_nat;
-      double occnat_c = oc.occ_nat;
-      int j2c = oc.j2;
-      for (size_t ind_klj=0; ind_klj<dim_klj; ind_klj++)
+      auto& kljJ = klj_list_i[ ind_klj ];
+      size_t k = kljJ[0];
+      size_t l = kljJ[1];
+      size_t j = kljJ[2];
+      int Jkl = kljJ[3];
+      Orbit& oj = Z.modelspace->GetOrbit(j);
+      Orbit& ok = Z.modelspace->GetOrbit(k);
+      Orbit& ol = Z.modelspace->GetOrbit(l);
+      double de_j = std::abs( 2*oj.n + oj.l - e_fermi[oj.tz2]);
+      double de_k = std::abs( 2*ok.n + ok.l - e_fermi[ok.tz2]);
+      double de_l = std::abs( 2*ol.n + ol.l - e_fermi[ol.tz2]);
+      double occnat_j = oj.occ_nat;
+      double occnat_k = ok.occ_nat;
+      double occnat_l = ol.occ_nat;
+      if ( (de_k + de_l + de_c) > Z.modelspace->GetdE3max() ) continue;
+      if ( (de_a + de_b + de_j) > Z.modelspace->GetdE3max() ) continue;
+      if ( (occnat_k*(1-occnat_k) * occnat_l*(1-occnat_l) * occnat_c*(1-occnat_c) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+      int twoJp_min = std::max( std::abs(2*Jab - oj.j2), std::abs(2*Jkl-j2c));
+      int twoJp_max = std::min( 2*Jab + oj.j2, 2*Jkl+j2c);
+      for (int twoJp=twoJp_min; twoJp<=twoJp_max; twoJp+=2)
       {
-        auto& kljJ = klj_list_i[ ind_klj ];
-        size_t k = kljJ[0];
-        size_t l = kljJ[1];
-        size_t j = kljJ[2];
-        int Jkl = kljJ[3];
-        Orbit& oj = Z.modelspace->GetOrbit(j);
-        Orbit& ok = Z.modelspace->GetOrbit(k);
-        Orbit& ol = Z.modelspace->GetOrbit(l);
-        double de_j = std::abs( 2*oj.n + oj.l - e_fermi[oj.tz2]);
-        double de_k = std::abs( 2*ok.n + ok.l - e_fermi[ok.tz2]);
-        double de_l = std::abs( 2*ol.n + ol.l - e_fermi[ol.tz2]);
-        double occnat_j = oj.occ_nat;
-        double occnat_k = ok.occ_nat;
-        double occnat_l = ol.occ_nat;
-        if ( (de_k + de_l + de_c) > Z.modelspace->GetdE3max() ) continue; 
-        if ( (de_a + de_b + de_j) > Z.modelspace->GetdE3max() ) continue;
-        if ( (occnat_k*(1-occnat_k) * occnat_l*(1-occnat_l) * occnat_c*(1-occnat_c) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-        int twoJp_min = std::max( std::abs(2*Jab - oj.j2), std::abs(2*Jkl-j2c));
-        int twoJp_max = std::min( 2*Jab + oj.j2, 2*Jkl+j2c);
-        for (int twoJp=twoJp_min; twoJp<=twoJp_max; twoJp+=2)
-        {
-           kljJJ_needed.insert({k,l,c,(size_t)Jkl,(size_t)twoJp});
-           kljJJ_needed.insert({a,b,j,(size_t)Jab,(size_t)twoJp});
-        }// for twoJp
-      }// for ind_klj
-    }// for ind_abc
+        kljJJ_needed.insert({k,l,c,(size_t)Jkl,(size_t)twoJp});
+        kljJJ_needed.insert({a,b,j,(size_t)Jab,(size_t)twoJp});
+      }// for twoJp
+    }// for ind_klj
+  }// for ind_abc
 
-   // now compute the couplings once and store them in a hash table
-   std::vector<double> recoupling_cache; // a vector storing all the relevant recoupling info
-   std::unordered_map<size_t, size_t> recoupling_cache_lookup; // a lookup table so we can find the info easily
+  // now compute the couplings once and store them in a hash table
+  std::vector<double> recoupling_cache; // a vector storing all the relevant recoupling info
+  std::unordered_map<size_t, size_t> recoupling_cache_lookup; // a lookup table so we can find the info easily
 
-   for ( auto kljJJ : kljJJ_needed )
-   {
-     size_t k = kljJJ[0];
-     size_t l = kljJJ[1];
-     size_t j = kljJJ[2];
-     size_t Jkl = kljJJ[3];
-     size_t twoJp = kljJJ[4];
-     size_t hash = Hash_comm232_key( kljJJ );
-
-     std::vector<size_t> iketlist;
-     std::vector<double> recouplelist;
-     size_t ch_check = Y.ThreeBody.GetKetIndex_withRecoupling( Jkl, twoJp, k, l, j, iketlist, recouplelist) ;
-     size_t listsize = iketlist.size();
-     recoupling_cache_lookup[hash] = recoupling_cache.size();
-     recoupling_cache.push_back(ch_check);
-     recoupling_cache.push_back(listsize);
-     for (size_t ik : iketlist) recoupling_cache.push_back(ik); // Store the size_t (an unsigned int) as a double. I hope this doesn't cause problems...
-     for (double rec : recouplelist) recoupling_cache.push_back( rec);// Point to where this element lives in the vector
-   }
-
-
-    // Now fill the matrices
-    for (size_t ind_abc=0; ind_abc<dim_abc; ind_abc++) // rows of X2MAT
+  for ( auto kljJJ : kljJJ_needed )
+  {
+    size_t k = kljJJ[0];
+    size_t l = kljJJ[1];
+    size_t j = kljJJ[2];
+    size_t Jkl = kljJJ[3];
+    size_t twoJp = kljJJ[4];
+    size_t hash = Hash_comm232_key( kljJJ );
+
+    std::vector<size_t> iketlist;
+    std::vector<double> recouplelist;
+    size_t ch_check = Y.ThreeBody.GetKetIndex_withRecoupling( Jkl, twoJp, k, l, j, iketlist, recouplelist) ;
+    size_t listsize = iketlist.size();
+    recoupling_cache_lookup[hash] = recoupling_cache.size();
+    recoupling_cache.push_back(ch_check);
+    recoupling_cache.push_back(listsize);
+    for (size_t ik : iketlist) recoupling_cache.push_back(ik); // Store the size_t (an unsigned int) as a double. I hope this doesn't cause problems...
+    for (double rec : recouplelist) recoupling_cache.push_back( rec);// Point to where this element lives in the vector
+  }
+
+
+  // Now fill the matrices
+  for (size_t ind_abc=0; ind_abc<dim_abc; ind_abc++) // rows of X2MAT
+  {
+
+    auto& abcJ = klj_list_i[ abc_list[ind_abc] ];
+    size_t a = abcJ[0];
+    size_t b = abcJ[1];
+    size_t c = abcJ[2];
+    int Jab  = abcJ[3];
+    Orbit& oa = Z.modelspace->GetOrbit(a);
+    Orbit& ob = Z.modelspace->GetOrbit(b);
+    Orbit& oc = Z.modelspace->GetOrbit(c);
+    int j2c = oc.j2;
+    double jc = 0.5 * j2c;
+    double occ_abc = abc_occ_list[ind_abc]; // TODO: we can probably incorporate that hat factor with the occupation factor
+
+    double de_a = std::abs( 2*oa.n + oa.l - e_fermi[oa.tz2]);
+    double de_b = std::abs( 2*ob.n + ob.l - e_fermi[ob.tz2]);
+    double de_c = std::abs( 2*oc.n + oc.l - e_fermi[oc.tz2]);
+    double occnat_a = oa.occ_nat;
+    double occnat_b = ob.occ_nat;
+    double occnat_c = oc.occ_nat;
+
+    // fill the 2 body part
+    for (size_t ind_i=0; ind_i<dim_i; ind_i++)// ind_i indexes the list of sp states in this one body channel. columns of X2MAT
     {
+      size_t i = obc_orbits[ind_i]; // i is the orbit index as per ModelSpace
 
-      auto& abcJ = klj_list_i[ abc_list[ind_abc] ];
-      size_t a = abcJ[0];
-      size_t b = abcJ[1];
-      size_t c = abcJ[2];
-      int Jab  = abcJ[3];
-      Orbit& oa = Z.modelspace->GetOrbit(a);
-      Orbit& ob = Z.modelspace->GetOrbit(b);
-      Orbit& oc = Z.modelspace->GetOrbit(c);
-      int j2c = oc.j2;
-      double jc = 0.5 * j2c;
-      double occ_abc = abc_occ_list[ind_abc]; // TODO: we can probably incorporate that hat factor with the occupation factor
-
-      double de_a = std::abs( 2*oa.n + oa.l - e_fermi[oa.tz2]);
-      double de_b = std::abs( 2*ob.n + ob.l - e_fermi[ob.tz2]);
-      double de_c = std::abs( 2*oc.n + oc.l - e_fermi[oc.tz2]);
-      double occnat_a = oa.occ_nat;
-      double occnat_b = ob.occ_nat;
-      double occnat_c = oc.occ_nat;
-
-      // fill the 2 body part
-      for (size_t ind_i=0; ind_i<dim_i; ind_i++)// ind_i indexes the list of sp states in this one body channel. columns of X2MAT
-      {
-        size_t i = obc_orbits[ind_i]; // i is the orbit index as per ModelSpace
+      X2MAT(ind_i,ind_abc) = -sqrt( (2*Jab+1.)) * occ_abc*  X.TwoBody.GetTBME_J(Jab,c,i,a,b);
+      Y2MAT(ind_i,ind_abc) = -sqrt( (2*Jab+1.)) * occ_abc*  Y.TwoBody.GetTBME_J(Jab,c,i,a,b);
+    }// for ind_i
 
-        X2MAT(ind_i,ind_abc) = -sqrt( (2*Jab+1.)) * occ_abc*  X.TwoBody.GetTBME_J(Jab,c,i,a,b);
-        Y2MAT(ind_i,ind_abc) = -sqrt( (2*Jab+1.)) * occ_abc*  Y.TwoBody.GetTBME_J(Jab,c,i,a,b);
-      }// for ind_i
 
+    // now the 3 body part
+    for (size_t ind_klj=0; ind_klj<dim_klj; ind_klj++)
+    {
+      // <abi Jab twoJ | X | klc Jkl twoJ >
+      auto& kljJ = klj_list_i[ ind_klj ];
+      size_t k = kljJ[0];
+      size_t l = kljJ[1];
+      size_t j = kljJ[2];
+      int Jkl = kljJ[3];
+      Orbit& oj = Z.modelspace->GetOrbit(j);
+      Orbit& ok = Z.modelspace->GetOrbit(k);
+      Orbit& ol = Z.modelspace->GetOrbit(l);
+      double ji = 0.5 * j2i;
+      double jj = 0.5 * oj.j2;
+      double jk = 0.5 * ok.j2;
+      double jl = 0.5 * ol.j2;
 
-      // now the 3 body part
-      for (size_t ind_klj=0; ind_klj<dim_klj; ind_klj++)
-      {
-        // <abi Jab twoJ | X | klc Jkl twoJ >
-        auto& kljJ = klj_list_i[ ind_klj ];
-        size_t k = kljJ[0];
-        size_t l = kljJ[1];
-        size_t j = kljJ[2];
-        int Jkl = kljJ[3];
-        Orbit& oj = Z.modelspace->GetOrbit(j);
-        Orbit& ok = Z.modelspace->GetOrbit(k);
-        Orbit& ol = Z.modelspace->GetOrbit(l);
-        double ji = 0.5 * j2i;
-        double jj = 0.5 * oj.j2;
-        double jk = 0.5 * ok.j2;
-        double jl = 0.5 * ol.j2;
+      double de_j = std::abs( 2*oj.n + oj.l - e_fermi[oj.tz2]);
+      double de_k = std::abs( 2*ok.n + ok.l - e_fermi[ok.tz2]);
+      double de_l = std::abs( 2*ol.n + ol.l - e_fermi[ol.tz2]);
+      double occnat_j = oj.occ_nat;
+      double occnat_k = ok.occ_nat;
+      double occnat_l = ol.occ_nat;
+      // Are these checks redundant?
+      if ( (de_a + de_b + de_j) > Z.modelspace->GetdE3max() ) continue;
+      if ( (de_k + de_l + de_c) > Z.modelspace->GetdE3max() ) continue;
+      if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_j*(1-occnat_j) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+      if ( (occnat_k*(1-occnat_k) * occnat_l*(1-occnat_l) * occnat_c*(1-occnat_c) ) < Z.modelspace->GetOccNat3Cut() ) continue;
 
-        double de_j = std::abs( 2*oj.n + oj.l - e_fermi[oj.tz2]);
-        double de_k = std::abs( 2*ok.n + ok.l - e_fermi[ok.tz2]);
-        double de_l = std::abs( 2*ol.n + ol.l - e_fermi[ol.tz2]);
-        double occnat_j = oj.occ_nat;
-        double occnat_k = ok.occ_nat;
-        double occnat_l = ol.occ_nat;
-        // Are these checks redundant?
-        if ( (de_a + de_b + de_j) > Z.modelspace->GetdE3max() ) continue;
-        if ( (de_k + de_l + de_c) > Z.modelspace->GetdE3max() ) continue;
-        if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_j*(1-occnat_j) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-        if ( (occnat_k*(1-occnat_k) * occnat_l*(1-occnat_l) * occnat_c*(1-occnat_c) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-        
-        int twoJp_min = std::max( std::abs(2*Jab - oj.j2), std::abs(2*Jkl-j2c));
-        int twoJp_max = std::min( 2*Jab + oj.j2, 2*Jkl+j2c);
+      int twoJp_min = std::max( std::abs(2*Jab - oj.j2), std::abs(2*Jkl-j2c));
+      int twoJp_max = std::min( 2*Jab + oj.j2, 2*Jkl+j2c);
 
 
-        for (int twoJp=twoJp_min; twoJp<=twoJp_max; twoJp+=2)
+      for (int twoJp=twoJp_min; twoJp<=twoJp_max; twoJp+=2)
+      {
+        double sixj = X.modelspace->GetSixJ(Jkl,jj,ji,  Jab, jc, 0.5*twoJp );
+
+        std::array<size_t,5> abjJJ = { a,b,j,(size_t)Jab,(size_t)twoJp} ;
+        std::array<size_t,5> klcJJ = { k,l,c,(size_t)Jkl,(size_t)twoJp} ;
+        size_t hash_abj = Hash_comm232_key( abjJJ );
+        size_t hash_klc = Hash_comm232_key( klcJJ );
+        size_t pointer_abj = recoupling_cache_lookup.at(hash_abj);
+        size_t pointer_klc = recoupling_cache_lookup.at(hash_klc);
+        size_t ch_check = recoupling_cache[pointer_abj];
+        size_t listsize_abj = recoupling_cache[pointer_abj+1];
+        size_t listsize_klc = recoupling_cache[pointer_klc+1];
+
+        double xabjklc = 0;
+        double yabjklc = 0;
+        for ( size_t ilist_abj=0; ilist_abj<listsize_abj; ilist_abj++)
         {
-           double sixj = X.modelspace->GetSixJ(Jkl,jj,ji,  Jab, jc, 0.5*twoJp );
-
-           std::array<size_t,5> abjJJ = { a,b,j,(size_t)Jab,(size_t)twoJp} ;
-           std::array<size_t,5> klcJJ = { k,l,c,(size_t)Jkl,(size_t)twoJp} ;
-           size_t hash_abj = Hash_comm232_key( abjJJ );
-           size_t hash_klc = Hash_comm232_key( klcJJ );
-           size_t pointer_abj = recoupling_cache_lookup.at(hash_abj);
-           size_t pointer_klc = recoupling_cache_lookup.at(hash_klc);
-           size_t ch_check = recoupling_cache[pointer_abj];
-           size_t listsize_abj = recoupling_cache[pointer_abj+1];
-           size_t listsize_klc = recoupling_cache[pointer_klc+1];
-           
-           double xabjklc = 0;
-           double yabjklc = 0;
-           for ( size_t ilist_abj=0; ilist_abj<listsize_abj; ilist_abj++)
-           {
-             size_t ibra_abj = (size_t) recoupling_cache[pointer_abj+2+ilist_abj];
-             double recouple_bra =      recoupling_cache[pointer_abj+2+listsize_abj+ilist_abj];
-             for ( size_t ilist_klc=0; ilist_klc<listsize_klc; ilist_klc++)
-             {
-               size_t iket_klc = (size_t) recoupling_cache[pointer_klc+2+ilist_klc];
-               double recouple_ket =      recoupling_cache[pointer_klc+2+listsize_klc+ilist_klc];
-
-               xabjklc += recouple_bra*recouple_ket * X3.GetME_pn_PN_ch(ch_check,ch_check, ibra_abj, iket_klc );
-               yabjklc += recouple_bra*recouple_ket * Y3.GetME_pn_PN_ch(ch_check,ch_check, ibra_abj, iket_klc );
-             }
-           }
-
-           X3MAT(ind_abc, ind_klj) += (twoJp+1.)/sqrt(2*Jkl+1.) * sixj * xabjklc;
-           Y3MAT(ind_abc, ind_klj) += (twoJp+1.)/sqrt(2*Jkl+1.) * sixj * yabjklc;
+          size_t ibra_abj = (size_t) recoupling_cache[pointer_abj+2+ilist_abj];
+          double recouple_bra =      recoupling_cache[pointer_abj+2+listsize_abj+ilist_abj];
+          for ( size_t ilist_klc=0; ilist_klc<listsize_klc; ilist_klc++)
+          {
+            size_t iket_klc = (size_t) recoupling_cache[pointer_klc+2+ilist_klc];
+            double recouple_ket =      recoupling_cache[pointer_klc+2+listsize_klc+ilist_klc];
 
-        }// for twoJp
-      }// for ind_klj
-    }// for ind_abc
+            xabjklc += recouple_bra*recouple_ket * X3.GetME_pn_PN_ch(ch_check,ch_check, ibra_abj, iket_klc );
+            yabjklc += recouple_bra*recouple_ket * Y3.GetME_pn_PN_ch(ch_check,ch_check, ibra_abj, iket_klc );
+          }
+        }
+
+        X3MAT(ind_abc, ind_klj) += (twoJp+1.)/sqrt(2*Jkl+1.) * sixj * xabjklc;
+        Y3MAT(ind_abc, ind_klj) += (twoJp+1.)/sqrt(2*Jkl+1.) * sixj * yabjklc;
 
-    // now we do the mat mult
-    ZMAT_list[obc_key] =  (  X2MAT * Y3MAT - Y2MAT * X3MAT  ) ;
+      }// for twoJp
+    }// for ind_klj
+  }// for ind_abc
+
+  // now we do the mat mult
+  ZMAT_list[obc_key] =  (  X2MAT * Y3MAT - Y2MAT * X3MAT  ) ;
 
   }// for iter_i in local one body channels
 
   // now we need to unpack all that mess and store it in Z
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
   for ( size_t ch=0; ch<nch; ch++)
   {
     TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
@@ -2793,8 +3015,8 @@ void comm232ss( const Operator& X, const Operator& Y, Operator& Z )
         if ( ind_klj == list_i.size()   or ind_kli==list_j.size() or ind_ijl==list_k.size() or ind_ijk==list_l.size() )   continue;
 
 
-        double zijkl =            ZMat_j(ind_j, ind_kli) - phase_ij * ZMat_i(ind_i, ind_klj) 
-                - hermX*hermY * ( ZMat_l(ind_l, ind_ijk) - phase_kl * ZMat_k(ind_k, ind_ijl) ) ;
+        double zijkl =            ZMat_j(ind_j, ind_kli) - phase_ij * ZMat_i(ind_i, ind_klj)
+          - hermX*hermY * ( ZMat_l(ind_l, ind_ijk) - phase_kl * ZMat_k(ind_k, ind_ijl) ) ;
 
         // normalize the tbme
         zijkl *= -1.0 / sqrt((1+bra.delta_pq())*(1+ket.delta_pq()));
@@ -2804,144 +3026,144 @@ void comm232ss( const Operator& X, const Operator& Y, Operator& Z )
   }// for ch
 
   Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
-}
-
+  }
 
 
 
 
 
 
-void comm232ss_debug( const Operator& X, const Operator& Y, Operator& Z )
-{
-  double tstart = omp_get_wtime();
-  auto& X2 = X.TwoBody;
-  auto& X3 = X.ThreeBody;
-  auto& Y2 = Y.TwoBody;
-  auto& Y3 = Y.ThreeBody;
-  auto& Z2 = Z.TwoBody;
 
-  bool x_has_3 = X3.is_allocated;
-  bool y_has_3 = Y3.is_allocated;
+  void comm232ss_debug( const Operator& X, const Operator& Y, Operator& Z )
+  {
+    double tstart = omp_get_wtime();
+    auto& X2 = X.TwoBody;
+    auto& X3 = X.ThreeBody;
+    auto& Y2 = Y.TwoBody;
+    auto& Y3 = Y.ThreeBody;
+    auto& Z2 = Z.TwoBody;
 
-  int hermX = X.IsHermitian() ? 1 : -1;
-  int hermY = Y.IsHermitian() ? 1 : -1;
+    bool x_has_3 = X3.is_allocated;
+    bool y_has_3 = Y3.is_allocated;
 
-  std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
+    int hermX = X.IsHermitian() ? 1 : -1;
+    int hermY = Y.IsHermitian() ? 1 : -1;
 
-  int nch = Z.modelspace->GetNumberTwoBodyChannels();
+    std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
 
-//  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
-  for (int ch=0; ch<nch; ch++)
-  {
-    auto& tbc = Z.modelspace->GetTwoBodyChannel(ch);
-    int J = tbc.J;
-    int nkets = tbc.GetNumberKets();
+    int nch = Z.modelspace->GetNumberTwoBodyChannels();
 
-//    double tstart = omp_get_wtime();
-    // The strategy used here is the following. We reorganize <ic|X|ab> as <i|X|abc'>  and  <abj|Y|klc> as <abc'|Y|klj'>
-    // where the prime indicates time reversal. Then we can cast things as a matrix multiplication
-    //  <i|Z|klj'> = <i|X|abc'><abc'|Y|klj'>   and then we need to transform Z back to <ij|Z|kl>
-    //
-    //   i|   c|      i|                a| b| j|       a| b|   /c'
-    //    |____|  ==>  |____             |__|__|  ==>   |__|__/
-    //    |    |       |    |\           |  |  |        |  |  \
-    //   a|   b|      a|   b| \c'       k| l| c|       k| l|   \j'
-    //
-    // The matrices for X and Z will clearly not be square. The left side is just a single particle orbit, while the right has 3 orbits.
-    // Here, I determine which single orbits will be needed in this two-body channel.
-    std::set<size_t> ij_orbits_set;
-    std::set<int> j_jvals_set;
-    for ( int ibra=0; ibra<nkets; ibra++)
-    {
-      Ket& bra = tbc.GetKet(ibra);
-      ij_orbits_set.insert( bra.p );
-      ij_orbits_set.insert( bra.q );
-      j_jvals_set.insert( bra.op->j2);
-      j_jvals_set.insert( bra.oq->j2);
-    }
-    std::vector<size_t> ij_orbits;
-    std::vector<int> j_jvals;
-    std::map<size_t,size_t> ij_orbits_lookup;
-    std::map<int,size_t> jvals_lookup;
-    for ( auto i : ij_orbits_set )
-    {
-      ij_orbits.push_back(i); // list of all the indices an orbit (either i or j ) in bra could have
-      ij_orbits_lookup[i] = ij_orbits.size()-1;
-    }
-    for ( auto j : j_jvals_set )
+    //  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+    for (int ch=0; ch<nch; ch++)
     {
-       j_jvals.push_back(j);  // list of possible j values (angular momentum) an orbit in bra could have
-       jvals_lookup[j] = j_jvals.size()-1;
-    }
-    size_t nij = ij_orbits.size();
-    size_t njvals = j_jvals.size();
-//    std::cout << "   ch = " << ch << "   njvals = " << njvals << std::endl;
+      auto& tbc = Z.modelspace->GetTwoBodyChannel(ch);
+      int J = tbc.J;
+      int nkets = tbc.GetNumberKets();
+
+      //    double tstart = omp_get_wtime();
+      // The strategy used here is the following. We reorganize <ic|X|ab> as <i|X|abc'>  and  <abj|Y|klc> as <abc'|Y|klj'>
+      // where the prime indicates time reversal. Then we can cast things as a matrix multiplication
+      //  <i|Z|klj'> = <i|X|abc'><abc'|Y|klj'>   and then we need to transform Z back to <ij|Z|kl>
+      //
+      //   i|   c|      i|                a| b| j|       a| b|   /c'
+      //    |____|  ==>  |____             |__|__|  ==>   |__|__/
+      //    |    |       |    |\           |  |  |        |  |  \
+      //   a|   b|      a|   b| \c'       k| l| c|       k| l|   \j'
+      //
+      // The matrices for X and Z will clearly not be square. The left side is just a single particle orbit, while the right has 3 orbits.
+      // Here, I determine which single orbits will be needed in this two-body channel.
+      std::set<size_t> ij_orbits_set;
+      std::set<int> j_jvals_set;
+      for ( int ibra=0; ibra<nkets; ibra++)
+      {
+        Ket& bra = tbc.GetKet(ibra);
+        ij_orbits_set.insert( bra.p );
+        ij_orbits_set.insert( bra.q );
+        j_jvals_set.insert( bra.op->j2);
+        j_jvals_set.insert( bra.oq->j2);
+      }
+      std::vector<size_t> ij_orbits;
+      std::vector<int> j_jvals;
+      std::map<size_t,size_t> ij_orbits_lookup;
+      std::map<int,size_t> jvals_lookup;
+      for ( auto i : ij_orbits_set )
+      {
+        ij_orbits.push_back(i); // list of all the indices an orbit (either i or j ) in bra could have
+        ij_orbits_lookup[i] = ij_orbits.size()-1;
+      }
+      for ( auto j : j_jvals_set )
+      {
+        j_jvals.push_back(j);  // list of possible j values (angular momentum) an orbit in bra could have
+        jvals_lookup[j] = j_jvals.size()-1;
+      }
+      size_t nij = ij_orbits.size();
+      size_t njvals = j_jvals.size();
+      //    std::cout << "   ch = " << ch << "   njvals = " << njvals << std::endl;
 
-    Z.profiler.timer["comm232_block1"] += omp_get_wtime() - tstart;
-    tstart = omp_get_wtime();
+      Z.profiler.timer["comm232_block1"] += omp_get_wtime() - tstart;
+      tstart = omp_get_wtime();
 
-    // next, we make a list of the abc' combinations that will inter into the sum
-    std::vector<size_t> ch_ab_list;
-    std::vector<size_t> iket_ab_list;
-    std::vector<size_t> a_list;
-    std::vector<size_t> b_list;
-    std::vector<size_t> c_list;
-    std::vector<double> occ_abc_list;
+      // next, we make a list of the abc' combinations that will inter into the sum
+      std::vector<size_t> ch_ab_list;
+      std::vector<size_t> iket_ab_list;
+      std::vector<size_t> a_list;
+      std::vector<size_t> b_list;
+      std::vector<size_t> c_list;
+      std::vector<double> occ_abc_list;
 
-    for (int ch_ab=0; ch_ab<nch; ch_ab++)
-    {
-      auto& tbc_ab = X.modelspace->GetTwoBodyChannel(ch_ab);
-      int Jab = tbc_ab.J;
-      size_t nkets_ab = tbc_ab.GetNumberKets();
-      for ( size_t iket_ab=0; iket_ab<nkets_ab; iket_ab++ )
+      for (int ch_ab=0; ch_ab<nch; ch_ab++)
       {
-        Ket& ket_ab = tbc_ab.GetKet(iket_ab);
-        int a=ket_ab.p;
-        int b=ket_ab.q;
-        Orbit& oa = Z.modelspace->GetOrbit(a);
-        Orbit& ob = Z.modelspace->GetOrbit(b);
-        int ea = 2*oa.n + oa.l;
-        int eb = 2*ob.n + ob.l;
-
-        for (auto c : Z.modelspace->all_orbits )
+        auto& tbc_ab = X.modelspace->GetTwoBodyChannel(ch_ab);
+        int Jab = tbc_ab.J;
+        size_t nkets_ab = tbc_ab.GetNumberKets();
+        for ( size_t iket_ab=0; iket_ab<nkets_ab; iket_ab++ )
         {
-          Orbit& oc = Z.modelspace->GetOrbit(c);
-          double jc = 0.5*oc.j2;
-          int ec = 2*oc.n + oc.l;
-//          if ( (std::abs( ea-e_fermi[oa.tz2]) + std::abs(eb-e_fermi[ob.tz2]) + std::abs(ec-e_fermi[oc.tz2])) > Z.modelspace->GetdE3max() ) continue;
-          double occfactor = oa.occ * ob.occ * (1-oc.occ) + (1-oa.occ) * (1-ob.occ) * oc.occ;
-          if ( std::abs(occfactor) < 1e-6 ) continue;
-          if ( std::abs( oa.tz2 + ob.tz2 - oc.tz2)>2) continue;
-          if (a==b) occfactor *=0.5;  // we sum a<=b, and drop the 1/2, but we still need the 1/2 for a==b
-//          if (  (std::abs( 2*Jab -oc.j2)>oj.j2)  or  ((2*Jab+oc.j2)<oj.j2) ) continue;
-//          if (  (std::abs( 2*Jab -oc.j2)>std::max(oi.j2,oj.j2))  or  ((2*Jab+oc.j2)<std::min(oi.j2,oj.j2)) ) continue;
-//          if ( tbc_ab.parity + oj.l + oc.l
-          ch_ab_list.push_back(ch_ab);
-          iket_ab_list.push_back(iket_ab);
-          a_list.push_back(a);
-          b_list.push_back(b);
-          c_list.push_back(c);
-          occ_abc_list.push_back(occfactor);
-        }// for c
-      }// for iket_ab
-    } // for ch_ab
+          Ket& ket_ab = tbc_ab.GetKet(iket_ab);
+          int a=ket_ab.p;
+          int b=ket_ab.q;
+          Orbit& oa = Z.modelspace->GetOrbit(a);
+          Orbit& ob = Z.modelspace->GetOrbit(b);
+          int ea = 2*oa.n + oa.l;
+          int eb = 2*ob.n + ob.l;
+
+          for (auto c : Z.modelspace->all_orbits )
+          {
+            Orbit& oc = Z.modelspace->GetOrbit(c);
+            double jc = 0.5*oc.j2;
+            int ec = 2*oc.n + oc.l;
+            //          if ( (std::abs( ea-e_fermi[oa.tz2]) + std::abs(eb-e_fermi[ob.tz2]) + std::abs(ec-e_fermi[oc.tz2])) > Z.modelspace->GetdE3max() ) continue;
+            double occfactor = oa.occ * ob.occ * (1-oc.occ) + (1-oa.occ) * (1-ob.occ) * oc.occ;
+            if ( std::abs(occfactor) < 1e-6 ) continue;
+            if ( std::abs( oa.tz2 + ob.tz2 - oc.tz2)>2) continue;
+            if (a==b) occfactor *=0.5;  // we sum a<=b, and drop the 1/2, but we still need the 1/2 for a==b
+            //          if (  (std::abs( 2*Jab -oc.j2)>oj.j2)  or  ((2*Jab+oc.j2)<oj.j2) ) continue;
+            //          if (  (std::abs( 2*Jab -oc.j2)>std::max(oi.j2,oj.j2))  or  ((2*Jab+oc.j2)<std::min(oi.j2,oj.j2)) ) continue;
+            //          if ( tbc_ab.parity + oj.l + oc.l
+            ch_ab_list.push_back(ch_ab);
+            iket_ab_list.push_back(iket_ab);
+            a_list.push_back(a);
+            b_list.push_back(b);
+            c_list.push_back(c);
+            occ_abc_list.push_back(occfactor);
+          }// for c
+        }// for iket_ab
+      } // for ch_ab
 
-    Z.profiler.timer["comm232_block2"] += omp_get_wtime() - tstart;
-    tstart = omp_get_wtime();
+      Z.profiler.timer["comm232_block2"] += omp_get_wtime() - tstart;
+      tstart = omp_get_wtime();
 
-    // allocate the matrices
-    size_t n_abc = ch_ab_list.size();
+      // allocate the matrices
+      size_t n_abc = ch_ab_list.size();
 
-    arma::mat X2MAT( nij,   n_abc,             arma::fill::zeros);
-    arma::mat Y3MAT( n_abc, nij*njvals*nkets,  arma::fill::zeros);
-    arma::mat Y2MAT( nij,   n_abc,             arma::fill::zeros);
-    arma::mat X3MAT( n_abc, nij*njvals*nkets,  arma::fill::zeros);
+      arma::mat X2MAT( nij,   n_abc,             arma::fill::zeros);
+      arma::mat Y3MAT( n_abc, nij*njvals*nkets,  arma::fill::zeros);
+      arma::mat Y2MAT( nij,   n_abc,             arma::fill::zeros);
+      arma::mat X3MAT( n_abc, nij*njvals*nkets,  arma::fill::zeros);
 
 
 
-    // Now fill the X2 mat and Y3 mat
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+      // Now fill the X2 mat and Y3 mat
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
 
       for (size_t ind_abc=0; ind_abc<n_abc; ind_abc++)
       {
@@ -2952,7 +3174,7 @@ void comm232ss_debug( const Operator& X, const Operator& Y, Operator& Z )
         Orbit& oa = X.modelspace->GetOrbit(a);
         Orbit& ob = X.modelspace->GetOrbit(b);
         Orbit& oc = X.modelspace->GetOrbit(c);
-        
+
         double jc = 0.5 * oc.j2;
         double d_ea = std::abs( 2*oa.n +oa.l - e_fermi[oa.tz2]);
         double d_eb = std::abs( 2*ob.n +ob.l - e_fermi[ob.tz2]);
@@ -2960,533 +3182,533 @@ void comm232ss_debug( const Operator& X, const Operator& Y, Operator& Z )
         double occnat_a = oa.occ_nat;
         double occnat_b = ob.occ_nat;
         double occnat_c = oc.occ_nat;
-    for ( size_t ind_i=0; ind_i<nij; ind_i++ )
-    {
-      size_t i = ij_orbits[ind_i];
-//      if (ch==0) std::cout << "  ind_i = " << ind_i << "   i = " << i << std::endl;
-      Orbit& oi = X.modelspace->GetOrbit(i);
-      double ji = 0.5*oi.j2;
-      double d_ei = std::abs( 2*oi.n +oi.l - e_fermi[oi.tz2]);
-      double occnat_i = oi.occ_nat;
+        for ( size_t ind_i=0; ind_i<nij; ind_i++ )
+        {
+          size_t i = ij_orbits[ind_i];
+          //      if (ch==0) std::cout << "  ind_i = " << ind_i << "   i = " << i << std::endl;
+          Orbit& oi = X.modelspace->GetOrbit(i);
+          double ji = 0.5*oi.j2;
+          double d_ei = std::abs( 2*oi.n +oi.l - e_fermi[oi.tz2]);
+          double occnat_i = oi.occ_nat;
 
 
-        if ( (d_ea+d_eb+d_ei) > Z.modelspace->GetdE3max() ) continue;
+          if ( (d_ea+d_eb+d_ei) > Z.modelspace->GetdE3max() ) continue;
 
-        X2MAT(ind_i,ind_abc) = -sqrt( (2*Jab+1.)) * occ_abc_list[ind_abc] *  X.TwoBody.GetTBME_J(Jab,c,i,a,b);
-        Y2MAT(ind_i,ind_abc) = -sqrt( (2*Jab+1.)) * occ_abc_list[ind_abc] *  Y.TwoBody.GetTBME_J(Jab,c,i,a,b);
-        
+          X2MAT(ind_i,ind_abc) = -sqrt( (2*Jab+1.)) * occ_abc_list[ind_abc] *  X.TwoBody.GetTBME_J(Jab,c,i,a,b);
+          Y2MAT(ind_i,ind_abc) = -sqrt( (2*Jab+1.)) * occ_abc_list[ind_abc] *  Y.TwoBody.GetTBME_J(Jab,c,i,a,b);
 
-        if ( (oa.l+ob.l+oi.l+tbc.parity+oc.l)%2 != Y.parity) continue; //TODO: this will cause problems if we try something with Y.parity =1
-        if ( std::abs((oa.tz2+ob.tz2+oi.tz2)-(tbc.Tz*2+oc.tz2)) > 2*Y.rank_T) continue;
 
-        int twoJp_min = std::max( std::abs(2*Jab - oi.j2), std::abs(2*J-oc.j2));
-        int twoJp_max = std::min( 2*Jab + oi.j2, 2*J+oc.j2);
+          if ( (oa.l+ob.l+oi.l+tbc.parity+oc.l)%2 != Y.parity) continue; //TODO: this will cause problems if we try something with Y.parity =1
+          if ( std::abs((oa.tz2+ob.tz2+oi.tz2)-(tbc.Tz*2+oc.tz2)) > 2*Y.rank_T) continue;
 
-        // Why is this part structured like this?
-        // In tests, the time for this entire commutator routine was dominated by the time to access 3-body matrix elements.
-        // That's because I'm asking for them in an order different from the one in which they're stored, which means recoupling.
-        // Fortunately, both the X and Y block need exactly the same recoupling, and we can pull the recoupling for the bra
-        // side a few loops out.
-        for (int twoJp=twoJp_min; twoJp<=twoJp_max; twoJp+=2)
-        {
-           std::vector<size_t> ibra_list;
-           std::vector<double> recouple_bra_list;
-           size_t ch_check = Y.ThreeBody.GetKetIndex_withRecoupling( Jab, twoJp, a, b, i, ibra_list, recouple_bra_list) ;
+          int twoJp_min = std::max( std::abs(2*Jab - oi.j2), std::abs(2*J-oc.j2));
+          int twoJp_max = std::min( 2*Jab + oi.j2, 2*J+oc.j2);
+
+          // Why is this part structured like this?
+          // In tests, the time for this entire commutator routine was dominated by the time to access 3-body matrix elements.
+          // That's because I'm asking for them in an order different from the one in which they're stored, which means recoupling.
+          // Fortunately, both the X and Y block need exactly the same recoupling, and we can pull the recoupling for the bra
+          // side a few loops out.
+          for (int twoJp=twoJp_min; twoJp<=twoJp_max; twoJp+=2)
+          {
+            std::vector<size_t> ibra_list;
+            std::vector<double> recouple_bra_list;
+            size_t ch_check = Y.ThreeBody.GetKetIndex_withRecoupling( Jab, twoJp, a, b, i, ibra_list, recouple_bra_list) ;
 
             for ( size_t ind_jj=0; ind_jj<njvals; ind_jj++ )
             {
-             int jj2 = j_jvals[ind_jj];
-             double jj = 0.5*jj2;
-             double sixj = X.modelspace->GetSixJ(J,ji,jj,  Jab, jc, 0.5*twoJp );
-             if (std::abs(sixj)<1e-7) continue;
-          // now loop over |kl> states
-             for (int iket=0; iket<nkets; iket++)
-             {
-               size_t index_kli = (ind_jj+ind_i*njvals)*nkets + iket;
-               Ket& ket = tbc.GetKet(iket);
-               int k = ket.p;
-               int l = ket.q;
-//               if (i==0 and k==2 and l==2) std::cout << "i==0,l==2,k==2 => index kli = " <<index_kli << std::endl;
-               double d_ek = std::abs( 2*ket.op->n +ket.op->l - e_fermi[ket.op->tz2]);
-               double d_el = std::abs( 2*ket.oq->n +ket.oq->l - e_fermi[ket.oq->tz2]);
-               double occnat_k = ket.op->occ_nat;
-               double occnat_l = ket.oq->occ_nat;
-               if ( (d_ek+d_el+d_ec) > Z.modelspace->GetdE3max() ) continue;
-               if ( (occnat_k*(1-occnat_k) * occnat_l*(1-occnat_l) * occnat_c*(1-occnat_c) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-               std::vector<size_t> iket_list;
-               std::vector<double> recouple_ket_list;
-               ch_check = Y.ThreeBody.GetKetIndex_withRecoupling( J, twoJp, k, l, c, iket_list, recouple_ket_list) ;
-      
-               double xabiklc = 0;
-               double yabiklc = 0;
-               for (size_t I=0; I<ibra_list.size(); I++)
-               {
-                 for (size_t J=0; J<iket_list.size(); J++)
-                 {
-                   // I explicitly check if x and y have 3-body components because the call GetME_pn_PN_ch goes straight to the data array
-                   // without a safety net. If the 3-body structure isn't allocated, then bad things will happen.
-                   if (x_has_3) xabiklc += recouple_bra_list[I]*recouple_ket_list[J] * X3.GetME_pn_PN_ch(ch_check,ch_check, ibra_list[I], iket_list[J] );
-                   if (y_has_3) yabiklc += recouple_bra_list[I]*recouple_ket_list[J] * Y3.GetME_pn_PN_ch(ch_check,ch_check, ibra_list[I], iket_list[J] );
-                 }
-               }
-
-//               X3MAT(ind_abc, index_kli) -= (twoJp+1) * sixj * xabiklc;
-//               Y3MAT(ind_abc, index_kli) -= (twoJp+1) * sixj * yabiklc;
-               X3MAT(ind_abc, index_kli) += (twoJp+1)/sqrt(2*J+1) * sixj * xabiklc;
-               Y3MAT(ind_abc, index_kli) += (twoJp+1)/sqrt(2*J+1) * sixj * yabiklc;
-//               if (ch==8 and ind_abc ==9 and index_kli==20)
-//               {
-//          std::cout << "ind_abc = " << ind_abc << "   ind_kli = " << index_kli << "    abiklc = " << a << " " << b << " " << i << " " << k << " " << l << " " << c << "   Jkl Jab twoJp = " << J << " " << Jab << " " << twoJp << " read y " << Y3.GetME_pn(Jab,J,twoJp,a,b,i,k,l,c) << "   yabiklc = " << yabiklc << " , " << Y3MAT(ind_abc, index_kli)  << std::endl;
-//               }
-
-             }// for iket
-           }
-        }// for ind_jj
-      }// for ind_abc
-          
-    } // for ind_i
-
-    Z.profiler.timer["comm232_block3"] += omp_get_wtime() - tstart;
-    tstart = omp_get_wtime();
- /// now we're back out to the ch loop level.
-
-    // finally do the matrix multiplication
-//    arma::mat ZMat =  -sqrt(1./(2*J+1)) * (  X2MAT * Y3MAT - Y2MAT * X3MAT  ) ;
-//    std::cout << "Y3MAT size : " << Y3MAT.n_cols << " x " << Y3MAT.n_rows << std::endl;
-    arma::mat ZMat =  (  X2MAT * Y3MAT - Y2MAT * X3MAT  ) ;
-
-//    if (ch==8)
-//    {
-//      std::cout << "ch = " << ch << "   and X2MAT = " << std::endl << X2MAT.row(5) << std::endl;
-//      std::cout << "ch = " << ch << "   and Y3MAT = " << std::endl << Y3MAT.col(20) << std::endl;
-//      std::cout << "   product = " << X2MAT.row(5) * Y3MAT.col(20) << std::endl;
-//     double xysum =0;
-//     for (size_t ii=0; ii<X2MAT.n_cols; ii++)
-//     {
-//       double z = X2MAT(5,ii) * Y3MAT(ii,20);
-//       xysum += z;
-//       std::cout << X2MAT(5,ii) << " " << Y3MAT(ii,20) << "  " << z << "  " << xysum << std::endl;
-//     }
-//      std::cout << "ch = " << ch << "   and Y2MAT = " << std::endl << Y2MAT.row(5) << std::endl;
-//      std::cout << "ch = " << ch << "   and X3MAT = " << std::endl << X3MAT.col(20) << std::endl;
-//      std::cout << "   product = " << Y2MAT.row(5) * X3MAT.col(20) << std::endl;
-//    }
-
-    Z.profiler.timer["comm232_block4"] += omp_get_wtime() - tstart;
-    tstart = omp_get_wtime();
-
-    // now convert back from <i|Z|klj'> to <ij|Z|kl>
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
-    for (int ibra=0; ibra<nkets; ibra++)
-    {
-      Ket& bra = tbc.GetKet(ibra);
-      int i=bra.p;
-      int j=bra.q;
-      Orbit& oi = Z.modelspace->GetOrbit(i);
-      Orbit& oj = Z.modelspace->GetOrbit(j);
-      double ji = 0.5*oi.j2;
-      double jj = 0.5*oj.j2;
-      size_t ind_i = ij_orbits_lookup[i];
-      size_t ind_j = ij_orbits_lookup[j];
-      size_t ind_ji = jvals_lookup[oi.j2];
-      size_t ind_jj = jvals_lookup[oj.j2];
+              int jj2 = j_jvals[ind_jj];
+              double jj = 0.5*jj2;
+              double sixj = X.modelspace->GetSixJ(J,ji,jj,  Jab, jc, 0.5*twoJp );
+              if (std::abs(sixj)<1e-7) continue;
+              // now loop over |kl> states
+              for (int iket=0; iket<nkets; iket++)
+              {
+                size_t index_kli = (ind_jj+ind_i*njvals)*nkets + iket;
+                Ket& ket = tbc.GetKet(iket);
+                int k = ket.p;
+                int l = ket.q;
+                //               if (i==0 and k==2 and l==2) std::cout << "i==0,l==2,k==2 => index kli = " <<index_kli << std::endl;
+                double d_ek = std::abs( 2*ket.op->n +ket.op->l - e_fermi[ket.op->tz2]);
+                double d_el = std::abs( 2*ket.oq->n +ket.oq->l - e_fermi[ket.oq->tz2]);
+                double occnat_k = ket.op->occ_nat;
+                double occnat_l = ket.oq->occ_nat;
+                if ( (d_ek+d_el+d_ec) > Z.modelspace->GetdE3max() ) continue;
+                if ( (occnat_k*(1-occnat_k) * occnat_l*(1-occnat_l) * occnat_c*(1-occnat_c) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+                std::vector<size_t> iket_list;
+                std::vector<double> recouple_ket_list;
+                ch_check = Y.ThreeBody.GetKetIndex_withRecoupling( J, twoJp, k, l, c, iket_list, recouple_ket_list) ;
 
-      for (int iket=ibra; iket<nkets; iket++)
-      {
-        Ket& ket = tbc.GetKet(iket);
-        int k = ket.p;
-        int l = ket.q;
-        Orbit& ok = Z.modelspace->GetOrbit(k);
-        Orbit& ol = Z.modelspace->GetOrbit(l);
-        double jk = 0.5*ok.j2;
-        double jl = 0.5*ol.j2;
-        size_t ind_k = ij_orbits_lookup[k];
-        size_t ind_l = ij_orbits_lookup[l];
-        size_t ind_jk = jvals_lookup[ok.j2];
-        size_t ind_jl = jvals_lookup[ol.j2];
+                double xabiklc = 0;
+                double yabiklc = 0;
+                for (size_t I=0; I<ibra_list.size(); I++)
+                {
+                  for (size_t J=0; J<iket_list.size(); J++)
+                  {
+                    // I explicitly check if x and y have 3-body components because the call GetME_pn_PN_ch goes straight to the data array
+                    // without a safety net. If the 3-body structure isn't allocated, then bad things will happen.
+                    if (x_has_3) xabiklc += recouple_bra_list[I]*recouple_ket_list[J] * X3.GetME_pn_PN_ch(ch_check,ch_check, ibra_list[I], iket_list[J] );
+                    if (y_has_3) yabiklc += recouple_bra_list[I]*recouple_ket_list[J] * Y3.GetME_pn_PN_ch(ch_check,ch_check, ibra_list[I], iket_list[J] );
+                  }
+                }
 
-        int phase_ij = X.modelspace->phase( (oi.j2+oj.j2)/2-J);
-        int phase_kl = X.modelspace->phase( (ok.j2+ol.j2)/2-J);
-        double zijkl = ZMat(ind_j,  (ind_jj+ind_i*njvals)*nkets + iket) ;
-        zijkl -= phase_ij * ZMat(ind_i,  (ind_ji+ind_j*njvals)*nkets + iket) ;
+                //               X3MAT(ind_abc, index_kli) -= (twoJp+1) * sixj * xabiklc;
+                //               Y3MAT(ind_abc, index_kli) -= (twoJp+1) * sixj * yabiklc;
+                X3MAT(ind_abc, index_kli) += (twoJp+1)/sqrt(2*J+1) * sixj * xabiklc;
+                Y3MAT(ind_abc, index_kli) += (twoJp+1)/sqrt(2*J+1) * sixj * yabiklc;
+                //               if (ch==8 and ind_abc ==9 and index_kli==20)
+                //               {
+                //          std::cout << "ind_abc = " << ind_abc << "   ind_kli = " << index_kli << "    abiklc = " << a << " " << b << " " << i << " " << k << " " << l << " " << c << "   Jkl Jab twoJp = " << J << " " << Jab << " " << twoJp << " read y " << Y3.GetME_pn(Jab,J,twoJp,a,b,i,k,l,c) << "   yabiklc = " << yabiklc << " , " << Y3MAT(ind_abc, index_kli)  << std::endl;
+                //               }
 
-        zijkl -= hermX*hermY* ZMat(ind_l, (ind_jl+ind_k*njvals)*nkets + ibra);
-        zijkl += hermX*hermY*phase_kl * ZMat(ind_k, (ind_jk+ind_l*njvals)*nkets + ibra);
+              }// for iket
+            }
+          }// for ind_jj
+        }// for ind_abc
+
+      } // for ind_i
+
+      Z.profiler.timer["comm232_block3"] += omp_get_wtime() - tstart;
+      tstart = omp_get_wtime();
+      /// now we're back out to the ch loop level.
+
+      // finally do the matrix multiplication
+      //    arma::mat ZMat =  -sqrt(1./(2*J+1)) * (  X2MAT * Y3MAT - Y2MAT * X3MAT  ) ;
+      //    std::cout << "Y3MAT size : " << Y3MAT.n_cols << " x " << Y3MAT.n_rows << std::endl;
+      arma::mat ZMat =  (  X2MAT * Y3MAT - Y2MAT * X3MAT  ) ;
+
+      //    if (ch==8)
+      //    {
+      //      std::cout << "ch = " << ch << "   and X2MAT = " << std::endl << X2MAT.row(5) << std::endl;
+      //      std::cout << "ch = " << ch << "   and Y3MAT = " << std::endl << Y3MAT.col(20) << std::endl;
+      //      std::cout << "   product = " << X2MAT.row(5) * Y3MAT.col(20) << std::endl;
+      //     double xysum =0;
+      //     for (size_t ii=0; ii<X2MAT.n_cols; ii++)
+      //     {
+      //       double z = X2MAT(5,ii) * Y3MAT(ii,20);
+      //       xysum += z;
+      //       std::cout << X2MAT(5,ii) << " " << Y3MAT(ii,20) << "  " << z << "  " << xysum << std::endl;
+      //     }
+      //      std::cout << "ch = " << ch << "   and Y2MAT = " << std::endl << Y2MAT.row(5) << std::endl;
+      //      std::cout << "ch = " << ch << "   and X3MAT = " << std::endl << X3MAT.col(20) << std::endl;
+      //      std::cout << "   product = " << Y2MAT.row(5) * X3MAT.col(20) << std::endl;
+      //    }
+
+      Z.profiler.timer["comm232_block4"] += omp_get_wtime() - tstart;
+      tstart = omp_get_wtime();
+
+      // now convert back from <i|Z|klj'> to <ij|Z|kl>
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+      for (int ibra=0; ibra<nkets; ibra++)
+      {
+        Ket& bra = tbc.GetKet(ibra);
+        int i=bra.p;
+        int j=bra.q;
+        Orbit& oi = Z.modelspace->GetOrbit(i);
+        Orbit& oj = Z.modelspace->GetOrbit(j);
+        double ji = 0.5*oi.j2;
+        double jj = 0.5*oj.j2;
+        size_t ind_i = ij_orbits_lookup[i];
+        size_t ind_j = ij_orbits_lookup[j];
+        size_t ind_ji = jvals_lookup[oi.j2];
+        size_t ind_jj = jvals_lookup[oj.j2];
 
-////       if (ch==0 and ibra<5 and iket<5)
-//       if (ch==8 and i==0 and j==1 and ( (k==2 and l==5) or (k==5 and l==2) ) )
-//       {
-//         std::cout << " ibra,iket " << ibra << " " << iket << "   ijkl " << i << " " << j << " " << k << " " << l << std::endl;
-//         std::cout << "    " << ZMat(ind_j,  (ind_jj+ind_i*njvals)*nkets + iket) << "  -  " <<  phase_ij * ZMat(ind_i,  (ind_ji+ind_j*njvals)*nkets + iket)
-//                   << "  -  " << hermX*hermY* ZMat(ind_l, (ind_jl+ind_k*njvals)*nkets + ibra) << "  +   " << hermX*hermY*phase_kl * ZMat(ind_k, (ind_jk+ind_l*njvals)*nkets + ibra)
-//                   << "  third term obtained from Z(" << ind_l << " , " << (ind_jl+ind_k*njvals)*nkets + ibra  << std::endl;
-//       }
+        for (int iket=ibra; iket<nkets; iket++)
+        {
+          Ket& ket = tbc.GetKet(iket);
+          int k = ket.p;
+          int l = ket.q;
+          Orbit& ok = Z.modelspace->GetOrbit(k);
+          Orbit& ol = Z.modelspace->GetOrbit(l);
+          double jk = 0.5*ok.j2;
+          double jl = 0.5*ol.j2;
+          size_t ind_k = ij_orbits_lookup[k];
+          size_t ind_l = ij_orbits_lookup[l];
+          size_t ind_jk = jvals_lookup[ok.j2];
+          size_t ind_jl = jvals_lookup[ol.j2];
 
+          int phase_ij = X.modelspace->phase( (oi.j2+oj.j2)/2-J);
+          int phase_kl = X.modelspace->phase( (ok.j2+ol.j2)/2-J);
+          double zijkl = ZMat(ind_j,  (ind_jj+ind_i*njvals)*nkets + iket) ;
+          zijkl -= phase_ij * ZMat(ind_i,  (ind_ji+ind_j*njvals)*nkets + iket) ;
 
-        // normalize the tbme
-        zijkl *= -1.0 / sqrt((1+bra.delta_pq())*(1+ket.delta_pq()));
-        Z2.AddToTBME(ch,ch,ibra,iket,zijkl);
+          zijkl -= hermX*hermY* ZMat(ind_l, (ind_jl+ind_k*njvals)*nkets + ibra);
+          zijkl += hermX*hermY*phase_kl * ZMat(ind_k, (ind_jk+ind_l*njvals)*nkets + ibra);
 
-      }//for iket
-    }//for ibra
+          ////       if (ch==0 and ibra<5 and iket<5)
+          //       if (ch==8 and i==0 and j==1 and ( (k==2 and l==5) or (k==5 and l==2) ) )
+          //       {
+          //         std::cout << " ibra,iket " << ibra << " " << iket << "   ijkl " << i << " " << j << " " << k << " " << l << std::endl;
+          //         std::cout << "    " << ZMat(ind_j,  (ind_jj+ind_i*njvals)*nkets + iket) << "  -  " <<  phase_ij * ZMat(ind_i,  (ind_ji+ind_j*njvals)*nkets + iket)
+          //                   << "  -  " << hermX*hermY* ZMat(ind_l, (ind_jl+ind_k*njvals)*nkets + ibra) << "  +   " << hermX*hermY*phase_kl * ZMat(ind_k, (ind_jk+ind_l*njvals)*nkets + ibra)
+          //                   << "  third term obtained from Z(" << ind_l << " , " << (ind_jl+ind_k*njvals)*nkets + ibra  << std::endl;
+          //       }
 
-    Z.profiler.timer["comm232_block5"] += omp_get_wtime() - tstart;
 
+          // normalize the tbme
+          zijkl *= -1.0 / sqrt((1+bra.delta_pq())*(1+ket.delta_pq()));
+          Z2.AddToTBME(ch,ch,ibra,iket,zijkl);
 
-  }// for ch
+        }//for iket
+      }//for ibra
 
-  Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
-}
+      Z.profiler.timer["comm232_block5"] += omp_get_wtime() - tstart;
 
 
+    }// for ch
 
+    Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
+  }
 
 
 
 
 
-// the old way that also works. It's slower but easier to read.
-void comm232ss_slow( const Operator& X, const Operator& Y, Operator& Z )
-{
-  double tstart = omp_get_wtime();
-  auto& X2 = X.TwoBody;
-  auto& X3 = X.ThreeBody;
-  auto& Y2 = Y.TwoBody;
-  auto& Y3 = Y.ThreeBody;
-  auto& Z2 = Z.TwoBody;
 
-  int nch = Z.modelspace->GetNumberTwoBodyChannels();
 
-  std::vector<std::array<size_t,2>> channels;
-  for (auto& iter : Z.TwoBody.MatEl ) channels.push_back(iter.first);
-  size_t nchans = channels.size();
-//  for (int ch=0; ch<nch; ch++)
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
-  for (size_t ich=0; ich<nchans; ich++)
-  {
-    size_t ch_bra = channels[ich][0];
-    size_t ch_ket = channels[ich][1];
-//    auto& tbc = Z.modelspace->GetTwoBodyChannel(ch);
-    auto& tbc_bra = Z.modelspace->GetTwoBodyChannel(ch_bra);
-    auto& tbc_ket = Z.modelspace->GetTwoBodyChannel(ch_ket);
-    int J = tbc_bra.J;
-//    int nkets = tbc.GetNumberKets();
-    int nbras = tbc_bra.GetNumberKets();
-    int nkets = tbc_ket.GetNumberKets();
-//    for (int ibra=0; ibra<nkets; ibra++)
-    for (int ibra=0; ibra<nbras; ibra++)
+
+  // the old way that also works. It's slower but easier to read.
+  void comm232ss_slow( const Operator& X, const Operator& Y, Operator& Z )
+  {
+    double tstart = omp_get_wtime();
+    auto& X2 = X.TwoBody;
+    auto& X3 = X.ThreeBody;
+    auto& Y2 = Y.TwoBody;
+    auto& Y3 = Y.ThreeBody;
+    auto& Z2 = Z.TwoBody;
+
+    int nch = Z.modelspace->GetNumberTwoBodyChannels();
+
+    std::vector<std::array<size_t,2>> channels;
+    for (auto& iter : Z.TwoBody.MatEl ) channels.push_back(iter.first);
+    size_t nchans = channels.size();
+    //  for (int ch=0; ch<nch; ch++)
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+    for (size_t ich=0; ich<nchans; ich++)
     {
-      Ket& bra = tbc_bra.GetKet(ibra);
-      int i=bra.p;
-      int j=bra.q;
-      Orbit& oi = Z.modelspace->GetOrbit(i);
-      Orbit& oj = Z.modelspace->GetOrbit(j);
-      double occnat_i = oi.occ_nat;
-      double occnat_j = oj.occ_nat;
-      double ji = 0.5*oi.j2;
-      double jj = 0.5*oj.j2;
-      int ket_min = ( ch_bra==ch_ket ) ? ibra : 0;
-      for (int iket=ket_min; iket<nkets; iket++)
+      size_t ch_bra = channels[ich][0];
+      size_t ch_ket = channels[ich][1];
+      //    auto& tbc = Z.modelspace->GetTwoBodyChannel(ch);
+      auto& tbc_bra = Z.modelspace->GetTwoBodyChannel(ch_bra);
+      auto& tbc_ket = Z.modelspace->GetTwoBodyChannel(ch_ket);
+      int J = tbc_bra.J;
+      //    int nkets = tbc.GetNumberKets();
+      int nbras = tbc_bra.GetNumberKets();
+      int nkets = tbc_ket.GetNumberKets();
+      //    for (int ibra=0; ibra<nkets; ibra++)
+      for (int ibra=0; ibra<nbras; ibra++)
       {
-        double zijkl = 0;
-//        Ket& ket = tbc.GetKet(iket);
-        Ket& ket = tbc_ket.GetKet(iket);
-        int k = ket.p;
-        int l = ket.q;
-        Orbit& ok = Z.modelspace->GetOrbit(k);
-        Orbit& ol = Z.modelspace->GetOrbit(l);
-        double jk = 0.5*ok.j2;
-        double jl = 0.5*ol.j2;
-        double occnat_k = ok.occ_nat;
-        double occnat_l = ol.occ_nat;
-        for (auto c : Z.modelspace->all_orbits )
+        Ket& bra = tbc_bra.GetKet(ibra);
+        int i=bra.p;
+        int j=bra.q;
+        Orbit& oi = Z.modelspace->GetOrbit(i);
+        Orbit& oj = Z.modelspace->GetOrbit(j);
+        double occnat_i = oi.occ_nat;
+        double occnat_j = oj.occ_nat;
+        double ji = 0.5*oi.j2;
+        double jj = 0.5*oj.j2;
+        int ket_min = ( ch_bra==ch_ket ) ? ibra : 0;
+        for (int iket=ket_min; iket<nkets; iket++)
         {
-          Orbit& oc = Z.modelspace->GetOrbit(c);
-          double jc = 0.5*oc.j2;
-          double occnat_c = oc.occ_nat;
-
-          for (int ch_ab=0; ch_ab<nch; ch_ab++)
+          double zijkl = 0;
+          //        Ket& ket = tbc.GetKet(iket);
+          Ket& ket = tbc_ket.GetKet(iket);
+          int k = ket.p;
+          int l = ket.q;
+          Orbit& ok = Z.modelspace->GetOrbit(k);
+          Orbit& ol = Z.modelspace->GetOrbit(l);
+          double jk = 0.5*ok.j2;
+          double jl = 0.5*ol.j2;
+          double occnat_k = ok.occ_nat;
+          double occnat_l = ol.occ_nat;
+          for (auto c : Z.modelspace->all_orbits )
           {
-            auto& tbc_ab = X.modelspace->GetTwoBodyChannel(ch_ab);
-            int Jab = tbc_ab.J;
-            size_t nkets_ab = tbc_ab.GetNumberKets();
-            for ( size_t iket_ab=0; iket_ab<nkets_ab; iket_ab++ )
+            Orbit& oc = Z.modelspace->GetOrbit(c);
+            double jc = 0.5*oc.j2;
+            double occnat_c = oc.occ_nat;
+
+            for (int ch_ab=0; ch_ab<nch; ch_ab++)
             {
-              Ket& ket_ab = tbc_ab.GetKet(iket_ab);
-              int a=ket_ab.p;
-              int b=ket_ab.q;
-              Orbit& oa = Z.modelspace->GetOrbit(a);
-              Orbit& ob = Z.modelspace->GetOrbit(b);
-              double occnat_a = oa.occ_nat;
-              double occnat_b = ob.occ_nat;
-              double occfactor = oa.occ * ob.occ * (1-oc.occ) + (1-oa.occ) * (1-ob.occ) * oc.occ;
-              if ( std::abs(occfactor) < 1e-6 ) continue;
-              if (a==b) occfactor *=0.5;  // we sum a<=b, and drop the 1/2, but we still need the 1/2 for a==b
-
-              // Xicab term
-//              if ( ( (oi.l+oc.l+tbc_ab.parity)%2==0) and ((oi.tz2+oc.tz2)==2*tbc_ab.Tz)
-//                  and (std::abs(oi.j2-oc.j2)<=2*Jab)  and (oi.j2+oc.j2>=2*Jab) )
-              if (  (  ( ((oi.l+oc.l+tbc_ab.parity)%2==X.parity) and (std::abs(oi.tz2+oc.tz2-2*tbc_ab.Tz)==2*X.rank_T ) )
-                   or  ( ((oi.l+oc.l+tbc_ab.parity)%2==Y.parity) and (std::abs(oi.tz2+oc.tz2-2*tbc_ab.Tz)==2*Y.rank_T ) ) )
-                  and (std::abs(oi.j2-oc.j2)<=2*Jab)  and (oi.j2+oc.j2>=2*Jab) )
+              auto& tbc_ab = X.modelspace->GetTwoBodyChannel(ch_ab);
+              int Jab = tbc_ab.J;
+              size_t nkets_ab = tbc_ab.GetNumberKets();
+              for ( size_t iket_ab=0; iket_ab<nkets_ab; iket_ab++ )
               {
-
-                if ( (occnat_k*(1-occnat_k) * occnat_l*(1-occnat_l) * occnat_c*(1-occnat_c) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-                if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_j*(1-occnat_j) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-                int twoJ_min = std::max( std::abs(oc.j2-2*J), std::abs( oj.j2-2*Jab ) );
-                int twoJ_max = std::min( oc.j2+2*J,  oj.j2+2*Jab );
-                double xciab = X2.GetTBME_J(Jab,c,i,a,b);
-                double yciab = Y2.GetTBME_J(Jab,c,i,a,b);
-//                double xciab = X2.GetTBME(ch_ab,c,i,a,b);
-//                double yciab = Y2.GetTBME(ch_ab,c,i,a,b);
-                int phasefactor = Z.modelspace->phase((oi.j2+oj.j2)/2-J);
-                for (int twoJ=twoJ_min; twoJ<=twoJ_max; twoJ+=2)
+                Ket& ket_ab = tbc_ab.GetKet(iket_ab);
+                int a=ket_ab.p;
+                int b=ket_ab.q;
+                Orbit& oa = Z.modelspace->GetOrbit(a);
+                Orbit& ob = Z.modelspace->GetOrbit(b);
+                double occnat_a = oa.occ_nat;
+                double occnat_b = ob.occ_nat;
+                double occfactor = oa.occ * ob.occ * (1-oc.occ) + (1-oa.occ) * (1-ob.occ) * oc.occ;
+                if ( std::abs(occfactor) < 1e-6 ) continue;
+                if (a==b) occfactor *=0.5;  // we sum a<=b, and drop the 1/2, but we still need the 1/2 for a==b
+
+                // Xicab term
+                //              if ( ( (oi.l+oc.l+tbc_ab.parity)%2==0) and ((oi.tz2+oc.tz2)==2*tbc_ab.Tz)
+                //                  and (std::abs(oi.j2-oc.j2)<=2*Jab)  and (oi.j2+oc.j2>=2*Jab) )
+                if (  (  ( ((oi.l+oc.l+tbc_ab.parity)%2==X.parity) and (std::abs(oi.tz2+oc.tz2-2*tbc_ab.Tz)==2*X.rank_T ) )
+                      or  ( ((oi.l+oc.l+tbc_ab.parity)%2==Y.parity) and (std::abs(oi.tz2+oc.tz2-2*tbc_ab.Tz)==2*Y.rank_T ) ) )
+                    and (std::abs(oi.j2-oc.j2)<=2*Jab)  and (oi.j2+oc.j2>=2*Jab) )
                 {
 
-                  double Jtot = 0.5 * twoJ;
-                  double sixj = Z.modelspace->GetSixJ(jj,ji,J, jc,Jtot,Jab);
-                  double hatfactor = (twoJ+1) * sqrt( (2*Jab+1.)/(2*J+1) );
-                  double xabjklc = X3.GetME_pn(Jab,J,twoJ,a,b,j,k,l,c);
-                  double yabjklc = Y3.GetME_pn(Jab,J,twoJ,a,b,j,k,l,c);
-                  zijkl += occfactor * hatfactor * phasefactor * sixj * ( xciab * yabjklc  - yciab * xabjklc);
+                  if ( (occnat_k*(1-occnat_k) * occnat_l*(1-occnat_l) * occnat_c*(1-occnat_c) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+                  if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_j*(1-occnat_j) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+                  int twoJ_min = std::max( std::abs(oc.j2-2*J), std::abs( oj.j2-2*Jab ) );
+                  int twoJ_max = std::min( oc.j2+2*J,  oj.j2+2*Jab );
+                  double xciab = X2.GetTBME_J(Jab,c,i,a,b);
+                  double yciab = Y2.GetTBME_J(Jab,c,i,a,b);
+                  //                double xciab = X2.GetTBME(ch_ab,c,i,a,b);
+                  //                double yciab = Y2.GetTBME(ch_ab,c,i,a,b);
+                  int phasefactor = Z.modelspace->phase((oi.j2+oj.j2)/2-J);
+                  for (int twoJ=twoJ_min; twoJ<=twoJ_max; twoJ+=2)
+                  {
+
+                    double Jtot = 0.5 * twoJ;
+                    double sixj = Z.modelspace->GetSixJ(jj,ji,J, jc,Jtot,Jab);
+                    double hatfactor = (twoJ+1) * sqrt( (2*Jab+1.)/(2*J+1) );
+                    double xabjklc = X3.GetME_pn(Jab,J,twoJ,a,b,j,k,l,c);
+                    double yabjklc = Y3.GetME_pn(Jab,J,twoJ,a,b,j,k,l,c);
+                    zijkl += occfactor * hatfactor * phasefactor * sixj * ( xciab * yabjklc  - yciab * xabjklc);
+                  }
                 }
-              }
 
 
-              // Xjcab term
-//              if ( ( (oj.l+oc.l+tbc_ab.parity)%2==0) and ((oj.tz2+oc.tz2)==2*tbc_ab.Tz)
-              if (  (  ( ((oj.l+oc.l+tbc_ab.parity)%2==X.parity) and (std::abs(oj.tz2+oc.tz2-2*tbc_ab.Tz)==2*X.rank_T ) )
-                   or  ( ((oj.l+oc.l+tbc_ab.parity)%2==Y.parity) and (std::abs(oj.tz2+oc.tz2-2*tbc_ab.Tz)==2*Y.rank_T ) ) )
-                  and (std::abs(oj.j2-oc.j2)<=2*Jab)  and (oj.j2+oc.j2>=2*Jab) )
-              {
-                if ( (occnat_k*(1-occnat_k) * occnat_l*(1-occnat_l) * occnat_c*(1-occnat_c) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-                if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_i*(1-occnat_i) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-                int twoJ_min = std::max( std::abs(oc.j2-2*J), std::abs( oi.j2-2*Jab ) );
-                int twoJ_max = std::min( oc.j2+2*J,  oi.j2+2*Jab );
-//                double xcjab = X2.GetTBME(ch_ab,c,j,a,b);
-//                double ycjab = Y2.GetTBME(ch_ab,c,j,a,b);
-                double xcjab = X2.GetTBME_J(Jab,c,j,a,b);
-                double ycjab = Y2.GetTBME_J(Jab,c,j,a,b);
-                int phasefactor = 1;
-                for (int twoJ=twoJ_min; twoJ<=twoJ_max; twoJ+=2)
+                // Xjcab term
+                //              if ( ( (oj.l+oc.l+tbc_ab.parity)%2==0) and ((oj.tz2+oc.tz2)==2*tbc_ab.Tz)
+                if (  (  ( ((oj.l+oc.l+tbc_ab.parity)%2==X.parity) and (std::abs(oj.tz2+oc.tz2-2*tbc_ab.Tz)==2*X.rank_T ) )
+                      or  ( ((oj.l+oc.l+tbc_ab.parity)%2==Y.parity) and (std::abs(oj.tz2+oc.tz2-2*tbc_ab.Tz)==2*Y.rank_T ) ) )
+                    and (std::abs(oj.j2-oc.j2)<=2*Jab)  and (oj.j2+oc.j2>=2*Jab) )
                 {
-                  double Jtot = 0.5 * twoJ;
-                  double sixj = Z.modelspace->GetSixJ(ji,jj,J, jc,Jtot,Jab);
-                  double hatfactor = (twoJ+1) * sqrt( (2*Jab+1.)/(2*J+1) );
-                  double xabiklc = X3.GetME_pn(Jab,J,twoJ,a,b,i,k,l,c);
-                  double yabiklc = Y3.GetME_pn(Jab,J,twoJ,a,b,i,k,l,c);
-                  zijkl -= occfactor * hatfactor * phasefactor * sixj * ( xcjab * yabiklc - ycjab * xabiklc);
+                  if ( (occnat_k*(1-occnat_k) * occnat_l*(1-occnat_l) * occnat_c*(1-occnat_c) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+                  if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_i*(1-occnat_i) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+                  int twoJ_min = std::max( std::abs(oc.j2-2*J), std::abs( oi.j2-2*Jab ) );
+                  int twoJ_max = std::min( oc.j2+2*J,  oi.j2+2*Jab );
+                  //                double xcjab = X2.GetTBME(ch_ab,c,j,a,b);
+                  //                double ycjab = Y2.GetTBME(ch_ab,c,j,a,b);
+                  double xcjab = X2.GetTBME_J(Jab,c,j,a,b);
+                  double ycjab = Y2.GetTBME_J(Jab,c,j,a,b);
+                  int phasefactor = 1;
+                  for (int twoJ=twoJ_min; twoJ<=twoJ_max; twoJ+=2)
+                  {
+                    double Jtot = 0.5 * twoJ;
+                    double sixj = Z.modelspace->GetSixJ(ji,jj,J, jc,Jtot,Jab);
+                    double hatfactor = (twoJ+1) * sqrt( (2*Jab+1.)/(2*J+1) );
+                    double xabiklc = X3.GetME_pn(Jab,J,twoJ,a,b,i,k,l,c);
+                    double yabiklc = Y3.GetME_pn(Jab,J,twoJ,a,b,i,k,l,c);
+                    zijkl -= occfactor * hatfactor * phasefactor * sixj * ( xcjab * yabiklc - ycjab * xabiklc);
+                  }
                 }
-              }
- 
 
-              // Xabkc term
-//              if ( ( (ok.l+oc.l+tbc_ab.parity)%2==0) and ((ok.tz2+oc.tz2)==2*tbc_ab.Tz)
-              if (  (  ( ((ok.l+oc.l+tbc_ab.parity)%2==X.parity) and (std::abs(ok.tz2+oc.tz2-2*tbc_ab.Tz)==2*X.rank_T ) )
-                   or  ( ((ok.l+oc.l+tbc_ab.parity)%2==Y.parity) and (std::abs(ok.tz2+oc.tz2-2*tbc_ab.Tz)==2*Y.rank_T ) ) )
-                  and (std::abs(ok.j2-oc.j2)<=2*Jab)  and (ok.j2+oc.j2>=2*Jab) )
-              {
-                if ( (occnat_i*(1-occnat_i) * occnat_j*(1-occnat_j) * occnat_c*(1-occnat_c) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-                if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_l*(1-occnat_l) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-                int twoJ_min = std::max( std::abs(oc.j2-2*J), std::abs( ol.j2-2*Jab ) );
-                int twoJ_max = std::min( oc.j2+2*J,  ol.j2+2*Jab );
-//                double xabck = X2.GetTBME(ch_ab,a,b,c,k);
-//                double yabck = Y2.GetTBME(ch_ab,a,b,c,k);
-                double xabck = X2.GetTBME_J(Jab,a,b,c,k);
-                double yabck = Y2.GetTBME_J(Jab,a,b,c,k);
-                int phasefactor = Z.modelspace->phase((ok.j2+ol.j2)/2-J);
-                for (int twoJ=twoJ_min; twoJ<=twoJ_max; twoJ+=2)
+
+                // Xabkc term
+                //              if ( ( (ok.l+oc.l+tbc_ab.parity)%2==0) and ((ok.tz2+oc.tz2)==2*tbc_ab.Tz)
+                if (  (  ( ((ok.l+oc.l+tbc_ab.parity)%2==X.parity) and (std::abs(ok.tz2+oc.tz2-2*tbc_ab.Tz)==2*X.rank_T ) )
+                      or  ( ((ok.l+oc.l+tbc_ab.parity)%2==Y.parity) and (std::abs(ok.tz2+oc.tz2-2*tbc_ab.Tz)==2*Y.rank_T ) ) )
+                    and (std::abs(ok.j2-oc.j2)<=2*Jab)  and (ok.j2+oc.j2>=2*Jab) )
                 {
-                  double Jtot = 0.5 * twoJ;
-                  double sixj = Z.modelspace->GetSixJ(jl,jk,J, jc,Jtot,Jab);
-                  double hatfactor = (twoJ+1) * sqrt( (2*Jab+1.)/(2*J+1) );
-                  double xijcabl = X3.GetME_pn(J,Jab,twoJ,i,j,c,a,b,l);
-                  double yijcabl = Y3.GetME_pn(J,Jab,twoJ,i,j,c,a,b,l);
-                  zijkl -= occfactor * hatfactor * phasefactor * sixj * ( yijcabl*xabck - xijcabl*yabck ); 
+                  if ( (occnat_i*(1-occnat_i) * occnat_j*(1-occnat_j) * occnat_c*(1-occnat_c) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+                  if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_l*(1-occnat_l) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+                  int twoJ_min = std::max( std::abs(oc.j2-2*J), std::abs( ol.j2-2*Jab ) );
+                  int twoJ_max = std::min( oc.j2+2*J,  ol.j2+2*Jab );
+                  //                double xabck = X2.GetTBME(ch_ab,a,b,c,k);
+                  //                double yabck = Y2.GetTBME(ch_ab,a,b,c,k);
+                  double xabck = X2.GetTBME_J(Jab,a,b,c,k);
+                  double yabck = Y2.GetTBME_J(Jab,a,b,c,k);
+                  int phasefactor = Z.modelspace->phase((ok.j2+ol.j2)/2-J);
+                  for (int twoJ=twoJ_min; twoJ<=twoJ_max; twoJ+=2)
+                  {
+                    double Jtot = 0.5 * twoJ;
+                    double sixj = Z.modelspace->GetSixJ(jl,jk,J, jc,Jtot,Jab);
+                    double hatfactor = (twoJ+1) * sqrt( (2*Jab+1.)/(2*J+1) );
+                    double xijcabl = X3.GetME_pn(J,Jab,twoJ,i,j,c,a,b,l);
+                    double yijcabl = Y3.GetME_pn(J,Jab,twoJ,i,j,c,a,b,l);
+                    zijkl -= occfactor * hatfactor * phasefactor * sixj * ( yijcabl*xabck - xijcabl*yabck );
+                  }
                 }
-              }
 
 
-              // Xablc term
-//              if ( ( (ol.l+oc.l+tbc_ab.parity)%2==0) and ((ol.tz2+oc.tz2)==2*tbc_ab.Tz)
-              if (  (  ( ((ol.l+oc.l+tbc_ab.parity)%2==X.parity) and (std::abs(ol.tz2+oc.tz2-2*tbc_ab.Tz)==2*X.rank_T ) )
-                   or  ( ((ol.l+oc.l+tbc_ab.parity)%2==Y.parity) and (std::abs(ol.tz2+oc.tz2-2*tbc_ab.Tz)==2*Y.rank_T ) ) )
-                  and (std::abs(ol.j2-oc.j2)<=2*Jab)  and (ol.j2+oc.j2>=2*Jab) )
-              {
-                if ( (occnat_i*(1-occnat_i) * occnat_j*(1-occnat_j) * occnat_c*(1-occnat_c) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-                if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_k*(1-occnat_k) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-                int twoJ_min = std::max( std::abs(oc.j2-2*J), std::abs( ok.j2-2*Jab ) );
-                int twoJ_max = std::min( oc.j2+2*J,  ok.j2+2*Jab );
-                double xabcl = X2.GetTBME_J(Jab,a,b,c,l);
-                double yabcl = Y2.GetTBME_J(Jab,a,b,c,l);
-//                double xabcl = X2.GetTBME(ch_ab,a,b,c,l);
-//                double yabcl = Y2.GetTBME(ch_ab,a,b,c,l);
-                int phasefactor = 1;
-                for (int twoJ=twoJ_min; twoJ<=twoJ_max; twoJ+=2)
+                // Xablc term
+                //              if ( ( (ol.l+oc.l+tbc_ab.parity)%2==0) and ((ol.tz2+oc.tz2)==2*tbc_ab.Tz)
+                if (  (  ( ((ol.l+oc.l+tbc_ab.parity)%2==X.parity) and (std::abs(ol.tz2+oc.tz2-2*tbc_ab.Tz)==2*X.rank_T ) )
+                      or  ( ((ol.l+oc.l+tbc_ab.parity)%2==Y.parity) and (std::abs(ol.tz2+oc.tz2-2*tbc_ab.Tz)==2*Y.rank_T ) ) )
+                    and (std::abs(ol.j2-oc.j2)<=2*Jab)  and (ol.j2+oc.j2>=2*Jab) )
                 {
-                  double Jtot = 0.5 * twoJ;
-                  double sixj = Z.modelspace->GetSixJ(jk,jl,J, jc, Jtot,Jab);
-                  double hatfactor = (twoJ+1) * sqrt( (2*Jab+1.)/(2*J+1) );
-                  double xijcabk = X3.GetME_pn(J,Jab,twoJ,i,j,c,a,b,k);
-                  double yijcabk = Y3.GetME_pn(J,Jab,twoJ,i,j,c,a,b,k);
-                  zijkl += occfactor * hatfactor * phasefactor * sixj * ( yijcabk*xabcl - xijcabk*yabcl );
+                  if ( (occnat_i*(1-occnat_i) * occnat_j*(1-occnat_j) * occnat_c*(1-occnat_c) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+                  if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_k*(1-occnat_k) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+                  int twoJ_min = std::max( std::abs(oc.j2-2*J), std::abs( ok.j2-2*Jab ) );
+                  int twoJ_max = std::min( oc.j2+2*J,  ok.j2+2*Jab );
+                  double xabcl = X2.GetTBME_J(Jab,a,b,c,l);
+                  double yabcl = Y2.GetTBME_J(Jab,a,b,c,l);
+                  //                double xabcl = X2.GetTBME(ch_ab,a,b,c,l);
+                  //                double yabcl = Y2.GetTBME(ch_ab,a,b,c,l);
+                  int phasefactor = 1;
+                  for (int twoJ=twoJ_min; twoJ<=twoJ_max; twoJ+=2)
+                  {
+                    double Jtot = 0.5 * twoJ;
+                    double sixj = Z.modelspace->GetSixJ(jk,jl,J, jc, Jtot,Jab);
+                    double hatfactor = (twoJ+1) * sqrt( (2*Jab+1.)/(2*J+1) );
+                    double xijcabk = X3.GetME_pn(J,Jab,twoJ,i,j,c,a,b,k);
+                    double yijcabk = Y3.GetME_pn(J,Jab,twoJ,i,j,c,a,b,k);
+                    zijkl += occfactor * hatfactor * phasefactor * sixj * ( yijcabk*xabcl - xijcabk*yabcl );
+                  }
                 }
-              }
 
-            }// for iket_ab
-          }// for ch2
-        }// for c
+              }// for iket_ab
+            }// for ch2
+          }// for c
+
+          // normalize the tbme
+          zijkl *= -1.0 / sqrt((1+bra.delta_pq())*(1+ket.delta_pq()));
+          //        Z2.AddToTBME(ch,ch,ibra,iket,zijkl);
+          Z2.AddToTBME(ch_bra,ch_ket,ibra,iket,zijkl);
+        }// for iket
+      }// for ibra
+    }// for ch
+
+    Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
+  }
+
+
+
 
-        // normalize the tbme
-        zijkl *= -1.0 / sqrt((1+bra.delta_pq())*(1+ket.delta_pq()));
-//        Z2.AddToTBME(ch,ch,ibra,iket,zijkl);
-        Z2.AddToTBME(ch_bra,ch_ket,ibra,iket,zijkl);
-      }// for iket
-    }// for ibra
-  }// for ch
 
-  Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
-}
 
 
+  //*****************************************************************************************
+  //
+  // i|  j|
+  //  |   |           Uncoupled expression:
+  //  *~~[X]~~~~*        Z_ijkl = 1/6 sum_abcd (nanbncn`d -n`an`bn`cnd)(X_ijdabc Y_abckld - Y_ijdabc Xabckld)
+  //  |   |     /\
+  // a|  b|   c(  )d
+  //  |   |     \/
+  //  *~~[Y]~~~~*      Coupled expression:
+  //  |   |              Z_{ijkl}^{J} = 1/6 sum_abcd (nanbncn`d-n`an`bn`cnd) 1/(2J+1) sum_J1J' (2J'+1)(X_{ijdabc}^{J J1 J'} Y_{abckld}^{J1 J J'} - X<->Y )
+  // k|  l|
+  //
+  //
+  //  Checked with UnitTest and passed.
+  //
+  void comm332_ppph_hhhpss( const Operator& X, const Operator& Y, Operator& Z )
+  {
+    double tstart = omp_get_wtime();
+    auto& X3 = X.ThreeBody;
+    auto& Y3 = Y.ThreeBody;
+    auto& Z2 = Z.TwoBody;
+
+    int hX = X.IsHermitian() ? 1 : -1;
+    int hY = Y.IsHermitian() ? 1 : -1;
+    std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
+
+    int nch = Z.modelspace->GetNumberTwoBodyChannels();
+    size_t nch3 = Z.modelspace->GetNumberThreeBodyChannels();
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+    for (int ch=0; ch<nch; ch++)
+    {
+      TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
+      int J = tbc.J;
+      int nkets = tbc.GetNumberKets();
 
+      std::vector<size_t> ch3_abc_list;
+      std::vector<size_t> iket_abc_list;
+      std::vector<size_t> d_list;
+      std::vector<double> factor_list;
 
+      // figure out how bit the abcd side of the matrices should be, and store some stuff for later lookup
+      for (size_t ch_abc=0; ch_abc<nch3; ch_abc++)
+      {
+        ThreeBodyChannel& Tbc_abc = Z.modelspace->GetThreeBodyChannel(ch_abc);
+        if ( std::abs( Tbc_abc.twoTz - 2*tbc.Tz) > 1) continue;
+        int twoJ = Tbc_abc.twoJ;
+        size_t nkets_abc = Tbc_abc.GetNumberKets();
+        for (size_t iket_abc=0; iket_abc<nkets_abc; iket_abc++)
+        {
+          Ket3& ket_abc = Tbc_abc.GetKet(iket_abc);
+          size_t a = ket_abc.p;
+          size_t b = ket_abc.q;
+          size_t c = ket_abc.r;
+          double occ_abc = ket_abc.op->occ * ket_abc.oq->occ * ket_abc.oR->occ;
+          double occ_abc_bar = (1-ket_abc.op->occ) * (1-ket_abc.oq->occ) * (1-ket_abc.oR->occ);
+          double d_ea = std::abs( 2*ket_abc.op->n + ket_abc.op->l - e_fermi[ ket_abc.op->tz2]);
+          double d_eb = std::abs( 2*ket_abc.oq->n + ket_abc.oq->l - e_fermi[ ket_abc.oq->tz2]);
+          double d_ec = std::abs( 2*ket_abc.oR->n + ket_abc.oR->l - e_fermi[ ket_abc.oR->tz2]);
+          double occnat_a = ket_abc.op->occ_nat;
+          double occnat_b = ket_abc.oq->occ_nat;
+          double occnat_c = ket_abc.oR->occ_nat;
+          if ( (d_ea+d_eb+d_ec)>Z.modelspace->dE3max) continue;
+          if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_c*(1-occnat_c) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+          if ( (std::abs(occ_abc)==0) and (std::abs(occ_abc_bar)==0) ) continue;
+          int Jab = ket_abc.Jpq;
+
+          double symm_factor = 6;  // 6 possible orderings of abc. If a==b, then only 3 orderings, and if a==b==c, then only 1 ordering.
+          if ( a==b and b==c )
+            symm_factor = 1;
+          else if (a==b or a==c or b==c )
+            symm_factor = 3;
+
+          for ( auto d : Z.modelspace->all_orbits )
+          {
+            Orbit& od = Z.modelspace->GetOrbit(d);
+            double nd = od.occ;
+            //          double d_ed = std::abs( 2*od.n + od.l - e_fermi[od.tz2]);
+            //          double occnat_d = od.occ_nat;
+            double occfactor = occ_abc*(1-nd) - occ_abc_bar*nd ;
+            if (std::abs(occfactor)<1e-6) continue;
+            if ( (std::abs( 2*J-od.j2) > twoJ) or (2*J+od.j2)<twoJ ) continue;
+            if ( (od.l+tbc.parity + Tbc_abc.parity)%2>0) continue;
+            if ( (Tbc_abc.twoTz)!=(od.tz2 + 2*tbc.Tz) ) continue;
 
 
+            ch3_abc_list.push_back(ch_abc);
+            iket_abc_list.push_back(iket_abc);
+            d_list.push_back(d);
+            factor_list.push_back( (twoJ+1.)/(2*J+1) * occfactor * symm_factor/6. );
+          }// for d
+        }//for iket_abc
+      }// for ch_abc
 
-//*****************************************************************************************
-//
-// i|  j|      
-//  |   |           Uncoupled expression:
-//  *~~[X]~~~~*        Z_ijkl = 1/6 sum_abcd (nanbncn`d -n`an`bn`cnd)(X_ijdabc Y_abckld - Y_ijdabc Xabckld)
-//  |   |     /\                                                                                                    
-// a|  b|   c(  )d
-//  |   |     \/ 
-//  *~~[Y]~~~~*      Coupled expression:
-//  |   |              Z_{ijkl}^{J} = 1/6 sum_abcd (nanbncn`d-n`an`bn`cnd) 1/(2J+1) sum_J1J' (2J'+1)(X_{ijdabc}^{J J1 J'} Y_{abckld}^{J1 J J'} - X<->Y )
-// k|  l|                                                                                                                                        
-//                                                 
-//                                                                                                         
-//  Checked with UnitTest and passed.
-//
-void comm332_ppph_hhhpss( const Operator& X, const Operator& Y, Operator& Z )
-{
-  double tstart = omp_get_wtime();
-  auto& X3 = X.ThreeBody;
-  auto& Y3 = Y.ThreeBody;
-  auto& Z2 = Z.TwoBody;
 
-  int hX = X.IsHermitian() ? 1 : -1;
-  int hY = Y.IsHermitian() ? 1 : -1;
-  std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
-  
-  int nch = Z.modelspace->GetNumberTwoBodyChannels();
-  size_t nch3 = Z.modelspace->GetNumberThreeBodyChannels();
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
-  for (int ch=0; ch<nch; ch++)
-  {
-    TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
-    int J = tbc.J;
-    int nkets = tbc.GetNumberKets();
+      // initialize the matrices
+      size_t dim_abcd = ch3_abc_list.size();
+      arma::mat XMAT(nkets, dim_abcd, arma::fill::zeros);
+      arma::mat YMAT(nkets, dim_abcd, arma::fill::zeros);
 
-    std::vector<size_t> ch3_abc_list;
-    std::vector<size_t> iket_abc_list;
-    std::vector<size_t> d_list;
-    std::vector<double> factor_list;
-    
-    // figure out how bit the abcd side of the matrices should be, and store some stuff for later lookup
-    for (size_t ch_abc=0; ch_abc<nch3; ch_abc++)
-    {
-      ThreeBodyChannel& Tbc_abc = Z.modelspace->GetThreeBodyChannel(ch_abc);
-      if ( std::abs( Tbc_abc.twoTz - 2*tbc.Tz) > 1) continue;
-      int twoJ = Tbc_abc.twoJ;
-      size_t nkets_abc = Tbc_abc.GetNumberKets();
-      for (size_t iket_abc=0; iket_abc<nkets_abc; iket_abc++)
+
+      // fill the matrices  TODO: I think we can make this faster by first doing the recoupling lookup for ijd
+      for (size_t index_abcd=0; index_abcd<dim_abcd; index_abcd++)
       {
+        size_t ch_abc = ch3_abc_list[index_abcd];
+        size_t iket_abc = iket_abc_list[index_abcd];
+        double factor = factor_list[index_abcd];
+        ThreeBodyChannel& Tbc_abc = Z.modelspace->GetThreeBodyChannel(ch_abc);
         Ket3& ket_abc = Tbc_abc.GetKet(iket_abc);
+        int Jab = ket_abc.Jpq;
+        int twoJ = Tbc_abc.twoJ;
         size_t a = ket_abc.p;
         size_t b = ket_abc.q;
         size_t c = ket_abc.r;
-        double occ_abc = ket_abc.op->occ * ket_abc.oq->occ * ket_abc.oR->occ;
-        double occ_abc_bar = (1-ket_abc.op->occ) * (1-ket_abc.oq->occ) * (1-ket_abc.oR->occ);
-        double d_ea = std::abs( 2*ket_abc.op->n + ket_abc.op->l - e_fermi[ ket_abc.op->tz2]);
-        double d_eb = std::abs( 2*ket_abc.oq->n + ket_abc.oq->l - e_fermi[ ket_abc.oq->tz2]);
-        double d_ec = std::abs( 2*ket_abc.oR->n + ket_abc.oR->l - e_fermi[ ket_abc.oR->tz2]);
-        double occnat_a = ket_abc.op->occ_nat;
-        double occnat_b = ket_abc.oq->occ_nat;
-        double occnat_c = ket_abc.oR->occ_nat;
-        if ( (d_ea+d_eb+d_ec)>Z.modelspace->dE3max) continue;
-        if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_c*(1-occnat_c) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-        if ( (std::abs(occ_abc)==0) and (std::abs(occ_abc_bar)==0) ) continue;
-        int Jab = ket_abc.Jpq;
+        size_t d = d_list[index_abcd];
+        Orbit& od = Z.modelspace->GetOrbit(d);
+        double d_ed = std::abs(2*od.n + od.l - e_fermi[od.tz2]);
+        double occnat_d = od.occ_nat;
 
-        double symm_factor = 6;  // 6 possible orderings of abc. If a==b, then only 3 orderings, and if a==b==c, then only 1 ordering.
-        if ( a==b and b==c )
-           symm_factor = 1;
-        else if (a==b or a==c or b==c )
-           symm_factor = 3;
-
-        for ( auto d : Z.modelspace->all_orbits ) 
+        for (int ibra=0; ibra<nkets; ibra++)
         {
-          Orbit& od = Z.modelspace->GetOrbit(d);
-          double nd = od.occ;
-//          double d_ed = std::abs( 2*od.n + od.l - e_fermi[od.tz2]);
-//          double occnat_d = od.occ_nat;
-          double occfactor = occ_abc*(1-nd) - occ_abc_bar*nd ;
-          if (std::abs(occfactor)<1e-6) continue;
-          if ( (std::abs( 2*J-od.j2) > twoJ) or (2*J+od.j2)<twoJ ) continue;
-          if ( (od.l+tbc.parity + Tbc_abc.parity)%2>0) continue;
-          if ( (Tbc_abc.twoTz)!=(od.tz2 + 2*tbc.Tz) ) continue;
-
-
-          ch3_abc_list.push_back(ch_abc);
-          iket_abc_list.push_back(iket_abc);
-          d_list.push_back(d);
-          factor_list.push_back( (twoJ+1.)/(2*J+1) * occfactor * symm_factor/6. );
-         }// for d
-      }//for iket_abc
-    }// for ch_abc
-
-
-    // initialize the matrices
-    size_t dim_abcd = ch3_abc_list.size();
-    arma::mat XMAT(nkets, dim_abcd, arma::fill::zeros);
-    arma::mat YMAT(nkets, dim_abcd, arma::fill::zeros);
-
-
-    // fill the matrices  TODO: I think we can make this faster by first doing the recoupling lookup for ijd
-    for (size_t index_abcd=0; index_abcd<dim_abcd; index_abcd++)
-    {
-      size_t ch_abc = ch3_abc_list[index_abcd];
-      size_t iket_abc = iket_abc_list[index_abcd];
-      double factor = factor_list[index_abcd];
-      ThreeBodyChannel& Tbc_abc = Z.modelspace->GetThreeBodyChannel(ch_abc);
-      Ket3& ket_abc = Tbc_abc.GetKet(iket_abc);
-      int Jab = ket_abc.Jpq;
-      int twoJ = Tbc_abc.twoJ;
-      size_t a = ket_abc.p;
-      size_t b = ket_abc.q;
-      size_t c = ket_abc.r;
-      size_t d = d_list[index_abcd];
-      Orbit& od = Z.modelspace->GetOrbit(d);
-      double d_ed = std::abs(2*od.n + od.l - e_fermi[od.tz2]);
-      double occnat_d = od.occ_nat;
-
-      for (int ibra=0; ibra<nkets; ibra++)
-      {
-        Ket& bra = tbc.GetKet(ibra);
-        int i = bra.p;
-        int j = bra.q;
-        double d_ei = std::abs( 2*bra.op->n + bra.op->l - e_fermi[bra.op->tz2]);
-        double d_ej = std::abs( 2*bra.oq->n + bra.oq->l - e_fermi[bra.oq->tz2]);
-        double occnat_i = bra.op->occ_nat;
-        double occnat_j = bra.oq->occ_nat;
-        if ( (d_ei+d_ej+d_ed)>Z.modelspace->dE3max) continue;
-        if ( (occnat_i*(1-occnat_i) * occnat_j*(1-occnat_j) * occnat_d*(1-occnat_d) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-        double norm2b = (i==j) ? 1./sqrt(2) : 1;
-
-        XMAT(ibra,index_abcd) = norm2b * X3.GetME_pn(J,Jab,twoJ, i,j,d,a,b,c);
-        YMAT(ibra,index_abcd) = norm2b * factor * Y3.GetME_pn(J,Jab,twoJ, i,j,d,a,b,c);
+          Ket& bra = tbc.GetKet(ibra);
+          int i = bra.p;
+          int j = bra.q;
+          double d_ei = std::abs( 2*bra.op->n + bra.op->l - e_fermi[bra.op->tz2]);
+          double d_ej = std::abs( 2*bra.oq->n + bra.oq->l - e_fermi[bra.oq->tz2]);
+          double occnat_i = bra.op->occ_nat;
+          double occnat_j = bra.oq->occ_nat;
+          if ( (d_ei+d_ej+d_ed)>Z.modelspace->dE3max) continue;
+          if ( (occnat_i*(1-occnat_i) * occnat_j*(1-occnat_j) * occnat_d*(1-occnat_d) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+          double norm2b = (i==j) ? 1./sqrt(2) : 1;
+
+          XMAT(ibra,index_abcd) = norm2b * X3.GetME_pn(J,Jab,twoJ, i,j,d,a,b,c);
+          YMAT(ibra,index_abcd) = norm2b * factor * Y3.GetME_pn(J,Jab,twoJ, i,j,d,a,b,c);
 
         }// for ibra
       }// for index_abcd
@@ -3502,86 +3724,86 @@ void comm332_ppph_hhhpss( const Operator& X, const Operator& Y, Operator& Z )
           Z2.AddToTBME(ch,ch,ibra,iket,ZMAT(ibra,iket) );
         }
       }
-  }// for ch
-  Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
-}
+    }// for ch
+    Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
+  }
 
 
-// the old slow way
-/*
-void comm332_ppph_hhhpss( const Operator& X, const Operator& Y, Operator& Z )
+  // the old slow way
+  /*
+     void comm332_ppph_hhhpss( const Operator& X, const Operator& Y, Operator& Z )
+     {
+     double tstart = omp_get_wtime();
+     auto& X3 = X.ThreeBody;
+     auto& Y3 = Y.ThreeBody;
+     auto& Z2 = Z.TwoBody;
+
+     int nch = Z.modelspace->GetNumberTwoBodyChannels();
+     size_t nch3 = Z.modelspace->GetNumberThreeBodyChannels();
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+for (int ch=0; ch<nch; ch++)
 {
-  double tstart = omp_get_wtime();
-  auto& X3 = X.ThreeBody;
-  auto& Y3 = Y.ThreeBody;
-  auto& Z2 = Z.TwoBody;
-  
-  int nch = Z.modelspace->GetNumberTwoBodyChannels();
-  size_t nch3 = Z.modelspace->GetNumberThreeBodyChannels();
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
-  for (int ch=0; ch<nch; ch++)
-  {
-    TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
-    int J = tbc.J;
-    int nkets = tbc.GetNumberKets();
-    for (int ibra=0; ibra<nkets; ibra++)
-    {
-      Ket& bra = tbc.GetKet(ibra);
-      int i = bra.p;
-      int j = bra.q;
-      for (int iket=ibra; iket<nkets; iket++) 
-      {
-        Ket& ket = tbc.GetKet(iket);
-        int k = ket.p;
-        int l = ket.q;
+TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
+int J = tbc.J;
+int nkets = tbc.GetNumberKets();
+for (int ibra=0; ibra<nkets; ibra++)
+{
+Ket& bra = tbc.GetKet(ibra);
+int i = bra.p;
+int j = bra.q;
+for (int iket=ibra; iket<nkets; iket++)
+{
+Ket& ket = tbc.GetKet(iket);
+int k = ket.p;
+int l = ket.q;
 
-        double zijkl = 0;
+double zijkl = 0;
 
-        for (size_t ch_abc=0; ch_abc<nch3; ch_abc++)
-        {
-          ThreeBodyChannel& Tbc_abc = Z.modelspace->GetThreeBodyChannel(ch_abc);
-          if ( std::abs( Tbc_abc.twoTz - 2*tbc.Tz) > 1) continue;
-          int twoJ = Tbc_abc.twoJ;
-          size_t nkets_abc = Tbc_abc.GetNumberKets();
-          for (size_t iket_abc=0; iket_abc<nkets_abc; iket_abc++)
-          {
-            Ket3& ket_abc = Tbc_abc.GetKet(iket_abc);
-            size_t a = ket_abc.p;
-            size_t b = ket_abc.q;
-            size_t c = ket_abc.r;
-            double occ_abc = ket_abc.op->occ * ket_abc.oq->occ * ket_abc.oR->occ;
-            double occ_abc_bar = (1-ket_abc.op->occ) * (1-ket_abc.oq->occ) * (1-ket_abc.oR->occ);
-            if ( (std::abs(occ_abc)==0) and (std::abs(occ_abc_bar)==0) ) continue;
-            int Jab = ket_abc.Jpq;
-
-              double symm_factor = 6;  // 6 possible orderings of abc. If a==b, then only 3 orderings, and if a==b==c, then only 1 ordering.
-              if ( a==b and b==c )
-                 symm_factor = 1;
-              else if (a==b or a==c or b==c )
-                 symm_factor = 3;
-
-              for ( auto d : Z.modelspace->all_orbits ) 
-              {
-                Orbit& od = Z.modelspace->GetOrbit(d);
-                double nd = od.occ;
-                double occfactor = occ_abc*(1-nd) - occ_abc_bar*nd ;
-                if (std::abs(occfactor)<1e-6) continue;
-                if ( (std::abs( 2*J-od.j2) > twoJ) or (2*J+od.j2)<twoJ ) continue;
-                if ( (od.l+tbc.parity + Tbc_abc.parity)%2>0) continue;
-                if ( (Tbc_abc.twoTz)!=(od.tz2 + 2*tbc.Tz) ) continue;
-                zijkl += symm_factor * 1./6  * (twoJ+1.)/(2*J+1) * occfactor 
-                         *(  X3.GetME_pn(J,Jab,twoJ, i,j,d,a,b,c) * Y3.GetME_pn(Jab, J, twoJ, a,b,c,k,l,d)
-                           - Y3.GetME_pn(J,Jab,twoJ, i,j,d,a,b,c) * X3.GetME_pn(Jab, J, twoJ, a,b,c,k,l,d) );
-
-              }// for d
-          }// for iket_abc
-        }// for ch_abc
-        zijkl /=  sqrt((1.+bra.delta_pq())*(1.+ket.delta_pq()));
-        Z2.AddToTBME(ch,ch,ibra,iket,zijkl);
-      }// for iket
-    }// for ibra
-  }// for ch
-  Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
+for (size_t ch_abc=0; ch_abc<nch3; ch_abc++)
+{
+ThreeBodyChannel& Tbc_abc = Z.modelspace->GetThreeBodyChannel(ch_abc);
+if ( std::abs( Tbc_abc.twoTz - 2*tbc.Tz) > 1) continue;
+int twoJ = Tbc_abc.twoJ;
+size_t nkets_abc = Tbc_abc.GetNumberKets();
+for (size_t iket_abc=0; iket_abc<nkets_abc; iket_abc++)
+{
+Ket3& ket_abc = Tbc_abc.GetKet(iket_abc);
+size_t a = ket_abc.p;
+size_t b = ket_abc.q;
+size_t c = ket_abc.r;
+double occ_abc = ket_abc.op->occ * ket_abc.oq->occ * ket_abc.oR->occ;
+double occ_abc_bar = (1-ket_abc.op->occ) * (1-ket_abc.oq->occ) * (1-ket_abc.oR->occ);
+if ( (std::abs(occ_abc)==0) and (std::abs(occ_abc_bar)==0) ) continue;
+int Jab = ket_abc.Jpq;
+
+double symm_factor = 6;  // 6 possible orderings of abc. If a==b, then only 3 orderings, and if a==b==c, then only 1 ordering.
+if ( a==b and b==c )
+symm_factor = 1;
+else if (a==b or a==c or b==c )
+symm_factor = 3;
+
+for ( auto d : Z.modelspace->all_orbits )
+{
+Orbit& od = Z.modelspace->GetOrbit(d);
+double nd = od.occ;
+double occfactor = occ_abc*(1-nd) - occ_abc_bar*nd ;
+if (std::abs(occfactor)<1e-6) continue;
+if ( (std::abs( 2*J-od.j2) > twoJ) or (2*J+od.j2)<twoJ ) continue;
+if ( (od.l+tbc.parity + Tbc_abc.parity)%2>0) continue;
+if ( (Tbc_abc.twoTz)!=(od.tz2 + 2*tbc.Tz) ) continue;
+zijkl += symm_factor * 1./6  * (twoJ+1.)/(2*J+1) * occfactor
+   *(  X3.GetME_pn(J,Jab,twoJ, i,j,d,a,b,c) * Y3.GetME_pn(Jab, J, twoJ, a,b,c,k,l,d)
+   - Y3.GetME_pn(J,Jab,twoJ, i,j,d,a,b,c) * X3.GetME_pn(Jab, J, twoJ, a,b,c,k,l,d) );
+
+   }// for d
+   }// for iket_abc
+   }// for ch_abc
+   zijkl /=  sqrt((1.+bra.delta_pq())*(1.+ket.delta_pq()));
+   Z2.AddToTBME(ch,ch,ibra,iket,zijkl);
+   }// for iket
+}// for ibra
+}// for ch
+Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
 }
 */
 
@@ -3597,8 +3819,8 @@ void comm332_ppph_hhhpss( const Operator& X, const Operator& Y, Operator& Z )
 //   *~~~[X]~~*  |            Z_ijkl = 1/6 sum_abcd (nanbncn`d -n`an`bn`cnd)(X_ijdabc Y_abckld - Y_ijdabc Xabckld)
 //  / \  / \  |  |                  + 1/4 (1-Pij)(1-Pkl) sum_{abcd} nanbn`cn`d ( X_abicdk Y_cdjabl - Y_abicdk X_cdjabl )
 // (a c)(b d) |  |
-//  \ /  \ /  |  |     
-//   *~~~[Y]~~|~~*       
+//  \ /  \ /  |  |
+//   *~~~[Y]~~|~~*
 //            |  |   Coupled expression:
 //           k| l|     Z_{ijkl}^{J} = 1/6 sum_abcd (nanbncn`d-n`an`bn`cnd) 1/(2J+1) sum_J1J' (2J'+1)(X_{ijdabc}^{J J1 J'} Y_{abckld}^{J1 J J'} - X<->Y )
 //                                    + 1/4  (1-Pij^J)(1-Pkl^J) sum_{abcd} nanbn`cn`d sum_{J1 J2 J' J"} (2J'+1)(2J"+1)  (-1)^{2J+J2+J'+J"+2j-i-k}
@@ -3617,68 +3839,151 @@ void comm332_ppph_hhhpss( const Operator& X, const Operator& Y, Operator& Z )
 //    *~~~[Y]~~~*
 //              | \
 //             l|  \j'
-//              
-//        Tested with UnitTest and passed.                                                               
+//
+//        Tested with UnitTest and passed.
 //
 void comm332_pphhss( const Operator& X, const Operator& Y, Operator& Z )
 {
   double tstart = omp_get_wtime();
-//  double t_internal = omp_get_wtime();
+  //  double t_internal = omp_get_wtime();
   auto& X3 = X.ThreeBody;
   auto& Y3 = Y.ThreeBody;
   auto& Z2 = Z.TwoBody;
   std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
-//  std::cout << "  fermi levels " << e_fermi[-1] << " " << e_fermi[+1] << std::endl;
- 
+  //  std::cout << "  fermi levels " << e_fermi[-1] << " " << e_fermi[+1] << std::endl;
 
-   size_t nch = Z.modelspace->GetNumberTwoBodyChannels();
-   size_t nch_CC = Z.modelspace->TwoBodyChannels_CC.size();
 
-   std::deque<arma::mat> Z_bar ( nch_CC );
-   std::deque<arma::mat> Z_bar_flipbra ( nch_CC );
-   std::deque<arma::mat> Z_bar_flipket ( nch_CC );
-   std::deque<arma::mat> Z_bar_flipboth ( nch_CC );
+  size_t nch = Z.modelspace->GetNumberTwoBodyChannels();
+  size_t nch_CC = Z.modelspace->TwoBodyChannels_CC.size();
 
-   // before entering the parallel loop, lets allocate the Pandya-transformed matrices Zbar.
-   // we keep 4 because we want i<j and i>j and k<l and k>l
-   for (size_t ch=0;ch<nch_CC;++ch)
-   {
-      TwoBodyChannel_CC& tbc_CC = Z.modelspace->GetTwoBodyChannel_CC(ch);
-      index_t nKets_cc = tbc_CC.GetNumberKets();
+  std::deque<arma::mat> Z_bar ( nch_CC );
+  std::deque<arma::mat> Z_bar_flipbra ( nch_CC );
+  std::deque<arma::mat> Z_bar_flipket ( nch_CC );
+  std::deque<arma::mat> Z_bar_flipboth ( nch_CC );
 
-      Z_bar[ch].zeros( nKets_cc, nKets_cc );
-      Z_bar_flipbra[ch].zeros( nKets_cc, nKets_cc );
-      Z_bar_flipket[ch].zeros( nKets_cc, nKets_cc );
-      Z_bar_flipboth[ch].zeros( nKets_cc, nKets_cc );
-   }
+  // before entering the parallel loop, lets allocate the Pandya-transformed matrices Zbar.
+  // we keep 4 because we want i<j and i>j and k<l and k>l
+  for (size_t ch=0;ch<nch_CC;++ch)
+  {
+    TwoBodyChannel_CC& tbc_CC = Z.modelspace->GetTwoBodyChannel_CC(ch);
+    index_t nKets_cc = tbc_CC.GetNumberKets();
 
-   double occnat_factor_max = 0;
-   for ( auto i : Z.modelspace->all_orbits)
-   {
-      double occnat_i = Z.modelspace->GetOrbit(i).occ_nat;
-      occnat_factor_max = std::max( occnat_factor_max, occnat_i*(1-occnat_i) );
-   }
+    Z_bar[ch].zeros( nKets_cc, nKets_cc );
+    Z_bar_flipbra[ch].zeros( nKets_cc, nKets_cc );
+    Z_bar_flipket[ch].zeros( nKets_cc, nKets_cc );
+    Z_bar_flipboth[ch].zeros( nKets_cc, nKets_cc );
+  }
+
+  double occnat_factor_max = 0;
+  for ( auto i : Z.modelspace->all_orbits)
+  {
+    double occnat_i = Z.modelspace->GetOrbit(i).occ_nat;
+    occnat_factor_max = std::max( occnat_factor_max, occnat_i*(1-occnat_i) );
+  }
 
   // Loop through Pandya-transformed channels and compute the matrix Zbar by mat mult
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
-   for (size_t ch=0;ch<nch_CC;++ch)
-   {
-      TwoBodyChannel_CC& tbc_CC = Z.modelspace->GetTwoBodyChannel_CC(ch);
-      index_t nKets_cc = tbc_CC.GetNumberKets();
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+  for (size_t ch=0;ch<nch_CC;++ch)
+  {
+    TwoBodyChannel_CC& tbc_CC = Z.modelspace->GetTwoBodyChannel_CC(ch);
+    index_t nKets_cc = tbc_CC.GetNumberKets();
+
+    int J_ph = tbc_CC.J;
+    int parity_ph = tbc_CC.parity;
+    int Tz_ph = tbc_CC.Tz;
+
+    size_t n_abcd_states = 0;
+
+    // count the abcd states that can act in this channel
+    for (int ch_ab=0; ch_ab<nch; ch_ab++)
+    {
+      TwoBodyChannel& tbc_ab = Z.modelspace->GetTwoBodyChannel(ch_ab);
+      int Jab = tbc_ab.J;
+      int nkets_ab = tbc_ab.GetNumberKets();
+
+      for (int ch_cd=0; ch_cd<nch; ch_cd++)
+      {
+        TwoBodyChannel& tbc_cd = Z.modelspace->GetTwoBodyChannel(ch_cd);
+        int Jcd = tbc_cd.J;
+        int nkets_cd = tbc_cd.GetNumberKets();
+        if (  std::abs(Jab-Jcd)>J_ph or (Jab+Jcd)<J_ph ) continue;
+        if ( (tbc_ab.parity + tbc_cd.parity + tbc_CC.parity)%2 >0 ) continue;
+        if ( std::abs( tbc_cd.Tz - tbc_ab.Tz) != tbc_CC.Tz ) continue;
+        for (int iket_ab=0; iket_ab<nkets_ab; iket_ab++)
+        {
+          Ket& ket_ab = tbc_ab.GetKet(iket_ab);
+          int a = ket_ab.p;
+          int b = ket_ab.q;
+          double na = ket_ab.op->occ;
+          double nb = ket_ab.oq->occ;
+          double occnat_a = ket_ab.op->occ_nat;
+          double occnat_b = ket_ab.oq->occ_nat;
+          double d_ea = std::abs(2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2]);
+          double d_eb = std::abs(2*ket_ab.oq->n + ket_ab.oq->l - e_fermi[ket_ab.oq->tz2]);
+          if ( na*nb<1e-8 and (1-na)*(1-nb)<1e-8 ) continue;
+          if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_factor_max ) < Z.modelspace->GetOccNat3Cut() ) continue ;
+          if ( (d_ea + d_eb) > Z.modelspace->GetdE3max() ) continue;
+
+          for (int iket_cd=0; iket_cd<nkets_cd; iket_cd++)
+          {
+            Ket& ket_cd = tbc_cd.GetKet(iket_cd);
+            int c = ket_cd.p;
+            int d = ket_cd.q;
+            double nc = ket_cd.op->occ;
+            double nd = ket_cd.oq->occ;
+            double occnat_c = ket_cd.op->occ_nat;
+            double occnat_d = ket_cd.oq->occ_nat;
+            double d_ec = std::abs(2*ket_cd.op->n + ket_cd.op->l - e_fermi[ket_cd.op->tz2]);
+            double d_ed = std::abs(2*ket_cd.oq->n + ket_cd.oq->l - e_fermi[ket_cd.oq->tz2]);
+            double occupation_factor = (1-na)*(1-nb)*nc*nd - na*nb*(1-nc)*(1-nd);
+            if (std::abs(occupation_factor)<1e-6) continue;
+            if ( (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_factor_max ) < Z.modelspace->GetOccNat3Cut() ) continue ;
+            if ( (d_ec + d_ed) > Z.modelspace->GetdE3max() ) continue;
+
+            n_abcd_states++;
+
+          }// for iket_cd
+        }// for iket_ab
+      }// for ch_cd
+    }// for ch_ab
+
+
+    // Now that we know how big they are, allocate the matrices
+    arma::mat X3_ij( nKets_cc, n_abcd_states, arma::fill::zeros );
+    arma::mat X3_ji( nKets_cc, n_abcd_states, arma::fill::zeros );
+    arma::mat Y3_ij( n_abcd_states, nKets_cc, arma::fill::zeros );
+    arma::mat Y3_ji( n_abcd_states, nKets_cc, arma::fill::zeros );
+
+
+    // Fill the matrices, which are basically <ij`| X | cd a`b`> type things (the ticks ` mean time-reversed state)
+    for (size_t ibra_CC=0; ibra_CC<nKets_cc; ibra_CC++)
+    {
+      Ket& bra_CC = tbc_CC.GetKet(ibra_CC);
+      int i = bra_CC.p;
+      int j = bra_CC.q;
+      Orbit& oi = Z.modelspace->GetOrbit(i);
+      Orbit& oj = Z.modelspace->GetOrbit(j);
 
-      int J_ph = tbc_CC.J;
-      int parity_ph = tbc_CC.parity;
-      int Tz_ph = tbc_CC.Tz;
 
-      size_t n_abcd_states = 0;
+      int j2i = oi.j2;
+      int j2j = oj.j2;
+      double ji = 0.5*j2i;
+      double jj = 0.5*j2j;
+      int phase_ij = Z.modelspace->phase( (j2i+j2j)/2);
+
+      double d_ei = std::abs(2*oi.n + oi.l - e_fermi[oi.tz2]);
+      double d_ej = std::abs(2*oj.n + oj.l - e_fermi[oj.tz2]);
+      double occnat_i = oi.occ_nat;
+      double occnat_j = oj.occ_nat;
 
-      // count the abcd states that can act in this channel
+      size_t ind_abcd = -1;
       for (int ch_ab=0; ch_ab<nch; ch_ab++)
       {
         TwoBodyChannel& tbc_ab = Z.modelspace->GetTwoBodyChannel(ch_ab);
         int Jab = tbc_ab.J;
         int nkets_ab = tbc_ab.GetNumberKets();
 
+
         for (int ch_cd=0; ch_cd<nch; ch_cd++)
         {
           TwoBodyChannel& tbc_cd = Z.modelspace->GetTwoBodyChannel(ch_cd);
@@ -3687,6 +3992,22 @@ void comm332_pphhss( const Operator& X, const Operator& Y, Operator& Z )
           if (  std::abs(Jab-Jcd)>J_ph or (Jab+Jcd)<J_ph ) continue;
           if ( (tbc_ab.parity + tbc_cd.parity + tbc_CC.parity)%2 >0 ) continue;
           if ( std::abs( tbc_cd.Tz - tbc_ab.Tz) != tbc_CC.Tz ) continue;
+
+
+          int twoJp_min = std::min( {std::abs(2*Jab-j2i), std::abs(2*Jcd-j2j), std::abs(2*Jab-j2j), std::abs(2*Jcd-j2i) });
+          int twoJp_max = std::max( {(2*Jab+j2i), (2*Jcd+j2j), (2*Jab+j2j), (2*Jcd+j2i) });
+          std::vector<double> sixj_ij_list;
+          std::vector<double> sixj_ji_list;
+          for ( int twoJp=twoJp_min; twoJp<=twoJp_max; twoJp+=2)
+          {
+            sixj_ij_list.push_back( (twoJp+1) * Z.modelspace->GetSixJ(ji,jj,J_ph, Jcd,Jab,0.5*twoJp) * Z.modelspace->phase((j2i+twoJp)/2) );
+            sixj_ji_list.push_back( (twoJp+1) * Z.modelspace->GetSixJ(jj,ji,J_ph, Jcd,Jab,0.5*twoJp) * Z.modelspace->phase((j2j+twoJp)/2) );
+          }
+
+          bool abi_cdj_Tz_ok = (  (2*tbc_ab.Tz + oi.tz2) == (2*tbc_cd.Tz + oj.tz2) );
+          bool abj_cdi_Tz_ok = (  (2*tbc_ab.Tz + oj.tz2) == (2*tbc_cd.Tz + oi.tz2) );
+
+
           for (int iket_ab=0; iket_ab<nkets_ab; iket_ab++)
           {
             Ket& ket_ab = tbc_ab.GetKet(iket_ab);
@@ -3694,401 +4015,302 @@ void comm332_pphhss( const Operator& X, const Operator& Y, Operator& Z )
             int b = ket_ab.q;
             double na = ket_ab.op->occ;
             double nb = ket_ab.oq->occ;
-            double occnat_a = ket_ab.op->occ_nat;
-            double occnat_b = ket_ab.oq->occ_nat;
+            if ( na*nb<1e-8 and (1-na)*(1-nb)<1e-8 ) continue;
             double d_ea = std::abs(2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2]);
             double d_eb = std::abs(2*ket_ab.oq->n + ket_ab.oq->l - e_fermi[ket_ab.oq->tz2]);
-            if ( na*nb<1e-8 and (1-na)*(1-nb)<1e-8 ) continue;
+            double occnat_a = ket_ab.op->occ_nat;
+            double occnat_b = ket_ab.oq->occ_nat;
+            bool keep_abi = ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_i*(1-occnat_i) ) >= Z.modelspace->GetOccNat3Cut() ) ;
+            bool keep_abj = ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_j*(1-occnat_j) ) >= Z.modelspace->GetOccNat3Cut() ) ;
+            keep_abi = keep_abi and (d_ea+d_eb+d_ei <= Z.modelspace->dE3max );
+            keep_abj = keep_abj and (d_ea+d_eb+d_ej <= Z.modelspace->dE3max );
+
             if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_factor_max ) < Z.modelspace->GetOccNat3Cut() ) continue ;
             if ( (d_ea + d_eb) > Z.modelspace->GetdE3max() ) continue;
 
-            for (int iket_cd=0; iket_cd<nkets_cd; iket_cd++)
-            {
-              Ket& ket_cd = tbc_cd.GetKet(iket_cd);
-              int c = ket_cd.p;
-              int d = ket_cd.q;
-              double nc = ket_cd.op->occ;
-              double nd = ket_cd.oq->occ;
-              double occnat_c = ket_cd.op->occ_nat;
-              double occnat_d = ket_cd.oq->occ_nat;
-              double d_ec = std::abs(2*ket_cd.op->n + ket_cd.op->l - e_fermi[ket_cd.op->tz2]);
-              double d_ed = std::abs(2*ket_cd.oq->n + ket_cd.oq->l - e_fermi[ket_cd.oq->tz2]);
-              double occupation_factor = (1-na)*(1-nb)*nc*nd - na*nb*(1-nc)*(1-nd);
-              if (std::abs(occupation_factor)<1e-6) continue;
-              if ( (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_factor_max ) < Z.modelspace->GetOccNat3Cut() ) continue ;
-              if ( (d_ec + d_ed) > Z.modelspace->GetdE3max() ) continue;
-
-              n_abcd_states++;
-
-            }// for iket_cd
-          }// for iket_ab
-        }// for ch_cd
-      }// for ch_ab
-      
-
-      // Now that we know how big they are, allocate the matrices
-      arma::mat X3_ij( nKets_cc, n_abcd_states, arma::fill::zeros );
-      arma::mat X3_ji( nKets_cc, n_abcd_states, arma::fill::zeros );
-      arma::mat Y3_ij( n_abcd_states, nKets_cc, arma::fill::zeros );
-      arma::mat Y3_ji( n_abcd_states, nKets_cc, arma::fill::zeros );
-
-
-      // Fill the matrices, which are basically <ij`| X | cd a`b`> type things (the ticks ` mean time-reversed state)
-      for (size_t ibra_CC=0; ibra_CC<nKets_cc; ibra_CC++)
-      {
-        Ket& bra_CC = tbc_CC.GetKet(ibra_CC);
-        int i = bra_CC.p;
-        int j = bra_CC.q;
-        Orbit& oi = Z.modelspace->GetOrbit(i);
-        Orbit& oj = Z.modelspace->GetOrbit(j);
-
-
-        int j2i = oi.j2;
-        int j2j = oj.j2;
-        double ji = 0.5*j2i;
-        double jj = 0.5*j2j;
-        int phase_ij = Z.modelspace->phase( (j2i+j2j)/2);
-
-        double d_ei = std::abs(2*oi.n + oi.l - e_fermi[oi.tz2]);
-        double d_ej = std::abs(2*oj.n + oj.l - e_fermi[oj.tz2]);
-        double occnat_i = oi.occ_nat;
-        double occnat_j = oj.occ_nat;
-
-        size_t ind_abcd = -1;
-        for (int ch_ab=0; ch_ab<nch; ch_ab++)
-        {
-          TwoBodyChannel& tbc_ab = Z.modelspace->GetTwoBodyChannel(ch_ab);
-          int Jab = tbc_ab.J;
-          int nkets_ab = tbc_ab.GetNumberKets();
-
+            std::vector<size_t> ch_abi_list;
+            std::vector<size_t> ch_abj_list;
+            std::vector<std::vector<size_t>> kets_abi_list;
+            std::vector<std::vector<size_t>> kets_abj_list;
+            std::vector<std::vector<double>> recouple_abi_list;
+            std::vector<std::vector<double>> recouple_abj_list;
 
-          for (int ch_cd=0; ch_cd<nch; ch_cd++)
-          {
-            TwoBodyChannel& tbc_cd = Z.modelspace->GetTwoBodyChannel(ch_cd);
-            int Jcd = tbc_cd.J;
-            int nkets_cd = tbc_cd.GetNumberKets();
-            if (  std::abs(Jab-Jcd)>J_ph or (Jab+Jcd)<J_ph ) continue;
-            if ( (tbc_ab.parity + tbc_cd.parity + tbc_CC.parity)%2 >0 ) continue;
-            if ( std::abs( tbc_cd.Tz - tbc_ab.Tz) != tbc_CC.Tz ) continue;
-
-
-            int twoJp_min = std::min( {std::abs(2*Jab-j2i), std::abs(2*Jcd-j2j), std::abs(2*Jab-j2j), std::abs(2*Jcd-j2i) });
-            int twoJp_max = std::max( {(2*Jab+j2i), (2*Jcd+j2j), (2*Jab+j2j), (2*Jcd+j2i) });
-            std::vector<double> sixj_ij_list;
-            std::vector<double> sixj_ji_list;
-            for ( int twoJp=twoJp_min; twoJp<=twoJp_max; twoJp+=2)
-            {
-              sixj_ij_list.push_back( (twoJp+1) * Z.modelspace->GetSixJ(ji,jj,J_ph, Jcd,Jab,0.5*twoJp) * Z.modelspace->phase((j2i+twoJp)/2) );
-              sixj_ji_list.push_back( (twoJp+1) * Z.modelspace->GetSixJ(jj,ji,J_ph, Jcd,Jab,0.5*twoJp) * Z.modelspace->phase((j2j+twoJp)/2) );
-            }
-
-            bool abi_cdj_Tz_ok = (  (2*tbc_ab.Tz + oi.tz2) == (2*tbc_cd.Tz + oj.tz2) );
-            bool abj_cdi_Tz_ok = (  (2*tbc_ab.Tz + oj.tz2) == (2*tbc_cd.Tz + oi.tz2) );
-
-
-            for (int iket_ab=0; iket_ab<nkets_ab; iket_ab++)
+            if ( keep_abi or keep_abj )
             {
-              Ket& ket_ab = tbc_ab.GetKet(iket_ab);
-              int a = ket_ab.p;
-              int b = ket_ab.q;
-              double na = ket_ab.op->occ;
-              double nb = ket_ab.oq->occ;
-              if ( na*nb<1e-8 and (1-na)*(1-nb)<1e-8 ) continue;
-              double d_ea = std::abs(2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2]);
-              double d_eb = std::abs(2*ket_ab.oq->n + ket_ab.oq->l - e_fermi[ket_ab.oq->tz2]);
-              double occnat_a = ket_ab.op->occ_nat;
-              double occnat_b = ket_ab.oq->occ_nat;
-              bool keep_abi = ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_i*(1-occnat_i) ) >= Z.modelspace->GetOccNat3Cut() ) ;
-              bool keep_abj = ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_j*(1-occnat_j) ) >= Z.modelspace->GetOccNat3Cut() ) ;
-              keep_abi = keep_abi and (d_ea+d_eb+d_ei <= Z.modelspace->dE3max );
-              keep_abj = keep_abj and (d_ea+d_eb+d_ej <= Z.modelspace->dE3max );
-
-              if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_factor_max ) < Z.modelspace->GetOccNat3Cut() ) continue ;
-              if ( (d_ea + d_eb) > Z.modelspace->GetdE3max() ) continue;
-
-              std::vector<size_t> ch_abi_list;
-              std::vector<size_t> ch_abj_list;
-              std::vector<std::vector<size_t>> kets_abi_list;
-              std::vector<std::vector<size_t>> kets_abj_list;
-              std::vector<std::vector<double>> recouple_abi_list;
-              std::vector<std::vector<double>> recouple_abj_list;
-
-              if ( keep_abi or keep_abj )
+              for ( int twoJp=twoJp_min; twoJp<=twoJp_max; twoJp+=2)
               {
-                for ( int twoJp=twoJp_min; twoJp<=twoJp_max; twoJp+=2)
+                std::vector<size_t> ketlist;
+                std::vector<double> reclist;
+                size_t ch_check = -1;
+                if ( keep_abi  and abi_cdj_Tz_ok and (std::abs(2*Jab-oi.j2)<=twoJp) and (2*Jab+oi.j2 >=twoJp) )
                 {
-                  std::vector<size_t> ketlist;
-                  std::vector<double> reclist;
-                  size_t ch_check = -1;
-                  if ( keep_abi  and abi_cdj_Tz_ok and (std::abs(2*Jab-oi.j2)<=twoJp) and (2*Jab+oi.j2 >=twoJp) )
-                  {
-                    ch_check = Y.ThreeBody.GetKetIndex_withRecoupling( Jab, twoJp, a, b, i, ketlist, reclist) ;
-                  }
-                  ch_abi_list.push_back( ch_check );
-                  kets_abi_list.push_back( ketlist );
-                  recouple_abi_list.push_back( reclist );
-                  ketlist.clear();
-                  reclist.clear();
-                  ch_check = -1;
-                  if ( keep_abj  and abj_cdi_Tz_ok  and (std::abs(2*Jab-oj.j2)<=twoJp) and (2*Jab+oj.j2 >=twoJp) )
-                  {
-                    ch_check = Y.ThreeBody.GetKetIndex_withRecoupling( Jab, twoJp, a, b, j, ketlist, reclist) ;
-                  }
-                  ch_abj_list.push_back( ch_check );
-                  kets_abj_list.push_back( ketlist );
-                  recouple_abj_list.push_back( reclist );
+                  ch_check = Y.ThreeBody.GetKetIndex_withRecoupling( Jab, twoJp, a, b, i, ketlist, reclist) ;
                 }
+                ch_abi_list.push_back( ch_check );
+                kets_abi_list.push_back( ketlist );
+                recouple_abi_list.push_back( reclist );
+                ketlist.clear();
+                reclist.clear();
+                ch_check = -1;
+                if ( keep_abj  and abj_cdi_Tz_ok  and (std::abs(2*Jab-oj.j2)<=twoJp) and (2*Jab+oj.j2 >=twoJp) )
+                {
+                  ch_check = Y.ThreeBody.GetKetIndex_withRecoupling( Jab, twoJp, a, b, j, ketlist, reclist) ;
+                }
+                ch_abj_list.push_back( ch_check );
+                kets_abj_list.push_back( ketlist );
+                recouple_abj_list.push_back( reclist );
               }
+            }
 
 
-              for (int iket_cd=0; iket_cd<nkets_cd; iket_cd++)
-              {
-                Ket& ket_cd = tbc_cd.GetKet(iket_cd);
-                int c = ket_cd.p;
-                int d = ket_cd.q;
-                double nc = ket_cd.op->occ;
-                double nd = ket_cd.oq->occ;
-                double d_ec = std::abs(2*ket_cd.op->n + ket_cd.op->l - e_fermi[ket_cd.op->tz2]);
-                double d_ed = std::abs(2*ket_cd.oq->n + ket_cd.oq->l - e_fermi[ket_cd.oq->tz2]);
-                double occnat_c = ket_cd.op->occ_nat;
-                double occnat_d = ket_cd.oq->occ_nat;
-                double occupation_factor = (1-na)*(1-nb)*nc*nd - na*nb*(1-nc)*(1-nd);
-                if (std::abs(occupation_factor)<1e-6) continue;
+            for (int iket_cd=0; iket_cd<nkets_cd; iket_cd++)
+            {
+              Ket& ket_cd = tbc_cd.GetKet(iket_cd);
+              int c = ket_cd.p;
+              int d = ket_cd.q;
+              double nc = ket_cd.op->occ;
+              double nd = ket_cd.oq->occ;
+              double d_ec = std::abs(2*ket_cd.op->n + ket_cd.op->l - e_fermi[ket_cd.op->tz2]);
+              double d_ed = std::abs(2*ket_cd.oq->n + ket_cd.oq->l - e_fermi[ket_cd.oq->tz2]);
+              double occnat_c = ket_cd.op->occ_nat;
+              double occnat_d = ket_cd.oq->occ_nat;
+              double occupation_factor = (1-na)*(1-nb)*nc*nd - na*nb*(1-nc)*(1-nd);
+              if (std::abs(occupation_factor)<1e-6) continue;
 
-                if ( (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_factor_max ) < Z.modelspace->GetOccNat3Cut() ) continue ;
-                if ( (d_ec + d_ed) > Z.modelspace->GetdE3max() ) continue;
+              if ( (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_factor_max ) < Z.modelspace->GetOccNat3Cut() ) continue ;
+              if ( (d_ec + d_ed) > Z.modelspace->GetdE3max() ) continue;
 
-                double symmetry_factor = 1;  // we only sum a<=b and c<=d, so we undercount by a factor of 4, canceling the 1/4 in the formula 
-                if (a==b) symmetry_factor *= 0.5; // if a==b or c==d, then the permutation doesn't give a new state, so there's less undercounting
-                if (c==d) symmetry_factor *= 0.5;
+              double symmetry_factor = 1;  // we only sum a<=b and c<=d, so we undercount by a factor of 4, canceling the 1/4 in the formula
+              if (a==b) symmetry_factor *= 0.5; // if a==b or c==d, then the permutation doesn't give a new state, so there's less undercounting
+              if (c==d) symmetry_factor *= 0.5;
 
-                ind_abcd++; // increment the matrix index.
+              ind_abcd++; // increment the matrix index.
 
-                if ( not ( keep_abi or keep_abj) ) continue; // need this after the ind_abcd++... maybe be more clever?
+              if ( not ( keep_abi or keep_abj) ) continue; // need this after the ind_abcd++... maybe be more clever?
 
-                bool keep_cdi = ( (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_i*(1-occnat_i) ) >= Z.modelspace->GetOccNat3Cut() ) ;
-                bool keep_cdj = ( (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_j*(1-occnat_j) ) >= Z.modelspace->GetOccNat3Cut() ) ;
-                keep_cdi = keep_cdi and (d_ec+d_ed+d_ei <= Z.modelspace->dE3max );
-                keep_cdj = keep_cdj and (d_ec+d_ed+d_ej <= Z.modelspace->dE3max );
+              bool keep_cdi = ( (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_i*(1-occnat_i) ) >= Z.modelspace->GetOccNat3Cut() ) ;
+              bool keep_cdj = ( (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_j*(1-occnat_j) ) >= Z.modelspace->GetOccNat3Cut() ) ;
+              keep_cdi = keep_cdi and (d_ec+d_ed+d_ei <= Z.modelspace->dE3max );
+              keep_cdj = keep_cdj and (d_ec+d_ed+d_ej <= Z.modelspace->dE3max );
 
-                if ( not ( keep_cdi or keep_cdj) ) continue;
+              if ( not ( keep_cdi or keep_cdj) ) continue;
 
 
-                std::vector<size_t> ch_cdi_list;
-                std::vector<size_t> ch_cdj_list;
-                std::vector<std::vector<size_t>> kets_cdi_list;
-                std::vector<std::vector<size_t>> kets_cdj_list;
-                std::vector<std::vector<double>> recouple_cdi_list;
-                std::vector<std::vector<double>> recouple_cdj_list;
+              std::vector<size_t> ch_cdi_list;
+              std::vector<size_t> ch_cdj_list;
+              std::vector<std::vector<size_t>> kets_cdi_list;
+              std::vector<std::vector<size_t>> kets_cdj_list;
+              std::vector<std::vector<double>> recouple_cdi_list;
+              std::vector<std::vector<double>> recouple_cdj_list;
 
-                for ( int twoJp=twoJp_min; twoJp<=twoJp_max; twoJp+=2)
+              for ( int twoJp=twoJp_min; twoJp<=twoJp_max; twoJp+=2)
+              {
+                std::vector<size_t> ketlist;
+                std::vector<double> reclist;
+                size_t ch_check=-1;
+                if ( keep_abj and keep_cdi and abj_cdi_Tz_ok  and (std::abs(2*Jcd-oi.j2)<=twoJp) and (2*Jcd+oi.j2 >=twoJp) )
                 {
-                  std::vector<size_t> ketlist;
-                  std::vector<double> reclist;
-                  size_t ch_check=-1;
-                  if ( keep_abj and keep_cdi and abj_cdi_Tz_ok  and (std::abs(2*Jcd-oi.j2)<=twoJp) and (2*Jcd+oi.j2 >=twoJp) )
-                  {
-                    ch_check = Y.ThreeBody.GetKetIndex_withRecoupling( Jcd, twoJp, c, d, i, ketlist, reclist) ;
-                  }
-                  ch_cdi_list.push_back( ch_check );
-                  kets_cdi_list.push_back( ketlist );
-                  recouple_cdi_list.push_back( reclist );
-                  ketlist.clear();
-                  reclist.clear();
-                  ch_check = -1;
-                  if ( keep_abi and keep_cdj and abi_cdj_Tz_ok  and (std::abs(2*Jcd-oj.j2)<=twoJp) and (2*Jcd+oj.j2 >=twoJp) )
-                  {
-                    ch_check = Y.ThreeBody.GetKetIndex_withRecoupling( Jcd, twoJp, c, d, j, ketlist, reclist) ;
-                  }
-                  ch_cdj_list.push_back( ch_check );
-                  kets_cdj_list.push_back( ketlist );
-                  recouple_cdj_list.push_back( reclist );
-                }// for twoJp
-
-                for ( int twoJp=twoJp_min; twoJp<=twoJp_max; twoJp+=2)
+                  ch_check = Y.ThreeBody.GetKetIndex_withRecoupling( Jcd, twoJp, c, d, i, ketlist, reclist) ;
+                }
+                ch_cdi_list.push_back( ch_check );
+                kets_cdi_list.push_back( ketlist );
+                recouple_cdi_list.push_back( reclist );
+                ketlist.clear();
+                reclist.clear();
+                ch_check = -1;
+                if ( keep_abi and keep_cdj and abi_cdj_Tz_ok  and (std::abs(2*Jcd-oj.j2)<=twoJp) and (2*Jcd+oj.j2 >=twoJp) )
                 {
-                  double sixj_ij = sixj_ij_list[(twoJp-twoJp_min)/2]; // <-- these also include a phase and a (twoJp+1)
-                  double sixj_ji = sixj_ji_list[(twoJp-twoJp_min)/2];
+                  ch_check = Y.ThreeBody.GetKetIndex_withRecoupling( Jcd, twoJp, c, d, j, ketlist, reclist) ;
+                }
+                ch_cdj_list.push_back( ch_check );
+                kets_cdj_list.push_back( ketlist );
+                recouple_cdj_list.push_back( reclist );
+              }// for twoJp
+
+              for ( int twoJp=twoJp_min; twoJp<=twoJp_max; twoJp+=2)
+              {
+                double sixj_ij = sixj_ij_list[(twoJp-twoJp_min)/2]; // <-- these also include a phase and a (twoJp+1)
+                double sixj_ji = sixj_ji_list[(twoJp-twoJp_min)/2];
 
-                  if ( keep_abi and keep_cdj and abi_cdj_Tz_ok   )
+                if ( keep_abi and keep_cdj and abi_cdj_Tz_ok   )
+                {
+                  size_t ch_abi = ch_abi_list[(twoJp-twoJp_min)/2];
+                  auto& kets_abi = kets_abi_list[(twoJp-twoJp_min)/2];
+                  auto& kets_cdj = kets_cdj_list[(twoJp-twoJp_min)/2];
+                  auto& recouple_abi = recouple_abi_list[(twoJp-twoJp_min)/2];
+                  auto& recouple_cdj = recouple_cdj_list[(twoJp-twoJp_min)/2];
+                  double xabicdj = 0;
+                  double ycdjabi = 0;
+                  for ( size_t Iabi=0; Iabi<kets_abi.size(); Iabi++)
                   {
-                    size_t ch_abi = ch_abi_list[(twoJp-twoJp_min)/2];
-                    auto& kets_abi = kets_abi_list[(twoJp-twoJp_min)/2];
-                    auto& kets_cdj = kets_cdj_list[(twoJp-twoJp_min)/2];
-                    auto& recouple_abi = recouple_abi_list[(twoJp-twoJp_min)/2];
-                    auto& recouple_cdj = recouple_cdj_list[(twoJp-twoJp_min)/2];
-                    double xabicdj = 0;
-                    double ycdjabi = 0;
-                    for ( size_t Iabi=0; Iabi<kets_abi.size(); Iabi++)
+                    for ( size_t Icdj=0; Icdj<kets_cdj.size(); Icdj++)
                     {
-                      for ( size_t Icdj=0; Icdj<kets_cdj.size(); Icdj++)
-                      {
-                         xabicdj += recouple_abi[Iabi] * recouple_cdj[Icdj] * X3.GetME_pn_PN_ch(ch_abi,ch_abi, kets_abi[Iabi], kets_cdj[Icdj] );
-                         ycdjabi += recouple_abi[Iabi] * recouple_cdj[Icdj] * Y3.GetME_pn_PN_ch(ch_abi,ch_abi, kets_cdj[Icdj], kets_abi[Iabi] );
-                      }
+                      xabicdj += recouple_abi[Iabi] * recouple_cdj[Icdj] * X3.GetME_pn_PN_ch(ch_abi,ch_abi, kets_abi[Iabi], kets_cdj[Icdj] );
+                      ycdjabi += recouple_abi[Iabi] * recouple_cdj[Icdj] * Y3.GetME_pn_PN_ch(ch_abi,ch_abi, kets_cdj[Icdj], kets_abi[Iabi] );
                     }
-                    X3_ij(ibra_CC, ind_abcd) +=  sixj_ij * xabicdj;
-                    Y3_ij(ind_abcd, ibra_CC) +=  sixj_ij * ycdjabi * occupation_factor * symmetry_factor ;
                   }
-                  
-                  if (keep_abj and keep_cdi and abj_cdi_Tz_ok)
+                  X3_ij(ibra_CC, ind_abcd) +=  sixj_ij * xabicdj;
+                  Y3_ij(ind_abcd, ibra_CC) +=  sixj_ij * ycdjabi * occupation_factor * symmetry_factor ;
+                }
+
+                if (keep_abj and keep_cdi and abj_cdi_Tz_ok)
+                {
+                  size_t ch_abj = ch_abj_list[(twoJp-twoJp_min)/2];
+                  auto& kets_abj = kets_abj_list[(twoJp-twoJp_min)/2];
+                  auto& kets_cdi = kets_cdi_list[(twoJp-twoJp_min)/2];
+                  auto& recouple_abj = recouple_abj_list[(twoJp-twoJp_min)/2];
+                  auto& recouple_cdi = recouple_cdi_list[(twoJp-twoJp_min)/2];
+                  double xabjcdi = 0;
+                  double ycdiabj = 0;
+                  for ( size_t Iabj=0; Iabj<kets_abj.size(); Iabj++)
                   {
-                    size_t ch_abj = ch_abj_list[(twoJp-twoJp_min)/2];
-                    auto& kets_abj = kets_abj_list[(twoJp-twoJp_min)/2];
-                    auto& kets_cdi = kets_cdi_list[(twoJp-twoJp_min)/2];
-                    auto& recouple_abj = recouple_abj_list[(twoJp-twoJp_min)/2];
-                    auto& recouple_cdi = recouple_cdi_list[(twoJp-twoJp_min)/2];
-                    double xabjcdi = 0;
-                    double ycdiabj = 0;
-                    for ( size_t Iabj=0; Iabj<kets_abj.size(); Iabj++)
+                    for ( size_t Icdi=0; Icdi<kets_cdi.size(); Icdi++)
                     {
-                      for ( size_t Icdi=0; Icdi<kets_cdi.size(); Icdi++)
-                      {
-                         xabjcdi += recouple_abj[Iabj] * recouple_cdi[Icdi] * X3.GetME_pn_PN_ch(ch_abj,ch_abj, kets_abj[Iabj], kets_cdi[Icdi] );
-                         ycdiabj += recouple_abj[Iabj] * recouple_cdi[Icdi] * Y3.GetME_pn_PN_ch(ch_abj,ch_abj, kets_cdi[Icdi], kets_abj[Iabj] );
-                      }
+                      xabjcdi += recouple_abj[Iabj] * recouple_cdi[Icdi] * X3.GetME_pn_PN_ch(ch_abj,ch_abj, kets_abj[Iabj], kets_cdi[Icdi] );
+                      ycdiabj += recouple_abj[Iabj] * recouple_cdi[Icdi] * Y3.GetME_pn_PN_ch(ch_abj,ch_abj, kets_cdi[Icdi], kets_abj[Iabj] );
                     }
-                    X3_ji(ibra_CC, ind_abcd) +=  sixj_ji * xabjcdi;
-                    Y3_ji(ind_abcd, ibra_CC) +=  sixj_ji * ycdiabj * occupation_factor * symmetry_factor;
                   }
+                  X3_ji(ibra_CC, ind_abcd) +=  sixj_ji * xabjcdi;
+                  Y3_ji(ind_abcd, ibra_CC) +=  sixj_ji * ycdiabj * occupation_factor * symmetry_factor;
+                }
 
-                }// for twoJp
+              }// for twoJp
 
-              }// for iket_cd
-            }// for iket_ab
-          }// for ch_cd
-        }// for ch_ab
+            }// for iket_cd
+          }// for iket_ab
+        }// for ch_cd
+      }// for ch_ab
 
-      }// for ibra_CC
+    }// for ibra_CC
 
-      Z_bar[ch] = X3_ij * Y3_ij;
-      Z_bar_flipbra[ch] = X3_ji * Y3_ij;
-      Z_bar_flipket[ch] = X3_ij * Y3_ji;
-      Z_bar_flipboth[ch] = X3_ji * Y3_ji;
+    Z_bar[ch] = X3_ij * Y3_ij;
+    Z_bar_flipbra[ch] = X3_ji * Y3_ij;
+    Z_bar_flipket[ch] = X3_ij * Y3_ji;
+    Z_bar_flipboth[ch] = X3_ji * Y3_ji;
 
-   }// for ch  (ph-coupled 2-body channels)
+  }// for ch  (ph-coupled 2-body channels)
 
-   
-//  Z.profiler.timer["comm332_CC_loops"] += omp_get_wtime() - t_internal;
-//  t_internal = omp_get_wtime();
 
-   // Now transform Zbar to Z
+  //  Z.profiler.timer["comm332_CC_loops"] += omp_get_wtime() - t_internal;
+  //  t_internal = omp_get_wtime();
 
-   #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
-   for (size_t ch=0; ch<nch; ch++)
-   {
-     TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
-     int J = tbc.J;
-     size_t nkets = tbc.GetNumberKets();
-     for (size_t ibra=0; ibra<nkets; ibra++)
-     {
-       Ket& bra = tbc.GetKet(ibra);
-       size_t i = bra.p;
-       size_t j = bra.q;
-       Orbit& oi = Z.modelspace->GetOrbit(i);
-       Orbit& oj = Z.modelspace->GetOrbit(j);
-       double ji = 0.5*oi.j2;
-       double jj = 0.5*oj.j2;
-       int phase_ij = Z.modelspace->phase( (oi.j2+oj.j2)/2-J);
-       for (size_t iket=ibra; iket<nkets; iket++)
-       {
-         Ket& ket = tbc.GetKet(iket);
-         size_t k = ket.p;
-         size_t l = ket.q;
-         Orbit& ok = Z.modelspace->GetOrbit(k);
-         Orbit& ol = Z.modelspace->GetOrbit(l);
-         double jk = 0.5*ok.j2;
-         double jl = 0.5*ol.j2;
-         int phase_kl = Z.modelspace->phase( (ok.j2+ol.j2)/2-J);
-
-         double zijkl = 0;
-
-         int parity_cc = (oi.l+ol.l)%2;
-         int Tz_cc = std::abs(oi.tz2-ol.tz2)/2;
-         int J_ph_min = std::max( std::abs(oi.j2-ol.j2), std::abs(ok.j2-oj.j2))/2;
-         int J_ph_max = std::min( (oi.j2+ol.j2), (ok.j2+oj.j2))/2;
-         for (int J_ph=J_ph_min; J_ph<=J_ph_max; J_ph++)
-         {
-           int ch_cc = Z.modelspace->GetTwoBodyChannelIndex(J_ph,parity_cc,Tz_cc);
-           TwoBodyChannel_CC& tbc_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_cc);
-           int indx_il = tbc_cc.GetLocalIndex(std::min(i,l),std::max(i,l)) ;
-           int indx_kj = tbc_cc.GetLocalIndex(std::min(k,j),std::max(k,j)) ;
-           double sixj = Z.modelspace->GetSixJ(ji,jj,J, jk,jl,J_ph);
-           double zbar_ilkj;
-           double zbar_jkli;
-           if (i<=l and k<=j) // il kj
-           {
-              zbar_ilkj = Z_bar[ch_cc](indx_il, indx_kj);
-              zbar_jkli = Z_bar_flipboth[ch_cc](indx_kj,indx_il);
-           }
-           else if ( i>l and k<=j) /// li kj
-           {
-              zbar_ilkj = Z_bar_flipbra[ch_cc](indx_il, indx_kj);
-              zbar_jkli = Z_bar_flipbra[ch_cc](indx_kj,indx_il);
-           }
-           else if ( i<=l and k>j) // il jk
-           {
-              zbar_ilkj = Z_bar_flipket[ch_cc](indx_il, indx_kj);
-              zbar_jkli = Z_bar_flipket[ch_cc](indx_kj,indx_il);
-           }
-           else  // li jk
-           {
-              zbar_ilkj = Z_bar_flipboth[ch_cc](indx_il, indx_kj);
-              zbar_jkli = Z_bar[ch_cc](indx_kj,indx_il);
-           }
-
-           zijkl += (2*J_ph+1)*sixj * ( zbar_ilkj + phase_ij*phase_kl * zbar_jkli);
-         }
-
-         parity_cc = (oj.l+ol.l)%2;
-         Tz_cc = std::abs(oj.tz2-ol.tz2)/2;
-         J_ph_min = std::max( std::abs(oj.j2-ol.j2), std::abs(ok.j2-oi.j2))/2;
-         J_ph_max = std::min( (oj.j2+ol.j2), (ok.j2+oi.j2))/2;
-         for (int J_ph=J_ph_min; J_ph<=J_ph_max; J_ph++)
-         {
-           int ch_cc = Z.modelspace->GetTwoBodyChannelIndex(J_ph,parity_cc,Tz_cc);
-           TwoBodyChannel_CC& tbc_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_cc);
-           int indx_jl = tbc_cc.GetLocalIndex(std::min(j,l),std::max(j,l)) ;
-           int indx_ki = tbc_cc.GetLocalIndex(std::min(k,i),std::max(k,i)) ;
-           double sixj = Z.modelspace->GetSixJ(jj,ji,J, jk,jl,J_ph);
-           double zbar_jlki;
-           double zbar_iklj;
-
-           if ( j<=l and k<=i )
-           {
-             zbar_jlki = Z_bar[ch_cc](indx_jl, indx_ki); // <-- this one
-             zbar_iklj = Z_bar_flipboth[ch_cc](indx_ki, indx_jl);
-           }
-           else if ( j<=l and k>i)
-           {
-             zbar_jlki = Z_bar_flipket[ch_cc](indx_jl, indx_ki);
-             zbar_iklj = Z_bar_flipket[ch_cc](indx_ki, indx_jl);
-           }
-           else if ( j>l and k<=i)
-           {
-             zbar_jlki = Z_bar_flipbra[ch_cc](indx_jl, indx_ki);
-             zbar_iklj = Z_bar_flipbra[ch_cc](indx_ki, indx_jl);
-           }
-           else if ( j>l and k>i)
-           {
-             zbar_jlki = Z_bar_flipboth[ch_cc](indx_jl, indx_ki);
-             zbar_iklj = Z_bar[ch_cc](indx_ki, indx_jl);
-           }
-
-           zijkl -= (2*J_ph+1)*sixj * ( phase_ij * zbar_jlki + phase_kl * zbar_iklj);
-
-         }       
+  // Now transform Zbar to Z
+
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+  for (size_t ch=0; ch<nch; ch++)
+  {
+    TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
+    int J = tbc.J;
+    size_t nkets = tbc.GetNumberKets();
+    for (size_t ibra=0; ibra<nkets; ibra++)
+    {
+      Ket& bra = tbc.GetKet(ibra);
+      size_t i = bra.p;
+      size_t j = bra.q;
+      Orbit& oi = Z.modelspace->GetOrbit(i);
+      Orbit& oj = Z.modelspace->GetOrbit(j);
+      double ji = 0.5*oi.j2;
+      double jj = 0.5*oj.j2;
+      int phase_ij = Z.modelspace->phase( (oi.j2+oj.j2)/2-J);
+      for (size_t iket=ibra; iket<nkets; iket++)
+      {
+        Ket& ket = tbc.GetKet(iket);
+        size_t k = ket.p;
+        size_t l = ket.q;
+        Orbit& ok = Z.modelspace->GetOrbit(k);
+        Orbit& ol = Z.modelspace->GetOrbit(l);
+        double jk = 0.5*ok.j2;
+        double jl = 0.5*ol.j2;
+        int phase_kl = Z.modelspace->phase( (ok.j2+ol.j2)/2-J);
+
+        double zijkl = 0;
+
+        int parity_cc = (oi.l+ol.l)%2;
+        int Tz_cc = std::abs(oi.tz2-ol.tz2)/2;
+        int J_ph_min = std::max( std::abs(oi.j2-ol.j2), std::abs(ok.j2-oj.j2))/2;
+        int J_ph_max = std::min( (oi.j2+ol.j2), (ok.j2+oj.j2))/2;
+        for (int J_ph=J_ph_min; J_ph<=J_ph_max; J_ph++)
+        {
+          int ch_cc = Z.modelspace->GetTwoBodyChannelIndex(J_ph,parity_cc,Tz_cc);
+          TwoBodyChannel_CC& tbc_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_cc);
+          int indx_il = tbc_cc.GetLocalIndex(std::min(i,l),std::max(i,l)) ;
+          int indx_kj = tbc_cc.GetLocalIndex(std::min(k,j),std::max(k,j)) ;
+          double sixj = Z.modelspace->GetSixJ(ji,jj,J, jk,jl,J_ph);
+          double zbar_ilkj;
+          double zbar_jkli;
+          if (i<=l and k<=j) // il kj
+          {
+            zbar_ilkj = Z_bar[ch_cc](indx_il, indx_kj);
+            zbar_jkli = Z_bar_flipboth[ch_cc](indx_kj,indx_il);
+          }
+          else if ( i>l and k<=j) /// li kj
+          {
+            zbar_ilkj = Z_bar_flipbra[ch_cc](indx_il, indx_kj);
+            zbar_jkli = Z_bar_flipbra[ch_cc](indx_kj,indx_il);
+          }
+          else if ( i<=l and k>j) // il jk
+          {
+            zbar_ilkj = Z_bar_flipket[ch_cc](indx_il, indx_kj);
+            zbar_jkli = Z_bar_flipket[ch_cc](indx_kj,indx_il);
+          }
+          else  // li jk
+          {
+            zbar_ilkj = Z_bar_flipboth[ch_cc](indx_il, indx_kj);
+            zbar_jkli = Z_bar[ch_cc](indx_kj,indx_il);
+          }
+
+          zijkl += (2*J_ph+1)*sixj * ( zbar_ilkj + phase_ij*phase_kl * zbar_jkli);
+        }
+
+        parity_cc = (oj.l+ol.l)%2;
+        Tz_cc = std::abs(oj.tz2-ol.tz2)/2;
+        J_ph_min = std::max( std::abs(oj.j2-ol.j2), std::abs(ok.j2-oi.j2))/2;
+        J_ph_max = std::min( (oj.j2+ol.j2), (ok.j2+oi.j2))/2;
+        for (int J_ph=J_ph_min; J_ph<=J_ph_max; J_ph++)
+        {
+          int ch_cc = Z.modelspace->GetTwoBodyChannelIndex(J_ph,parity_cc,Tz_cc);
+          TwoBodyChannel_CC& tbc_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_cc);
+          int indx_jl = tbc_cc.GetLocalIndex(std::min(j,l),std::max(j,l)) ;
+          int indx_ki = tbc_cc.GetLocalIndex(std::min(k,i),std::max(k,i)) ;
+          double sixj = Z.modelspace->GetSixJ(jj,ji,J, jk,jl,J_ph);
+          double zbar_jlki;
+          double zbar_iklj;
+
+          if ( j<=l and k<=i )
+          {
+            zbar_jlki = Z_bar[ch_cc](indx_jl, indx_ki); // <-- this one
+            zbar_iklj = Z_bar_flipboth[ch_cc](indx_ki, indx_jl);
+          }
+          else if ( j<=l and k>i)
+          {
+            zbar_jlki = Z_bar_flipket[ch_cc](indx_jl, indx_ki);
+            zbar_iklj = Z_bar_flipket[ch_cc](indx_ki, indx_jl);
+          }
+          else if ( j>l and k<=i)
+          {
+            zbar_jlki = Z_bar_flipbra[ch_cc](indx_jl, indx_ki);
+            zbar_iklj = Z_bar_flipbra[ch_cc](indx_ki, indx_jl);
+          }
+          else if ( j>l and k>i)
+          {
+            zbar_jlki = Z_bar_flipboth[ch_cc](indx_jl, indx_ki);
+            zbar_iklj = Z_bar[ch_cc](indx_ki, indx_jl);
+          }
+
+          zijkl -= (2*J_ph+1)*sixj * ( phase_ij * zbar_jlki + phase_kl * zbar_iklj);
+
+        }
 
         // make it a normalized TBME
         zijkl /=  sqrt((1.+bra.delta_pq())*(1.+ket.delta_pq()));
         // the AddToTBME routine automatically takes care of the hermitian conjugate as well
         Z2.AddToTBME(ch,ch,ibra,iket,zijkl);
- 
-       }// for iket
-     }// for ibra
-   }// for ch
 
-//  Z.profiler.timer["comm332_main_loop"] += omp_get_wtime() - t_internal;
+      }// for iket
+    }// for ibra
+  }// for ch
+
+  //  Z.profiler.timer["comm332_main_loop"] += omp_get_wtime() - t_internal;
 
   Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
 }
@@ -4096,17 +4318,17 @@ void comm332_pphhss( const Operator& X, const Operator& Y, Operator& Z )
 
 
 void comm332_pphhss_debug( const Operator& X, const Operator& Y, Operator& Z )
-//void comm332_pphhss( const Operator& X, const Operator& Y, Operator& Z )
+  //void comm332_pphhss( const Operator& X, const Operator& Y, Operator& Z )
 {
-//  std::cout << "================== BEGIN " << __func__ << " ===================" << std::endl;
+  //  std::cout << "================== BEGIN " << __func__ << " ===================" << std::endl;
   double tstart = omp_get_wtime();
   auto& X3 = X.ThreeBody;
   auto& Y3 = Y.ThreeBody;
   auto& Z2 = Z.TwoBody;
   std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
-  
+
   int nch = Z.modelspace->GetNumberTwoBodyChannels();
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
   for (int ch=0; ch<nch; ch++)
   {
     TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
@@ -4127,7 +4349,7 @@ void comm332_pphhss_debug( const Operator& X, const Operator& Y, Operator& Z )
       double d_ej = std::abs(2*bra.oq->n + bra.oq->l - e_fermi[bra.oq->tz2]);
       double occnat_i = bra.op->occ_nat;
       double occnat_j = bra.oq->occ_nat;
-      for (int iket=ibra; iket<nkets; iket++) 
+      for (int iket=ibra; iket<nkets; iket++)
       {
         Ket& ket = tbc.GetKet(iket);
         int k = ket.p;
@@ -4149,8 +4371,8 @@ void comm332_pphhss_debug( const Operator& X, const Operator& Y, Operator& Z )
 
         int J_ph_min = std::min( { std::abs(ji2 - jl2), std::abs(jj2-jk2), std::abs(jj2 - jl2), std::abs(ji2 - jk2)} )/2;
         int J_ph_max = std::max( {ji2+jl2, jj2+jk2, jj2+jl2, ji2+jk2} )/2;
-//        int J_ph_min = std::max( std::abs(ji2 - jl2), std::abs(jj2-jk2) )/2;
-//        int J_ph_max = std::min( ji2+jl2, jj2+jk2 )/2;
+        //        int J_ph_min = std::max( std::abs(ji2 - jl2), std::abs(jj2-jk2) )/2;
+        //        int J_ph_max = std::min( ji2+jl2, jj2+jk2 )/2;
 
         for (int J_ph=J_ph_min; J_ph<=J_ph_max; J_ph++)
         {
@@ -4209,8 +4431,8 @@ void comm332_pphhss_debug( const Operator& X, const Operator& Y, Operator& Z )
                   double d_ed = std::abs(2*ket_cd.oq->n + ket_cd.oq->l - e_fermi[ket_cd.oq->tz2]);
                   double occnat_c = ket_cd.op->occ_nat;
                   double occnat_d = ket_cd.oq->occ_nat;
-//                  double jc = 0.5*ket_cd.op->j2;
-//                  double jd = 0.5*ket_cd.oq->j2;
+                  //                  double jc = 0.5*ket_cd.op->j2;
+                  //                  double jd = 0.5*ket_cd.oq->j2;
                   double occupation_factor = (1-na)*(1-nb)*nc*nd - na*nb*(1-nc)*(1-nd);
                   if (std::abs(occupation_factor)<1e-6) continue;
 
@@ -4225,7 +4447,7 @@ void comm332_pphhss_debug( const Operator& X, const Operator& Y, Operator& Z )
                   if ( not ( keep_cdk or keep_cdl) ) continue;
                   if ( not ( keep_cdi or keep_cdj) ) continue;
 
-                  double symmetry_factor = 1;  // we only sum a<=b and c<=d, so we undercount by a factor of 4, canceling the 1/4 in the formula 
+                  double symmetry_factor = 1;  // we only sum a<=b and c<=d, so we undercount by a factor of 4, canceling the 1/4 in the formula
                   if (a==b) symmetry_factor *= 0.5; // if a==b or c==d, then the permutation doesn't give a new state, so there's less undercounting
                   if (c==d) symmetry_factor *= 0.5;
 
@@ -4240,18 +4462,18 @@ void comm332_pphhss_debug( const Operator& X, const Operator& Y, Operator& Z )
 
 
                   if ( keep_abi and keep_cdl and keep_cdj and keep_abk
-                     and ( (tbc_ab.parity + tbc_cd.parity + oi.l + ol.l)%2 == X.parity)
-                     and  ( std::abs(2*tbc_ab.Tz+oi.tz2 - 2*tbc_cd.Tz - ol.tz2) == 2*X.rank_T ) 
-                      and ( std::abs(ji2-jl2)<=2*J_ph ) and ( (ji2+jl2)>=2*J_ph )   
+                      and ( (tbc_ab.parity + tbc_cd.parity + oi.l + ol.l)%2 == X.parity)
+                      and  ( std::abs(2*tbc_ab.Tz+oi.tz2 - 2*tbc_cd.Tz - ol.tz2) == 2*X.rank_T )
+                      and ( std::abs(ji2-jl2)<=2*J_ph ) and ( (ji2+jl2)>=2*J_ph )
                       and ( std::abs(jj2-jk2)<=2*J_ph ) and ( (jj2+jk2)>=2*J_ph )   )
                   {
                     int twoJp_min = std::max( std::abs(2*Jab-ji2), std::abs(2*Jcd-jl2));
                     int twoJp_max = std::min( (2*Jab+ji2), (2*Jcd+jl2));
-//                    if (i==0 and j==1 and k==0 and l==1)
-//                    {
-////                      std::cout << "Getting a contribution from Xabicdl = " << a << " " << b << " " << i << " " << c << " " << d << " " << l << std::endl;
-//                      std::cout << "Getting a contribution from X = " << a << " " << b << " " << i << " " << c << " " << d << " " << l << "   " << na << " " << nb << " " << nc << " " << nd << " -> " << occupation_factor << std::endl;
-//                    }
+                    //                    if (i==0 and j==1 and k==0 and l==1)
+                    //                    {
+                    ////                      std::cout << "Getting a contribution from Xabicdl = " << a << " " << b << " " << i << " " << c << " " << d << " " << l << std::endl;
+                    //                      std::cout << "Getting a contribution from X = " << a << " " << b << " " << i << " " << c << " " << d << " " << l << "   " << na << " " << nb << " " << nc << " " << nd << " -> " << occupation_factor << std::endl;
+                    //                    }
                     for ( int twoJp=twoJp_min; twoJp<=twoJp_max; twoJp+=2)
                     {
                       double sixj_x = Z.modelspace->GetSixJ(ji,jl,J_ph, Jcd,Jab,0.5*twoJp);
@@ -4270,9 +4492,9 @@ void comm332_pphhss_debug( const Operator& X, const Operator& Y, Operator& Z )
 
 
                   if ( keep_abj and keep_cdl and keep_cdi and keep_abk
-                     and ( (tbc_ab.parity + tbc_cd.parity + oj.l + ol.l)%2 == X.parity)
-                     and  ( std::abs(2*tbc_ab.Tz+oj.tz2 - 2*tbc_cd.Tz - ol.tz2) == 2*X.rank_T )  
-                      and ( std::abs(jj2-jl2)<=2*J_ph ) and ( (jj2+jl2)>=2*J_ph )   
+                      and ( (tbc_ab.parity + tbc_cd.parity + oj.l + ol.l)%2 == X.parity)
+                      and  ( std::abs(2*tbc_ab.Tz+oj.tz2 - 2*tbc_cd.Tz - ol.tz2) == 2*X.rank_T )
+                      and ( std::abs(jj2-jl2)<=2*J_ph ) and ( (jj2+jl2)>=2*J_ph )
                       and ( std::abs(ji2-jk2)<=2*J_ph ) and ( (ji2+jk2)>=2*J_ph )   )
                   {
                     int twoJp_min = std::max( std::abs(2*Jab-jj2), std::abs(2*Jcd-jl2));
@@ -4291,27 +4513,27 @@ void comm332_pphhss_debug( const Operator& X, const Operator& Y, Operator& Z )
                       double sixj_x = Z.modelspace->GetSixJ(ji,jk,J_ph, Jab,Jcd,0.5*twoJp);
                       Y3_ik += (twoJp+1) * sixj_x * Z.modelspace->phase((jk2+twoJp)/2) * Y3.GetME_pn( Jcd, Jab, twoJp, c,d,i,a,b,k);
                     }
-//                    if (i==0 and j==1 and k==0 and l==1)
-//                    {
-////                      std::cout << "Getting a contribution from Xabjcdl = " << a << " " << b << " " << j << " " << c << " " << d << " " << l << std::endl;
-//                      std::cout << "Getting a contribution from X = " << a << " " << b << " " << j << " " << c << " " << d << " " << l  << "   "  << na << " " << nb << " " << nc << " " << nd << " -> "<< occupation_factor << " X3_jl = " << X3_jl << "  Y3_ik = " << Y3_ik << std::endl;
-//                    }
+                    //                    if (i==0 and j==1 and k==0 and l==1)
+                    //                    {
+                    ////                      std::cout << "Getting a contribution from Xabjcdl = " << a << " " << b << " " << j << " " << c << " " << d << " " << l << std::endl;
+                    //                      std::cout << "Getting a contribution from X = " << a << " " << b << " " << j << " " << c << " " << d << " " << l  << "   "  << na << " " << nb << " " << nc << " " << nd << " -> "<< occupation_factor << " X3_jl = " << X3_jl << "  Y3_ik = " << Y3_ik << std::endl;
+                    //                    }
                   }
 
 
                   if ( keep_abi and keep_cdk and keep_cdj and keep_abl
-                     and ( (tbc_ab.parity + tbc_cd.parity + oi.l + ok.l)%2 == X.parity)
-                     and  ( std::abs(2*tbc_ab.Tz+oi.tz2 - 2*tbc_cd.Tz - ok.tz2) == 2*X.rank_T )  
-                      and ( std::abs(ji2-jk2)<=2*J_ph ) and ( (ji2+jk2)>=2*J_ph )   
+                      and ( (tbc_ab.parity + tbc_cd.parity + oi.l + ok.l)%2 == X.parity)
+                      and  ( std::abs(2*tbc_ab.Tz+oi.tz2 - 2*tbc_cd.Tz - ok.tz2) == 2*X.rank_T )
+                      and ( std::abs(ji2-jk2)<=2*J_ph ) and ( (ji2+jk2)>=2*J_ph )
                       and ( std::abs(jj2-jl2)<=2*J_ph ) and ( (jj2+jl2)>=2*J_ph )   )
                   {
                     int twoJp_min = std::max( std::abs(2*Jab-ji2), std::abs(2*Jcd-jk2));
                     int twoJp_max = std::min( (2*Jab+ji2), (2*Jcd+jk2));
-//                    if (i==0 and j==1 and k==0 and l==1)
-//                    {
-////                      std::cout << "Getting a contribution from Xabicdk = " << a << " " << b << " " << i << " " << c << " " << d << " " << k << std::endl;
-//                      std::cout << "Getting a contribution from X = " << a << " " << b << " " << i << " " << c << " " << d << " " << k  << "   "  << na << " " << nb << " " << nc << " " << nd << " -> "<< occupation_factor << std::endl;
-//                    }
+                    //                    if (i==0 and j==1 and k==0 and l==1)
+                    //                    {
+                    ////                      std::cout << "Getting a contribution from Xabicdk = " << a << " " << b << " " << i << " " << c << " " << d << " " << k << std::endl;
+                    //                      std::cout << "Getting a contribution from X = " << a << " " << b << " " << i << " " << c << " " << d << " " << k  << "   "  << na << " " << nb << " " << nc << " " << nd << " -> "<< occupation_factor << std::endl;
+                    //                    }
                     for ( int twoJp=twoJp_min; twoJp<=twoJp_max; twoJp+=2)
                     {
                       double sixj_x = Z.modelspace->GetSixJ(ji,jk,J_ph, Jcd,Jab,0.5*twoJp);
@@ -4328,18 +4550,18 @@ void comm332_pphhss_debug( const Operator& X, const Operator& Y, Operator& Z )
 
 
                   if ( keep_abj and keep_cdk and keep_cdi and keep_abl
-                     and ( (tbc_ab.parity + tbc_cd.parity + oj.l + ok.l)%2 == X.parity)
-                     and  ( std::abs(2*tbc_ab.Tz+oj.tz2 - 2*tbc_cd.Tz - ok.tz2) == 2*X.rank_T )  
-                      and ( std::abs(jj2-jk2)<=2*J_ph ) and ( (jj2+jk2)>=2*J_ph )   
+                      and ( (tbc_ab.parity + tbc_cd.parity + oj.l + ok.l)%2 == X.parity)
+                      and  ( std::abs(2*tbc_ab.Tz+oj.tz2 - 2*tbc_cd.Tz - ok.tz2) == 2*X.rank_T )
+                      and ( std::abs(jj2-jk2)<=2*J_ph ) and ( (jj2+jk2)>=2*J_ph )
                       and ( std::abs(ji2-jl2)<=2*J_ph ) and ( (ji2+jl2)>=2*J_ph )   )
                   {
                     int twoJp_min = std::max( std::abs(2*Jab-jj2), std::abs(2*Jcd-jk2));
                     int twoJp_max = std::min( (2*Jab+jj2), (2*Jcd+jk2));
-//                    if (i==0 and j==1 and k==0 and l==1)
-//                    {
-////                      std::cout << "Getting a contribution from Xabjcdk = " << a << " " << b << " " << j << " " << c << " " << d << " " << k << std::endl;
-//                      std::cout << "Getting a contribution from X = " << a << " " << b << " " << j << " " << c << " " << d << " " << k  << "   "  << na << " " << nb << " " << nc << " " << nd << " -> "<< occupation_factor << std::endl;
-//                    }
+                    //                    if (i==0 and j==1 and k==0 and l==1)
+                    //                    {
+                    ////                      std::cout << "Getting a contribution from Xabjcdk = " << a << " " << b << " " << j << " " << c << " " << d << " " << k << std::endl;
+                    //                      std::cout << "Getting a contribution from X = " << a << " " << b << " " << j << " " << c << " " << d << " " << k  << "   "  << na << " " << nb << " " << nc << " " << nd << " -> "<< occupation_factor << std::endl;
+                    //                    }
                     for ( int twoJp=twoJp_min; twoJp<=twoJp_max; twoJp+=2)
                     {
                       double sixj_x = Z.modelspace->GetSixJ(jj,jk,J_ph, Jcd,Jab,0.5*twoJp);
@@ -4360,27 +4582,27 @@ void comm332_pphhss_debug( const Operator& X, const Operator& Y, Operator& Z )
                   zbar_jlki += occupation_factor * symmetry_factor * X3_jl * Y3_ik;
                   zbar_iklj += occupation_factor * symmetry_factor * X3_ik * Y3_jl;
                   zbar_jkli += occupation_factor * symmetry_factor * X3_jk * Y3_il;
-//                  zbar_ilkj += occupation_factor * symmetry_factor * ( X3_il * Y3_jk + phase_ij*phase_kl*X3_jk * Y3_il);
-//                  zbar_jlki += occupation_factor * symmetry_factor * ( X3_jl * Y3_ik + phase_ij*phase_kl*X3_ik * Y3_jl);
+                  //                  zbar_ilkj += occupation_factor * symmetry_factor * ( X3_il * Y3_jk + phase_ij*phase_kl*X3_jk * Y3_il);
+                  //                  zbar_jlki += occupation_factor * symmetry_factor * ( X3_jl * Y3_ik + phase_ij*phase_kl*X3_ik * Y3_jl);
 
 
 
                 }// for iket_cd
-            }// for iket_ab
-              }// for ch_cd
+              }// for iket_ab
+            }// for ch_cd
           }// for ch_ab
 
 
-        double sixj1 = Z.modelspace->GetSixJ(ji, jj, J,  jk,jl, J_ph);
-        double sixj1_flip = Z.modelspace->GetSixJ(jj, ji, J,  jk,jl, J_ph);
-//        int phase_ij = Z.modelspace->phase( (ji2+jj2)/2-J);
-//        int phase_kl = Z.modelspace->phase( (jk2+jl2)/2-J);
-        zijkl += (2*J_ph+1) * (  sixj1 * (zbar_ilkj + phase_ij*phase_kl * zbar_jkli) - sixj1_flip*( phase_ij*zbar_jlki + phase_kl*zbar_iklj) );
-//        zijkl += (2*J_ph+1) * (  sixj1 * zbar_ilkj   - sixj1_flip* phase_ij*zbar_jlki );
-//        if ( i==0 and j==1 and k==0 and l==1)
-//        {
-//           std::cout << " Jph = " << J_ph << " zbar_ilkj " << zbar_ilkj << "   zbar_jkli " << zbar_jkli << "   zbar_jlki " << zbar_jlki << "   zbar_iklj " << zbar_iklj << "  ->  " << zijkl << std::endl;
-//        }
+          double sixj1 = Z.modelspace->GetSixJ(ji, jj, J,  jk,jl, J_ph);
+          double sixj1_flip = Z.modelspace->GetSixJ(jj, ji, J,  jk,jl, J_ph);
+          //        int phase_ij = Z.modelspace->phase( (ji2+jj2)/2-J);
+          //        int phase_kl = Z.modelspace->phase( (jk2+jl2)/2-J);
+          zijkl += (2*J_ph+1) * (  sixj1 * (zbar_ilkj + phase_ij*phase_kl * zbar_jkli) - sixj1_flip*( phase_ij*zbar_jlki + phase_kl*zbar_iklj) );
+          //        zijkl += (2*J_ph+1) * (  sixj1 * zbar_ilkj   - sixj1_flip* phase_ij*zbar_jlki );
+          //        if ( i==0 and j==1 and k==0 and l==1)
+          //        {
+          //           std::cout << " Jph = " << J_ph << " zbar_ilkj " << zbar_ilkj << "   zbar_jkli " << zbar_jkli << "   zbar_jlki " << zbar_jlki << "   zbar_iklj " << zbar_iklj << "  ->  " << zijkl << std::endl;
+          //        }
 
 
         }// for J_ph
@@ -4401,172 +4623,172 @@ void comm332_pphhss_debug( const Operator& X, const Operator& Y, Operator& Z )
 //void comm332_pphhss( const Operator& X, const Operator& Y, Operator& Z )
 void comm332_pphhss_debug( const Operator& X, const Operator& Y, Operator& Z )
 {
-  double tstart = omp_get_wtime();
-  auto& X3 = X.ThreeBody;
-  auto& Y3 = Y.ThreeBody;
-  auto& Z2 = Z.TwoBody;
-  std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
-  
-  int nch = Z.modelspace->GetNumberTwoBodyChannels();
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
-  for (int ch=0; ch<nch; ch++)
+double tstart = omp_get_wtime();
+auto& X3 = X.ThreeBody;
+auto& Y3 = Y.ThreeBody;
+auto& Z2 = Z.TwoBody;
+std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
+
+int nch = Z.modelspace->GetNumberTwoBodyChannels();
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+for (int ch=0; ch<nch; ch++)
+{
+TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
+int J = tbc.J;
+int nkets = tbc.GetNumberKets();
+for (int ibra=0; ibra<nkets; ibra++)
+{
+Ket& bra = tbc.GetKet(ibra);
+int i = bra.p;
+int j = bra.q;
+int ji2 = bra.op->j2;
+int jj2 = bra.oq->j2;
+double ji = 0.5*ji2;
+double jj = 0.5*jj2;
+double d_ei = std::abs(2*bra.op->n + bra.op->l - e_fermi[bra.op->tz2]);
+double d_ej = std::abs(2*bra.oq->n + bra.oq->l - e_fermi[bra.oq->tz2]);
+double occnat_i = bra.op->occ_nat;
+double occnat_j = bra.oq->occ_nat;
+for (int iket=ibra; iket<nkets; iket++)
+{
+Ket& ket = tbc.GetKet(iket);
+int k = ket.p;
+int l = ket.q;
+int jk2 = ket.op->j2;
+int jl2 = ket.oq->j2;
+double jk = 0.5*jk2;
+double jl = 0.5*jl2;
+double d_ek = std::abs(2*ket.op->n + ket.op->l - e_fermi[ket.op->tz2]);
+double d_el = std::abs(2*ket.oq->n + ket.oq->l - e_fermi[ket.oq->tz2]);
+double occnat_k = ket.op->occ_nat;
+double occnat_l = ket.oq->occ_nat;
+
+double zijkl = 0;
+// Now the loops on the right hand side
+for (int ch_ab=0; ch_ab<nch; ch_ab++)
+{
+TwoBodyChannel& tbc_ab = Z.modelspace->GetTwoBodyChannel(ch_ab);
+int Jab = tbc_ab.J;
+int nkets = tbc_ab.GetNumberKets();
+for (int iket_ab=0; iket_ab<nkets; iket_ab++)
+{
+Ket& ket_ab = tbc_ab.GetKet(iket_ab);
+int a = ket_ab.p;
+int b = ket_ab.q;
+double na = ket_ab.op->occ;
+double nb = ket_ab.oq->occ;
+double d_ea = std::abs(2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2]);
+double d_eb = std::abs(2*ket_ab.oq->n + ket_ab.oq->l - e_fermi[ket_ab.oq->tz2]);
+double occnat_a = ket_ab.op->occ_nat;
+double occnat_b = ket_ab.oq->occ_nat;
+bool keep_abi = ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_i*(1-occnat_i) ) >= Z.modelspace->GetOccNat3Cut() ) ;
+bool keep_abj = ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_j*(1-occnat_j) ) >= Z.modelspace->GetOccNat3Cut() ) ;
+bool keep_abk = ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_k*(1-occnat_k) ) >= Z.modelspace->GetOccNat3Cut() ) ;
+bool keep_abl = ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_l*(1-occnat_l) ) >= Z.modelspace->GetOccNat3Cut() ) ;
+keep_abi = keep_abi and (d_ea+d_eb+d_ei <= Z.modelspace->dE3max );
+keep_abj = keep_abj and (d_ea+d_eb+d_ej <= Z.modelspace->dE3max );
+keep_abk = keep_abk and (d_ea+d_eb+d_ek <= Z.modelspace->dE3max );
+keep_abl = keep_abl and (d_ea+d_eb+d_el <= Z.modelspace->dE3max );
+if ( not ( keep_abi or keep_abj) ) continue;
+if ( not ( keep_abk or keep_abl) ) continue;
+
+for (int ch_cd=0; ch_cd<nch; ch_cd++)
+{
+  TwoBodyChannel& tbc_cd = Z.modelspace->GetTwoBodyChannel(ch_cd);
+  int Jcd = tbc_cd.J;
+  int nkets = tbc_cd.GetNumberKets();
+  for (int iket_cd=0; iket_cd<nkets; iket_cd++)
   {
-    TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
-    int J = tbc.J;
-    int nkets = tbc.GetNumberKets();
-    for (int ibra=0; ibra<nkets; ibra++)
+    Ket& ket_cd = tbc_cd.GetKet(iket_cd);
+    int c = ket_cd.p;
+    int d = ket_cd.q;
+    double nc = ket_cd.op->occ;
+    double nd = ket_cd.oq->occ;
+    double d_ec = std::abs(2*ket_cd.op->n + ket_cd.op->l - e_fermi[ket_cd.op->tz2]);
+    double d_ed = std::abs(2*ket_cd.oq->n + ket_cd.oq->l - e_fermi[ket_cd.oq->tz2]);
+    double occnat_c = ket_cd.op->occ_nat;
+    double occnat_d = ket_cd.oq->occ_nat;
+    //                double jc = 0.5*ket_cd.op->j2;
+    //                double jd = 0.5*ket_cd.oq->j2;
+    double occupation_factor = (1-na)*(1-nb)*nc*nd - na*nb*(1-nc)*(1-nd);
+    if (std::abs(occupation_factor)<1e-6) continue;
+
+
+    bool keep_cdi = ( (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_i*(1-occnat_i) ) >= Z.modelspace->GetOccNat3Cut() ) ;
+    bool keep_cdj = ( (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_j*(1-occnat_j) ) >= Z.modelspace->GetOccNat3Cut() ) ;
+    bool keep_cdk = ( (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_k*(1-occnat_k) ) >= Z.modelspace->GetOccNat3Cut() ) ;
+    bool keep_cdl = ( (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_l*(1-occnat_l) ) >= Z.modelspace->GetOccNat3Cut() ) ;
+    keep_cdi = keep_cdi and (d_ec+d_ed+d_ei <= Z.modelspace->dE3max );
+    keep_cdj = keep_cdj and (d_ec+d_ed+d_ej <= Z.modelspace->dE3max );
+    keep_cdk = keep_cdk and (d_ec+d_ed+d_ek <= Z.modelspace->dE3max );
+    keep_cdl = keep_cdl and (d_ec+d_ed+d_el <= Z.modelspace->dE3max );
+    if ( not ( keep_cdk or keep_cdl) ) continue;
+    if ( not ( keep_cdi or keep_cdj) ) continue;
+
+    double symmetry_factor = 1;  // we only sum a<=b and c<=d, so we undercount by a factor of 4, canceling the 1/4 in the formula
+    if (a==b) symmetry_factor *= 0.5; // if a==b or c==d, then the permutation doesn't give a new state, so there's less undercounting
+    if (c==d) symmetry_factor *= 0.5;
+
+    // Figure out which range of twoJp and twoJpp we will need
+    int twoJp_min  = std::max(  std::min(std::abs(2*Jab - ji2),std::abs(2*Jab-jj2)), std::min(std::abs(2*Jcd - jl2),std::abs(2*Jcd-jk2)) );
+    int twoJpp_min = std::max(  std::min(std::abs(2*Jcd - jj2),std::abs(2*Jcd-ji2)), std::min(std::abs(2*Jab - jk2),std::abs(2*Jab-jl2)) );
+    int twoJp_max  = std::min(  2*Jab + std::max(ji2,jj2),  2*Jcd + std::max(jk2,jl2) );
+    int twoJpp_max = std::min(  2*Jcd + std::max(ji2,jj2),  2*Jab + std::max(jk2,jl2) );
+
+    if (twoJpp_max<twoJpp_min) continue;
+    for (int twoJp=twoJp_min; twoJp<=twoJp_max; twoJp+=2)
     {
-      Ket& bra = tbc.GetKet(ibra);
-      int i = bra.p;
-      int j = bra.q;
-      int ji2 = bra.op->j2;
-      int jj2 = bra.oq->j2;
-      double ji = 0.5*ji2;
-      double jj = 0.5*jj2;
-      double d_ei = std::abs(2*bra.op->n + bra.op->l - e_fermi[bra.op->tz2]);
-      double d_ej = std::abs(2*bra.oq->n + bra.oq->l - e_fermi[bra.oq->tz2]);
-      double occnat_i = bra.op->occ_nat;
-      double occnat_j = bra.oq->occ_nat;
-      for (int iket=ibra; iket<nkets; iket++) 
-      {
-        Ket& ket = tbc.GetKet(iket);
-        int k = ket.p;
-        int l = ket.q;
-        int jk2 = ket.op->j2;
-        int jl2 = ket.oq->j2;
-        double jk = 0.5*jk2;
-        double jl = 0.5*jl2;
-        double d_ek = std::abs(2*ket.op->n + ket.op->l - e_fermi[ket.op->tz2]);
-        double d_el = std::abs(2*ket.oq->n + ket.oq->l - e_fermi[ket.oq->tz2]);
-        double occnat_k = ket.op->occ_nat;
-        double occnat_l = ket.oq->occ_nat;
-
-        double zijkl = 0;
-        // Now the loops on the right hand side
-        for (int ch_ab=0; ch_ab<nch; ch_ab++)
-        {
-          TwoBodyChannel& tbc_ab = Z.modelspace->GetTwoBodyChannel(ch_ab);
-          int Jab = tbc_ab.J;
-          int nkets = tbc_ab.GetNumberKets();
-          for (int iket_ab=0; iket_ab<nkets; iket_ab++)
-          {
-            Ket& ket_ab = tbc_ab.GetKet(iket_ab);
-            int a = ket_ab.p;
-            int b = ket_ab.q;
-            double na = ket_ab.op->occ;
-            double nb = ket_ab.oq->occ;
-            double d_ea = std::abs(2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2]);
-            double d_eb = std::abs(2*ket_ab.oq->n + ket_ab.oq->l - e_fermi[ket_ab.oq->tz2]);
-            double occnat_a = ket_ab.op->occ_nat;
-            double occnat_b = ket_ab.oq->occ_nat;
-            bool keep_abi = ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_i*(1-occnat_i) ) >= Z.modelspace->GetOccNat3Cut() ) ;
-            bool keep_abj = ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_j*(1-occnat_j) ) >= Z.modelspace->GetOccNat3Cut() ) ;
-            bool keep_abk = ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_k*(1-occnat_k) ) >= Z.modelspace->GetOccNat3Cut() ) ;
-            bool keep_abl = ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_l*(1-occnat_l) ) >= Z.modelspace->GetOccNat3Cut() ) ;
-            keep_abi = keep_abi and (d_ea+d_eb+d_ei <= Z.modelspace->dE3max );
-            keep_abj = keep_abj and (d_ea+d_eb+d_ej <= Z.modelspace->dE3max );
-            keep_abk = keep_abk and (d_ea+d_eb+d_ek <= Z.modelspace->dE3max );
-            keep_abl = keep_abl and (d_ea+d_eb+d_el <= Z.modelspace->dE3max );
-            if ( not ( keep_abi or keep_abj) ) continue;
-            if ( not ( keep_abk or keep_abl) ) continue;
-
-            for (int ch_cd=0; ch_cd<nch; ch_cd++)
-            {
-              TwoBodyChannel& tbc_cd = Z.modelspace->GetTwoBodyChannel(ch_cd);
-              int Jcd = tbc_cd.J;
-              int nkets = tbc_cd.GetNumberKets();
-              for (int iket_cd=0; iket_cd<nkets; iket_cd++)
-              {
-                Ket& ket_cd = tbc_cd.GetKet(iket_cd);
-                int c = ket_cd.p;
-                int d = ket_cd.q;
-                double nc = ket_cd.op->occ;
-                double nd = ket_cd.oq->occ;
-                double d_ec = std::abs(2*ket_cd.op->n + ket_cd.op->l - e_fermi[ket_cd.op->tz2]);
-                double d_ed = std::abs(2*ket_cd.oq->n + ket_cd.oq->l - e_fermi[ket_cd.oq->tz2]);
-                double occnat_c = ket_cd.op->occ_nat;
-                double occnat_d = ket_cd.oq->occ_nat;
-//                double jc = 0.5*ket_cd.op->j2;
-//                double jd = 0.5*ket_cd.oq->j2;
-                double occupation_factor = (1-na)*(1-nb)*nc*nd - na*nb*(1-nc)*(1-nd);
-                if (std::abs(occupation_factor)<1e-6) continue;
-
-
-                bool keep_cdi = ( (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_i*(1-occnat_i) ) >= Z.modelspace->GetOccNat3Cut() ) ;
-                bool keep_cdj = ( (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_j*(1-occnat_j) ) >= Z.modelspace->GetOccNat3Cut() ) ;
-                bool keep_cdk = ( (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_k*(1-occnat_k) ) >= Z.modelspace->GetOccNat3Cut() ) ;
-                bool keep_cdl = ( (occnat_c*(1-occnat_c) * occnat_d*(1-occnat_d) * occnat_l*(1-occnat_l) ) >= Z.modelspace->GetOccNat3Cut() ) ;
-                keep_cdi = keep_cdi and (d_ec+d_ed+d_ei <= Z.modelspace->dE3max );
-                keep_cdj = keep_cdj and (d_ec+d_ed+d_ej <= Z.modelspace->dE3max );
-                keep_cdk = keep_cdk and (d_ec+d_ed+d_ek <= Z.modelspace->dE3max );
-                keep_cdl = keep_cdl and (d_ec+d_ed+d_el <= Z.modelspace->dE3max );
-                if ( not ( keep_cdk or keep_cdl) ) continue;
-                if ( not ( keep_cdi or keep_cdj) ) continue;
-
-                double symmetry_factor = 1;  // we only sum a<=b and c<=d, so we undercount by a factor of 4, canceling the 1/4 in the formula 
-                if (a==b) symmetry_factor *= 0.5; // if a==b or c==d, then the permutation doesn't give a new state, so there's less undercounting
-                if (c==d) symmetry_factor *= 0.5;
-
-                // Figure out which range of twoJp and twoJpp we will need
-                int twoJp_min  = std::max(  std::min(std::abs(2*Jab - ji2),std::abs(2*Jab-jj2)), std::min(std::abs(2*Jcd - jl2),std::abs(2*Jcd-jk2)) );
-                int twoJpp_min = std::max(  std::min(std::abs(2*Jcd - jj2),std::abs(2*Jcd-ji2)), std::min(std::abs(2*Jab - jk2),std::abs(2*Jab-jl2)) );
-                int twoJp_max  = std::min(  2*Jab + std::max(ji2,jj2),  2*Jcd + std::max(jk2,jl2) );
-                int twoJpp_max = std::min(  2*Jcd + std::max(ji2,jj2),  2*Jab + std::max(jk2,jl2) );
-
-                if (twoJpp_max<twoJpp_min) continue;
-                for (int twoJp=twoJp_min; twoJp<=twoJp_max; twoJp+=2)
-                {
 
-                    double xabicdl = (keep_abi and keep_cdl) ? X3.GetME_pn(Jab,Jcd,twoJp, a,b,i,c,d,l) : 0;
-                    double xabicdk = (keep_abi and keep_cdk) ? X3.GetME_pn(Jab,Jcd,twoJp, a,b,i,c,d,k) : 0;
-                    double xabjcdl = (keep_abj and keep_cdl) ? X3.GetME_pn(Jab,Jcd,twoJp, a,b,j,c,d,l) : 0;
-                    double xabjcdk = (keep_abj and keep_cdk) ? X3.GetME_pn(Jab,Jcd,twoJp, a,b,j,c,d,k) : 0;
+      double xabicdl = (keep_abi and keep_cdl) ? X3.GetME_pn(Jab,Jcd,twoJp, a,b,i,c,d,l) : 0;
+      double xabicdk = (keep_abi and keep_cdk) ? X3.GetME_pn(Jab,Jcd,twoJp, a,b,i,c,d,k) : 0;
+      double xabjcdl = (keep_abj and keep_cdl) ? X3.GetME_pn(Jab,Jcd,twoJp, a,b,j,c,d,l) : 0;
+      double xabjcdk = (keep_abj and keep_cdk) ? X3.GetME_pn(Jab,Jcd,twoJp, a,b,j,c,d,k) : 0;
 
-                  for (int twoJpp=twoJpp_min; twoJpp<=twoJpp_max; twoJpp+=2)
-                  {
-                    double Jp = 0.5 * twoJp;
-                    double Jpp = 0.5 * twoJpp;
-                    double hatfactor = (twoJp+1)*(twoJpp+1);
-
-                    // I think having these in the inner loop may be disastrous for performance
-                    double ninej1 = (keep_abi and keep_cdl and keep_cdj and keep_abk) ? Z.modelspace->GetNineJ(Jab,jk,Jpp, ji,J,jj, Jp,jl,Jcd) : 0;
-                    double ninej2 = (keep_abj and keep_cdl and keep_cdi and keep_abk) ? Z.modelspace->GetNineJ(Jab,jk,Jpp, jj,J,ji, Jp,jl,Jcd) : 0; // permute i<->j
-                    double ninej3 = (keep_abi and keep_cdk and keep_cdj and keep_abl) ? Z.modelspace->GetNineJ(Jab,jl,Jpp, ji,J,jj, Jp,jk,Jcd) : 0; // permute k<->l
-                    double ninej4 = (keep_abj and keep_cdk and keep_cdi and keep_abl) ? Z.modelspace->GetNineJ(Jab,jl,Jpp, jj,J,ji, Jp,jk,Jcd) : 0; // permute i<->j and k<->l
-
-                    // These phase factors account for the minus signs associated with the permutations
-                    // so that all the permuted terms should just be added with their phase (no extra minus sign).
-                    int phase1 = Z.modelspace->phase( (ji2+jk2+twoJp+twoJpp)/2 );
-                    int phase2 = Z.modelspace->phase( (ji2+jk2+twoJp+twoJpp)/2 -J ); // from permuting i<->j
-                    int phase3 = Z.modelspace->phase( (ji2+jk2+twoJp+twoJpp)/2 -J ); // from permuting k<->l
-                    int phase4 = Z.modelspace->phase( (ji2+jk2+twoJp+twoJpp)/2 ); // from permuting i<->j and k<->l
-
-                    double ycdjabk = (keep_cdj and keep_abk) ? Y3.GetME_pn(Jcd,Jab,twoJpp,c,d,j,a,b,k) : 0;
-                    double ycdjabl = (keep_cdj and keep_abl) ? Y3.GetME_pn(Jcd,Jab,twoJpp,c,d,j,a,b,l) : 0;
-                    double ycdiabk = (keep_cdi and keep_abk) ? Y3.GetME_pn(Jcd,Jab,twoJpp,c,d,i,a,b,k) : 0;
-                    double ycdiabl = (keep_cdi and keep_abl) ? Y3.GetME_pn(Jcd,Jab,twoJpp,c,d,i,a,b,l) : 0;
-                    zijkl += symmetry_factor * hatfactor * occupation_factor * (
-                                      1*phase1 * ninej1 * xabicdl * ycdjabk
-                                    + 1*phase2 * ninej2 * xabjcdl * ycdiabk // i<->j
-                                    + 1*phase3 * ninej3 * xabicdk * ycdjabl // k<->l
-                                    + 1*phase4 * ninej4 * xabjcdk * ycdiabl // i<->j and k<->l
-                                   );
-
-                  }// for twoJpp
-                }// for twoJp
-                
-              }// for iket_cd
-            }// for ch_cd
-          }// for iket_ab
-        }// for ch_ab
-        // make it a normalized TBME
-        zijkl /=  sqrt((1.+bra.delta_pq())*(1.+ket.delta_pq()));
-        // the AddToTBME routine automatically takes care of the hermitian conjugate as well
-        Z2.AddToTBME(ch,ch,ibra,iket,zijkl);
-      }// for iket
-    }// for ibra
-  }// for ch
-  Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
+      for (int twoJpp=twoJpp_min; twoJpp<=twoJpp_max; twoJpp+=2)
+      {
+        double Jp = 0.5 * twoJp;
+        double Jpp = 0.5 * twoJpp;
+        double hatfactor = (twoJp+1)*(twoJpp+1);
+
+        // I think having these in the inner loop may be disastrous for performance
+        double ninej1 = (keep_abi and keep_cdl and keep_cdj and keep_abk) ? Z.modelspace->GetNineJ(Jab,jk,Jpp, ji,J,jj, Jp,jl,Jcd) : 0;
+        double ninej2 = (keep_abj and keep_cdl and keep_cdi and keep_abk) ? Z.modelspace->GetNineJ(Jab,jk,Jpp, jj,J,ji, Jp,jl,Jcd) : 0; // permute i<->j
+        double ninej3 = (keep_abi and keep_cdk and keep_cdj and keep_abl) ? Z.modelspace->GetNineJ(Jab,jl,Jpp, ji,J,jj, Jp,jk,Jcd) : 0; // permute k<->l
+        double ninej4 = (keep_abj and keep_cdk and keep_cdi and keep_abl) ? Z.modelspace->GetNineJ(Jab,jl,Jpp, jj,J,ji, Jp,jk,Jcd) : 0; // permute i<->j and k<->l
+
+        // These phase factors account for the minus signs associated with the permutations
+        // so that all the permuted terms should just be added with their phase (no extra minus sign).
+        int phase1 = Z.modelspace->phase( (ji2+jk2+twoJp+twoJpp)/2 );
+        int phase2 = Z.modelspace->phase( (ji2+jk2+twoJp+twoJpp)/2 -J ); // from permuting i<->j
+        int phase3 = Z.modelspace->phase( (ji2+jk2+twoJp+twoJpp)/2 -J ); // from permuting k<->l
+        int phase4 = Z.modelspace->phase( (ji2+jk2+twoJp+twoJpp)/2 ); // from permuting i<->j and k<->l
+
+        double ycdjabk = (keep_cdj and keep_abk) ? Y3.GetME_pn(Jcd,Jab,twoJpp,c,d,j,a,b,k) : 0;
+        double ycdjabl = (keep_cdj and keep_abl) ? Y3.GetME_pn(Jcd,Jab,twoJpp,c,d,j,a,b,l) : 0;
+        double ycdiabk = (keep_cdi and keep_abk) ? Y3.GetME_pn(Jcd,Jab,twoJpp,c,d,i,a,b,k) : 0;
+        double ycdiabl = (keep_cdi and keep_abl) ? Y3.GetME_pn(Jcd,Jab,twoJpp,c,d,i,a,b,l) : 0;
+        zijkl += symmetry_factor * hatfactor * occupation_factor * (
+            1*phase1 * ninej1 * xabicdl * ycdjabk
+            + 1*phase2 * ninej2 * xabjcdl * ycdiabk // i<->j
+            + 1*phase3 * ninej3 * xabicdk * ycdjabl // k<->l
+            + 1*phase4 * ninej4 * xabjcdk * ycdiabl // i<->j and k<->l
+            );
+
+      }// for twoJpp
+    }// for twoJp
+
+  }// for iket_cd
+}// for ch_cd
+}// for iket_ab
+}// for ch_ab
+// make it a normalized TBME
+zijkl /=  sqrt((1.+bra.delta_pq())*(1.+ket.delta_pq()));
+// the AddToTBME routine automatically takes care of the hermitian conjugate as well
+Z2.AddToTBME(ch,ch,ibra,iket,zijkl);
+}// for iket
+}// for ibra
+}// for ch
+Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
 }
 
 */
@@ -4603,9 +4825,9 @@ void comm133ss( const Operator& X, const Operator& Y, Operator& Z )
   double Y3NORM = Y3.Norm();
   bool x3_allocated = X3.is_allocated;
   bool y3_allocated = Y3.is_allocated;
-//  if (X3NORM<1e-6 and Y3NORM<1e-6 ) return;
+  //  if (X3NORM<1e-6 and Y3NORM<1e-6 ) return;
   size_t nch3 = Z.modelspace->GetNumberThreeBodyChannels();
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
   for (size_t ch3=0; ch3<nch3; ch3++)
   {
     auto& Tbc = Z.modelspace->GetThreeBodyChannel(ch3);
@@ -4647,14 +4869,24 @@ void comm133ss( const Operator& X, const Operator& Y, Operator& Z )
       Orbit& oj = Z.modelspace->GetOrbit(j);
       Orbit& ok = Z.modelspace->GetOrbit(k);
       int Jij = bra.Jpq;
+      double d_ei = std::abs(2*oi.n + oi.l - e_fermi[oi.tz2]);
+      double d_ej = std::abs(2*oj.n + oj.l - e_fermi[oj.tz2]);
+      double d_ek = std::abs(2*ok.n + ok.l - e_fermi[ok.tz2]);
+      double occnat_i = oi.occ_nat;
+      double occnat_j = oj.occ_nat;
+      double occnat_k = ok.occ_nat;
 
 
       for (auto a : X.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) )
       {
+        Orbit& oa = X.modelspace->GetOrbit(a);
+        double d_ea = std::abs(2*oa.n+oa.l - e_fermi[oa.tz2]);
+        double occnat_a = oa.occ_nat;
+        if (  (d_ea+d_ej+d_ek ) > Z.modelspace->GetdE3max() ) continue;
+        if ( (occnat_a*(1-occnat_a) * occnat_j*(1-occnat_j) * occnat_k*(1-occnat_k) ) < Z.modelspace->GetOccNat3Cut() ) continue;
         std::vector<size_t> ket_list;
         std::vector<double> recouple_list;
-        Orbit& oa = X.modelspace->GetOrbit(a);
-        
+
         size_t ch_check = Z3.GetKetIndex_withRecoupling( Jij, twoJ, a, j, k,  ket_list,  recouple_list );
         for (size_t ilist=0; ilist<ket_list.size(); ilist++)
         {
@@ -4668,6 +4900,12 @@ void comm133ss( const Operator& X, const Operator& Y, Operator& Z )
       }
       for (auto a : X.OneBodyChannels.at({oj.l,oj.j2,oj.tz2}) )
       {
+
+        Orbit& oa = Z.modelspace->GetOrbit(a);
+        double d_ea = std::abs(2*oa.n+oa.l - e_fermi[oa.tz2]);
+        double occnat_a = oa.occ_nat;
+        if (  (d_ei+d_ea+d_ek ) > Z.modelspace->GetdE3max() ) continue;
+        if ( (occnat_i*(1-occnat_i) * occnat_a*(1-occnat_a) * occnat_k*(1-occnat_k) ) < Z.modelspace->GetOccNat3Cut() ) continue;
         std::vector<size_t> ket_list;
         std::vector<double> recouple_list;
         size_t ch_check = Z3.GetKetIndex_withRecoupling( Jij, twoJ, i, a, k,  ket_list,  recouple_list );
@@ -4683,6 +4921,11 @@ void comm133ss( const Operator& X, const Operator& Y, Operator& Z )
       }
       for (auto a : X.OneBodyChannels.at({ok.l,ok.j2,ok.tz2}) )
       {
+        Orbit& oa = Z.modelspace->GetOrbit(a);
+        double d_ea = std::abs(2*oa.n+oa.l - e_fermi[oa.tz2]);
+        double occnat_a = oa.occ_nat;
+        if (  (d_ei+d_ej+d_ea ) > Z.modelspace->GetdE3max() ) continue;
+        if ( (occnat_i*(1-occnat_i) * occnat_j*(1-occnat_j) * occnat_a*(1-occnat_a) ) < Z.modelspace->GetOccNat3Cut() ) continue;
         std::vector<size_t> ket_list;
         std::vector<double> recouple_list;
         size_t ch_check = Z3.GetKetIndex_withRecoupling( Jij, twoJ, i, j, a,  ket_list,  recouple_list );
@@ -4704,18 +4947,18 @@ void comm133ss( const Operator& X, const Operator& Y, Operator& Z )
     {
       for ( auto& iter_ket : kept_lookup )
       {
-//        if ( X3NORM > 1e-6)
+        //        if ( X3NORM > 1e-6)
         if ( x3_allocated )
-           X3MAT( iter_bra.second, iter_ket.second) = X3.GetME_pn_PN_ch(ch3,ch3, iter_bra.first, iter_ket.first );
-//        if ( Y3NORM > 1e-6)
+          X3MAT( iter_bra.second, iter_ket.second) = X3.GetME_pn_PN_ch(ch3,ch3, iter_bra.first, iter_ket.first );
+        //        if ( Y3NORM > 1e-6)
         if ( y3_allocated )
-           Y3MAT( iter_bra.second, iter_ket.second) = Y3.GetME_pn_PN_ch(ch3,ch3, iter_bra.first, iter_ket.first );
+          Y3MAT( iter_bra.second, iter_ket.second) = Y3.GetME_pn_PN_ch(ch3,ch3, iter_bra.first, iter_ket.first );
       }
     }
 
 
     // Do the matrix multiplication
-//    Z3MAT = X1MAT*Y3MAT - Y1MAT*X3MAT +  hermX*hermY * ( X3MAT.t()*Y1MAT.t() - Y3MAT.t()*X1MAT.t() );
+    //    Z3MAT = X1MAT*Y3MAT - Y1MAT*X3MAT +  hermX*hermY * ( X3MAT.t()*Y1MAT.t() - Y3MAT.t()*X1MAT.t() );
     Z3MAT = X1MAT*Y3MAT - Y1MAT*X3MAT;
     Z3MAT -=  hermX*hermY * Z3MAT.t();
 
@@ -4729,7 +4972,7 @@ void comm133ss( const Operator& X, const Operator& Y, Operator& Z )
         Z3.AddToME_pn_PN_ch(ch3,ch3, iter_bra.first,iter_ket.first,  Z3MAT(iter_bra.second,iter_ket.second) );
       }
     }
- 
+
   }// for ch3
   Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
 }
@@ -4737,88 +4980,88 @@ void comm133ss( const Operator& X, const Operator& Y, Operator& Z )
 
 // the old slow way
 /*
-void comm133ss( const Operator& X, const Operator& Y, Operator& Z )
-{
+   void comm133ss( const Operator& X, const Operator& Y, Operator& Z )
+   {
 //  double normY = Y.ThreeBodyNorm();
 //  int e3maxcut = 96;
-  auto& X3 = X.ThreeBody;
-  auto& Y3 = Y.ThreeBody;
-  auto& Z3 = Z.ThreeBody;
-  auto& X1 = X.OneBody;
-  auto& Y1 = Y.OneBody;
+auto& X3 = X.ThreeBody;
+auto& Y3 = Y.ThreeBody;
+auto& Z3 = Z.ThreeBody;
+auto& X1 = X.OneBody;
+auto& Y1 = Y.OneBody;
 //  std::cout << "Y1 =" << std::endl << Y1 << std::endl;
-  int norbs = Z.modelspace->GetNumberOrbits();
-  if (X3.Norm()<1e-6 and Y3.Norm()<1e-6 ) return;
-  size_t nch3 = Z.modelspace->GetNumberThreeBodyChannels();
+int norbs = Z.modelspace->GetNumberOrbits();
+if (X3.Norm()<1e-6 and Y3.Norm()<1e-6 ) return;
+size_t nch3 = Z.modelspace->GetNumberThreeBodyChannels();
 //  #pragma omp parallel for schedule(dynamic,1)
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
-  for (size_t ch3=0; ch3<=nch3; ch3++)
-  {
-    auto& Tbc = Z.modelspace->GetThreeBodyChannel(ch3);
-    int twoJ = Tbc.twoJ;
-    size_t nkets = Tbc.GetNumberKets();
-    for (size_t ibra=0; ibra<nkets; ibra++)
-    {
-      Ket3& bra = Tbc.GetKet(ibra);
-      size_t i = bra.p;
-      size_t j = bra.q;
-      size_t k = bra.r;
-      Orbit& oi = Z.modelspace->GetOrbit(i);
-      Orbit& oj = Z.modelspace->GetOrbit(j);
-      Orbit& ok = Z.modelspace->GetOrbit(k);
-      int Jij = bra.Jpq;
-      for (size_t iket=ibra; iket<nkets; iket++)
-      {
-        Ket3& ket = Tbc.GetKet(iket);
-        size_t l = ket.p;
-        size_t m = ket.q;
-        size_t n = ket.r;
-        Orbit& ol = Z.modelspace->GetOrbit(l);
-        Orbit& om = Z.modelspace->GetOrbit(m);
-        Orbit& on = Z.modelspace->GetOrbit(n);
-        int Jlm = ket.Jpq;
-        
-        double zsum =0;
-        // First, connect on the bra side
-        for (auto a : X.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) )
-        {
-          zsum += X1(i,a) * Y3.GetME_pn(Jij, Jlm, twoJ, a, j, k, l, m, n);
-          zsum -= Y1(i,a) * X3.GetME_pn(Jij, Jlm, twoJ, a, j, k, l, m, n);
-        }
-        for (auto a : X.OneBodyChannels.at({oj.l,oj.j2,oj.tz2}) )
-        {
-          zsum += X1(j,a) * Y3.GetME_pn(Jij, Jlm, twoJ, i, a, k, l, m, n);
-          zsum -= Y1(j,a) * X3.GetME_pn(Jij, Jlm, twoJ, i, a, k, l, m, n);
-        }
-        for (auto a : X.OneBodyChannels.at({ok.l,ok.j2,ok.tz2}) )
-        {
-          zsum += X1(k,a) * Y3.GetME_pn(Jij, Jlm, twoJ, i, j, a, l, m, n);
-          zsum -= Y1(k,a) * X3.GetME_pn(Jij, Jlm, twoJ, i, j, a, l, m, n);
-        }
-        // Now connect on the ket side
-        for (auto a : X.OneBodyChannels.at({ol.l,ol.j2,ol.tz2}) )
-        {
-          zsum -= X1(a,l) * Y3.GetME_pn(Jij, Jlm, twoJ, i, j, k, a, m, n);
-          zsum += Y1(a,l) * X3.GetME_pn(Jij, Jlm, twoJ, i, j, k, a, m, n);
-        }
-        for (auto a : X.OneBodyChannels.at({om.l,om.j2,om.tz2}) )
-        {
-          zsum -= X1(a,m) * Y3.GetME_pn(Jij, Jlm, twoJ, i, j, k, l, a, n);
-          zsum += Y1(a,m) * X3.GetME_pn(Jij, Jlm, twoJ, i, j, k, l, a, n);
-        }
-        for (auto a : X.OneBodyChannels.at({on.l,on.j2,on.tz2}) )
-        {
-          zsum -= X1(a,n) * Y3.GetME_pn(Jij, Jlm, twoJ, i, j, k, l, m, a);
-          zsum += Y1(a,n) * X3.GetME_pn(Jij, Jlm, twoJ, i, j, k, l, m, a);
-        }
-  
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+for (size_t ch3=0; ch3<=nch3; ch3++)
+{
+auto& Tbc = Z.modelspace->GetThreeBodyChannel(ch3);
+int twoJ = Tbc.twoJ;
+size_t nkets = Tbc.GetNumberKets();
+for (size_t ibra=0; ibra<nkets; ibra++)
+{
+Ket3& bra = Tbc.GetKet(ibra);
+size_t i = bra.p;
+size_t j = bra.q;
+size_t k = bra.r;
+Orbit& oi = Z.modelspace->GetOrbit(i);
+Orbit& oj = Z.modelspace->GetOrbit(j);
+Orbit& ok = Z.modelspace->GetOrbit(k);
+int Jij = bra.Jpq;
+for (size_t iket=ibra; iket<nkets; iket++)
+{
+Ket3& ket = Tbc.GetKet(iket);
+size_t l = ket.p;
+size_t m = ket.q;
+size_t n = ket.r;
+Orbit& ol = Z.modelspace->GetOrbit(l);
+Orbit& om = Z.modelspace->GetOrbit(m);
+Orbit& on = Z.modelspace->GetOrbit(n);
+int Jlm = ket.Jpq;
+
+double zsum =0;
+// First, connect on the bra side
+for (auto a : X.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) )
+{
+zsum += X1(i,a) * Y3.GetME_pn(Jij, Jlm, twoJ, a, j, k, l, m, n);
+zsum -= Y1(i,a) * X3.GetME_pn(Jij, Jlm, twoJ, a, j, k, l, m, n);
+}
+for (auto a : X.OneBodyChannels.at({oj.l,oj.j2,oj.tz2}) )
+{
+zsum += X1(j,a) * Y3.GetME_pn(Jij, Jlm, twoJ, i, a, k, l, m, n);
+zsum -= Y1(j,a) * X3.GetME_pn(Jij, Jlm, twoJ, i, a, k, l, m, n);
+}
+for (auto a : X.OneBodyChannels.at({ok.l,ok.j2,ok.tz2}) )
+{
+zsum += X1(k,a) * Y3.GetME_pn(Jij, Jlm, twoJ, i, j, a, l, m, n);
+zsum -= Y1(k,a) * X3.GetME_pn(Jij, Jlm, twoJ, i, j, a, l, m, n);
+}
+// Now connect on the ket side
+for (auto a : X.OneBodyChannels.at({ol.l,ol.j2,ol.tz2}) )
+{
+zsum -= X1(a,l) * Y3.GetME_pn(Jij, Jlm, twoJ, i, j, k, a, m, n);
+zsum += Y1(a,l) * X3.GetME_pn(Jij, Jlm, twoJ, i, j, k, a, m, n);
+}
+for (auto a : X.OneBodyChannels.at({om.l,om.j2,om.tz2}) )
+{
+zsum -= X1(a,m) * Y3.GetME_pn(Jij, Jlm, twoJ, i, j, k, l, a, n);
+zsum += Y1(a,m) * X3.GetME_pn(Jij, Jlm, twoJ, i, j, k, l, a, n);
+}
+for (auto a : X.OneBodyChannels.at({on.l,on.j2,on.tz2}) )
+{
+  zsum -= X1(a,n) * Y3.GetME_pn(Jij, Jlm, twoJ, i, j, k, l, m, a);
+  zsum += Y1(a,n) * X3.GetME_pn(Jij, Jlm, twoJ, i, j, k, l, m, a);
+}
+
 //        Z3.AddToME_pn(Jij, Jlm, twoJ, i,j,k,l,m,n, zsum );
-        Z3.AddToME_pn_PN_ch(ch3,ch3, ibra, iket, zsum );
+Z3.AddToME_pn_PN_ch(ch3,ch3, ibra, iket, zsum );
+
+}// for iket
+}// for ibra
+}// for ch3
 
-      }// for iket
-    }// for ibra
-  }// for ch3
-            
 }
 */
 
@@ -4828,7 +5071,7 @@ void comm133ss( const Operator& X, const Operator& Y, Operator& Z )
 
 //*****************************************************************************************
 //
-//  i|  j|  k|   Uncoupled expression:  
+//  i|  j|  k|   Uncoupled expression:
 //   |~X~|   |      Z_ijklmn  =  P(ij/k)P(lm/n) sum_a  (X_ijla * Y_akmn - Y_ijla * X_akmn)
 //   |   |a  |
 //   |   |~Y~|   Coupled expression:
@@ -4841,14 +5084,14 @@ void comm133ss( const Operator& X, const Operator& Y, Operator& Z )
 //  |   |a  |     -->          |a
 //  |   |~Y~|                  |~Y~|\
 // l|  m|  n|                 m|  n| \k
-//  checked with UnitTest, and it looks good. 
+//  checked with UnitTest, and it looks good.
 //
 void comm223ss( const Operator& X, const Operator& Y, Operator& Z )
 {
-//  std::cout << " Enter " << __func__ << std::endl;
+  //  std::cout << " Enter " << __func__ << std::endl;
   double tstart = omp_get_wtime();
   double t_internal = omp_get_wtime();
-//  int e3maxcut = 999;
+  //  int e3maxcut = 999;
   int norbs = Z.modelspace->GetNumberOrbits();
   auto& Z3 = Z.ThreeBody;
   auto& X2 = X.TwoBody;
@@ -4870,9 +5113,9 @@ void comm223ss( const Operator& X, const Operator& Y, Operator& Z )
   auto unhash_key_ijnJ = [](size_t& i,size_t& j, size_t& n, size_t& Jij, size_t key){ i=(key & 0xFFFL);j=((key>>12)&0xFFFL);n=((key>>24)&0xFFFL);Jij=((key>>36)&0xFFFL); }; //  0xF = 15 = 1111 (4bits), so 0xFFF is 12 bits of 1's. 0xFFFL makes it a long
   std::vector< std::unordered_map<size_t, size_t>> ket_lookup_pph; // in a given channel, map  i,j,n,Jij -> matrix index
 
-//  std::vector< arma::mat > Zbar;
-//  std::vector< arma::sp_mat > Zbar; // make it a sparse matrix
-//  std::vector<double> Zbar;  // store the transformed Z in a 1D vector.
+  //  std::vector< arma::mat > Zbar;
+  //  std::vector< arma::sp_mat > Zbar; // make it a sparse matrix
+  //  std::vector<double> Zbar;  // store the transformed Z in a 1D vector.
   std::vector<float> Zbar;  // store the transformed Z in a 1D vector.
   std::vector<size_t> Zbar_start_pointers;  // ch -> index in Zbar where that channel starts
 
@@ -4882,11 +5125,11 @@ void comm223ss( const Operator& X, const Operator& Y, Operator& Z )
   double occnat_factor_max = 0;
   for ( auto i : Z.modelspace->all_orbits)
   {
-     double occnat_i = Z.modelspace->GetOrbit(i).occ_nat;
-     occnat_factor_max = std::max( occnat_factor_max, occnat_i*(1-occnat_i) );
+    double occnat_i = Z.modelspace->GetOrbit(i).occ_nat;
+    occnat_factor_max = std::max( occnat_factor_max, occnat_i*(1-occnat_i) );
   }
 
-//  std::cout << "BeginLoop over ph channels" << std::endl;
+  //  std::cout << "BeginLoop over ph channels" << std::endl;
   size_t nch_pph = 0;
   size_t Zbar_n_elements = 0; // total number of elements stored in Zbar
   // Generate all the pph type channels J,parity,Tz. Note that these will be
@@ -4911,7 +5154,7 @@ void comm223ss( const Operator& X, const Operator& Y, Operator& Z )
       int j2n_min = std::abs(2*Jij-twoJph);
       int j2n_max = (2*Jij+twoJph);
       int parity_n = (parity_ij + parity_ph)%2;
-      
+
       std::vector<size_t> good_n;
       for ( int j2n=j2n_min; j2n<=j2n_max; j2n+=2)
       {
@@ -4945,8 +5188,9 @@ void comm223ss( const Operator& X, const Operator& Y, Operator& Z )
         if ( (occnat_i*(1-occnat_i) * occnat_j*(1-occnat_j) * occnat_factor_max ) < Z.modelspace->GetOccNat3Cut() ) continue;
         if ( (d_ei+d_ej) > Z.modelspace->GetdE3max() ) continue;
         if ( (ei + ej) > Z.modelspace->GetE3max() ) continue;
-        if ( perturbative_triples and  not ( (ket_ij.op->cvq + ket_ij.oq->cvq)==0 or (ket_ij.op->cvq+ket_ij.oq->cvq)>2) ) continue;
-        good_ij.push_back({i,j}); 
+        //        if ( perturbative_triples and  not ( (ket_ij.op->cvq + ket_ij.oq->cvq)==0 or (ket_ij.op->cvq+ket_ij.oq->cvq)>2) ) continue;
+        if ( perturbative_triples and  (ket_ij.op->cvq==0 and ket_ij.oq->cvq!=0) or (ket_ij.op->cvq!=0 and ket_ij.oq->cvq==0) ) continue;
+        good_ij.push_back({i,j});
       }//for iket_ij
 
       for ( auto& ij : good_ij )
@@ -4971,44 +5215,44 @@ void comm223ss( const Operator& X, const Operator& Y, Operator& Z )
     channels_pph[{twoJph, parity_ph,twoTz_ph}] = nch_pph;
     channel_list_pph.push_back({twoJph, parity_ph,twoTz_ph});
     ket_lookup_pph.push_back( good_kets_ijn );
-//    Zbar.push_back( arma::mat( ngood_ijn, ngood_ijn, arma::fill::zeros )  );
-//    Zbar.push_back( arma::sp_mat( ngood_ijn, ngood_ijn )  );
-    Zbar_start_pointers.push_back( Zbar_n_elements ) ;     
+    //    Zbar.push_back( arma::mat( ngood_ijn, ngood_ijn, arma::fill::zeros )  );
+    //    Zbar.push_back( arma::sp_mat( ngood_ijn, ngood_ijn )  );
+    Zbar_start_pointers.push_back( Zbar_n_elements ) ;
     Zbar_n_elements += ngood_ijn * (ngood_ijn+1) / 2 ;
     nch_pph++;
   }// for iter_obc
-//  std::cout << "Nominally " << nch_pph << "  pph channels " << std::endl;
+  //  std::cout << "Nominally " << nch_pph << "  pph channels " << std::endl;
 
   Zbar.resize( Zbar_n_elements, 0. );
   std::cout << __func__ << "  allocating Zbar   " << Zbar_n_elements << " elements  ~ " << Zbar_n_elements * sizeof(float) /(1024.*1024*1024) << " GB" << std::endl;
-  
+
   Z.profiler.timer["comm223_setup_loop"] += omp_get_wtime() - t_internal;
   t_internal = omp_get_wtime();
-//  std::cout << "done with setup" << std::endl;
-
- // Now we should fill those Zbar matrices.
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
- for (size_t ch_pph=0; ch_pph<nch_pph; ch_pph++)
- {
-
-   auto& ch_info = channel_list_pph[ch_pph];
-   int twoJph    = ch_info[0];
-   int parity_ph = ch_info[1];
-   int twoTz_ph  = ch_info[2];
-   int l_a = ((twoJph+1)/2)%2 == parity_ph ? (twoJph+1)/2  :  (twoJph-1)/2;
-
-
-//   auto& a_set = Z.modelspace->OneBodyChannels.at({l_a,twoJph,twoTz_ph}); // list of one-body orbits in this channel
-   std::vector<size_t> a_list;
-   for (auto a : Z.modelspace->OneBodyChannels.at({l_a,twoJph,twoTz_ph}) ) a_list.push_back(a);
-   size_t number_a = a_list.size();
-
-   auto& good_kets_ijn = ket_lookup_pph[ch_pph];
-   size_t ngood_ijn = good_kets_ijn.size();
-   arma::mat Xph( ngood_ijn, number_a );
-   arma::mat Yph( number_a, ngood_ijn );
-   for (auto& iter_ijn : good_kets_ijn )
-   {
+  //  std::cout << "done with setup" << std::endl;
+
+  // Now we should fill those Zbar matrices.
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+  for (size_t ch_pph=0; ch_pph<nch_pph; ch_pph++)
+  {
+
+    auto& ch_info = channel_list_pph[ch_pph];
+    int twoJph    = ch_info[0];
+    int parity_ph = ch_info[1];
+    int twoTz_ph  = ch_info[2];
+    int l_a = ((twoJph+1)/2)%2 == parity_ph ? (twoJph+1)/2  :  (twoJph-1)/2;
+
+
+    //   auto& a_set = Z.modelspace->OneBodyChannels.at({l_a,twoJph,twoTz_ph}); // list of one-body orbits in this channel
+    std::vector<size_t> a_list;
+    for (auto a : Z.modelspace->OneBodyChannels.at({l_a,twoJph,twoTz_ph}) ) a_list.push_back(a);
+    size_t number_a = a_list.size();
+
+    auto& good_kets_ijn = ket_lookup_pph[ch_pph];
+    size_t ngood_ijn = good_kets_ijn.size();
+    arma::mat Xph( ngood_ijn, number_a );
+    arma::mat Yph( number_a, ngood_ijn );
+    for (auto& iter_ijn : good_kets_ijn )
+    {
       size_t Iijn = iter_ijn.second;
 
       size_t key = iter_ijn.first;
@@ -5025,41 +5269,41 @@ void comm223ss( const Operator& X, const Operator& Y, Operator& Z )
 
       }// for index_a
 
-   }//for iter_ijn
-   arma::mat z_tmp = Xph*Yph;
-   z_tmp -= hX*hY * z_tmp.t();
-   // Fold the full (anti-)symmetric matrix into a more compact storage
-   // we  use row-major ordering so that the inner loop runs over adjacent elements
-   size_t start_ptr = Zbar_start_pointers[ch_pph];
-   for (size_t II=0; II<ngood_ijn; II++)
-   {
-     size_t row_index = start_ptr + ( 2*ngood_ijn - II - 1) * II / 2 ;
-     for (size_t JJ=II; JJ<ngood_ijn; JJ++)
-     {
-//       size_t zbar_index =  row_index + JJ;
-       Zbar[ row_index+JJ ] = z_tmp(II,JJ);
-     }
-   }
-//   Zbar[ch_pph] = z_tmp;
-//   Zbar[ch_pph] = Xph*Yph;
-//   Zbar[ch_pph] = arma::sp_mat( Xph*Yph );
-//   Zbar[ch_pph] -= hX*hY*Zbar[ch_pph].t();
- }// for ch_pph
+    }//for iter_ijn
+    arma::mat z_tmp = Xph*Yph;
+    z_tmp -= hX*hY * z_tmp.t();
+    // Fold the full (anti-)symmetric matrix into a more compact storage
+    // we  use row-major ordering so that the inner loop runs over adjacent elements
+    size_t start_ptr = Zbar_start_pointers[ch_pph];
+    for (size_t II=0; II<ngood_ijn; II++)
+    {
+      size_t row_index = start_ptr + ( 2*ngood_ijn - II - 1) * II / 2 ;
+      for (size_t JJ=II; JJ<ngood_ijn; JJ++)
+      {
+        //       size_t zbar_index =  row_index + JJ;
+        Zbar[ row_index+JJ ] = z_tmp(II,JJ);
+      }
+    }
+    //   Zbar[ch_pph] = z_tmp;
+    //   Zbar[ch_pph] = Xph*Yph;
+    //   Zbar[ch_pph] = arma::sp_mat( Xph*Yph );
+    //   Zbar[ch_pph] -= hX*hY*Zbar[ch_pph].t();
+  }// for ch_pph
 
-// std::cout << "Done filling matrices " << std::endl;
+  // std::cout << "Done filling matrices " << std::endl;
 
 
   Z.profiler.timer["comm223_fill_loop"] += omp_get_wtime() - t_internal;
   t_internal = omp_get_wtime();
 
 
-//  std::vector< std::map<std::array<size_t,2>,size_t>::iterator> channel_iterators;
+  //  std::vector< std::map<std::array<size_t,2>,size_t>::iterator> channel_iterators;
   std::vector< std::pair<const std::array<size_t,2>,size_t>> channel_iterators;
   for (auto iter : Z.ThreeBody.ch_start ) channel_iterators.push_back(iter);
   size_t nch3 = Z.modelspace->GetNumberThreeBodyChannels();
   size_t n_iter = channel_iterators.size();
-//  for (size_t ch3=0; ch3<nch3; ch3++ )
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+  //  for (size_t ch3=0; ch3<nch3; ch3++ )
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
   for (size_t ch3=0; ch3<nch3; ch3++)
   {
     auto& Tbc = Z.modelspace->GetThreeBodyChannel(ch3);
@@ -5095,10 +5339,10 @@ void comm223ss( const Operator& X, const Operator& Y, Operator& Z )
       std::vector<int> J1p_max = {J1,  std::min(ok.j2+oj.j2, twoJ+oi.j2)/2 , std::min(oi.j2+ok.j2, twoJ+oj.j2)/2 };
       std::vector<std::vector<double>> recouple_ijk = {{1},{},{} };
       for (int J1p=J1p_min[1]; J1p<=J1p_max[1]; J1p++)
-           recouple_ijk[1].push_back( sqrt( (2*J1+1)*(2*J1p+1)) * Z.modelspace->GetSixJ(ji,jj,J1,jk,Jtot,J1p) );
+        recouple_ijk[1].push_back( sqrt( (2*J1+1)*(2*J1p+1)) * Z.modelspace->GetSixJ(ji,jj,J1,jk,Jtot,J1p) );
 
       for (int J1p=J1p_min[2]; J1p<=J1p_max[2]; J1p++)
-           recouple_ijk[2].push_back( -Z.modelspace->phase((oj.j2+ok.j2)/2+J1+J1p)*sqrt( (2*J1+1)*(2*J1p+1)) * Z.modelspace->GetSixJ(jj,ji,J1,jk,Jtot,J1p) );
+        recouple_ijk[2].push_back( -Z.modelspace->phase((oj.j2+ok.j2)/2+J1+J1p)*sqrt( (2*J1+1)*(2*J1p+1)) * Z.modelspace->GetSixJ(jj,ji,J1,jk,Jtot,J1p) );
 
 
       for (size_t iket=ibra; iket<nkets3; iket++)
@@ -5130,12 +5374,12 @@ void comm223ss( const Operator& X, const Operator& Y, Operator& Z )
         std::vector<int> J2p_min = {J2,  std::max(std::abs(on.j2-om.j2), std::abs(twoJ-ol.j2) )/2,   std::max( std::abs(ol.j2-on.j2), std::abs(twoJ-om.j2) )/2 };
         std::vector<int> J2p_max = {J2,  std::min(on.j2+om.j2, twoJ+ol.j2)/2 , std::min(ol.j2+on.j2,twoJ+om.j2)/2 };
         std::vector<std::vector<double>> recouple_lmn = {{1},{},{} };
-            
+
         for (int J2p=J2p_min[1]; J2p<=J2p_max[1]; J2p++)
-           recouple_lmn[1].push_back( sqrt( (2*J2+1)*(2*J2p+1)) * Z.modelspace->GetSixJ(jl,jm,J2,jn,Jtot,J2p) );
+          recouple_lmn[1].push_back( sqrt( (2*J2+1)*(2*J2p+1)) * Z.modelspace->GetSixJ(jl,jm,J2,jn,Jtot,J2p) );
 
         for (int J2p=J2p_min[2]; J2p<=J2p_max[2]; J2p++)
-             recouple_lmn[2].push_back( -Z.modelspace->phase((om.j2+on.j2)/2+J2+J2p)*sqrt( (2*J2+1)*(2*J2p+1)) * Z.modelspace->GetSixJ(jm,jl,J2,jn,Jtot,J2p) );
+          recouple_lmn[2].push_back( -Z.modelspace->phase((om.j2+on.j2)/2+J2+J2p)*sqrt( (2*J2+1)*(2*J2p+1)) * Z.modelspace->GetSixJ(jm,jl,J2,jn,Jtot,J2p) );
 
 
         double zijklmn = 0;
@@ -5186,34 +5430,34 @@ void comm223ss( const Operator& X, const Operator& Y, Operator& Z )
                 int twoJph_max = std::min( 2*J1p+o6.j2 , 2*J2p+o3.j2 );
                 for ( int twoJph=twoJph_min; twoJph<=twoJph_max; twoJph++)
                 {
-                   auto iter_ch = channels_pph.find({ twoJph, parity_ph, twoTz_ph});
-                   if ( iter_ch == channels_pph.end() )  continue;
-                   size_t ch_pph = iter_ch->second;
-                   double Jph = 0.5 * twoJph;
-
-                   size_t index_126 = ket_lookup_pph[ch_pph].at(key_126 );
-                   size_t index_453 = ket_lookup_pph[ch_pph].at(key_453 );
-
-                   double zbar_126453=0;
-                   size_t start_ptr = Zbar_start_pointers[ch_pph];
-                   size_t ngood_ijn = ket_lookup_pph[ch_pph].size();
-                   if ( index_126<= index_453 )
-                   {
-                     size_t zbar_index = start_ptr + ( 2*ngood_ijn - index_126 - 1) * index_126 / 2  + index_453 ;
-                     zbar_126453 = Zbar[ zbar_index ]  * phase_12 * phase_45;
-                   }
-                   else
-                   {
-                     size_t zbar_index = start_ptr + ( 2*ngood_ijn - index_453 - 1) * index_453 / 2  + index_126 ;
-                     zbar_126453 = hZ * Zbar[ zbar_index ]  * phase_12 * phase_45;
-                   }
-
-
-//                   double zbar_126453 =  phase_12 * phase_45 * Zbar[ch_pph](index_126,index_453);
-//                   std::cout <<  "  Zbar conjugates :  " << Zbar[ch_pph](index_126,index_453) << "  " << Zbar[ch_pph](index_453,index_126) << std::endl;
-
-                   double sixj1 = Z.modelspace->GetSixJ(J1p,j3,Jtot, J2p,j6,Jph);
-                   z_123456 +=   sixj1 * zbar_126453  ; 
+                  auto iter_ch = channels_pph.find({ twoJph, parity_ph, twoTz_ph});
+                  if ( iter_ch == channels_pph.end() )  continue;
+                  size_t ch_pph = iter_ch->second;
+                  double Jph = 0.5 * twoJph;
+
+                  size_t index_126 = ket_lookup_pph[ch_pph].at(key_126 );
+                  size_t index_453 = ket_lookup_pph[ch_pph].at(key_453 );
+
+                  double zbar_126453=0;
+                  size_t start_ptr = Zbar_start_pointers[ch_pph];
+                  size_t ngood_ijn = ket_lookup_pph[ch_pph].size();
+                  if ( index_126<= index_453 )
+                  {
+                    size_t zbar_index = start_ptr + ( 2*ngood_ijn - index_126 - 1) * index_126 / 2  + index_453 ;
+                    zbar_126453 = Zbar[ zbar_index ]  * phase_12 * phase_45;
+                  }
+                  else
+                  {
+                    size_t zbar_index = start_ptr + ( 2*ngood_ijn - index_453 - 1) * index_453 / 2  + index_126 ;
+                    zbar_126453 = hZ * Zbar[ zbar_index ]  * phase_12 * phase_45;
+                  }
+
+
+                  //                   double zbar_126453 =  phase_12 * phase_45 * Zbar[ch_pph](index_126,index_453);
+                  //                   std::cout <<  "  Zbar conjugates :  " << Zbar[ch_pph](index_126,index_453) << "  " << Zbar[ch_pph](index_453,index_126) << std::endl;
+
+                  double sixj1 = Z.modelspace->GetSixJ(J1p,j3,Jtot, J2p,j6,Jph);
+                  z_123456 +=   sixj1 * zbar_126453  ;
 
                 }
 
@@ -5224,7 +5468,7 @@ void comm223ss( const Operator& X, const Operator& Y, Operator& Z )
           }// for J1p
         }// for perm_ijk
 
-//        Z3.AddToME_pn_PN_ch( ch_bra,ch_ket,ibra,iket, z_ijklmn );
+        //        Z3.AddToME_pn_PN_ch( ch_bra,ch_ket,ibra,iket, z_ijklmn );
         Z3.AddToME_pn_PN_ch( ch3,ch3,ibra,iket, zijklmn );
       }// for iket
     }// for ibra
@@ -5237,7 +5481,7 @@ void comm223ss( const Operator& X, const Operator& Y, Operator& Z )
 
 
 
-bool check_2b_channel_Tz_parity( const Operator& Op, Orbit& o1, Orbit&o2, Orbit& o3, Orbit& o4 ) 
+bool check_2b_channel_Tz_parity( const Operator& Op, Orbit& o1, Orbit&o2, Orbit& o3, Orbit& o4 )
 {
   return (    ((o1.l+o2.l+o3.l+o4.l)%2==Op.parity)  and (  std::abs(o1.tz2+o2.tz2-o3.tz2-o4.tz2)==2*Op.rank_T)  );
 }
@@ -5246,7 +5490,7 @@ bool check_2b_channel_Tz_parity( const Operator& Op, Orbit& o1, Orbit&o2, Orbit&
 void comm223ss_debug( const Operator& X, const Operator& Y, Operator& Z )
 {
   double tstart = omp_get_wtime();
-//  int e3maxcut = 999;
+  //  int e3maxcut = 999;
   int norbs = Z.modelspace->GetNumberOrbits();
   auto& Z3 = Z.ThreeBody;
   auto& X2 = X.TwoBody;
@@ -5256,29 +5500,29 @@ void comm223ss_debug( const Operator& X, const Operator& Y, Operator& Z )
   std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
   // we loop over i, j<=i, k<=j    l<=i, m<=l, n<=m, and Jij, Jmn free unless  ijk == lmn, then we take Jmn <= Jij.
 
-//  std::vector< std::map<std::array<size_t,2>,size_t>::iterator> channel_iterators;
+  //  std::vector< std::map<std::array<size_t,2>,size_t>::iterator> channel_iterators;
   std::vector< std::pair<const std::array<size_t,2>,size_t>> channel_iterators;
   for (auto iter : Z.ThreeBody.ch_start ) channel_iterators.push_back(iter);
   size_t nch3 = Z.modelspace->GetNumberThreeBodyChannels();
   size_t n_iter = channel_iterators.size();
-//  for (size_t ch3=0; ch3<nch3; ch3++ )
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+  //  for (size_t ch3=0; ch3<nch3; ch3++ )
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
   for (size_t iiter=0; iiter<n_iter; iiter++ )
   {
     size_t ch_bra = channel_iterators[iiter].first[0];
     size_t ch_ket = channel_iterators[iiter].first[1];
-//    auto& Tbc = Z.modelspace->GetThreeBodyChannel(ch3);
+    //    auto& Tbc = Z.modelspace->GetThreeBodyChannel(ch3);
     auto& Tbc_bra = Z.modelspace->GetThreeBodyChannel(ch_bra);
     auto& Tbc_ket = Z.modelspace->GetThreeBodyChannel(ch_ket);
-//    size_t nkets3 = Tbc.GetNumberKets();
+    //    size_t nkets3 = Tbc.GetNumberKets();
     size_t nbras3 = Tbc_bra.GetNumberKets();
     size_t nkets3 = Tbc_ket.GetNumberKets();
-//    int twoJ = Tbc.twoJ;
+    //    int twoJ = Tbc.twoJ;
     int twoJ = Tbc_bra.twoJ;
     double Jtot = 0.5*twoJ;
     for (size_t ibra=0; ibra<nbras3; ibra++)
     {
-//      Ket3& bra = Tbc.GetKet(ibra);
+      //      Ket3& bra = Tbc.GetKet(ibra);
       Ket3& bra = Tbc_bra.GetKet(ibra);
       size_t i = bra.p;
       size_t j = bra.q;
@@ -5300,40 +5544,40 @@ void comm223ss_debug( const Operator& X, const Operator& Y, Operator& Z )
       int J1 = bra.Jpq;
 
 
-          int Jx_min,Jx_max,Jy_min,Jy_max;
+      int Jx_min,Jx_max,Jy_min,Jy_max;
 
-          std::vector<int> J_Pik;
-          std::vector<double> recouple_Pik;
-          Jx_min = std::max( std::abs(oi.j2-twoJ), std::abs(oj.j2-ok.j2) )/2;
-          Jx_max = std::min( oi.j2+twoJ, oj.j2+ok.j2)/2;
-          for (int Jx=Jx_min; Jx<=Jx_max; Jx++)
-          {
-             double recouple_coeff = (2*Jx+1) * Z.modelspace->GetSixJ(ji,jj,J1, jk,Jtot,Jx);
-             if (std::abs( recouple_coeff ) <1e-7) continue;
-             J_Pik.push_back( Jx );
-             recouple_Pik.push_back(recouple_coeff);
-          }
+      std::vector<int> J_Pik;
+      std::vector<double> recouple_Pik;
+      Jx_min = std::max( std::abs(oi.j2-twoJ), std::abs(oj.j2-ok.j2) )/2;
+      Jx_max = std::min( oi.j2+twoJ, oj.j2+ok.j2)/2;
+      for (int Jx=Jx_min; Jx<=Jx_max; Jx++)
+      {
+        double recouple_coeff = (2*Jx+1) * Z.modelspace->GetSixJ(ji,jj,J1, jk,Jtot,Jx);
+        if (std::abs( recouple_coeff ) <1e-7) continue;
+        J_Pik.push_back( Jx );
+        recouple_Pik.push_back(recouple_coeff);
+      }
 
 
-          std::vector<int> J_Pjk;
-          std::vector<double> recouple_Pjk;
-          Jx_min = std::max( std::abs(oj.j2-twoJ), std::abs(oi.j2-ok.j2) )/2;
-          Jx_max = std::min( oj.j2+twoJ, oi.j2+ok.j2)/2;
-          for (int Jx=Jx_min; Jx<=Jx_max; Jx++)
-          {
-             double recouple_coeff = (2*Jx+1) * Z.modelspace->GetSixJ(jj,ji,J1, jk,Jtot,Jx);
-             if (std::abs( recouple_coeff ) <1e-7) continue;
-             J_Pjk.push_back( Jx );
-             recouple_Pjk.push_back(recouple_coeff);
-          }
+      std::vector<int> J_Pjk;
+      std::vector<double> recouple_Pjk;
+      Jx_min = std::max( std::abs(oj.j2-twoJ), std::abs(oi.j2-ok.j2) )/2;
+      Jx_max = std::min( oj.j2+twoJ, oi.j2+ok.j2)/2;
+      for (int Jx=Jx_min; Jx<=Jx_max; Jx++)
+      {
+        double recouple_coeff = (2*Jx+1) * Z.modelspace->GetSixJ(jj,ji,J1, jk,Jtot,Jx);
+        if (std::abs( recouple_coeff ) <1e-7) continue;
+        J_Pjk.push_back( Jx );
+        recouple_Pjk.push_back(recouple_coeff);
+      }
 
 
       size_t ket_min = (ch_bra==ch_ket) ? ibra : 0;
-//      for (size_t iket=ibra; iket<nkets3; iket++)
+      //      for (size_t iket=ibra; iket<nkets3; iket++)
 
       for (size_t iket=ket_min; iket<nkets3; iket++)
       {
-//        Ket3& ket = Tbc.GetKet(iket);
+        //        Ket3& ket = Tbc.GetKet(iket);
         Ket3& ket = Tbc_ket.GetKet(iket);
         size_t l = ket.p;
         size_t m = ket.q;
@@ -5359,46 +5603,46 @@ void comm223ss_debug( const Operator& X, const Operator& Y, Operator& Z )
 
 
 
-          std::vector<int> J_Pln;
-          std::vector<double> recouple_Pln;
-          Jx_min = std::max( std::abs(ol.j2-twoJ), std::abs(om.j2-on.j2) )/2;
-          Jx_max = std::min( ol.j2+twoJ, om.j2+on.j2)/2;
-          for (int Jx=Jx_min; Jx<=Jx_max; Jx++)
-          {
-             double recouple_coeff = (2*Jx+1) * Z.modelspace->GetSixJ(jl,jm,J2, jn,Jtot,Jx);
-             if (std::abs( recouple_coeff ) <1e-7) continue;
-             J_Pln.push_back( Jx );
-             recouple_Pln.push_back(recouple_coeff);
-          }
+        std::vector<int> J_Pln;
+        std::vector<double> recouple_Pln;
+        Jx_min = std::max( std::abs(ol.j2-twoJ), std::abs(om.j2-on.j2) )/2;
+        Jx_max = std::min( ol.j2+twoJ, om.j2+on.j2)/2;
+        for (int Jx=Jx_min; Jx<=Jx_max; Jx++)
+        {
+          double recouple_coeff = (2*Jx+1) * Z.modelspace->GetSixJ(jl,jm,J2, jn,Jtot,Jx);
+          if (std::abs( recouple_coeff ) <1e-7) continue;
+          J_Pln.push_back( Jx );
+          recouple_Pln.push_back(recouple_coeff);
+        }
 
 
-          std::vector<int> J_Pmn;
-          std::vector<double> recouple_Pmn;
-          Jx_min = std::max( std::abs(om.j2-twoJ), std::abs(ol.j2-on.j2) )/2;
-          Jx_max = std::min( om.j2+twoJ, ol.j2+on.j2)/2;
-          for (int Jx=Jx_min; Jx<=Jx_max; Jx++)
-          {
-             double recouple_coeff = (2*Jx+1) * Z.modelspace->GetSixJ(jm,jl,J2, jn,Jtot,Jx);
-             if (std::abs( recouple_coeff ) <1e-7) continue;
-             J_Pmn.push_back( Jx );
-             recouple_Pmn.push_back(recouple_coeff);
-          }
+        std::vector<int> J_Pmn;
+        std::vector<double> recouple_Pmn;
+        Jx_min = std::max( std::abs(om.j2-twoJ), std::abs(ol.j2-on.j2) )/2;
+        Jx_max = std::min( om.j2+twoJ, ol.j2+on.j2)/2;
+        for (int Jx=Jx_min; Jx<=Jx_max; Jx++)
+        {
+          double recouple_coeff = (2*Jx+1) * Z.modelspace->GetSixJ(jm,jl,J2, jn,Jtot,Jx);
+          if (std::abs( recouple_coeff ) <1e-7) continue;
+          J_Pmn.push_back( Jx );
+          recouple_Pmn.push_back(recouple_coeff);
+        }
 
 
-//         for (int a=0; a<norbs; a++) // TODO: this can maybe be made more efficient by first looping through ja and computing the 6js?
-         for ( auto OBC_a : Z.OneBodyChannels ) 
-         {
-//          if ( OBC_a.second.size() < 1) continue;
+        //         for (int a=0; a<norbs; a++) // TODO: this can maybe be made more efficient by first looping through ja and computing the 6js?
+        for ( auto OBC_a : Z.OneBodyChannels )
+        {
+          //          if ( OBC_a.second.size() < 1) continue;
           Orbit& oa1 = Z.modelspace->GetOrbit(  *(OBC_a.second.begin()) );
-//          Orbit& oa = Z.modelspace->GetOrbit(a);
+          //          Orbit& oa = Z.modelspace->GetOrbit(a);
 
-//          double ja = 0.5*oa.j2;
+          //          double ja = 0.5*oa.j2;
           double ja = 0.5*oa1.j2;
 
 
           // TODO: recast these 9 terms into a loop as done in the other []->3 commutators
 
-          //Z5   remapped to ZZ1 
+          //Z5   remapped to ZZ1
           if (   (check_2b_channel_Tz_parity(X,oi,oj,on,oa1) and check_2b_channel_Tz_parity(Y,ok,oa1,om,ol))
               or (check_2b_channel_Tz_parity(Y,oi,oj,on,oa1) and check_2b_channel_Tz_parity(X,ok,oa1,om,ol)) )
           {
@@ -5420,7 +5664,7 @@ void comm223ss_debug( const Operator& X, const Operator& Y, Operator& Z )
 
           //Z7  remapped to Pik ZZ1
           if (  ( (check_2b_channel_Tz_parity(X,ok,oj,on,oa1) and check_2b_channel_Tz_parity(Y,oa1,oi,om,ol))
-              or (check_2b_channel_Tz_parity(Y,ok,oj,on,oa1) and check_2b_channel_Tz_parity(X,oa1,oi,om,ol)) )
+                or (check_2b_channel_Tz_parity(Y,ok,oj,on,oa1) and check_2b_channel_Tz_parity(X,oa1,oi,om,ol)) )
               and ( (std::abs(oa1.j2-oi.j2)<=2*J2 ) and (oa1.j2+oi.j2>=2*J2)  )   )
           {
             Jx_min = std::max(std::abs(ok.j2-oj.j2), std::abs(oa1.j2-on.j2) )/2;
@@ -5428,17 +5672,17 @@ void comm223ss_debug( const Operator& X, const Operator& Y, Operator& Z )
             double phase = Z.modelspace->phase( (ol.j2+om.j2+oi.j2+oa1.j2)/2);
             for (auto a : OBC_a.second )
             {
-             double xaiml = X2.GetTBME_J(J2,a,i,m,l);
-             double yaiml = Y2.GetTBME_J(J2,a,i,m,l);
-             for ( size_t i_Pik=0; i_Pik<J_Pik.size(); i_Pik++)
-             {
-               int Jx = J_Pik[i_Pik];
-               double recouple_ik = recouple_Pik[i_Pik];
-               double sixj2 = Z.modelspace->GetSixJ(jn,ja,Jx, ji,Jtot,J2);
-               if (std::abs(sixj2)<1e-7) continue;
-               double xkjna = X2.GetTBME_J(Jx,k,j,n,a);
-               double ykjna = Y2.GetTBME_J(Jx,k,j,n,a);
-               zijklmn += recouple_ik * phase * sixj2 * (xkjna*yaiml-ykjna*xaiml);
+              double xaiml = X2.GetTBME_J(J2,a,i,m,l);
+              double yaiml = Y2.GetTBME_J(J2,a,i,m,l);
+              for ( size_t i_Pik=0; i_Pik<J_Pik.size(); i_Pik++)
+              {
+                int Jx = J_Pik[i_Pik];
+                double recouple_ik = recouple_Pik[i_Pik];
+                double sixj2 = Z.modelspace->GetSixJ(jn,ja,Jx, ji,Jtot,J2);
+                if (std::abs(sixj2)<1e-7) continue;
+                double xkjna = X2.GetTBME_J(Jx,k,j,n,a);
+                double ykjna = Y2.GetTBME_J(Jx,k,j,n,a);
+                zijklmn += recouple_ik * phase * sixj2 * (xkjna*yaiml-ykjna*xaiml);
               }
             }
           }
@@ -5446,33 +5690,33 @@ void comm223ss_debug( const Operator& X, const Operator& Y, Operator& Z )
 
           //Z9  remapped to Pjk ZZ1
           if ( (  (check_2b_channel_Tz_parity(X,oi,ok,on,oa1) and check_2b_channel_Tz_parity(Y,oa1,oj,om,ol))
-               or (check_2b_channel_Tz_parity(Y,oi,ok,on,oa1) and check_2b_channel_Tz_parity(X,oa1,oj,om,ol)) ) 
+                or (check_2b_channel_Tz_parity(Y,oi,ok,on,oa1) and check_2b_channel_Tz_parity(X,oa1,oj,om,ol)) )
               and ( (std::abs(oa1.j2-oj.j2)<=2*J2 ) and (oa1.j2+oj.j2>=2*J2)  )  )
           {
             Jx_min = std::max(std::abs(ok.j2-oi.j2), std::abs(oa1.j2-on.j2) )/2;
             Jx_max = std::min((ok.j2+oi.j2), (oa1.j2+on.j2) )/2;
             for (auto a : OBC_a.second )
             {
-             double xajml = X2.GetTBME_J(J2,a,j,m,l);
-             double yajml = Y2.GetTBME_J(J2,a,j,m,l);
-             for ( size_t i_Pjk=0; i_Pjk<J_Pjk.size(); i_Pjk++)
-             {
-              int Jx = J_Pjk[i_Pjk];
-              double recouple_jk = recouple_Pjk[i_Pjk];
-              double phase = Z.modelspace->phase( (oa1.j2+ok.j2+ol.j2+om.j2)/2 -J1-Jx);
-              double sixj2 = Z.modelspace->GetSixJ(jj,ja,J2, jn,Jtot,Jx);
-              if (std::abs(sixj2)<1e-7) continue;
-              double xikna = X2.GetTBME_J(Jx,i,k,n,a);
-              double yikna = Y2.GetTBME_J(Jx,i,k,n,a);
-              zijklmn +=  phase * recouple_jk * sixj2 * (xikna*yajml-yikna*xajml);
-             }
+              double xajml = X2.GetTBME_J(J2,a,j,m,l);
+              double yajml = Y2.GetTBME_J(J2,a,j,m,l);
+              for ( size_t i_Pjk=0; i_Pjk<J_Pjk.size(); i_Pjk++)
+              {
+                int Jx = J_Pjk[i_Pjk];
+                double recouple_jk = recouple_Pjk[i_Pjk];
+                double phase = Z.modelspace->phase( (oa1.j2+ok.j2+ol.j2+om.j2)/2 -J1-Jx);
+                double sixj2 = Z.modelspace->GetSixJ(jj,ja,J2, jn,Jtot,Jx);
+                if (std::abs(sixj2)<1e-7) continue;
+                double xikna = X2.GetTBME_J(Jx,i,k,n,a);
+                double yikna = Y2.GetTBME_J(Jx,i,k,n,a);
+                zijklmn +=  phase * recouple_jk * sixj2 * (xikna*yajml-yikna*xajml);
+              }
             }
           }
 
 
           //Z4 remapped to Pmn ZZ1
           if (  ( (check_2b_channel_Tz_parity(X,oi,oj,om,oa1) and check_2b_channel_Tz_parity(Y,oa1,ok,ol,on))
-               or (check_2b_channel_Tz_parity(Y,oi,oj,om,oa1) and check_2b_channel_Tz_parity(X,oa1,ok,ol,on)) )
+                or (check_2b_channel_Tz_parity(Y,oi,oj,om,oa1) and check_2b_channel_Tz_parity(X,oa1,ok,ol,on)) )
               and ( (std::abs(om.j2-oa1.j2)<=2*J1 ) and (om.j2+oa1.j2>=2*J1)  ) )
           {
             Jx_min = std::max(std::abs(oa1.j2-ok.j2), std::abs(ol.j2-on.j2) )/2;
@@ -5500,8 +5744,8 @@ void comm223ss_debug( const Operator& X, const Operator& Y, Operator& Z )
 
           //Z1   remapped to Pln ZZ1
           if (  (   (check_2b_channel_Tz_parity(X,oi,oj,ol,oa1) and check_2b_channel_Tz_parity(Y,oa1,ok,om,on))
-                 or (check_2b_channel_Tz_parity(Y,oi,oj,ol,oa1) and check_2b_channel_Tz_parity(X,oa1,ok,om,on)) )
-             and (std::abs(ol.j2-oa1.j2)<=2*J1) and ((ol.j2+oa1.j2)>=2*J1) )
+                or (check_2b_channel_Tz_parity(Y,oi,oj,ol,oa1) and check_2b_channel_Tz_parity(X,oa1,ok,om,on)) )
+              and (std::abs(ol.j2-oa1.j2)<=2*J1) and ((ol.j2+oa1.j2)>=2*J1) )
           {
             Jx_min = std::max(std::abs(oa1.j2-ok.j2), std::abs(om.j2-on.j2) )/2;
             Jx_max = std::min((oa1.j2+ok.j2), (om.j2+on.j2) )/2;
@@ -5544,13 +5788,13 @@ void comm223ss_debug( const Operator& X, const Operator& Y, Operator& Z )
                 double ykjla = Y2.GetTBME_J(Jx,k,j,l,a);
                 for ( size_t i_Pln=0; i_Pln<J_Pln.size(); i_Pln++)
                 {
-                 int Jy = J_Pln[i_Pln];
-                 double recouple_ln = recouple_Pln[i_Pln];
-                 double sixj3 = Z.modelspace->GetSixJ(ji,ja,Jy, jl,Jtot,Jx);
-                 if (std::abs(sixj3)<1e-7) continue;
-                 double xaimn = X2.GetTBME_J(Jy,a,i,m,n);
-                 double yaimn = Y2.GetTBME_J(Jy,a,i,m,n);
-                 zijklmn +=  phase * recouple_ik  * recouple_ln *sixj3 * (xkjla*yaimn -ykjla*xaimn);
+                  int Jy = J_Pln[i_Pln];
+                  double recouple_ln = recouple_Pln[i_Pln];
+                  double sixj3 = Z.modelspace->GetSixJ(ji,ja,Jy, jl,Jtot,Jx);
+                  if (std::abs(sixj3)<1e-7) continue;
+                  double xaimn = X2.GetTBME_J(Jy,a,i,m,n);
+                  double yaimn = Y2.GetTBME_J(Jy,a,i,m,n);
+                  zijklmn +=  phase * recouple_ik  * recouple_ln *sixj3 * (xkjla*yaimn -ykjla*xaimn);
                 }
               }
             }
@@ -5571,12 +5815,12 @@ void comm223ss_debug( const Operator& X, const Operator& Y, Operator& Z )
               if ( Jx<Jx_min or Jx>Jx_max) continue;
               double recouple_jk = recouple_Pjk[i_Pjk];
               double phase =-Z.modelspace->phase( (ok.j2+om.j2+on.j2-oa1.j2)/2-J1-Jx);
-               for (auto a : OBC_a.second )
-               {
-                 double xikla = X2.GetTBME_J(Jx,i,k,l,a);
-                 double yikla = Y2.GetTBME_J(Jx,i,k,l,a);
-                 for ( size_t i_Pln=0; i_Pln<J_Pln.size(); i_Pln++)
-                 {
+              for (auto a : OBC_a.second )
+              {
+                double xikla = X2.GetTBME_J(Jx,i,k,l,a);
+                double yikla = Y2.GetTBME_J(Jx,i,k,l,a);
+                for ( size_t i_Pln=0; i_Pln<J_Pln.size(); i_Pln++)
+                {
                   int Jy = J_Pln[i_Pln];
                   double recouple_ln = recouple_Pln[i_Pln];
                   double sixj3 = Z.modelspace->GetSixJ(jj,ja,Jy, jl,Jtot,Jx);
@@ -5584,7 +5828,7 @@ void comm223ss_debug( const Operator& X, const Operator& Y, Operator& Z )
                   double xajmn = X2.GetTBME_J(Jy,a,j,m,n);
                   double yajmn = Y2.GetTBME_J(Jy,a,j,m,n);
                   zijklmn += phase * recouple_jk * recouple_ln *sixj3 * (xikla*yajmn-yikla*xajmn);
-                 }
+                }
               }
             }
           }
@@ -5618,7 +5862,7 @@ void comm223ss_debug( const Operator& X, const Operator& Y, Operator& Z )
                   double yailn = Y2.GetTBME_J(Jy,a,i,l,n);
                   zijklmn +=  phase * recouple_ik * recouple_mn * sixj3 * (xkjma*yailn-ykjma*xailn);
                 }
-             }
+              }
             }
           }
 
@@ -5656,13 +5900,13 @@ void comm223ss_debug( const Operator& X, const Operator& Y, Operator& Z )
 
 
 
-         }// for OBC_a
+        }// for OBC_a
 
-         zijklmn *=  sqrt( (2*J1+1.)*(2*J2+1.));
-         Z3.AddToME_pn_PN_ch( ch_bra,ch_ket,ibra,iket, zijklmn );
+        zijklmn *=  sqrt( (2*J1+1.)*(2*J2+1.));
+        Z3.AddToME_pn_PN_ch( ch_bra,ch_ket,ibra,iket, zijklmn );
 
-    }// for iket
-   }// for ibra
+      }// for iket
+    }// for ibra
   }// for ch3
   Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
 }
@@ -5672,307 +5916,307 @@ void comm223ss_debug( const Operator& X, const Operator& Y, Operator& Z )
 
 
 /*
-void comm223ss( const Operator& X, const Operator& Y, Operator& Z )
-{
-  double tstart = omp_get_wtime();
+   void comm223ss( const Operator& X, const Operator& Y, Operator& Z )
+   {
+   double tstart = omp_get_wtime();
 //  int e3maxcut = 999;
-  int norbs = Z.modelspace->GetNumberOrbits();
-  auto& Z3 = Z.ThreeBody;
-  auto& X2 = X.TwoBody;
-  auto& Y2 = Y.TwoBody;
-  if ( (std::abs( X2.Norm() * Y2.Norm() ) < 1e-6 ) and not Z.modelspace->scalar3b_transform_first_pass) return;
+int norbs = Z.modelspace->GetNumberOrbits();
+auto& Z3 = Z.ThreeBody;
+auto& X2 = X.TwoBody;
+auto& Y2 = Y.TwoBody;
+if ( (std::abs( X2.Norm() * Y2.Norm() ) < 1e-6 ) and not Z.modelspace->scalar3b_transform_first_pass) return;
 
-  std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
-  // we loop over i, j<=i, k<=j    l<=i, m<=l, n<=m, and Jij, Jmn free unless  ijk == lmn, then we take Jmn <= Jij.
+std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
+// we loop over i, j<=i, k<=j    l<=i, m<=l, n<=m, and Jij, Jmn free unless  ijk == lmn, then we take Jmn <= Jij.
 
 //  std::vector< std::map<std::array<size_t,2>,size_t>::iterator> channel_iterators;
-  std::vector< std::pair<const std::array<size_t,2>,size_t>> channel_iterators;
-  for (auto iter : Z.ThreeBody.ch_start ) channel_iterators.push_back(iter);
-  size_t nch3 = Z.modelspace->GetNumberThreeBodyChannels();
-  size_t n_iter = channel_iterators.size();
+std::vector< std::pair<const std::array<size_t,2>,size_t>> channel_iterators;
+for (auto iter : Z.ThreeBody.ch_start ) channel_iterators.push_back(iter);
+size_t nch3 = Z.modelspace->GetNumberThreeBodyChannels();
+size_t n_iter = channel_iterators.size();
 //  for (size_t ch3=0; ch3<nch3; ch3++ )
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
-  for (size_t iiter=0; iiter<n_iter; iiter++ )
-  {
-    size_t ch_bra = channel_iterators[iiter].first[0];
-    size_t ch_ket = channel_iterators[iiter].first[1];
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+for (size_t iiter=0; iiter<n_iter; iiter++ )
+{
+size_t ch_bra = channel_iterators[iiter].first[0];
+size_t ch_ket = channel_iterators[iiter].first[1];
 //    auto& Tbc = Z.modelspace->GetThreeBodyChannel(ch3);
-    auto& Tbc_bra = Z.modelspace->GetThreeBodyChannel(ch_bra);
-    auto& Tbc_ket = Z.modelspace->GetThreeBodyChannel(ch_ket);
+auto& Tbc_bra = Z.modelspace->GetThreeBodyChannel(ch_bra);
+auto& Tbc_ket = Z.modelspace->GetThreeBodyChannel(ch_ket);
 //    size_t nkets3 = Tbc.GetNumberKets();
-    size_t nbras3 = Tbc_bra.GetNumberKets();
-    size_t nkets3 = Tbc_ket.GetNumberKets();
+size_t nbras3 = Tbc_bra.GetNumberKets();
+size_t nkets3 = Tbc_ket.GetNumberKets();
 //    int twoJ = Tbc.twoJ;
-    int twoJ = Tbc_bra.twoJ;
-    double Jtot = 0.5*twoJ;
-    for (size_t ibra=0; ibra<nbras3; ibra++)
-    {
+int twoJ = Tbc_bra.twoJ;
+double Jtot = 0.5*twoJ;
+for (size_t ibra=0; ibra<nbras3; ibra++)
+{
 //      Ket3& bra = Tbc.GetKet(ibra);
-      Ket3& bra = Tbc_bra.GetKet(ibra);
-      size_t i = bra.p;
-      size_t j = bra.q;
-      size_t k = bra.r;
-      Orbit& oi = Z.modelspace->GetOrbit(i);
-      Orbit& oj = Z.modelspace->GetOrbit(j);
-      Orbit& ok = Z.modelspace->GetOrbit(k);
-      int ei = 2*oi.n + oi.l;
-      int ej = 2*oj.n + oj.l;
-      int ek = 2*ok.n + ok.l;
-      if ( (std::abs(ei-e_fermi[oi.tz2]) + std::abs(ej-e_fermi[oj.tz2]) + std::abs(ek-e_fermi[ok.tz2])) > Z.modelspace->GetdE3max() ) continue;
-      double ji = 0.5*oi.j2;
-      double jj = 0.5*oj.j2;
-      double jk = 0.5*ok.j2;
-      int J1 = bra.Jpq;
-      size_t ket_min = (ch_bra==ch_ket) ? ibra : 0;
+Ket3& bra = Tbc_bra.GetKet(ibra);
+size_t i = bra.p;
+size_t j = bra.q;
+size_t k = bra.r;
+Orbit& oi = Z.modelspace->GetOrbit(i);
+Orbit& oj = Z.modelspace->GetOrbit(j);
+Orbit& ok = Z.modelspace->GetOrbit(k);
+int ei = 2*oi.n + oi.l;
+int ej = 2*oj.n + oj.l;
+int ek = 2*ok.n + ok.l;
+if ( (std::abs(ei-e_fermi[oi.tz2]) + std::abs(ej-e_fermi[oj.tz2]) + std::abs(ek-e_fermi[ok.tz2])) > Z.modelspace->GetdE3max() ) continue;
+double ji = 0.5*oi.j2;
+double jj = 0.5*oj.j2;
+double jk = 0.5*ok.j2;
+int J1 = bra.Jpq;
+size_t ket_min = (ch_bra==ch_ket) ? ibra : 0;
 //      for (size_t iket=ibra; iket<nkets3; iket++)
-      for (size_t iket=ket_min; iket<nkets3; iket++)
-      {
+for (size_t iket=ket_min; iket<nkets3; iket++)
+{
 //        Ket3& ket = Tbc.GetKet(iket);
-        Ket3& ket = Tbc_ket.GetKet(iket);
-        size_t l = ket.p;
-        size_t m = ket.q;
-        size_t n = ket.r;
-        Orbit& ol = Z.modelspace->GetOrbit(l);
-        Orbit& om = Z.modelspace->GetOrbit(m);
-        Orbit& on = Z.modelspace->GetOrbit(n);
-        int el = 2*ol.n + ol.l;
-        int em = 2*om.n + om.l;
-        int en = 2*on.n + on.l;
-        if ( (std::abs(el-e_fermi[ol.tz2]) + std::abs(em-e_fermi[om.tz2]) + std::abs(en-e_fermi[on.tz2])) > Z.modelspace->GetdE3max() ) continue;
-        double jl = 0.5*ol.j2;
-        double jm = 0.5*om.j2;
-        double jn = 0.5*on.j2;
-        int J2 = ket.Jpq;
-
-        double zijklmn = 0;
-
-         for (int a=0; a<norbs; a++) // TODO: this can maybe be made more efficient by first looping through ja and computing the 6js?
-         {
-          Orbit& oa = Z.modelspace->GetOrbit(a);
+Ket3& ket = Tbc_ket.GetKet(iket);
+size_t l = ket.p;
+size_t m = ket.q;
+size_t n = ket.r;
+Orbit& ol = Z.modelspace->GetOrbit(l);
+Orbit& om = Z.modelspace->GetOrbit(m);
+Orbit& on = Z.modelspace->GetOrbit(n);
+int el = 2*ol.n + ol.l;
+int em = 2*om.n + om.l;
+int en = 2*on.n + on.l;
+if ( (std::abs(el-e_fermi[ol.tz2]) + std::abs(em-e_fermi[om.tz2]) + std::abs(en-e_fermi[on.tz2])) > Z.modelspace->GetdE3max() ) continue;
+double jl = 0.5*ol.j2;
+double jm = 0.5*om.j2;
+double jn = 0.5*on.j2;
+int J2 = ket.Jpq;
+
+double zijklmn = 0;
+
+for (int a=0; a<norbs; a++) // TODO: this can maybe be made more efficient by first looping through ja and computing the 6js?
+{
+  Orbit& oa = Z.modelspace->GetOrbit(a);
 
-          double ja = 0.5*oa.j2;
+  double ja = 0.5*oa.j2;
 
-          int Jx_min,Jx_max,Jy_min,Jy_max;
+  int Jx_min,Jx_max,Jy_min,Jy_max;
 
 
-          //Z1
-          if (  (   (check_2b_channel_Tz_parity(X,oi,oj,ol,oa) and check_2b_channel_Tz_parity(Y,oa,ok,om,on))
-                 or (check_2b_channel_Tz_parity(Y,oi,oj,ol,oa) and check_2b_channel_Tz_parity(X,oa,ok,om,on)) )
-             and (std::abs(ol.j2-oa.j2)<=2*J1) and ((ol.j2+oa.j2)>=2*J1) )
-          {
-            Jx_min = std::max(std::abs(oa.j2-ok.j2), std::abs(om.j2-on.j2) )/2;
-            Jx_max = std::min((oa.j2+ok.j2), (om.j2+on.j2) )/2;
-            double phase = -Z.modelspace->phase( (om.j2-on.j2-oa.j2-ok.j2)/2);
-            double xijla = X2.GetTBME_J(J1,i,j,l,a);
-            double yijla = Y2.GetTBME_J(J1,i,j,l,a);
-            for ( int Jx=Jx_min; Jx<=Jx_max; Jx++) 
-            {
-              double hats  =  (2*Jx+1) * sqrt( (2*J1+1.)*(2*J2+1.) );
-              double sixj1 = Z.modelspace->GetSixJ(jl,jm,J2, jn,Jtot,Jx);
-              double sixj2 = Z.modelspace->GetSixJ(jl,ja,J1, jk,Jtot,Jx);
-              double xakmn = X2.GetTBME_J(Jx,a,k,m,n);
-              double yakmn = Y2.GetTBME_J(Jx,a,k,m,n);
-              zijklmn += hats * phase * sixj1*sixj2 * (xijla*yakmn-yijla*xakmn);
-            }
-          }
+  //Z1
+  if (  (   (check_2b_channel_Tz_parity(X,oi,oj,ol,oa) and check_2b_channel_Tz_parity(Y,oa,ok,om,on))
+        or (check_2b_channel_Tz_parity(Y,oi,oj,ol,oa) and check_2b_channel_Tz_parity(X,oa,ok,om,on)) )
+      and (std::abs(ol.j2-oa.j2)<=2*J1) and ((ol.j2+oa.j2)>=2*J1) )
+  {
+    Jx_min = std::max(std::abs(oa.j2-ok.j2), std::abs(om.j2-on.j2) )/2;
+    Jx_max = std::min((oa.j2+ok.j2), (om.j2+on.j2) )/2;
+    double phase = -Z.modelspace->phase( (om.j2-on.j2-oa.j2-ok.j2)/2);
+    double xijla = X2.GetTBME_J(J1,i,j,l,a);
+    double yijla = Y2.GetTBME_J(J1,i,j,l,a);
+    for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
+    {
+      double hats  =  (2*Jx+1) * sqrt( (2*J1+1.)*(2*J2+1.) );
+      double sixj1 = Z.modelspace->GetSixJ(jl,jm,J2, jn,Jtot,Jx);
+      double sixj2 = Z.modelspace->GetSixJ(jl,ja,J1, jk,Jtot,Jx);
+      double xakmn = X2.GetTBME_J(Jx,a,k,m,n);
+      double yakmn = Y2.GetTBME_J(Jx,a,k,m,n);
+      zijklmn += hats * phase * sixj1*sixj2 * (xijla*yakmn-yijla*xakmn);
+    }
+  }
 
 
-          //Z2
-          if (   (check_2b_channel_Tz_parity(X,ok,oj,ol,oa) and check_2b_channel_Tz_parity(Y,oa,oi,om,on))
-              or (check_2b_channel_Tz_parity(Y,ok,oj,ol,oa) and check_2b_channel_Tz_parity(X,oa,oi,om,on)) )
-          {
-            Jx_min = std::max(std::abs(oa.j2-ol.j2), std::abs(ok.j2-oj.j2) )/2;
-            Jx_max = std::min((oa.j2+ol.j2), (ok.j2+oj.j2) )/2;
-            Jy_min = std::max(std::abs(oa.j2-oi.j2), std::abs(om.j2-on.j2) )/2;
-            Jy_max = std::min((oa.j2+oi.j2), (om.j2+on.j2) )/2;
-            double phase = Z.modelspace->phase( (om.j2+on.j2-oa.j2-oi.j2)/2);
-            for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
-            {
-              double sixj1 = Z.modelspace->GetSixJ(ji,jj,J1, jk,Jtot,Jx);
-              double xkjla = X2.GetTBME_J(Jx,k,j,l,a);
-              double ykjla = Y2.GetTBME_J(Jx,k,j,l,a);
-              for ( int Jy=Jy_min; Jy<=Jy_max; Jy++)
-              {
-               double hats  =  (2*Jx+1) * (2*Jy+1) * sqrt( (2*J1+1.)*(2*J2+1.) );
-               double sixj2 = Z.modelspace->GetSixJ(jl,jm,J2, jn,Jtot,Jy);
-               double sixj3 = Z.modelspace->GetSixJ(ji,ja,Jy, jl,Jtot,Jx);
-               double xaimn = X2.GetTBME_J(Jy,a,i,m,n);
-               double yaimn = Y2.GetTBME_J(Jy,a,i,m,n);
-               zijklmn += hats * phase * sixj1*sixj2*sixj3 * (xkjla*yaimn -ykjla*xaimn);
+  //Z2
+  if (   (check_2b_channel_Tz_parity(X,ok,oj,ol,oa) and check_2b_channel_Tz_parity(Y,oa,oi,om,on))
+      or (check_2b_channel_Tz_parity(Y,ok,oj,ol,oa) and check_2b_channel_Tz_parity(X,oa,oi,om,on)) )
+  {
+    Jx_min = std::max(std::abs(oa.j2-ol.j2), std::abs(ok.j2-oj.j2) )/2;
+    Jx_max = std::min((oa.j2+ol.j2), (ok.j2+oj.j2) )/2;
+    Jy_min = std::max(std::abs(oa.j2-oi.j2), std::abs(om.j2-on.j2) )/2;
+    Jy_max = std::min((oa.j2+oi.j2), (om.j2+on.j2) )/2;
+    double phase = Z.modelspace->phase( (om.j2+on.j2-oa.j2-oi.j2)/2);
+    for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
+    {
+      double sixj1 = Z.modelspace->GetSixJ(ji,jj,J1, jk,Jtot,Jx);
+      double xkjla = X2.GetTBME_J(Jx,k,j,l,a);
+      double ykjla = Y2.GetTBME_J(Jx,k,j,l,a);
+      for ( int Jy=Jy_min; Jy<=Jy_max; Jy++)
+      {
+        double hats  =  (2*Jx+1) * (2*Jy+1) * sqrt( (2*J1+1.)*(2*J2+1.) );
+        double sixj2 = Z.modelspace->GetSixJ(jl,jm,J2, jn,Jtot,Jy);
+        double sixj3 = Z.modelspace->GetSixJ(ji,ja,Jy, jl,Jtot,Jx);
+        double xaimn = X2.GetTBME_J(Jy,a,i,m,n);
+        double yaimn = Y2.GetTBME_J(Jy,a,i,m,n);
+        zijklmn += hats * phase * sixj1*sixj2*sixj3 * (xkjla*yaimn -ykjla*xaimn);
 
-              }
-            }
-          }
+      }
+    }
+  }
 
 
-          //Z3
-          if (   (check_2b_channel_Tz_parity(X,oi,ok,ol,oa) and check_2b_channel_Tz_parity(Y,oa,oj,om,on))
-              or (check_2b_channel_Tz_parity(Y,oi,ok,ol,oa) and check_2b_channel_Tz_parity(X,oa,oj,om,on)) )
-          {
-            Jx_min = std::max(std::abs(oa.j2-ol.j2), std::abs(oi.j2-ok.j2) )/2;
-            Jx_max = std::min((oa.j2+ol.j2), (oi.j2+ok.j2) )/2;
-            Jy_min = std::max(std::abs(oa.j2-oj.j2), std::abs(om.j2-on.j2) )/2;
-            Jy_max = std::min((oa.j2+oj.j2), (om.j2+on.j2) )/2;
-            for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
-            {
-              double phase =-Z.modelspace->phase( (ok.j2+om.j2+on.j2-oa.j2)/2-J1-Jx);
-              double sixj1 = Z.modelspace->GetSixJ(jj,ji,J1, jk,Jtot,Jx);
-              double xikla = X2.GetTBME_J(Jx,i,k,l,a);
-              double yikla = Y2.GetTBME_J(Jx,i,k,l,a);
-              for ( int Jy=Jy_min; Jy<=Jy_max; Jy++)
-              {
-               double hats  = (2*Jx+1) * (2*Jy+1) * sqrt( (2*J1+1.)*(2*J2+1.) );
-               double sixj2 = Z.modelspace->GetSixJ(jl,jm,J2, jn,Jtot,Jy);
-               double sixj3 = Z.modelspace->GetSixJ(jj,ja,Jy, jl,Jtot,Jx);
-               double xajmn = X2.GetTBME_J(Jy,a,j,m,n);
-               double yajmn = Y2.GetTBME_J(Jy,a,j,m,n);
-               zijklmn += hats * phase * sixj1*sixj2*sixj3 * (xikla*yajmn-yikla*xajmn);
-              }
-            }
-          }
+  //Z3
+  if (   (check_2b_channel_Tz_parity(X,oi,ok,ol,oa) and check_2b_channel_Tz_parity(Y,oa,oj,om,on))
+      or (check_2b_channel_Tz_parity(Y,oi,ok,ol,oa) and check_2b_channel_Tz_parity(X,oa,oj,om,on)) )
+  {
+    Jx_min = std::max(std::abs(oa.j2-ol.j2), std::abs(oi.j2-ok.j2) )/2;
+    Jx_max = std::min((oa.j2+ol.j2), (oi.j2+ok.j2) )/2;
+    Jy_min = std::max(std::abs(oa.j2-oj.j2), std::abs(om.j2-on.j2) )/2;
+    Jy_max = std::min((oa.j2+oj.j2), (om.j2+on.j2) )/2;
+    for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
+    {
+      double phase =-Z.modelspace->phase( (ok.j2+om.j2+on.j2-oa.j2)/2-J1-Jx);
+      double sixj1 = Z.modelspace->GetSixJ(jj,ji,J1, jk,Jtot,Jx);
+      double xikla = X2.GetTBME_J(Jx,i,k,l,a);
+      double yikla = Y2.GetTBME_J(Jx,i,k,l,a);
+      for ( int Jy=Jy_min; Jy<=Jy_max; Jy++)
+      {
+        double hats  = (2*Jx+1) * (2*Jy+1) * sqrt( (2*J1+1.)*(2*J2+1.) );
+        double sixj2 = Z.modelspace->GetSixJ(jl,jm,J2, jn,Jtot,Jy);
+        double sixj3 = Z.modelspace->GetSixJ(jj,ja,Jy, jl,Jtot,Jx);
+        double xajmn = X2.GetTBME_J(Jy,a,j,m,n);
+        double yajmn = Y2.GetTBME_J(Jy,a,j,m,n);
+        zijklmn += hats * phase * sixj1*sixj2*sixj3 * (xikla*yajmn-yikla*xajmn);
+      }
+    }
+  }
 
-          //Z4
-          if (  ( (check_2b_channel_Tz_parity(X,oi,oj,om,oa) and check_2b_channel_Tz_parity(Y,oa,ok,ol,on))
-               or (check_2b_channel_Tz_parity(Y,oi,oj,om,oa) and check_2b_channel_Tz_parity(X,oa,ok,ol,on)) )
-              and ( (std::abs(om.j2-oa.j2)<=2*J1 ) and (om.j2+oa.j2>=2*J1)  ) )
-          {
-            Jx_min = std::max(std::abs(oa.j2-ok.j2), std::abs(ol.j2-on.j2) )/2;
-            Jx_max = std::min((oa.j2+ok.j2), (ol.j2+on.j2) )/2;
-            double phase = -Z.modelspace->phase( (om.j2-on.j2-oa.j2-ok.j2)/2-J2);
-            double xijma = X2.GetTBME_J(J1,i,j,m,a);
-            double yijma = Y2.GetTBME_J(J1,i,j,m,a);
-            for ( int Jx=Jx_min; Jx<=Jx_max; Jx++) 
-            {
-              double hats  =  (2*Jx+1) * sqrt( (2*J1+1.)*(2*J2+1.) );
-              double sixj1 = Z.modelspace->GetSixJ(jm,jl,J2, jn,Jtot,Jx);
-              double sixj2 = Z.modelspace->GetSixJ(jm,ja,J1, jk,Jtot,Jx);
-              double xakln = X2.GetTBME_J(Jx,a,k,l,n);
-              double yakln = Y2.GetTBME_J(Jx,a,k,l,n);
-              zijklmn += hats * phase * sixj1*sixj2 * (xijma*yakln-yijma*xakln);
-            }
-          }
+  //Z4
+  if (  ( (check_2b_channel_Tz_parity(X,oi,oj,om,oa) and check_2b_channel_Tz_parity(Y,oa,ok,ol,on))
+        or (check_2b_channel_Tz_parity(Y,oi,oj,om,oa) and check_2b_channel_Tz_parity(X,oa,ok,ol,on)) )
+      and ( (std::abs(om.j2-oa.j2)<=2*J1 ) and (om.j2+oa.j2>=2*J1)  ) )
+  {
+    Jx_min = std::max(std::abs(oa.j2-ok.j2), std::abs(ol.j2-on.j2) )/2;
+    Jx_max = std::min((oa.j2+ok.j2), (ol.j2+on.j2) )/2;
+    double phase = -Z.modelspace->phase( (om.j2-on.j2-oa.j2-ok.j2)/2-J2);
+    double xijma = X2.GetTBME_J(J1,i,j,m,a);
+    double yijma = Y2.GetTBME_J(J1,i,j,m,a);
+    for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
+    {
+      double hats  =  (2*Jx+1) * sqrt( (2*J1+1.)*(2*J2+1.) );
+      double sixj1 = Z.modelspace->GetSixJ(jm,jl,J2, jn,Jtot,Jx);
+      double sixj2 = Z.modelspace->GetSixJ(jm,ja,J1, jk,Jtot,Jx);
+      double xakln = X2.GetTBME_J(Jx,a,k,l,n);
+      double yakln = Y2.GetTBME_J(Jx,a,k,l,n);
+      zijklmn += hats * phase * sixj1*sixj2 * (xijma*yakln-yijma*xakln);
+    }
+  }
 
-          //Z5
-          if (   (check_2b_channel_Tz_parity(X,oi,oj,on,oa) and check_2b_channel_Tz_parity(Y,ok,oa,om,ol))
-              or (check_2b_channel_Tz_parity(Y,oi,oj,on,oa) and check_2b_channel_Tz_parity(X,ok,oa,om,ol)) )
-          {
-            double hats  =  sqrt( (2*J1+1.)*(2*J2+1.) );
-            double phase =  1;
-            double sixj1 = Z.modelspace->GetSixJ(jn,ja,J1, jk,Jtot,J2);
-            double xijna = X2.GetTBME_J(J1,i,j,n,a);
-            double yijna = Y2.GetTBME_J(J1,i,j,n,a);
-            double xkalm = X2.GetTBME_J(J2,k,a,l,m);
-            double ykalm = Y2.GetTBME_J(J2,k,a,l,m);
-            zijklmn += hats * phase * sixj1 * (xijna*ykalm-yijna*xkalm);
-          }
+  //Z5
+  if (   (check_2b_channel_Tz_parity(X,oi,oj,on,oa) and check_2b_channel_Tz_parity(Y,ok,oa,om,ol))
+      or (check_2b_channel_Tz_parity(Y,oi,oj,on,oa) and check_2b_channel_Tz_parity(X,ok,oa,om,ol)) )
+  {
+    double hats  =  sqrt( (2*J1+1.)*(2*J2+1.) );
+    double phase =  1;
+    double sixj1 = Z.modelspace->GetSixJ(jn,ja,J1, jk,Jtot,J2);
+    double xijna = X2.GetTBME_J(J1,i,j,n,a);
+    double yijna = Y2.GetTBME_J(J1,i,j,n,a);
+    double xkalm = X2.GetTBME_J(J2,k,a,l,m);
+    double ykalm = Y2.GetTBME_J(J2,k,a,l,m);
+    zijklmn += hats * phase * sixj1 * (xijna*ykalm-yijna*xkalm);
+  }
 
-          //Z6
-          if (   (check_2b_channel_Tz_parity(X,ok,oj,om,oa) and check_2b_channel_Tz_parity(Y,oa,oi,ol,on))
-              or (check_2b_channel_Tz_parity(Y,ok,oj,om,oa) and check_2b_channel_Tz_parity(X,oa,oi,ol,on)) )
-          {
-            Jx_min = std::max(std::abs(oa.j2-om.j2), std::abs(oj.j2-ok.j2) )/2;
-            Jx_max = std::min((oa.j2+om.j2), (oj.j2+ok.j2) )/2;
-            Jy_min = std::max(std::abs(oa.j2-oi.j2), std::abs(ol.j2-on.j2) )/2;
-            Jy_max = std::min((oa.j2+oi.j2), (ol.j2+on.j2) )/2;
-            double phase =-Z.modelspace->phase( (on.j2-om.j2-oi.j2-oa.j2)/2-J2);
-            for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
-            {
-              double sixj1 = Z.modelspace->GetSixJ(ji,jj,J1, jk,Jtot,Jx);
-              double xkjma = X2.GetTBME_J(Jx,k,j,m,a);
-              double ykjma = Y2.GetTBME_J(Jx,k,j,m,a);
-             for ( int Jy=Jy_min; Jy<=Jy_max; Jy++)
-             {
-              double hats  =  (2*Jx+1) * (2*Jy+1) * sqrt( (2*J1+1.)*(2*J2+1.) );
-              double sixj2 = Z.modelspace->GetSixJ(jm,jl,J2, jn,Jtot,Jy);
-              double sixj3 = Z.modelspace->GetSixJ(ji,ja,Jy, jm,Jtot,Jx);
-              double xailn = X2.GetTBME_J(Jy,a,i,l,n);
-              double yailn = Y2.GetTBME_J(Jy,a,i,l,n);
-              zijklmn += hats * phase * sixj1*sixj2*sixj3 * (xkjma*yailn-ykjma*xailn);
-             }
-            }
-          }
+  //Z6
+  if (   (check_2b_channel_Tz_parity(X,ok,oj,om,oa) and check_2b_channel_Tz_parity(Y,oa,oi,ol,on))
+      or (check_2b_channel_Tz_parity(Y,ok,oj,om,oa) and check_2b_channel_Tz_parity(X,oa,oi,ol,on)) )
+  {
+    Jx_min = std::max(std::abs(oa.j2-om.j2), std::abs(oj.j2-ok.j2) )/2;
+    Jx_max = std::min((oa.j2+om.j2), (oj.j2+ok.j2) )/2;
+    Jy_min = std::max(std::abs(oa.j2-oi.j2), std::abs(ol.j2-on.j2) )/2;
+    Jy_max = std::min((oa.j2+oi.j2), (ol.j2+on.j2) )/2;
+    double phase =-Z.modelspace->phase( (on.j2-om.j2-oi.j2-oa.j2)/2-J2);
+    for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
+    {
+      double sixj1 = Z.modelspace->GetSixJ(ji,jj,J1, jk,Jtot,Jx);
+      double xkjma = X2.GetTBME_J(Jx,k,j,m,a);
+      double ykjma = Y2.GetTBME_J(Jx,k,j,m,a);
+      for ( int Jy=Jy_min; Jy<=Jy_max; Jy++)
+      {
+        double hats  =  (2*Jx+1) * (2*Jy+1) * sqrt( (2*J1+1.)*(2*J2+1.) );
+        double sixj2 = Z.modelspace->GetSixJ(jm,jl,J2, jn,Jtot,Jy);
+        double sixj3 = Z.modelspace->GetSixJ(ji,ja,Jy, jm,Jtot,Jx);
+        double xailn = X2.GetTBME_J(Jy,a,i,l,n);
+        double yailn = Y2.GetTBME_J(Jy,a,i,l,n);
+        zijklmn += hats * phase * sixj1*sixj2*sixj3 * (xkjma*yailn-ykjma*xailn);
+      }
+    }
+  }
 
 
-          //Z7
-          if (  ( (check_2b_channel_Tz_parity(X,ok,oj,on,oa) and check_2b_channel_Tz_parity(Y,oa,oi,om,ol))
-              or (check_2b_channel_Tz_parity(Y,ok,oj,on,oa) and check_2b_channel_Tz_parity(X,oa,oi,om,ol)) )
-              and ( (std::abs(oa.j2-oi.j2)<=2*J2 ) and (oa.j2+oi.j2>=2*J2)  )   )
-          {
-            Jx_min = std::max(std::abs(ok.j2-oj.j2), std::abs(oa.j2-on.j2) )/2;
-            Jx_max = std::min((ok.j2+oj.j2), (oa.j2+on.j2) )/2;
-            double phase = Z.modelspace->phase( (ol.j2+om.j2+oi.j2+oa.j2)/2);
-            double xaiml = X2.GetTBME_J(J2,a,i,m,l);
-            double yaiml = Y2.GetTBME_J(J2,a,i,m,l);
-            for ( int Jx=Jx_min; Jx<=Jx_max; Jx++) 
-            {
-              double hats  =  (2*Jx+1) * sqrt( (2*J1+1.)*(2*J2+1.) );
-              double sixj1 = Z.modelspace->GetSixJ(ji,jj,J1, jk,Jtot,Jx);
-              double sixj2 = Z.modelspace->GetSixJ(ji,ja,J2, jn,Jtot,Jx);
-              double xkjna = X2.GetTBME_J(Jx,k,j,n,a);
-              double ykjna = Y2.GetTBME_J(Jx,k,j,n,a);
-              zijklmn += hats * phase * sixj1*sixj2 * (xkjna*yaiml-ykjna*xaiml);
-            }
-          }
+  //Z7
+  if (  ( (check_2b_channel_Tz_parity(X,ok,oj,on,oa) and check_2b_channel_Tz_parity(Y,oa,oi,om,ol))
+        or (check_2b_channel_Tz_parity(Y,ok,oj,on,oa) and check_2b_channel_Tz_parity(X,oa,oi,om,ol)) )
+      and ( (std::abs(oa.j2-oi.j2)<=2*J2 ) and (oa.j2+oi.j2>=2*J2)  )   )
+  {
+    Jx_min = std::max(std::abs(ok.j2-oj.j2), std::abs(oa.j2-on.j2) )/2;
+    Jx_max = std::min((ok.j2+oj.j2), (oa.j2+on.j2) )/2;
+    double phase = Z.modelspace->phase( (ol.j2+om.j2+oi.j2+oa.j2)/2);
+    double xaiml = X2.GetTBME_J(J2,a,i,m,l);
+    double yaiml = Y2.GetTBME_J(J2,a,i,m,l);
+    for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
+    {
+      double hats  =  (2*Jx+1) * sqrt( (2*J1+1.)*(2*J2+1.) );
+      double sixj1 = Z.modelspace->GetSixJ(ji,jj,J1, jk,Jtot,Jx);
+      double sixj2 = Z.modelspace->GetSixJ(ji,ja,J2, jn,Jtot,Jx);
+      double xkjna = X2.GetTBME_J(Jx,k,j,n,a);
+      double ykjna = Y2.GetTBME_J(Jx,k,j,n,a);
+      zijklmn += hats * phase * sixj1*sixj2 * (xkjna*yaiml-ykjna*xaiml);
+    }
+  }
 
 
 
-          //Z8
-          if (   (check_2b_channel_Tz_parity(X,oi,ok,om,oa) and check_2b_channel_Tz_parity(Y,oa,oj,ol,on))
-              or (check_2b_channel_Tz_parity(Y,oi,ok,om,oa) and check_2b_channel_Tz_parity(X,oa,oj,ol,on)) )
-          {
-            Jx_min = std::max(std::abs(oa.j2-om.j2), std::abs(oi.j2-ok.j2) )/2;
-            Jx_max = std::min((oa.j2+om.j2), (oi.j2+ok.j2) )/2;
-            Jy_min = std::max(std::abs(oa.j2-oj.j2), std::abs(ol.j2-on.j2) )/2;
-            Jy_max = std::min((oa.j2+oj.j2), (ol.j2+on.j2) )/2;
-            for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
-            {
-              double phase =-Z.modelspace->phase( (ok.j2+om.j2+on.j2-oa.j2)/2-J1-J2-Jx);
-              double sixj1 = Z.modelspace->GetSixJ(jj,ji,J1, jk,Jtot,Jx);
-              double xikma = X2.GetTBME_J(Jx,i,k,m,a);
-              double yikma = Y2.GetTBME_J(Jx,i,k,m,a);
-             for ( int Jy=Jy_min; Jy<=Jy_max; Jy++)
-             {
-              double hats  =  (2*Jx+1) * (2*Jy+1) * sqrt( (2*J1+1.)*(2*J2+1.) );
-              double sixj2 = Z.modelspace->GetSixJ(jm,jl,J2, jn,Jtot,Jy);
-              double sixj3 = Z.modelspace->GetSixJ(jj,ja,Jy, jm,Jtot,Jx);
-              double xajln = X2.GetTBME_J(Jy,a,j,l,n);
-              double yajln = Y2.GetTBME_J(Jy,a,j,l,n);
-              zijklmn += hats * phase * sixj1*sixj2*sixj3 * (xikma*yajln-yikma*xajln);
-             }
-            }
-          }
+  //Z8
+  if (   (check_2b_channel_Tz_parity(X,oi,ok,om,oa) and check_2b_channel_Tz_parity(Y,oa,oj,ol,on))
+      or (check_2b_channel_Tz_parity(Y,oi,ok,om,oa) and check_2b_channel_Tz_parity(X,oa,oj,ol,on)) )
+  {
+    Jx_min = std::max(std::abs(oa.j2-om.j2), std::abs(oi.j2-ok.j2) )/2;
+    Jx_max = std::min((oa.j2+om.j2), (oi.j2+ok.j2) )/2;
+    Jy_min = std::max(std::abs(oa.j2-oj.j2), std::abs(ol.j2-on.j2) )/2;
+    Jy_max = std::min((oa.j2+oj.j2), (ol.j2+on.j2) )/2;
+    for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
+    {
+      double phase =-Z.modelspace->phase( (ok.j2+om.j2+on.j2-oa.j2)/2-J1-J2-Jx);
+      double sixj1 = Z.modelspace->GetSixJ(jj,ji,J1, jk,Jtot,Jx);
+      double xikma = X2.GetTBME_J(Jx,i,k,m,a);
+      double yikma = Y2.GetTBME_J(Jx,i,k,m,a);
+      for ( int Jy=Jy_min; Jy<=Jy_max; Jy++)
+      {
+        double hats  =  (2*Jx+1) * (2*Jy+1) * sqrt( (2*J1+1.)*(2*J2+1.) );
+        double sixj2 = Z.modelspace->GetSixJ(jm,jl,J2, jn,Jtot,Jy);
+        double sixj3 = Z.modelspace->GetSixJ(jj,ja,Jy, jm,Jtot,Jx);
+        double xajln = X2.GetTBME_J(Jy,a,j,l,n);
+        double yajln = Y2.GetTBME_J(Jy,a,j,l,n);
+        zijklmn += hats * phase * sixj1*sixj2*sixj3 * (xikma*yajln-yikma*xajln);
+      }
+    }
+  }
 
 
-          //Z9
-          if ( (  (check_2b_channel_Tz_parity(X,oi,ok,on,oa) and check_2b_channel_Tz_parity(Y,oa,oj,om,ol))
-               or (check_2b_channel_Tz_parity(Y,oi,ok,on,oa) and check_2b_channel_Tz_parity(X,oa,oj,om,ol)) ) 
-              and ( (std::abs(oa.j2-oj.j2)<=2*J2 ) and (oa.j2+oj.j2>=2*J2)  )  )
-          {
-            Jx_min = std::max(std::abs(ok.j2-oi.j2), std::abs(oa.j2-on.j2) )/2;
-            Jx_max = std::min((ok.j2+oi.j2), (oa.j2+on.j2) )/2;
-            double xajml = X2.GetTBME_J(J2,a,j,m,l);
-            double yajml = Y2.GetTBME_J(J2,a,j,m,l);
-            for ( int Jx=Jx_min; Jx<=Jx_max; Jx++) 
-            {
-              double phase = Z.modelspace->phase( (oa.j2+ok.j2+ol.j2+om.j2)/2 -J1-Jx);
-              double hats  =  (2*Jx+1) * sqrt( (2*J1+1.)*(2*J2+1.) );
-              double sixj1 = Z.modelspace->GetSixJ(jj,ji,J1, jk,Jtot,Jx);
-              double sixj2 = Z.modelspace->GetSixJ(jj,ja,J2, jn,Jtot,Jx);
-              double xikna = X2.GetTBME_J(Jx,i,k,n,a);
-              double yikna = Y2.GetTBME_J(Jx,i,k,n,a);
-              zijklmn += hats * phase * sixj1*sixj2 * (xikna*yajml-yikna*xajml);
-            }
-          }
+  //Z9
+  if ( (  (check_2b_channel_Tz_parity(X,oi,ok,on,oa) and check_2b_channel_Tz_parity(Y,oa,oj,om,ol))
+        or (check_2b_channel_Tz_parity(Y,oi,ok,on,oa) and check_2b_channel_Tz_parity(X,oa,oj,om,ol)) )
+      and ( (std::abs(oa.j2-oj.j2)<=2*J2 ) and (oa.j2+oj.j2>=2*J2)  )  )
+  {
+    Jx_min = std::max(std::abs(ok.j2-oi.j2), std::abs(oa.j2-on.j2) )/2;
+    Jx_max = std::min((ok.j2+oi.j2), (oa.j2+on.j2) )/2;
+    double xajml = X2.GetTBME_J(J2,a,j,m,l);
+    double yajml = Y2.GetTBME_J(J2,a,j,m,l);
+    for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
+    {
+      double phase = Z.modelspace->phase( (oa.j2+ok.j2+ol.j2+om.j2)/2 -J1-Jx);
+      double hats  =  (2*Jx+1) * sqrt( (2*J1+1.)*(2*J2+1.) );
+      double sixj1 = Z.modelspace->GetSixJ(jj,ji,J1, jk,Jtot,Jx);
+      double sixj2 = Z.modelspace->GetSixJ(jj,ja,J2, jn,Jtot,Jx);
+      double xikna = X2.GetTBME_J(Jx,i,k,n,a);
+      double yikna = Y2.GetTBME_J(Jx,i,k,n,a);
+      zijklmn += hats * phase * sixj1*sixj2 * (xikna*yajml-yikna*xajml);
+    }
+  }
 
-         }// for a
+}// for a
 
 //             Z3.AddToME_pn_PN_ch( ch3,ch3,ibra,iket, zijklmn );
-             Z3.AddToME_pn_PN_ch( ch_bra,ch_ket,ibra,iket, zijklmn );
+Z3.AddToME_pn_PN_ch( ch_bra,ch_ket,ibra,iket, zijklmn );
 
-    }// for iket
-   }// for ibra
-  }// for ch3
-  Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
+}// for iket
+}// for ibra
+}// for ch3
+Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
 }
 */
 
@@ -5982,15 +6226,15 @@ void comm223ss( const Operator& X, const Operator& Y, Operator& Z )
 //
 //  |     |    |     Uncoupled expression:
 // i|    j|   k|       Z_ijklmn = 1/2 sum_{ab} (n`an`b - nanb) P(ij/k) X_{ijab} Y_{abklmn} - P(lm/n) Y_{ijkabn} X_{ablm}
-//  *~~X~~*    |                   
-// a|    b|    | 
+//  *~~X~~*    |
+// a|    b|    |
 //  *~~~~[Y]~~~*     Coupled expression:
-// l|    m|   n|     Z_{ijklmn}^{J1,J2,J} = 1/2 sum_{ab} (n`an`b - nanb) ( P(ij/k)^{J1,J} X_{ijab}^{J1} Y_{abklmn}^{J1,J2,J} 
+// l|    m|   n|     Z_{ijklmn}^{J1,J2,J} = 1/2 sum_{ab} (n`an`b - nanb) ( P(ij/k)^{J1,J} X_{ijab}^{J1} Y_{abklmn}^{J1,J2,J}
 //  |     |    |                                                         - P(lm/n)^{J2,J} Y_{ijkabn}^{J1,J2,J} X_{ablm}^{J2} )
-//  |     |    |                                                                                                                   
-//                                                                                          
-//                                                           
-//      Checked with UnitTest and passed                                                                      
+//  |     |    |
+//
+//
+//      Checked with UnitTest and passed
 //
 void comm233_pp_hhss( const Operator& X, const Operator& Y, Operator& Z )
 {
@@ -6014,7 +6258,7 @@ void comm233_pp_hhss( const Operator& X, const Operator& Y, Operator& Z )
 
   size_t nch2 = Z.modelspace->GetNumberTwoBodyChannels();
   size_t nch3 = Z.modelspace->GetNumberThreeBodyChannels();
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
   for (size_t ch3=0; ch3<nch3; ch3++)
   {
     auto& Tbc = Z.modelspace->GetThreeBodyChannel(ch3);
@@ -6078,46 +6322,47 @@ void comm233_pp_hhss( const Operator& X, const Operator& Y, Operator& Z )
         {
           for (size_t iket_ab=0; iket_ab<nkets_ab; iket_ab++)
           {
-              auto& ket_ab = tbc_ab.GetKet(iket_ab);
-              size_t a = ket_ab.p;
-              size_t b = ket_ab.q;
-              double d_ea = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
-              double d_eb = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
-              double occnat_a = ket_ab.op->occ_nat;
-              double occnat_b = ket_ab.oq->occ_nat;
-              if ( (d_ea + d_eb + d_ek) > Z.modelspace->dE3max ) continue;
-              if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_k*(1-occnat_k) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-              double occfactor = 1-ket_ab.op->occ-ket_ab.oq->occ;
-              if (std::abs(occfactor)<1e-6) continue;
-              double symm_factor =  (a==b) ? 1.0 : 2.0;
-              double xijab = X2.GetTBME_J(Jab,Jab,i,j,a,b);
-              double yijab = Y2.GetTBME_J(Jab,Jab,i,j,a,b);
+            auto& ket_ab = tbc_ab.GetKet(iket_ab);
+            size_t a = ket_ab.p;
+            size_t b = ket_ab.q;
+            double d_ea = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
+            double d_eb = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
+            double occnat_a = ket_ab.op->occ_nat;
+            double occnat_b = ket_ab.oq->occ_nat;
+            if ( (d_ea + d_eb + d_ek) > Z.modelspace->dE3max ) continue;
+            if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_k*(1-occnat_k) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+            double occfactor = 1-ket_ab.op->occ-ket_ab.oq->occ;
+            if (std::abs(occfactor)<1e-6) continue;
+            double symm_factor =  (a==b) ? 1.0 : 2.0;
+            double xijab = X2.GetTBME_J(Jab,Jab,i,j,a,b);
+            double yijab = Y2.GetTBME_J(Jab,Jab,i,j,a,b);
 
 
-              std::vector<size_t> ket_list;
-              std::vector<double> recouple_list;
-              
-              size_t ch_check = Z3.GetKetIndex_withRecoupling( Jab, twoJ, a, b, k,  ket_list,  recouple_list );
-              for (size_t ilist=0; ilist<ket_list.size(); ilist++)
-              {
-                auto iter_find = kept_lookup.find( ket_list[ilist] );
-                if (iter_find == kept_lookup.end() ) continue;
-                size_t index_ket = iter_find->second;
-                double recouple = recouple_list[ilist];
-                X2MAT(index_bra,index_ket) += 0.5 * symm_factor * occfactor * recouple * xijab ;
-                Y2MAT(index_bra,index_ket) += 0.5 * symm_factor * occfactor * recouple * yijab ;
-              }// for ilist
+            std::vector<size_t> ket_list;
+            std::vector<double> recouple_list;
+
+            size_t ch_check = Z3.GetKetIndex_withRecoupling( Jab, twoJ, a, b, k,  ket_list,  recouple_list );
+            for (size_t ilist=0; ilist<ket_list.size(); ilist++)
+            {
+              auto iter_find = kept_lookup.find( ket_list[ilist] );
+              if (iter_find == kept_lookup.end() ) continue;
+              size_t index_ket = iter_find->second;
+              double recouple = recouple_list[ilist];
+              X2MAT(index_bra,index_ket) += 0.5 * symm_factor * occfactor * recouple * xijab ;
+              Y2MAT(index_bra,index_ket) += 0.5 * symm_factor * occfactor * recouple * yijab ;
+            }// for ilist
 
           }// for iket_ab
         } // if J, Tz and parity check for term 1
 
         // Permute  Pik
         if ( ((2*tbc_ab.Tz + oi.tz2) == Tbc.twoTz)  and ( (tbc_ab.parity + oi.l + Tbc.parity)%2==0)
-                   and (std::abs(2*Jab-oi.j2)<=twoJ) and ((2*Jab+oi.j2)>=twoJ) )
+            and (std::abs(2*Jab-oi.j2)<=twoJ) and ((2*Jab+oi.j2)>=twoJ)
+            and (std::abs(2*Jab-oj.j2)<=ok.j2) and ((2*Jab+oj.j2)>=ok.j2) )
         {
-           double sixj = Z.modelspace->GetSixJ(ji,jj,Jij,jk,Jtot,Jab);
-           if (std::abs(sixj)>1e-6) 
-           {
+          double sixj = Z.modelspace->GetSixJ(ji,jj,Jij,jk,Jtot,Jab);
+          if (std::abs(sixj)>1e-6)
+          {
             double hats = sqrt( (2*Jij+1)*(2*Jab+1));
             for (size_t iket_ab=0; iket_ab<nkets_ab; iket_ab++)
             {
@@ -6138,7 +6383,7 @@ void comm233_pp_hhss( const Operator& X, const Operator& Y, Operator& Z )
 
               std::vector<size_t> ket_list;
               std::vector<double> recouple_list;
-              
+
               size_t ch_check = Z3.GetKetIndex_withRecoupling( Jab, twoJ, a, b, i,  ket_list,  recouple_list );
               for (size_t ilist=0; ilist<ket_list.size(); ilist++)
               {
@@ -6151,39 +6396,40 @@ void comm233_pp_hhss( const Operator& X, const Operator& Y, Operator& Z )
               }// for ilist
 
             }// for iket_ab
-           }// if sixj nonzero
+          }// if sixj nonzero
         } // if J, Tz and parity check for term 2
 
 
         // Permute  Pjk
-        if ( ((2*tbc_ab.Tz + oj.tz2) == Tbc.twoTz)  and ( (tbc_ab.parity + oj.l + Tbc.parity)%2==0) 
-                   and (std::abs(2*Jab-oj.j2)<=twoJ) and ((2*Jab+oj.j2)>=twoJ) )
+        if ( ((2*tbc_ab.Tz + oj.tz2) == Tbc.twoTz)  and ( (tbc_ab.parity + oj.l + Tbc.parity)%2==0)
+            and (std::abs(2*Jab-oj.j2)<=twoJ) and ((2*Jab+oj.j2)>=twoJ)
+            and (std::abs(2*Jab-oi.j2)<=ok.j2) and ((2*Jab+oi.j2)>=ok.j2) )
         {
-           double sixj = Z.modelspace->GetSixJ(jj,ji,Jij,jk,Jtot,Jab);
-           if (std::abs(sixj)>1e-6)
-           {
-             double hats = sqrt( (2*Jij+1)*(2*Jab+1));
-             int phase = Z.modelspace->phase( (oj.j2+ok.j2)/2-Jij-Jab);
-             for (size_t iket_ab=0; iket_ab<nkets_ab; iket_ab++)
-             {
-               auto& ket_ab = tbc_ab.GetKet(iket_ab);
-               size_t a = ket_ab.p;
-               size_t b = ket_ab.q;
-               double d_ea = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
-               double d_eb = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
-               double occnat_a = ket_ab.op->occ_nat;
-               double occnat_b = ket_ab.oq->occ_nat;
-               if ( (d_ea + d_eb + d_ej) > Z.modelspace->dE3max ) continue;
-               if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_j*(1-occnat_j) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-               double occfactor = 1-ket_ab.op->occ-ket_ab.oq->occ;
-               if (std::abs(occfactor)<1e-6) continue;
-               double symm_factor =  (a==b) ? 1.0 : 2.0;
-               double xikab = X2.GetTBME_J(Jab,Jab,i,k,a,b);
-               double yikab = Y2.GetTBME_J(Jab,Jab,i,k,a,b);
+          double sixj = Z.modelspace->GetSixJ(jj,ji,Jij,jk,Jtot,Jab);
+          if (std::abs(sixj)>1e-6)
+          {
+            double hats = sqrt( (2*Jij+1)*(2*Jab+1));
+            int phase = Z.modelspace->phase( (oj.j2+ok.j2)/2-Jij-Jab);
+            for (size_t iket_ab=0; iket_ab<nkets_ab; iket_ab++)
+            {
+              auto& ket_ab = tbc_ab.GetKet(iket_ab);
+              size_t a = ket_ab.p;
+              size_t b = ket_ab.q;
+              double d_ea = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
+              double d_eb = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
+              double occnat_a = ket_ab.op->occ_nat;
+              double occnat_b = ket_ab.oq->occ_nat;
+              if ( (d_ea + d_eb + d_ej) > Z.modelspace->dE3max ) continue;
+              if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_j*(1-occnat_j) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+              double occfactor = 1-ket_ab.op->occ-ket_ab.oq->occ;
+              if (std::abs(occfactor)<1e-6) continue;
+              double symm_factor =  (a==b) ? 1.0 : 2.0;
+              double xikab = X2.GetTBME_J(Jab,Jab,i,k,a,b);
+              double yikab = Y2.GetTBME_J(Jab,Jab,i,k,a,b);
 
               std::vector<size_t> ket_list;
               std::vector<double> recouple_list;
-              
+
               size_t ch_check = Z3.GetKetIndex_withRecoupling( Jab, twoJ, a, b, j,  ket_list,  recouple_list );
               for (size_t ilist=0; ilist<ket_list.size(); ilist++)
               {
@@ -6196,7 +6442,7 @@ void comm233_pp_hhss( const Operator& X, const Operator& Y, Operator& Z )
 
               }// for ilist
 
-             }// for iket_ab
+            }// for iket_ab
           }// if sixj nonzero
         } // if  J, Tz and parity check for term 3
 
@@ -6205,7 +6451,7 @@ void comm233_pp_hhss( const Operator& X, const Operator& Y, Operator& Z )
     }// for index_bra
 
 
-     // Fill X3 and Y3
+    // Fill X3 and Y3
     // kept_lookup is a map   Full index => Kept index, so iter_bra.first gives the full index, and iter_bra.second is the
     // index for the 3-body state we keep in this commutator
     for ( auto& iter_bra : kept_lookup )
@@ -6213,18 +6459,18 @@ void comm233_pp_hhss( const Operator& X, const Operator& Y, Operator& Z )
       for ( auto& iter_ket : kept_lookup )
       {
         if ( x3_allocated )
-           X3MAT( iter_bra.second, iter_ket.second) = X3.GetME_pn_PN_ch(ch3,ch3, iter_bra.first, iter_ket.first );
+          X3MAT( iter_bra.second, iter_ket.second) = X3.GetME_pn_PN_ch(ch3,ch3, iter_bra.first, iter_ket.first );
 
         if ( y3_allocated )
-           Y3MAT( iter_bra.second, iter_ket.second) = Y3.GetME_pn_PN_ch(ch3,ch3, iter_bra.first, iter_ket.first );
+          Y3MAT( iter_bra.second, iter_ket.second) = Y3.GetME_pn_PN_ch(ch3,ch3, iter_bra.first, iter_ket.first );
       }
     }
 
 
     // Do the matrix multiplication
-//    Z3MAT = X2MAT*Y3MAT - Y2MAT*X3MAT  +  hermX*hermY * ( X3MAT.t()*Y2MAT.t() - Y3MAT.t()*X2MAT.t() );
+    //    Z3MAT = X2MAT*Y3MAT - Y2MAT*X3MAT  +  hermX*hermY * ( X3MAT.t()*Y2MAT.t() - Y3MAT.t()*X2MAT.t() );
     Z3MAT = X2MAT*Y3MAT - Y2MAT*X3MAT ;
-    Z3MAT -= hermX * hermY * Z3MAT.t(); 
+    Z3MAT -= hermX * hermY * Z3MAT.t();
 
 
 
@@ -6235,14 +6481,14 @@ void comm233_pp_hhss( const Operator& X, const Operator& Y, Operator& Z )
       {
         if ( iter_ket.first > iter_bra.first ) continue;
         Z3.AddToME_pn_PN_ch(ch3,ch3, iter_bra.first,iter_ket.first,  Z3MAT(iter_bra.second,iter_ket.second) );
-//        if (ch3==0 and iter_bra.first<5 and iter_ket.first<5)
-//        {
-//          Ket3& bra = Tbc.GetKet( iter_bra.first );
-//          Ket3& ket = Tbc.GetKet( iter_ket.first );
-//        }
+        //        if (ch3==0 and iter_bra.first<5 and iter_ket.first<5)
+        //        {
+        //          Ket3& bra = Tbc.GetKet( iter_bra.first );
+        //          Ket3& ket = Tbc.GetKet( iter_ket.first );
+        //        }
       }
     }
- 
+
   }// for ch3
   Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
 }
@@ -6251,264 +6497,264 @@ void comm233_pp_hhss( const Operator& X, const Operator& Y, Operator& Z )
 // old much slower way
 /*
 
-void comm233_pp_hhss_debug( const Operator& X, const Operator& Y, Operator& Z )
-{
-
-  double tstart = omp_get_wtime();
-  auto& X2 = X.TwoBody;
-  auto& Y2 = Y.TwoBody;
-  auto& X3 = X.ThreeBody;
-  auto& Y3 = Y.ThreeBody;
-  auto& Z3 = Z.ThreeBody;
-  std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
-
-  size_t nch3 = Z.modelspace->GetNumberThreeBodyChannels();
-  size_t nch2 = Z.modelspace->GetNumberTwoBodyChannels();
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
-  for (size_t ch=0; ch<=nch3; ch++)
-  {
-    auto Tbc = Z.modelspace->GetThreeBodyChannel(ch);
-    size_t nket3 = Tbc.GetNumberKets();
-    int twoJ = Tbc.twoJ;
-    double Jtot = 0.5 * twoJ;
-    for (size_t ibra=0; ibra<nket3; ibra++)
-    {
-      auto& bra = Tbc.GetKet(ibra);
-      int J1 = bra.Jpq;
-      size_t i = bra.p;
-      size_t j = bra.q;
-      size_t k = bra.r;
-      Orbit& oi = Z.modelspace->GetOrbit(i);
-      Orbit& oj = Z.modelspace->GetOrbit(j);
-      Orbit& ok = Z.modelspace->GetOrbit(k);
-      double ji = 0.5*oi.j2;
-      double jj = 0.5*oj.j2;
-      double jk = 0.5*ok.j2;
-      double d_ei = std::abs( 2*oi.n + oi.l - e_fermi[oi.tz2]);
-      double d_ej = std::abs( 2*oj.n + oj.l - e_fermi[oj.tz2]);
-      double d_ek = std::abs( 2*ok.n + ok.l - e_fermi[ok.tz2]);
-      if ( (d_ei + d_ej + d_ek) > Z.modelspace->dE3max ) continue;
-      for (size_t iket=0; iket<=ibra; iket++)
-      {
-        auto& ket = Tbc.GetKet(iket);
-        int J2 = ket.Jpq;
-        int l = ket.p;
-        int m = ket.q;
-        int n = ket.r;
-        Orbit& ol = Z.modelspace->GetOrbit(l);
-        Orbit& om = Z.modelspace->GetOrbit(m);
-        Orbit& on = Z.modelspace->GetOrbit(n);
-        double jl = 0.5*ol.j2;
-        double jm = 0.5*om.j2;
-        double jn = 0.5*on.j2;
-        double d_el = std::abs( 2*ol.n + ol.l - e_fermi[ol.tz2]);
-        double d_em = std::abs( 2*om.n + om.l - e_fermi[om.tz2]);
-        double d_en = std::abs( 2*on.n + on.l - e_fermi[on.tz2]);
-        if ( (d_el + d_em + d_en) > Z.modelspace->dE3max ) continue;
-
-        double z_ijklmn = 0;
+   void comm233_pp_hhss_debug( const Operator& X, const Operator& Y, Operator& Z )
+   {
 
-        for (size_t ch_ab=0; ch_ab<nch2; ch_ab++)
-        {
-          auto& tbc_ab = Z.modelspace->GetTwoBodyChannel(ch_ab);
-          size_t nkets_ab = tbc_ab.GetNumberKets();
-          int Jab = tbc_ab.J;
+   double tstart = omp_get_wtime();
+   auto& X2 = X.TwoBody;
+   auto& Y2 = Y.TwoBody;
+   auto& X3 = X.ThreeBody;
+   auto& Y3 = Y.ThreeBody;
+   auto& Z3 = Z.ThreeBody;
+   std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
+
+   size_t nch3 = Z.modelspace->GetNumberThreeBodyChannels();
+   size_t nch2 = Z.modelspace->GetNumberTwoBodyChannels();
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+for (size_t ch=0; ch<=nch3; ch++)
+{
+auto Tbc = Z.modelspace->GetThreeBodyChannel(ch);
+size_t nket3 = Tbc.GetNumberKets();
+int twoJ = Tbc.twoJ;
+double Jtot = 0.5 * twoJ;
+for (size_t ibra=0; ibra<nket3; ibra++)
+{
+auto& bra = Tbc.GetKet(ibra);
+int J1 = bra.Jpq;
+size_t i = bra.p;
+size_t j = bra.q;
+size_t k = bra.r;
+Orbit& oi = Z.modelspace->GetOrbit(i);
+Orbit& oj = Z.modelspace->GetOrbit(j);
+Orbit& ok = Z.modelspace->GetOrbit(k);
+double ji = 0.5*oi.j2;
+double jj = 0.5*oj.j2;
+double jk = 0.5*ok.j2;
+double d_ei = std::abs( 2*oi.n + oi.l - e_fermi[oi.tz2]);
+double d_ej = std::abs( 2*oj.n + oj.l - e_fermi[oj.tz2]);
+double d_ek = std::abs( 2*ok.n + ok.l - e_fermi[ok.tz2]);
+if ( (d_ei + d_ej + d_ek) > Z.modelspace->dE3max ) continue;
+for (size_t iket=0; iket<=ibra; iket++)
+{
+auto& ket = Tbc.GetKet(iket);
+int J2 = ket.Jpq;
+int l = ket.p;
+int m = ket.q;
+int n = ket.r;
+Orbit& ol = Z.modelspace->GetOrbit(l);
+Orbit& om = Z.modelspace->GetOrbit(m);
+Orbit& on = Z.modelspace->GetOrbit(n);
+double jl = 0.5*ol.j2;
+double jm = 0.5*om.j2;
+double jn = 0.5*on.j2;
+double d_el = std::abs( 2*ol.n + ol.l - e_fermi[ol.tz2]);
+double d_em = std::abs( 2*om.n + om.l - e_fermi[om.tz2]);
+double d_en = std::abs( 2*on.n + on.l - e_fermi[on.tz2]);
+if ( (d_el + d_em + d_en) > Z.modelspace->dE3max ) continue;
+
+double z_ijklmn = 0;
+
+for (size_t ch_ab=0; ch_ab<nch2; ch_ab++)
+{
+auto& tbc_ab = Z.modelspace->GetTwoBodyChannel(ch_ab);
+size_t nkets_ab = tbc_ab.GetNumberKets();
+int Jab = tbc_ab.J;
 
-          if ( ((2*tbc_ab.Tz + ok.tz2) == Tbc.twoTz)  and ( (tbc_ab.parity + ok.l + Tbc.parity)%2==0) and Jab == J1)
-          {
-            for (size_t iket_ab=0; iket_ab<nkets_ab; iket_ab++)
-            {
-              auto& ket_ab = tbc_ab.GetKet(iket_ab);
-              size_t a = ket_ab.p;
-              size_t b = ket_ab.q;
-              double d_ea = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
-              double d_eb = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
-              if ( (d_ea + d_eb + d_ek) > Z.modelspace->dE3max ) continue;
-              double occfactor = 1-ket_ab.op->occ-ket_ab.oq->occ;
-              if (std::abs(occfactor)<1e-6) continue;
-              double symm_factor =  (a==b) ? 1.0 : 2.0;
-              double xijab = X2.GetTBME_J(Jab,Jab,i,j,a,b);
-              double yijab = Y2.GetTBME_J(Jab,Jab,i,j,a,b);
-              double xabklmn = X3.GetME_pn(J1,J2,twoJ,a,b,k,l,m,n);
-              double yabklmn = Y3.GetME_pn(J1,J2,twoJ,a,b,k,l,m,n);
-              z_ijklmn += 0.5 * symm_factor * occfactor * (xijab * yabklmn - yijab * xabklmn);
+if ( ((2*tbc_ab.Tz + ok.tz2) == Tbc.twoTz)  and ( (tbc_ab.parity + ok.l + Tbc.parity)%2==0) and Jab == J1)
+{
+for (size_t iket_ab=0; iket_ab<nkets_ab; iket_ab++)
+{
+auto& ket_ab = tbc_ab.GetKet(iket_ab);
+size_t a = ket_ab.p;
+size_t b = ket_ab.q;
+double d_ea = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
+double d_eb = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
+if ( (d_ea + d_eb + d_ek) > Z.modelspace->dE3max ) continue;
+double occfactor = 1-ket_ab.op->occ-ket_ab.oq->occ;
+if (std::abs(occfactor)<1e-6) continue;
+double symm_factor =  (a==b) ? 1.0 : 2.0;
+double xijab = X2.GetTBME_J(Jab,Jab,i,j,a,b);
+double yijab = Y2.GetTBME_J(Jab,Jab,i,j,a,b);
+double xabklmn = X3.GetME_pn(J1,J2,twoJ,a,b,k,l,m,n);
+double yabklmn = Y3.GetME_pn(J1,J2,twoJ,a,b,k,l,m,n);
+z_ijklmn += 0.5 * symm_factor * occfactor * (xijab * yabklmn - yijab * xabklmn);
 //              if (ch==0 and ibra==4 and iket==4)
 //              {
 //                 std::cout << "  iket_ab = " << iket_ab << "   adding to z   0.5 * " << symm_factor << " * " << occfactor << " * " << xijab << " " << yabklmn << "  =>  " << z_ijklmn << std::endl;;
 //              }
-            }// for iket_ab
-          } // if J, Tz and parity check for term 1
-
-
-          // Permute  Pik
-          if ( ((2*tbc_ab.Tz + oi.tz2) == Tbc.twoTz)  and ( (tbc_ab.parity + oi.l + Tbc.parity)%2==0)
-                     and (std::abs(2*Jab-oi.j2)<=twoJ) and ((2*Jab+oi.j2)>=twoJ) )
-          {
-             double sixj = Z.modelspace->GetSixJ(ji,jj,J1,jk,Jtot,Jab);
-             if (std::abs(sixj)>1e-6) 
-             {
-              double hats = sqrt( (2*J1+1)*(2*Jab+1));
-              for (size_t iket_ab=0; iket_ab<nkets_ab; iket_ab++)
-              {
-                auto& ket_ab = tbc_ab.GetKet(iket_ab);
-                size_t a = ket_ab.p;
-                size_t b = ket_ab.q;
-                double d_ea = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
-                double d_eb = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
-                if ( (d_ea + d_eb + d_ei) > Z.modelspace->dE3max ) continue;
-                double occfactor = 1-ket_ab.op->occ-ket_ab.oq->occ;
-                if (std::abs(occfactor)<1e-6) continue;
-                double symm_factor =  (a==b) ? 1.0 : 2.0;
-                double xkjab = X2.GetTBME_J(Jab,Jab,k,j,a,b);
-                double ykjab = Y2.GetTBME_J(Jab,Jab,k,j,a,b);
-                double xabilmn = X3.GetME_pn(Jab,J2,twoJ,a,b,i,l,m,n);
-                double yabilmn = Y3.GetME_pn(Jab,J2,twoJ,a,b,i,l,m,n);
-                z_ijklmn += 0.5  * symm_factor * occfactor * hats * sixj * (xkjab * yabilmn - ykjab * xabilmn);
-//              if (ch==0 and ibra==4 and iket==4)
-//              {
-//                 std::cout << "Pik  iket_ab = " << iket_ab << "   adding to z   0.5 * " << symm_factor << " * " << occfactor << " * " << hats
-//                           << " * " << sixj << " * " << xkjab << " " << yabilmn << "  =>  " << z_ijklmn << std::endl;;
-//              }
-              }// for iket_ab
-            }// if sixj nonzero
-          } // if J, Tz and parity check for term 2
-
-          // Permute  Pjk
-          if ( ((2*tbc_ab.Tz + oj.tz2) == Tbc.twoTz)  and ( (tbc_ab.parity + oj.l + Tbc.parity)%2==0) 
-                     and (std::abs(2*Jab-oj.j2)<=twoJ) and ((2*Jab+oj.j2)>=twoJ) )
-          {
-             double sixj = Z.modelspace->GetSixJ(jj,ji,J1,jk,Jtot,Jab);
-             if (std::abs(sixj)>1e-6)
-             {
-               double hats = sqrt( (2*J1+1)*(2*Jab+1));
-               int phase = Z.modelspace->phase( (oj.j2+ok.j2)/2-J1-Jab);
-               for (size_t iket_ab=0; iket_ab<nkets_ab; iket_ab++)
-               {
-                 auto& ket_ab = tbc_ab.GetKet(iket_ab);
-                 size_t a = ket_ab.p;
-                 size_t b = ket_ab.q;
-                 double d_ea = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
-                 double d_eb = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
-                 if ( (d_ea + d_eb + d_ej) > Z.modelspace->dE3max ) continue;
-                 double occfactor = 1-ket_ab.op->occ-ket_ab.oq->occ;
-                 if (std::abs(occfactor)<1e-6) continue;
-                 double symm_factor =  (a==b) ? 1.0 : 2.0;
-                 double xikab = X2.GetTBME_J(Jab,Jab,i,k,a,b);
-                 double yikab = Y2.GetTBME_J(Jab,Jab,i,k,a,b);
-                 double xabjlmn = X3.GetME_pn(Jab,J2,twoJ,a,b,j,l,m,n);
-                 double yabjlmn = Y3.GetME_pn(Jab,J2,twoJ,a,b,j,l,m,n);
-                 z_ijklmn -= 0.5 * symm_factor  * occfactor * phase * hats * sixj * (xikab * yabjlmn - yikab * xabjlmn);
-//              if (ch==0 and ibra==4 and iket==4)
-//              {
-//                 std::cout << "Pjk  iket_ab = " << iket_ab << "   adding to z   0.5 * " << symm_factor << " * " << occfactor << " * "
-//                           << phase << " * " << hats << " * " << sixj << " * " << xikab << " " << yabjlmn << "  =>  " << z_ijklmn << std::endl;
-//              }
-               }// for iket_ab
-            }// if sixj nonzero
-          } // if  J, Tz and parity check for term 3
-        
-          // direct Y3 X2 term
-          if ( ((2*tbc_ab.Tz + on.tz2) == Tbc.twoTz)  and ( (tbc_ab.parity + on.l + Tbc.parity)%2==0) and Jab == J2 )
-          {
-            for (size_t iket_ab=0; iket_ab<nkets_ab; iket_ab++)
-            {
-              auto& ket_ab = tbc_ab.GetKet(iket_ab);
-              size_t a = ket_ab.p;
-              size_t b = ket_ab.q;
-              double d_ea = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
-              double d_eb = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
-              if ( (d_ea + d_eb + d_en) > Z.modelspace->dE3max ) continue;
-              double occfactor = 1-ket_ab.op->occ-ket_ab.oq->occ;
-              if (std::abs(occfactor)<1e-6) continue;
-              double symm_factor =  (a==b) ? 1.0 : 2.0;
-              double xablm = X2.GetTBME_J(Jab,Jab,a,b,l,m);
-              double yablm = Y2.GetTBME_J(Jab,Jab,a,b,l,m);
-              double xijkabn = X3.GetME_pn(J1,J2,twoJ,i,j,k,a,b,n);
-              double yijkabn = Y3.GetME_pn(J1,J2,twoJ,i,j,k,a,b,n);
-              z_ijklmn -= 0.5 * symm_factor  * occfactor * (xablm * yijkabn - yablm * xijkabn);
-            }// for iket_ab
-          } // if  Tz and parity check for term 4
-
+}// for iket_ab
+} // if J, Tz and parity check for term 1
 
-          // Permute  Pln
-          if ( ((2*tbc_ab.Tz + ol.tz2) == Tbc.twoTz)  and ( (tbc_ab.parity + ol.l + Tbc.parity)%2==0) 
-                     and (std::abs(2*Jab-ol.j2)<=twoJ) and ((2*Jab+ol.j2)>=twoJ) )
-          {
-             double sixj = Z.modelspace->GetSixJ(jl,jm,J2,jn,Jtot,Jab);
-             if (std::abs(sixj)>1e-6) 
-             {
-               double hats = sqrt( (2*J2+1)*(2*Jab+1));
-               for (size_t iket_ab=0; iket_ab<nkets_ab; iket_ab++)
-               {
-                 auto& ket_ab = tbc_ab.GetKet(iket_ab);
-                 size_t a = ket_ab.p;
-                 size_t b = ket_ab.q;
-                 double d_ea = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
-                 double d_eb = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
-                 if ( (d_ea + d_eb + d_el) > Z.modelspace->dE3max ) continue;
-                 double occfactor = 1-ket_ab.op->occ-ket_ab.oq->occ;
-                 if (std::abs(occfactor)<1e-6) continue;
-                 double symm_factor =  (a==b) ? 1.0 : 2.0;
-                 double xabnm = X2.GetTBME_J(Jab,Jab,a,b,n,m);
-                 double yabnm = Y2.GetTBME_J(Jab,Jab,a,b,n,m);
-                 double xijkabl = X3.GetME_pn(J1,Jab,twoJ,i,j,k,a,b,l);
-                 double yijkabl = Y3.GetME_pn(J1,Jab,twoJ,i,j,k,a,b,l);
-                 z_ijklmn -= 0.5 * symm_factor  * occfactor * hats * sixj * (xabnm * yijkabl - yabnm * xijkabl);
-               }// for iket_ab
-             }// if sixj nonzero
-          } // if  Tz and parity check for term 5
-
-
-          // Permute  Pmn
-          if ( ((2*tbc_ab.Tz + om.tz2) == Tbc.twoTz)  and ( (tbc_ab.parity + om.l + Tbc.parity)%2==0) 
-                     and (std::abs(2*Jab-om.j2)<=twoJ) and ((2*Jab+om.j2)>=twoJ) )
-          {
-              double sixj = Z.modelspace->GetSixJ(jm,jl,J2,jn,Jtot,Jab);
-             if (std::abs(sixj)>1e-6) 
-             {
-              double hats = sqrt( (2*J2+1)*(2*Jab+1));
-              int phase = Z.modelspace->phase( (om.j2+on.j2)/2-J2-Jab);
-              for (size_t iket_ab=0; iket_ab<nkets_ab; iket_ab++)
-              {
-                auto& ket_ab = tbc_ab.GetKet(iket_ab);
-                size_t a = ket_ab.p;
-                size_t b = ket_ab.q;
-                double d_ea = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
-                double d_eb = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
-                if ( (d_ea + d_eb + d_em) > Z.modelspace->dE3max ) continue;
-                double occfactor = 1-ket_ab.op->occ-ket_ab.oq->occ;
-                if (std::abs(occfactor)<1e-6) continue;
-                double symm_factor =  (a==b) ? 1.0 : 2.0;
-                double xabln = X2.GetTBME_J(Jab,Jab,a,b,l,n);
-                double yabln = Y2.GetTBME_J(Jab,Jab,a,b,l,n);
-                double xijkabm = X3.GetME_pn(J1,Jab,twoJ,i,j,k,a,b,m);
-                double yijkabm = Y3.GetME_pn(J1,Jab,twoJ,i,j,k,a,b,m);
-                z_ijklmn += 0.5 * symm_factor * phase  * occfactor * hats * sixj * (xabln * yijkabm - yabln * xijkabm);
-              }// for iket_ab
-            }// if sixj nonzero
-          } // if  Tz and parity check for term 6
 
-        }// for ch_ab
+// Permute  Pik
+if ( ((2*tbc_ab.Tz + oi.tz2) == Tbc.twoTz)  and ( (tbc_ab.parity + oi.l + Tbc.parity)%2==0)
+    and (std::abs(2*Jab-oi.j2)<=twoJ) and ((2*Jab+oi.j2)>=twoJ) )
+{
+  double sixj = Z.modelspace->GetSixJ(ji,jj,J1,jk,Jtot,Jab);
+  if (std::abs(sixj)>1e-6)
+  {
+    double hats = sqrt( (2*J1+1)*(2*Jab+1));
+    for (size_t iket_ab=0; iket_ab<nkets_ab; iket_ab++)
+    {
+      auto& ket_ab = tbc_ab.GetKet(iket_ab);
+      size_t a = ket_ab.p;
+      size_t b = ket_ab.q;
+      double d_ea = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
+      double d_eb = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
+      if ( (d_ea + d_eb + d_ei) > Z.modelspace->dE3max ) continue;
+      double occfactor = 1-ket_ab.op->occ-ket_ab.oq->occ;
+      if (std::abs(occfactor)<1e-6) continue;
+      double symm_factor =  (a==b) ? 1.0 : 2.0;
+      double xkjab = X2.GetTBME_J(Jab,Jab,k,j,a,b);
+      double ykjab = Y2.GetTBME_J(Jab,Jab,k,j,a,b);
+      double xabilmn = X3.GetME_pn(Jab,J2,twoJ,a,b,i,l,m,n);
+      double yabilmn = Y3.GetME_pn(Jab,J2,twoJ,a,b,i,l,m,n);
+      z_ijklmn += 0.5  * symm_factor * occfactor * hats * sixj * (xkjab * yabilmn - ykjab * xabilmn);
+      //              if (ch==0 and ibra==4 and iket==4)
+      //              {
+      //                 std::cout << "Pik  iket_ab = " << iket_ab << "   adding to z   0.5 * " << symm_factor << " * " << occfactor << " * " << hats
+      //                           << " * " << sixj << " * " << xkjab << " " << yabilmn << "  =>  " << z_ijklmn << std::endl;;
+      //              }
+    }// for iket_ab
+  }// if sixj nonzero
+} // if J, Tz and parity check for term 2
+
+// Permute  Pjk
+if ( ((2*tbc_ab.Tz + oj.tz2) == Tbc.twoTz)  and ( (tbc_ab.parity + oj.l + Tbc.parity)%2==0)
+    and (std::abs(2*Jab-oj.j2)<=twoJ) and ((2*Jab+oj.j2)>=twoJ) )
+{
+  double sixj = Z.modelspace->GetSixJ(jj,ji,J1,jk,Jtot,Jab);
+  if (std::abs(sixj)>1e-6)
+  {
+    double hats = sqrt( (2*J1+1)*(2*Jab+1));
+    int phase = Z.modelspace->phase( (oj.j2+ok.j2)/2-J1-Jab);
+    for (size_t iket_ab=0; iket_ab<nkets_ab; iket_ab++)
+    {
+      auto& ket_ab = tbc_ab.GetKet(iket_ab);
+      size_t a = ket_ab.p;
+      size_t b = ket_ab.q;
+      double d_ea = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
+      double d_eb = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
+      if ( (d_ea + d_eb + d_ej) > Z.modelspace->dE3max ) continue;
+      double occfactor = 1-ket_ab.op->occ-ket_ab.oq->occ;
+      if (std::abs(occfactor)<1e-6) continue;
+      double symm_factor =  (a==b) ? 1.0 : 2.0;
+      double xikab = X2.GetTBME_J(Jab,Jab,i,k,a,b);
+      double yikab = Y2.GetTBME_J(Jab,Jab,i,k,a,b);
+      double xabjlmn = X3.GetME_pn(Jab,J2,twoJ,a,b,j,l,m,n);
+      double yabjlmn = Y3.GetME_pn(Jab,J2,twoJ,a,b,j,l,m,n);
+      z_ijklmn -= 0.5 * symm_factor  * occfactor * phase * hats * sixj * (xikab * yabjlmn - yikab * xabjlmn);
+      //              if (ch==0 and ibra==4 and iket==4)
+      //              {
+      //                 std::cout << "Pjk  iket_ab = " << iket_ab << "   adding to z   0.5 * " << symm_factor << " * " << occfactor << " * "
+      //                           << phase << " * " << hats << " * " << sixj << " * " << xikab << " " << yabjlmn << "  =>  " << z_ijklmn << std::endl;
+      //              }
+    }// for iket_ab
+  }// if sixj nonzero
+} // if  J, Tz and parity check for term 3
+
+// direct Y3 X2 term
+if ( ((2*tbc_ab.Tz + on.tz2) == Tbc.twoTz)  and ( (tbc_ab.parity + on.l + Tbc.parity)%2==0) and Jab == J2 )
+{
+  for (size_t iket_ab=0; iket_ab<nkets_ab; iket_ab++)
+  {
+    auto& ket_ab = tbc_ab.GetKet(iket_ab);
+    size_t a = ket_ab.p;
+    size_t b = ket_ab.q;
+    double d_ea = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
+    double d_eb = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
+    if ( (d_ea + d_eb + d_en) > Z.modelspace->dE3max ) continue;
+    double occfactor = 1-ket_ab.op->occ-ket_ab.oq->occ;
+    if (std::abs(occfactor)<1e-6) continue;
+    double symm_factor =  (a==b) ? 1.0 : 2.0;
+    double xablm = X2.GetTBME_J(Jab,Jab,a,b,l,m);
+    double yablm = Y2.GetTBME_J(Jab,Jab,a,b,l,m);
+    double xijkabn = X3.GetME_pn(J1,J2,twoJ,i,j,k,a,b,n);
+    double yijkabn = Y3.GetME_pn(J1,J2,twoJ,i,j,k,a,b,n);
+    z_ijklmn -= 0.5 * symm_factor  * occfactor * (xablm * yijkabn - yablm * xijkabn);
+  }// for iket_ab
+} // if  Tz and parity check for term 4
+
+
+// Permute  Pln
+if ( ((2*tbc_ab.Tz + ol.tz2) == Tbc.twoTz)  and ( (tbc_ab.parity + ol.l + Tbc.parity)%2==0)
+    and (std::abs(2*Jab-ol.j2)<=twoJ) and ((2*Jab+ol.j2)>=twoJ) )
+{
+  double sixj = Z.modelspace->GetSixJ(jl,jm,J2,jn,Jtot,Jab);
+  if (std::abs(sixj)>1e-6)
+  {
+    double hats = sqrt( (2*J2+1)*(2*Jab+1));
+    for (size_t iket_ab=0; iket_ab<nkets_ab; iket_ab++)
+    {
+      auto& ket_ab = tbc_ab.GetKet(iket_ab);
+      size_t a = ket_ab.p;
+      size_t b = ket_ab.q;
+      double d_ea = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
+      double d_eb = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
+      if ( (d_ea + d_eb + d_el) > Z.modelspace->dE3max ) continue;
+      double occfactor = 1-ket_ab.op->occ-ket_ab.oq->occ;
+      if (std::abs(occfactor)<1e-6) continue;
+      double symm_factor =  (a==b) ? 1.0 : 2.0;
+      double xabnm = X2.GetTBME_J(Jab,Jab,a,b,n,m);
+      double yabnm = Y2.GetTBME_J(Jab,Jab,a,b,n,m);
+      double xijkabl = X3.GetME_pn(J1,Jab,twoJ,i,j,k,a,b,l);
+      double yijkabl = Y3.GetME_pn(J1,Jab,twoJ,i,j,k,a,b,l);
+      z_ijklmn -= 0.5 * symm_factor  * occfactor * hats * sixj * (xabnm * yijkabl - yabnm * xijkabl);
+    }// for iket_ab
+  }// if sixj nonzero
+} // if  Tz and parity check for term 5
+
+
+// Permute  Pmn
+if ( ((2*tbc_ab.Tz + om.tz2) == Tbc.twoTz)  and ( (tbc_ab.parity + om.l + Tbc.parity)%2==0)
+    and (std::abs(2*Jab-om.j2)<=twoJ) and ((2*Jab+om.j2)>=twoJ) )
+{
+  double sixj = Z.modelspace->GetSixJ(jm,jl,J2,jn,Jtot,Jab);
+  if (std::abs(sixj)>1e-6)
+  {
+    double hats = sqrt( (2*J2+1)*(2*Jab+1));
+    int phase = Z.modelspace->phase( (om.j2+on.j2)/2-J2-Jab);
+    for (size_t iket_ab=0; iket_ab<nkets_ab; iket_ab++)
+    {
+      auto& ket_ab = tbc_ab.GetKet(iket_ab);
+      size_t a = ket_ab.p;
+      size_t b = ket_ab.q;
+      double d_ea = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
+      double d_eb = std::abs( 2*ket_ab.op->n + ket_ab.op->l - e_fermi[ket_ab.op->tz2] );
+      if ( (d_ea + d_eb + d_em) > Z.modelspace->dE3max ) continue;
+      double occfactor = 1-ket_ab.op->occ-ket_ab.oq->occ;
+      if (std::abs(occfactor)<1e-6) continue;
+      double symm_factor =  (a==b) ? 1.0 : 2.0;
+      double xabln = X2.GetTBME_J(Jab,Jab,a,b,l,n);
+      double yabln = Y2.GetTBME_J(Jab,Jab,a,b,l,n);
+      double xijkabm = X3.GetME_pn(J1,Jab,twoJ,i,j,k,a,b,m);
+      double yijkabm = Y3.GetME_pn(J1,Jab,twoJ,i,j,k,a,b,m);
+      z_ijklmn += 0.5 * symm_factor * phase  * occfactor * hats * sixj * (xabln * yijkabm - yabln * xijkabm);
+    }// for iket_ab
+  }// if sixj nonzero
+} // if  Tz and parity check for term 6
+
+}// for ch_ab
 
 //        if (ch==0 and ibra<5 and iket<5)
 //        {
-//          std::cout << __func__ << "   ch = " << ch << "  ibra =  " <<  ibra << "  iket = " << iket 
+//          std::cout << __func__ << "   ch = " << ch << "  ibra =  " <<  ibra << "  iket = " << iket
 //                    << "   ijklmn " << bra.p << " " << bra.q << " " << bra.r << " " << ket.p << " " << ket.q << " " << ket.r
-//                    << "  Jij Jlm twoJ " << bra.Jpq << " " << ket.Jpq << "  " << twoJ 
+//                    << "  Jij Jlm twoJ " << bra.Jpq << " " << ket.Jpq << "  " << twoJ
 //                    << "  zijklmn = " << z_ijklmn << std::endl;
 //        }
-        // no normalization to be done. we store un-normalized 3body matrix elements.
-        if (std::abs(z_ijklmn)>1e-6)
-        {
-//            Z3.AddToME_pn( J1, J2, twoJ, i,j,k,l,m,n, z_ijklmn );
-            Z3.AddToME_pn_PN_ch( ch,ch,ibra,iket, z_ijklmn );
-        }
+// no normalization to be done. we store un-normalized 3body matrix elements.
+if (std::abs(z_ijklmn)>1e-6)
+{
+  //            Z3.AddToME_pn( J1, J2, twoJ, i,j,k,l,m,n, z_ijklmn );
+  Z3.AddToME_pn_PN_ch( ch,ch,ibra,iket, z_ijklmn );
+}
 
-      }// for iket
-    }// for ibra
-  }// for ch
+}// for iket
+}// for ibra
+}// for ch
 
-  Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
+Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
 }
 */
 
@@ -6517,18 +6763,18 @@ void comm233_pp_hhss_debug( const Operator& X, const Operator& Y, Operator& Z )
 //
 // i|   j|        k|  Uncoupled expression:
 //  |    |         |    C_ijklmn = sum_{ab} (n`anb -nan`b) P(ij/k)P(lm/n) Y_{ijalmb} X_{bkan}
-//  |    |   *~~X~~|                
+//  |    |   *~~X~~|
 //  |    | a/ \b   |
 //  |    |  \ /    |
 //  |~~~[Y]~~*     |  Coupled expression:
-//  |    |         |  C_{ijklmn}^{J1,J2,J} =  P^{J1,J}(ij/k)P^{J2,j}_{lm/n) sum_{ab} (n`anb -nan`b)  
-// l|   m|        n|                          * sum_{J',J3} (2J'+1)(2J3+1) (-1)^{2J+k-n+J1-J2} 
-//  |    |         |                          { J   J2  n  }                                                                       
-//                                          * { J1  J'  a  } * Y_{ijalmb}^{J1,J2,J'} X_{bkan}^{J3}                                 
+//  |    |         |  C_{ijklmn}^{J1,J2,J} =  P^{J1,J}(ij/k)P^{J2,j}_{lm/n) sum_{ab} (n`anb -nan`b)
+// l|   m|        n|                          * sum_{J',J3} (2J'+1)(2J3+1) (-1)^{2J+k-n+J1-J2}
+//  |    |         |                          { J   J2  n  }
+//                                          * { J1  J'  a  } * Y_{ijalmb}^{J1,J2,J'} X_{bkan}^{J3}
 //                                            { k   b   J3 }
-//                                              
-//      Checked with UnitTest and passed                                                                      
-//                                                                           
+//
+//      Checked with UnitTest and passed
+//
 void comm233_phss( const Operator& X, const Operator& Y, Operator& Z )
 {
 
@@ -6553,19 +6799,19 @@ void comm233_phss( const Operator& X, const Operator& Y, Operator& Z )
   auto hash_key_lmij = [](size_t l,size_t m, size_t Jlm, size_t i, size_t j, size_t Jij){return ( l + (m<<12) + (i<<24) + (j<<36) + (Jlm<<48) + (Jij<<56) );};
   auto unhash_key_lmij = [](size_t& l, size_t& m, size_t& Jlm, size_t& i,size_t& j, size_t& Jij, size_t key){ l=(key & 0xFFFL);m=((key>>12)&0xFFFL);i=((key>>24)&0xFFFL);j=((key>>36)&0xFFFL); Jlm=((key>>48)&0xFFL); Jij=((key>>56)&0xFFL); }; //  0xF = 15 = 1111 (4bits), so 0xFFF is 12 bits of 1's. 0xFFFL makes it a long
   std::deque<std::unordered_map<size_t,size_t>> ph_kets3_lookup(nch2_CC); // map  lm Jlm  (ij Jij)` to matrix index
-//  std::deque<std::map<std::array<int,6>,size_t>> ph_kets3_lookup(nch2_CC); // map  lm Jlm  (ij Jij)` to matrix index
+  //  std::deque<std::map<std::array<int,6>,size_t>> ph_kets3_lookup(nch2_CC); // map  lm Jlm  (ij Jij)` to matrix index
 
   std::deque<arma::mat> Z3_ph(nch2_CC); // matrices for ph transformed Z3. This will be the big one.
 
   double occnat_factor_max = 0;
   for ( auto i : Z.modelspace->all_orbits)
   {
-     double occnat_i = Z.modelspace->GetOrbit(i).occ_nat;
-     occnat_factor_max = std::max( occnat_factor_max, occnat_i*(1-occnat_i) );
+    double occnat_i = Z.modelspace->GetOrbit(i).occ_nat;
+    occnat_factor_max = std::max( occnat_factor_max, occnat_i*(1-occnat_i) );
   }
 
 
-//  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+  //  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
   for (size_t ch_cc=0; ch_cc<nch2_CC; ch_cc++)
   {
     TwoBodyChannel_CC& tbc_CC = Z.modelspace->GetTwoBodyChannel_CC(ch_cc);
@@ -6584,78 +6830,78 @@ void comm233_phss( const Operator& X, const Operator& Y, Operator& Z )
       }
     }// for iket
 
-//    size_t nkets_ph = ph_kets_cc[ch_cc].size();
+    //    size_t nkets_ph = ph_kets_cc[ch_cc].size();
 
 
-   auto& ph_kets3 = ph_kets3_lookup[ch_cc];
-   size_t nkets3 = 0;
-   // next, figure out how many states we'll need for the 3b matrices
-   for (size_t ch_lm=0; ch_lm<nch2; ch_lm++)
-   {
-     TwoBodyChannel& tbc_lm = Z.modelspace->GetTwoBodyChannel(ch_lm);
-     size_t nkets_lm = tbc_lm.GetNumberKets();
-     for (size_t ch_ij=0; ch_ij<nch2; ch_ij++)
-     {
-       TwoBodyChannel& tbc_ij = Z.modelspace->GetTwoBodyChannel(ch_ij);
-       if ( (tbc_lm.parity + tbc_ij.parity)%2 != tbc_CC.parity ) continue;
-       if ( std::abs(tbc_lm.Tz - tbc_ij.Tz) != tbc_CC.Tz ) continue; // This abs bit may make things expensive...
-       if ( (std::abs( tbc_lm.J - tbc_ij.J) > tbc_CC.J) or ( tbc_lm.J + tbc_ij.J) < tbc_CC.J) continue;
+    auto& ph_kets3 = ph_kets3_lookup[ch_cc];
+    size_t nkets3 = 0;
+    // next, figure out how many states we'll need for the 3b matrices
+    for (size_t ch_lm=0; ch_lm<nch2; ch_lm++)
+    {
+      TwoBodyChannel& tbc_lm = Z.modelspace->GetTwoBodyChannel(ch_lm);
+      size_t nkets_lm = tbc_lm.GetNumberKets();
+      for (size_t ch_ij=0; ch_ij<nch2; ch_ij++)
+      {
+        TwoBodyChannel& tbc_ij = Z.modelspace->GetTwoBodyChannel(ch_ij);
+        if ( (tbc_lm.parity + tbc_ij.parity)%2 != tbc_CC.parity ) continue;
+        if ( std::abs(tbc_lm.Tz - tbc_ij.Tz) != tbc_CC.Tz ) continue; // This abs bit may make things expensive...
+        if ( (std::abs( tbc_lm.J - tbc_ij.J) > tbc_CC.J) or ( tbc_lm.J + tbc_ij.J) < tbc_CC.J) continue;
 
-       size_t nkets_ij = tbc_ij.GetNumberKets();
-       for ( size_t iket_lm=0; iket_lm<nkets_lm; iket_lm++)
-       {
-         Ket& ket_lm = tbc_lm.GetKet(iket_lm);
-         size_t l = ket_lm.p;
-         size_t m = ket_lm.q;
-         int Jlm  = tbc_lm.J;
-         Orbit& ol = Z.modelspace->GetOrbit(l);
-         Orbit& om = Z.modelspace->GetOrbit(m);
-         double d_el = std::abs( 2*ol.n + ol.l - e_fermi[ol.tz2]);
-         double d_em = std::abs( 2*om.n + om.l - e_fermi[om.tz2]);
-         double occnat_l = ol.occ_nat;
-         double occnat_m = om.occ_nat;
-         if ( (occnat_l*(1-occnat_l) * occnat_m*(1-occnat_m) * occnat_factor_max ) < Z.modelspace->GetOccNat3Cut() ) continue;
-         if ( (d_el + d_em ) > Z.modelspace->dE3max ) continue;
- 
-         for (size_t iket_ij=0; iket_ij<nkets_ij; iket_ij++)
-         {
-           Ket& ket_ij = tbc_ij.GetKet(iket_ij);
-           size_t i = ket_ij.p;
-           size_t j = ket_ij.q;
-           int Jij  = tbc_ij.J;
-           // Only compute one ordering of   lmij  vs ijlm  since we can get the other ordering from symmetry
-           if ( (std::min(i,j) > std::min(l,m)) or ((std::min(i,j)==std::min(l,m)) and (std::max(i,j) > std::max(l,m)))
-               or ((std::min(i,j)==std::min(l,m)) and (std::max(i,j)==std::max(l,m)) and (Jij>Jlm)) ) continue;
-
-           Orbit& oi = Z.modelspace->GetOrbit(i);
-           Orbit& oj = Z.modelspace->GetOrbit(j);
-           double occnat_i = oi.occ_nat;
-           double occnat_j = oj.occ_nat;
-           double d_ei = std::abs( 2*oi.n + oi.l - e_fermi[oi.tz2]);
-           double d_ej = std::abs( 2*oj.n + oj.l - e_fermi[oj.tz2]);
-           if ( (occnat_i*(1-occnat_i) * occnat_j*(1-occnat_j) * occnat_factor_max ) < Z.modelspace->GetOccNat3Cut() ) continue;
-           if ( (d_ei + d_ej ) > Z.modelspace->dE3max ) continue;
-
-           size_t key = hash_key_lmij( l,m,(size_t)Jlm,i,j,(size_t)Jij);
-           ph_kets3[ key ] = nkets3;
-//           ph_kets3[{l,m,Jlm,i,j,Jij}] = nkets3;
-           nkets3++;
-         }
-       }
-
-     }// for ch_ij
-   }// for ch_lm
-
-   // so now we can allocate the ph 3-body matrices
-
-   Z3_ph[ch_cc].zeros( 2*nkets_CC, nkets3 ); // Zbar_knlmij
+        size_t nkets_ij = tbc_ij.GetNumberKets();
+        for ( size_t iket_lm=0; iket_lm<nkets_lm; iket_lm++)
+        {
+          Ket& ket_lm = tbc_lm.GetKet(iket_lm);
+          size_t l = ket_lm.p;
+          size_t m = ket_lm.q;
+          int Jlm  = tbc_lm.J;
+          Orbit& ol = Z.modelspace->GetOrbit(l);
+          Orbit& om = Z.modelspace->GetOrbit(m);
+          double d_el = std::abs( 2*ol.n + ol.l - e_fermi[ol.tz2]);
+          double d_em = std::abs( 2*om.n + om.l - e_fermi[om.tz2]);
+          double occnat_l = ol.occ_nat;
+          double occnat_m = om.occ_nat;
+          if ( (occnat_l*(1-occnat_l) * occnat_m*(1-occnat_m) * occnat_factor_max ) < Z.modelspace->GetOccNat3Cut() ) continue;
+          if ( (d_el + d_em ) > Z.modelspace->dE3max ) continue;
+
+          for (size_t iket_ij=0; iket_ij<nkets_ij; iket_ij++)
+          {
+            Ket& ket_ij = tbc_ij.GetKet(iket_ij);
+            size_t i = ket_ij.p;
+            size_t j = ket_ij.q;
+            int Jij  = tbc_ij.J;
+            // Only compute one ordering of   lmij  vs ijlm  since we can get the other ordering from symmetry
+            if ( (std::min(i,j) > std::min(l,m)) or ((std::min(i,j)==std::min(l,m)) and (std::max(i,j) > std::max(l,m)))
+                or ((std::min(i,j)==std::min(l,m)) and (std::max(i,j)==std::max(l,m)) and (Jij>Jlm)) ) continue;
+
+            Orbit& oi = Z.modelspace->GetOrbit(i);
+            Orbit& oj = Z.modelspace->GetOrbit(j);
+            double occnat_i = oi.occ_nat;
+            double occnat_j = oj.occ_nat;
+            double d_ei = std::abs( 2*oi.n + oi.l - e_fermi[oi.tz2]);
+            double d_ej = std::abs( 2*oj.n + oj.l - e_fermi[oj.tz2]);
+            if ( (occnat_i*(1-occnat_i) * occnat_j*(1-occnat_j) * occnat_factor_max ) < Z.modelspace->GetOccNat3Cut() ) continue;
+            if ( (d_ei + d_ej ) > Z.modelspace->dE3max ) continue;
+
+            size_t key = hash_key_lmij( l,m,(size_t)Jlm,i,j,(size_t)Jij);
+            ph_kets3[ key ] = nkets3;
+            //           ph_kets3[{l,m,Jlm,i,j,Jij}] = nkets3;
+            nkets3++;
+          }
+        }
+
+      }// for ch_ij
+    }// for ch_lm
+
+    // so now we can allocate the ph 3-body matrices
+
+    Z3_ph[ch_cc].zeros( 2*nkets_CC, nkets3 ); // Zbar_knlmij
   }// for ch_cc
 
   Z.profiler.timer["comm233_setup_lists"] += omp_get_wtime() - t_internal;
   t_internal = omp_get_wtime();
 
   // Compute the particle-hole recoupled matrix elements of Z
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
   for (size_t ch_cc=0; ch_cc<nch2_CC; ch_cc++)
   {
     TwoBodyChannel_CC& tbc_CC = Z.modelspace->GetTwoBodyChannel_CC(ch_cc);
@@ -6664,11 +6910,11 @@ void comm233_phss( const Operator& X, const Operator& Y, Operator& Z )
     size_t nkets_ph = ph_kets_cc[ch_cc].size();
     size_t nkets3 = Z3_ph[ch_cc].n_cols;
 
-     arma::mat X2_ph( 2*nkets_CC, 2*nkets_ph, arma::fill::zeros ); // we need to store both permutations ij ji because the ph transformed 2bmes don't have as nice a symmetry
-     arma::mat Y2_ph( 2*nkets_CC, 2*nkets_ph, arma::fill::zeros );
+    arma::mat X2_ph( 2*nkets_CC, 2*nkets_ph, arma::fill::zeros ); // we need to store both permutations ij ji because the ph transformed 2bmes don't have as nice a symmetry
+    arma::mat Y2_ph( 2*nkets_CC, 2*nkets_ph, arma::fill::zeros );
 
-     arma::mat X3_ph( 2*nkets_ph,   nkets3, arma::fill::zeros ); // Xbar_ablmij
-     arma::mat Y3_ph( 2*nkets_ph,   nkets3, arma::fill::zeros );
+    arma::mat X3_ph( 2*nkets_ph,   nkets3, arma::fill::zeros ); // Xbar_ablmij
+    arma::mat Y3_ph( 2*nkets_ph,   nkets3, arma::fill::zeros );
 
     // now we fill the matrices
     for (size_t ibra_ij=0; ibra_ij<nkets_CC; ibra_ij++)
@@ -6689,7 +6935,7 @@ void comm233_phss( const Operator& X, const Operator& Y, Operator& Z )
         Orbit& ob = Z.modelspace->GetOrbit(b);
         double ja = 0.5 * oa.j2;
         double jb = 0.5 * ob.j2;
-//        double occ_factor = occfactors[ch_cc][iket_ab];
+        //        double occ_factor = occfactors[ch_cc][iket_ab];
 
         double occ_factor = oa.occ-ob.occ;
 
@@ -6745,7 +6991,7 @@ void comm233_phss( const Operator& X, const Operator& Y, Operator& Z )
       int Jij = (int)Jij_tmp;
 
 
-//      size_t index_ijlm = ph_kets3.at({i,j,Jij,l,m,Jlm});
+      //      size_t index_ijlm = ph_kets3.at({i,j,Jij,l,m,Jlm});
       Orbit& ol = Z.modelspace->GetOrbit(l);
       Orbit& om = Z.modelspace->GetOrbit(m);
       Orbit& oi = Z.modelspace->GetOrbit(i);
@@ -6759,7 +7005,7 @@ void comm233_phss( const Operator& X, const Operator& Y, Operator& Z )
       double d_ei = std::abs( 2*oi.n + oi.l - e_fermi[oi.tz2]);
       double d_ej = std::abs( 2*oj.n + oj.l - e_fermi[oj.tz2]);
 
-//      for ( size_t iket_ab=0; iket_ab<nkets_ph; iket_ab++)
+      //      for ( size_t iket_ab=0; iket_ab<nkets_ph; iket_ab++)
       for ( size_t iket_ab=0; iket_ab<2*nkets_ph; iket_ab++)
       {
         Ket& ket_ab = tbc_CC.GetKet( ph_kets_cc[ch_cc].at(iket_ab%nkets_ph));
@@ -6797,33 +7043,11 @@ void comm233_phss( const Operator& X, const Operator& Y, Operator& Z )
         {
           int phase_y = Z.modelspace->phase( (oa.j2+twoJp)/2 );
 
-//          std::vector<double> xandy = Y3.GetME_pn_PN_TwoOps( Jij,Jlm,twoJp, i,j,a, l,m,b, X3,Y3 );
-// TODO UNCOMMENT THESE 3 LINES
+          // get the X3 and Y3 elements in one go (to avoid doing the recoupling twice)
           auto xandy = Y3.GetME_pn_PN_TwoOps( Jij,Jlm,twoJp, i,j,a, l,m,b, X3,Y3 );
           double xablmij = xandy[0];
           double yablmij = xandy[1];
 
-//          std::vector<size_t> ibra_list;
-//          std::vector<size_t> iket_list;
-//          std::vector<double> recouple_bra_list;
-//          std::vector<double> recouple_ket_list;
-//          size_t ch_check_bra = Y.ThreeBody.GetKetIndex_withRecoupling( Jij, twoJp, i, j, a, ibra_list, recouple_bra_list) ;
-//          size_t ch_check_ket = Y.ThreeBody.GetKetIndex_withRecoupling( Jlm, twoJp, l, m, b, iket_list, recouple_ket_list) ;
-//          double xablmij = 0;
-//          double yablmij = 0;
-//          for ( size_t ind_bra=0; ind_bra<ibra_list.size(); ind_bra++)
-//          {
-//            double rec_bra = recouple_bra_list[ind_bra];
-//            size_t Ibra = ibra_list[ind_bra];
-//            for ( size_t ind_ket=0; ind_ket<iket_list.size(); ind_ket++)
-//            {
-//              double rec_ket = recouple_ket_list[ind_ket];
-//              size_t Iket = iket_list[ind_ket];
-//               xablmij += rec_bra * rec_ket * X3.GetME_pn_PN_ch(ch_check_bra,ch_check_ket,Ibra,Iket);
-//               yablmij += rec_bra * rec_ket * Y3.GetME_pn_PN_ch(ch_check_bra,ch_check_ket,Ibra,Iket);
-//            }
-//          }
-
 
           double sixjy = Z.modelspace->GetSixJ( Jij, Jlm, Jph, jb, ja, 0.5*twoJp);
           X3bar_ablmij -= phase_y * (twoJp+1) * sixjy * xablmij;
@@ -6835,20 +7059,20 @@ void comm233_phss( const Operator& X, const Operator& Y, Operator& Z )
         X3_ph(index_ab, index_lmij) = X3bar_ablmij ;
         Y3_ph(index_ab, index_lmij) = Y3bar_ablmij ;
 
-       }// for iket_ab
-      }// for iter_lmij
+      }// for iket_ab
+    }// for iter_lmij
 
-      Z3_ph[ch_cc] = X2_ph * Y3_ph - Y2_ph * X3_ph;
+    Z3_ph[ch_cc] = X2_ph * Y3_ph - Y2_ph * X3_ph;
 
   }// for ch_cc
-//  std::cout << "DONE WITH THE CC BIT" << std::endl;
+  //  std::cout << "DONE WITH THE CC BIT" << std::endl;
 
   Z.profiler.timer["comm233_fll_matrices"] += omp_get_wtime() - t_internal;
   t_internal = omp_get_wtime();
 
   // Now transform it back into standard coupling
   size_t nch3 = Z.modelspace->GetNumberThreeBodyChannels();
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
   for (size_t ch3=0; ch3<nch3; ch3++)
   {
     auto& Tbc = Z.modelspace->GetThreeBodyChannel(ch3);
@@ -6884,10 +7108,10 @@ void comm233_phss( const Operator& X, const Operator& Y, Operator& Z )
       std::vector<int> J1p_max = {J1,  std::min(ok.j2+oj.j2, twoJ+oi.j2)/2 , std::min(oi.j2+ok.j2, twoJ+oj.j2)/2 };
       std::vector<std::vector<double>> recouple_ijk = {{1},{},{} };
       for (int J1p=J1p_min[1]; J1p<=J1p_max[1]; J1p++)
-           recouple_ijk[1].push_back( sqrt( (2*J1+1)*(2*J1p+1)) * Z.modelspace->GetSixJ(ji,jj,J1,jk,Jtot,J1p) );
+        recouple_ijk[1].push_back( sqrt( (2*J1+1)*(2*J1p+1)) * Z.modelspace->GetSixJ(ji,jj,J1,jk,Jtot,J1p) );
 
       for (int J1p=J1p_min[2]; J1p<=J1p_max[2]; J1p++)
-           recouple_ijk[2].push_back( -Z.modelspace->phase((oj.j2+ok.j2)/2+J1+J1p)*sqrt( (2*J1+1)*(2*J1p+1)) * Z.modelspace->GetSixJ(jj,ji,J1,jk,Jtot,J1p) );
+        recouple_ijk[2].push_back( -Z.modelspace->phase((oj.j2+ok.j2)/2+J1+J1p)*sqrt( (2*J1+1)*(2*J1p+1)) * Z.modelspace->GetSixJ(jj,ji,J1,jk,Jtot,J1p) );
 
 
       for (size_t iket=ibra; iket<nkets3; iket++)
@@ -6917,12 +7141,12 @@ void comm233_phss( const Operator& X, const Operator& Y, Operator& Z )
         std::vector<int> J2p_min = {J2,  std::max(std::abs(on.j2-om.j2),std::abs(twoJ-ol.j2) )/2,   std::max(std::abs(ol.j2-on.j2), std::abs(twoJ-om.j2) )/2 };
         std::vector<int> J2p_max = {J2,  std::min(on.j2+om.j2, twoJ+ol.j2)/2 , std::min(ol.j2+on.j2, twoJ+om.j2)/2 };
         std::vector<std::vector<double>> recouple_lmn = {{1},{},{} };
-            
+
         for (int J2p=J2p_min[1]; J2p<=J2p_max[1]; J2p++)
-           recouple_lmn[1].push_back( sqrt( (2*J2+1)*(2*J2p+1)) * Z.modelspace->GetSixJ(jl,jm,J2,jn,Jtot,J2p) );
+          recouple_lmn[1].push_back( sqrt( (2*J2+1)*(2*J2p+1)) * Z.modelspace->GetSixJ(jl,jm,J2,jn,Jtot,J2p) );
 
         for (int J2p=J2p_min[2]; J2p<=J2p_max[2]; J2p++)
-             recouple_lmn[2].push_back( -Z.modelspace->phase((om.j2+on.j2)/2+J2+J2p)*sqrt( (2*J2+1)*(2*J2p+1)) * Z.modelspace->GetSixJ(jm,jl,J2,jn,Jtot,J2p) );
+          recouple_lmn[2].push_back( -Z.modelspace->phase((om.j2+on.j2)/2+J2+J2p)*sqrt( (2*J2+1)*(2*J2p+1)) * Z.modelspace->GetSixJ(jm,jl,J2,jn,Jtot,J2p) );
 
 
         double z_ijklmn = 0;
@@ -6971,36 +7195,36 @@ void comm233_phss( const Operator& X, const Operator& Y, Operator& Z )
 
                 for ( int Jph=Jph_min; Jph<=Jph_max; Jph++)
                 {
-                   size_t ch_ph = Z.modelspace->GetTwoBodyChannelIndex(Jph,parity_ph,Tz_ph);
-                   TwoBodyChannel_CC& tbc_CC = Z.modelspace->GetTwoBodyChannel_CC(ch_ph);
-                   size_t nkets_CC = tbc_CC.GetNumberKets();
-
-
-                   // we only compute one ordering of the right side of Zbar, but we can get the other ordering by symmetry
-                   // so we check here which ordering we need, and pick up the corresponding phase factor if needed.
-                   size_t index_36 = tbc_CC.GetLocalIndex(I3,I6);
-                   size_t key_4512 = hash_key_lmij(std::min(I4,I5),std::max(I4,I5),(size_t)J2p,std::min(I1,I2),std::max(I1,I2),(size_t)J1p);
-                   int phase_45 = (I4>I5) ? -Z.modelspace->phase( (o4.j2+o5.j2)/2 - J2p) : 1;
-                   int phase_12 = (I1>I2) ? -Z.modelspace->phase( (o1.j2+o2.j2)/2 - J1p) : 1;
-                   int flip_phase = 1;
-
-                   // if any of these are true, we're looking for the not-stored ordering
-                   if ( (std::min(I1,I2) > std::min(I4,I5)) or ((std::min(I1,I2)==std::min(I4,I5)) and (std::max(I1,I2) > std::max(I4,I5)))
-                        or ((std::min(I1,I2)==std::min(I4,I5)) and (std::max(I1,I2)==std::max(I4,I5)) and (J1p>J2p)) )
-                   {
-                     index_36 = tbc_CC.GetLocalIndex(I6,I3);
-                     key_4512 = hash_key_lmij(std::min(I1,I2),std::max(I1,I2),(size_t)J1p,std::min(I4,I5),std::max(I4,I5),(size_t)J2p);
-                     flip_phase = Z.modelspace->phase( (o3.j2-o6.j2)/2 );
-                   }
-                   size_t index_4512 = ph_kets3_lookup[ch_ph].at(key_4512);
-
-                   // < 36` Jph | Z | 45 J2p  (12 J1p)` ; Jph >
-                   double z_364512 =  flip_phase * phase_45*phase_12 * Z3_ph[ch_ph](index_36,index_4512);
-
-                   double sixj_ph = Z.modelspace->GetSixJ(J1p,j3,Jtot,  j6,J2p,Jph);
-                   int phase_ph = -Z.modelspace->phase( (twoJ +o3.j2)/2);
-                   z_123456 -=  phase_ph * (2*Jph+1) * sixj_ph * z_364512;
-                 }// for Jph
+                  size_t ch_ph = Z.modelspace->GetTwoBodyChannelIndex(Jph,parity_ph,Tz_ph);
+                  TwoBodyChannel_CC& tbc_CC = Z.modelspace->GetTwoBodyChannel_CC(ch_ph);
+                  size_t nkets_CC = tbc_CC.GetNumberKets();
+
+
+                  // we only compute one ordering of the right side of Zbar, but we can get the other ordering by symmetry
+                  // so we check here which ordering we need, and pick up the corresponding phase factor if needed.
+                  size_t index_36 = tbc_CC.GetLocalIndex(I3,I6);
+                  size_t key_4512 = hash_key_lmij(std::min(I4,I5),std::max(I4,I5),(size_t)J2p,std::min(I1,I2),std::max(I1,I2),(size_t)J1p);
+                  int phase_45 = (I4>I5) ? -Z.modelspace->phase( (o4.j2+o5.j2)/2 - J2p) : 1;
+                  int phase_12 = (I1>I2) ? -Z.modelspace->phase( (o1.j2+o2.j2)/2 - J1p) : 1;
+                  int flip_phase = 1;
+
+                  // if any of these are true, we're looking for the not-stored ordering
+                  if ( (std::min(I1,I2) > std::min(I4,I5)) or ((std::min(I1,I2)==std::min(I4,I5)) and (std::max(I1,I2) > std::max(I4,I5)))
+                      or ((std::min(I1,I2)==std::min(I4,I5)) and (std::max(I1,I2)==std::max(I4,I5)) and (J1p>J2p)) )
+                  {
+                    index_36 = tbc_CC.GetLocalIndex(I6,I3);
+                    key_4512 = hash_key_lmij(std::min(I1,I2),std::max(I1,I2),(size_t)J1p,std::min(I4,I5),std::max(I4,I5),(size_t)J2p);
+                    flip_phase = Z.modelspace->phase( (o3.j2-o6.j2)/2 );
+                  }
+                  size_t index_4512 = ph_kets3_lookup[ch_ph].at(key_4512);
+
+                  // < 36` Jph | Z | 45 J2p  (12 J1p)` ; Jph >
+                  double z_364512 =  flip_phase * phase_45*phase_12 * Z3_ph[ch_ph](index_36,index_4512);
+
+                  double sixj_ph = Z.modelspace->GetSixJ(J1p,j3,Jtot,  j6,J2p,Jph);
+                  int phase_ph = -Z.modelspace->phase( (twoJ +o3.j2)/2);
+                  z_123456 -=  phase_ph * (2*Jph+1) * sixj_ph * z_364512;
+                }// for Jph
 
                 // include the recoupling coefficients needed for the permutations
                 z_ijklmn += rec_ijk * rec_lmn * z_123456;
@@ -7038,7 +7262,7 @@ void comm233_phss_debug( const Operator& X, const Operator& Y, Operator& Z )
 
 
   size_t nch3 = Z.modelspace->GetNumberThreeBodyChannels();
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
   for (size_t ch3=0; ch3<nch3; ch3++)
   {
     auto& Tbc = Z.modelspace->GetThreeBodyChannel(ch3);
@@ -7092,352 +7316,352 @@ void comm233_phss_debug( const Operator& X, const Operator& Y, Operator& Z )
 
         for ( auto& a : Z.modelspace->all_orbits )
         {
-         Orbit& oa = Z.modelspace->GetOrbit(a);
-         double ja = 0.5 * oa.j2;
-         double occnat_a = oa.occ_nat;
-         double d_ea = std::abs( 2*oa.n + oa.l - e_fermi[oa.tz2]);
-         bool keep_ija = ( (occnat_i*(1-occnat_i) * occnat_j*(1-occnat_j) * occnat_a*(1-occnat_a) ) >= Z.modelspace->GetOccNat3Cut() ) ;
-         bool keep_kja = ( (occnat_k*(1-occnat_k) * occnat_j*(1-occnat_j) * occnat_a*(1-occnat_a) ) >= Z.modelspace->GetOccNat3Cut() ) ;
-         bool keep_ika = ( (occnat_i*(1-occnat_i) * occnat_k*(1-occnat_k) * occnat_a*(1-occnat_a) ) >= Z.modelspace->GetOccNat3Cut() ) ;
-         keep_ija = keep_ija and (d_ei+d_ej+d_ea <= Z.modelspace->dE3max );
-         keep_kja = keep_kja and (d_ek+d_ej+d_ea <= Z.modelspace->dE3max );
-         keep_ika = keep_ika and (d_ei+d_ek+d_ea <= Z.modelspace->dE3max );
-         if (not ( keep_ija or keep_kja or keep_ika) ) continue;
-
-         for ( auto& b : Z.modelspace->all_orbits )
-         {
-//           if (b<a) continue;
-           Orbit& ob = Z.modelspace->GetOrbit(b);
-           double jb = 0.5 * ob.j2;
-           double occnat_b = ob.occ_nat;
-           double d_eb = std::abs( 2*ob.n + ob.l - e_fermi[ob.tz2]);
-           double occ_factor = oa.occ-ob.occ;
-           if (std::abs(occ_factor)<1e-6) continue;
-
-           bool keep_lmb = ( (occnat_l*(1-occnat_l) * occnat_m*(1-occnat_m) * occnat_b*(1-occnat_b) ) >= Z.modelspace->GetOccNat3Cut() ) ;
-           bool keep_lnb = ( (occnat_l*(1-occnat_l) * occnat_n*(1-occnat_n) * occnat_b*(1-occnat_b) ) >= Z.modelspace->GetOccNat3Cut() ) ;
-           bool keep_nmb = ( (occnat_n*(1-occnat_n) * occnat_m*(1-occnat_m) * occnat_b*(1-occnat_b) ) >= Z.modelspace->GetOccNat3Cut() ) ;
-           keep_lmb = keep_lmb and (d_el+d_em+d_eb <= Z.modelspace->dE3max );
-           keep_lnb = keep_lnb and (d_el+d_en+d_eb <= Z.modelspace->dE3max );
-           keep_nmb = keep_nmb and (d_en+d_em+d_eb <= Z.modelspace->dE3max );
-           if (not ( keep_lmb or keep_lnb or keep_nmb) ) continue;
-
-
-           // Direct term i.e. Z1
-           if ( (ob.l+ok.l+oa.l+on.l)%2==0   and (  (ob.tz2+ok.tz2)==(oa.tz2+on.tz2) ) and keep_ija and keep_lmb )
-           {
-            int Jx_min = std::max( std::abs(ob.j2-ok.j2),std::abs(oa.j2-on.j2) )/2;
-            int Jx_max = std::min( ob.j2+ok.j2 ,  oa.j2+on.j2 )/2;
-            int twoJJ_min = std::max( std::abs(oa.j2-2*J1) , std::abs(ob.j2-2*J2) );
-            int twoJJ_max = std::min( oa.j2+2*J1 ,  ob.j2+2*J2 );
-            int phase = -Z.modelspace->phase((ok.j2+on.j2)/2+J1+J2);
-            for (int twoJJ=twoJJ_min; twoJJ<=twoJJ_max; twoJJ+=2)
-            {
-              double xijalmb = X3.GetME_pn( J1,J2,twoJJ, i,j,a,l,m,b);
-              double yijalmb = Y3.GetME_pn( J1,J2,twoJJ, i,j,a,l,m,b);
-              double JJtot = 0.5 * twoJJ;
-              for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
-              {
-                double xbkan = X2.GetTBME_J(Jx, b,k,a,n);
-                double ybkan = Y2.GetTBME_J(Jx, b,k,a,n);
-                double hats = (twoJJ+1)*(2*Jx+1);
-                double ninej = Z.modelspace->GetNineJ(jb,JJtot,J2,  jk,J1,Jtot, Jx,ja,jn);
-                z_ijklmn -= occ_factor * hats * phase * ninej * (xbkan * yijalmb - ybkan*xijalmb);
-              }// for Jx
-            }// for twoJ
-           }// Z1 block
-
-
-           // Z2  ~ Pik Z1     Xbian Ykjalmb
-           if ( (ob.l+oi.l+oa.l+on.l)%2==0   and (  (ob.tz2+oi.tz2)==(oa.tz2+on.tz2) ) and keep_kja and keep_lmb)
-           {
-            int J1p_min = std::abs(ok.j2-oj.j2)/2;
-            int J1p_max = ( ok.j2+oj.j2 )/2;
-            int Jx_min = std::max( std::abs(ob.j2-oi.j2),std::abs(oa.j2-on.j2) )/2;
-            int Jx_max = std::min( ob.j2+oi.j2 ,  oa.j2+on.j2 )/2;
-            for (int J1p=J1p_min; J1p<=J1p_max; J1p++)
-            {
-              double sixj = Z.modelspace->GetSixJ(ji,jj,J1,jk,Jtot,J1p);
-              if (std::abs(sixj)<1e-6) continue;
-              int twoJJ_min = std::max( std::abs(ob.j2-2*J2),std::abs(oa.j2-2*J1p) );
-              int twoJJ_max = std::min( ob.j2+2*J2 ,  oa.j2+2*J1p );
-              int phase = Z.modelspace->phase((oi.j2+on.j2)/2+J1p+J2);
-              for (int twoJJ=twoJJ_min; twoJJ<=twoJJ_max; twoJJ+=2)
-              {
-                double xkjalmb = X3.GetME_pn( J1p,J2,twoJJ, k,j,a,l,m,b);
-                double ykjalmb = Y3.GetME_pn( J1p,J2,twoJJ, k,j,a,l,m,b);
-                double JJtot = 0.5 * twoJJ;
-                for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
-                {
-                  double xbian = X2.GetTBME_J(Jx, b,i,a,n);
-                  double ybian = Y2.GetTBME_J(Jx, b,i,a,n);
-                  double hats = (twoJJ+1)*(2*Jx+1) * sqrt( (2*J1+1)*(2*J1p+1) );
-                  double ninej = Z.modelspace->GetNineJ(jb,JJtot,J2,  ji,J1p,Jtot, Jx,ja,jn);
-                  z_ijklmn += occ_factor * hats * phase * sixj * ninej * (xbian*ykjalmb - ybian*xkjalmb);
-                }// for Jx
-              }// for twoJ
-            }// for J1p
-           }// Z2 block
+          Orbit& oa = Z.modelspace->GetOrbit(a);
+          double ja = 0.5 * oa.j2;
+          double occnat_a = oa.occ_nat;
+          double d_ea = std::abs( 2*oa.n + oa.l - e_fermi[oa.tz2]);
+          bool keep_ija = ( (occnat_i*(1-occnat_i) * occnat_j*(1-occnat_j) * occnat_a*(1-occnat_a) ) >= Z.modelspace->GetOccNat3Cut() ) ;
+          bool keep_kja = ( (occnat_k*(1-occnat_k) * occnat_j*(1-occnat_j) * occnat_a*(1-occnat_a) ) >= Z.modelspace->GetOccNat3Cut() ) ;
+          bool keep_ika = ( (occnat_i*(1-occnat_i) * occnat_k*(1-occnat_k) * occnat_a*(1-occnat_a) ) >= Z.modelspace->GetOccNat3Cut() ) ;
+          keep_ija = keep_ija and (d_ei+d_ej+d_ea <= Z.modelspace->dE3max );
+          keep_kja = keep_kja and (d_ek+d_ej+d_ea <= Z.modelspace->dE3max );
+          keep_ika = keep_ika and (d_ei+d_ek+d_ea <= Z.modelspace->dE3max );
+          if (not ( keep_ija or keep_kja or keep_ika) ) continue;
+
+          for ( auto& b : Z.modelspace->all_orbits )
+          {
+            //           if (b<a) continue;
+            Orbit& ob = Z.modelspace->GetOrbit(b);
+            double jb = 0.5 * ob.j2;
+            double occnat_b = ob.occ_nat;
+            double d_eb = std::abs( 2*ob.n + ob.l - e_fermi[ob.tz2]);
+            double occ_factor = oa.occ-ob.occ;
+            if (std::abs(occ_factor)<1e-6) continue;
 
+            bool keep_lmb = ( (occnat_l*(1-occnat_l) * occnat_m*(1-occnat_m) * occnat_b*(1-occnat_b) ) >= Z.modelspace->GetOccNat3Cut() ) ;
+            bool keep_lnb = ( (occnat_l*(1-occnat_l) * occnat_n*(1-occnat_n) * occnat_b*(1-occnat_b) ) >= Z.modelspace->GetOccNat3Cut() ) ;
+            bool keep_nmb = ( (occnat_n*(1-occnat_n) * occnat_m*(1-occnat_m) * occnat_b*(1-occnat_b) ) >= Z.modelspace->GetOccNat3Cut() ) ;
+            keep_lmb = keep_lmb and (d_el+d_em+d_eb <= Z.modelspace->dE3max );
+            keep_lnb = keep_lnb and (d_el+d_en+d_eb <= Z.modelspace->dE3max );
+            keep_nmb = keep_nmb and (d_en+d_em+d_eb <= Z.modelspace->dE3max );
+            if (not ( keep_lmb or keep_lnb or keep_nmb) ) continue;
 
 
-           // Z3  ~ Pjk Z1      Xbjan Yikalmb
-           if ( (ob.l+oj.l+oa.l+on.l)%2==0   and (  (ob.tz2+oj.tz2)==(oa.tz2+on.tz2) ) and keep_ika and keep_lmb)
-           {
-            int J1p_min = std::abs(oi.j2-ok.j2)/2;
-            int J1p_max = ( oi.j2+ok.j2 )/2;
-            int Jx_min = std::max( std::abs(ob.j2-oj.j2),std::abs(oa.j2-on.j2) )/2;
-            int Jx_max = std::min( ob.j2+oj.j2 ,  oa.j2+on.j2 )/2;
-            for (int J1p=J1p_min; J1p<=J1p_max; J1p++)
+            // Direct term i.e. Z1
+            if ( (ob.l+ok.l+oa.l+on.l)%2==0   and (  (ob.tz2+ok.tz2)==(oa.tz2+on.tz2) ) and keep_ija and keep_lmb )
             {
-              double sixj = Z.modelspace->GetSixJ(jj,ji,J1,jk,Jtot,J1p);
-              if (std::abs(sixj)<1e-6) continue;
-              int twoJJ_min = std::max( std::abs(ob.j2-2*J2),std::abs(oa.j2-2*J1p) );
-              int twoJJ_max = std::min( ob.j2+2*J2 ,  oa.j2+2*J1p );
-              int phase = Z.modelspace->phase((ok.j2+on.j2)/2+J1+J2);
+              int Jx_min = std::max( std::abs(ob.j2-ok.j2),std::abs(oa.j2-on.j2) )/2;
+              int Jx_max = std::min( ob.j2+ok.j2 ,  oa.j2+on.j2 )/2;
+              int twoJJ_min = std::max( std::abs(oa.j2-2*J1) , std::abs(ob.j2-2*J2) );
+              int twoJJ_max = std::min( oa.j2+2*J1 ,  ob.j2+2*J2 );
+              int phase = -Z.modelspace->phase((ok.j2+on.j2)/2+J1+J2);
               for (int twoJJ=twoJJ_min; twoJJ<=twoJJ_max; twoJJ+=2)
               {
-                double xikalmb = X3.GetME_pn( J1p,J2,twoJJ, i,k,a,l,m,b);
-                double yikalmb = Y3.GetME_pn( J1p,J2,twoJJ, i,k,a,l,m,b);
+                double xijalmb = X3.GetME_pn( J1,J2,twoJJ, i,j,a,l,m,b);
+                double yijalmb = Y3.GetME_pn( J1,J2,twoJJ, i,j,a,l,m,b);
                 double JJtot = 0.5 * twoJJ;
                 for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
                 {
-                  double xbjan = X2.GetTBME_J(Jx, b,j,a,n);
-                  double ybjan = Y2.GetTBME_J(Jx, b,j,a,n);
-                  double hats = (twoJJ+1)*(2*Jx+1) * sqrt( (2*J1+1)*(2*J1p+1));
-                  double ninej = Z.modelspace->GetNineJ(jb,JJtot,J2,  jj,J1p,Jtot, Jx,ja,jn);
-                  z_ijklmn += occ_factor * hats * phase * sixj * ninej * (xbjan*yikalmb - ybjan*xikalmb);
+                  double xbkan = X2.GetTBME_J(Jx, b,k,a,n);
+                  double ybkan = Y2.GetTBME_J(Jx, b,k,a,n);
+                  double hats = (twoJJ+1)*(2*Jx+1);
+                  double ninej = Z.modelspace->GetNineJ(jb,JJtot,J2,  jk,J1,Jtot, Jx,ja,jn);
+                  z_ijklmn -= occ_factor * hats * phase * ninej * (xbkan * yijalmb - ybkan*xijalmb);
                 }// for Jx
               }// for twoJ
-            }// for J1p
-           }// Z3 block
-
+            }// Z1 block
 
 
-
-           // Z4  ~ Pln Z1    Xbkal Y ijanmb
-           if ( (ob.l+ok.l+oa.l+ol.l)%2==0   and (  (ob.tz2+ok.tz2)==(oa.tz2+ol.tz2) ) and keep_ija and keep_nmb)
-           {
-            int J2p_min = std::abs(on.j2-om.j2)/2;
-            int J2p_max = ( on.j2+om.j2 )/2;
-            int Jx_min = std::max( std::abs(ob.j2-ok.j2),std::abs(oa.j2-ol.j2) )/2;
-            int Jx_max = std::min( ob.j2+ok.j2 ,  oa.j2+ol.j2 )/2;
-            for (int J2p=J2p_min; J2p<=J2p_max; J2p++)
+            // Z2  ~ Pik Z1     Xbian Ykjalmb
+            if ( (ob.l+oi.l+oa.l+on.l)%2==0   and (  (ob.tz2+oi.tz2)==(oa.tz2+on.tz2) ) and keep_kja and keep_lmb)
             {
-              double sixj = Z.modelspace->GetSixJ(jl,jm,J2,jn,Jtot,J2p);
-              if (std::abs(sixj)<1e-6) continue;
-              int twoJJ_min = std::max( std::abs(ob.j2-2*J2p),std::abs(oa.j2-2*J1) );
-              int twoJJ_max = std::min( ob.j2+2*J2p ,  oa.j2+2*J1 );
-              int phase = Z.modelspace->phase((ok.j2+ol.j2)/2+J1+J2p);
-              for (int twoJJ=twoJJ_min; twoJJ<=twoJJ_max; twoJJ+=2)
+              int J1p_min = std::abs(ok.j2-oj.j2)/2;
+              int J1p_max = ( ok.j2+oj.j2 )/2;
+              int Jx_min = std::max( std::abs(ob.j2-oi.j2),std::abs(oa.j2-on.j2) )/2;
+              int Jx_max = std::min( ob.j2+oi.j2 ,  oa.j2+on.j2 )/2;
+              for (int J1p=J1p_min; J1p<=J1p_max; J1p++)
               {
-                double xijanmb = X3.GetME_pn( J1,J2p,twoJJ, i,j,a,n,m,b);
-                double yijanmb = Y3.GetME_pn( J1,J2p,twoJJ, i,j,a,n,m,b);
-                double JJtot = 0.5 * twoJJ;
-                for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
+                double sixj = Z.modelspace->GetSixJ(ji,jj,J1,jk,Jtot,J1p);
+                if (std::abs(sixj)<1e-6) continue;
+                int twoJJ_min = std::max( std::abs(ob.j2-2*J2),std::abs(oa.j2-2*J1p) );
+                int twoJJ_max = std::min( ob.j2+2*J2 ,  oa.j2+2*J1p );
+                int phase = Z.modelspace->phase((oi.j2+on.j2)/2+J1p+J2);
+                for (int twoJJ=twoJJ_min; twoJJ<=twoJJ_max; twoJJ+=2)
                 {
-                  double xbkal = X2.GetTBME_J(Jx, b,k,a,l);
-                  double ybkal = Y2.GetTBME_J(Jx, b,k,a,l);
-                  double hats = (twoJJ+1)*(2*Jx+1)*sqrt((2*J2+1)*(2*J2p+1));
-                  double ninej = Z.modelspace->GetNineJ(jb,JJtot,J2p,  jk,J1,Jtot, Jx,ja,jl);
-                  z_ijklmn += occ_factor * hats * phase * sixj * ninej * (xbkal*yijanmb - ybkal*xijanmb);
-                }// for Jx
-              }// for twoJ
-            }// for J1p
-           }// Z4 block
+                  double xkjalmb = X3.GetME_pn( J1p,J2,twoJJ, k,j,a,l,m,b);
+                  double ykjalmb = Y3.GetME_pn( J1p,J2,twoJJ, k,j,a,l,m,b);
+                  double JJtot = 0.5 * twoJJ;
+                  for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
+                  {
+                    double xbian = X2.GetTBME_J(Jx, b,i,a,n);
+                    double ybian = Y2.GetTBME_J(Jx, b,i,a,n);
+                    double hats = (twoJJ+1)*(2*Jx+1) * sqrt( (2*J1+1)*(2*J1p+1) );
+                    double ninej = Z.modelspace->GetNineJ(jb,JJtot,J2,  ji,J1p,Jtot, Jx,ja,jn);
+                    z_ijklmn += occ_factor * hats * phase * sixj * ninej * (xbian*ykjalmb - ybian*xkjalmb);
+                  }// for Jx
+                }// for twoJ
+              }// for J1p
+            }// Z2 block
 
 
 
-           // Z5  ~ Pmn Z1    Xbkam Yijalnb
-           if ( (ob.l+ok.l+oa.l+om.l)%2==0   and (  (ob.tz2+ok.tz2)==(oa.tz2+om.tz2) ) and keep_ija and keep_lnb)
-           {
-            int J2p_min = std::abs(ol.j2-on.j2)/2;
-            int J2p_max = ( ol.j2+on.j2 )/2;
-            int Jx_min = std::max( std::abs(ob.j2-ok.j2),std::abs(oa.j2-om.j2) )/2;
-            int Jx_max = std::min( ob.j2+ok.j2 ,  oa.j2+om.j2 )/2;
-            for (int J2p=J2p_min; J2p<=J2p_max; J2p++)
+            // Z3  ~ Pjk Z1      Xbjan Yikalmb
+            if ( (ob.l+oj.l+oa.l+on.l)%2==0   and (  (ob.tz2+oj.tz2)==(oa.tz2+on.tz2) ) and keep_ika and keep_lmb)
             {
-              double sixj = Z.modelspace->GetSixJ(jm,jl,J2,jn,Jtot,J2p);
-              if (std::abs(sixj)<1e-6) continue;
-              int twoJJ_min = std::max( std::abs(ob.j2-2*J2p),std::abs(oa.j2-2*J1) );
-              int twoJJ_max = std::min( ob.j2+2*J2p ,  oa.j2+2*J1 );
-              int phase = Z.modelspace->phase((ok.j2+on.j2)/2+J1+J2);
-              for (int twoJJ=twoJJ_min; twoJJ<=twoJJ_max; twoJJ+=2)
+              int J1p_min = std::abs(oi.j2-ok.j2)/2;
+              int J1p_max = ( oi.j2+ok.j2 )/2;
+              int Jx_min = std::max( std::abs(ob.j2-oj.j2),std::abs(oa.j2-on.j2) )/2;
+              int Jx_max = std::min( ob.j2+oj.j2 ,  oa.j2+on.j2 )/2;
+              for (int J1p=J1p_min; J1p<=J1p_max; J1p++)
               {
-                double xijalnb = X3.GetME_pn( J1,J2p,twoJJ, i,j,a,l,n,b);
-                double yijalnb = Y3.GetME_pn( J1,J2p,twoJJ, i,j,a,l,n,b);
-                double JJtot = 0.5 * twoJJ;
-                for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
+                double sixj = Z.modelspace->GetSixJ(jj,ji,J1,jk,Jtot,J1p);
+                if (std::abs(sixj)<1e-6) continue;
+                int twoJJ_min = std::max( std::abs(ob.j2-2*J2),std::abs(oa.j2-2*J1p) );
+                int twoJJ_max = std::min( ob.j2+2*J2 ,  oa.j2+2*J1p );
+                int phase = Z.modelspace->phase((ok.j2+on.j2)/2+J1+J2);
+                for (int twoJJ=twoJJ_min; twoJJ<=twoJJ_max; twoJJ+=2)
                 {
-                  double xbkam = X2.GetTBME_J(Jx, b,k,a,m);
-                  double ybkam = Y2.GetTBME_J(Jx, b,k,a,m);
-                  double hats = (twoJJ+1)*(2*Jx+1)*sqrt((2*J2+1)*(2*J2p+1));
-                  double ninej = Z.modelspace->GetNineJ(jb,JJtot,J2p,  jk,J1,Jtot, Jx,ja,jm);
-                  z_ijklmn += occ_factor * hats * phase * sixj * ninej * (xbkam*yijalnb - ybkam*xijalnb);
-                }// for Jx
-              }// for twoJ
-            }// for J1p
-           }// Z5 block
+                  double xikalmb = X3.GetME_pn( J1p,J2,twoJJ, i,k,a,l,m,b);
+                  double yikalmb = Y3.GetME_pn( J1p,J2,twoJJ, i,k,a,l,m,b);
+                  double JJtot = 0.5 * twoJJ;
+                  for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
+                  {
+                    double xbjan = X2.GetTBME_J(Jx, b,j,a,n);
+                    double ybjan = Y2.GetTBME_J(Jx, b,j,a,n);
+                    double hats = (twoJJ+1)*(2*Jx+1) * sqrt( (2*J1+1)*(2*J1p+1));
+                    double ninej = Z.modelspace->GetNineJ(jb,JJtot,J2,  jj,J1p,Jtot, Jx,ja,jn);
+                    z_ijklmn += occ_factor * hats * phase * sixj * ninej * (xbjan*yikalmb - ybjan*xikalmb);
+                  }// for Jx
+                }// for twoJ
+              }// for J1p
+            }// Z3 block
+
 
 
 
-           // Z6  ~ Pik Pln Z1     Xbial Ykjanmb
-           if ( (ob.l+oi.l+oa.l+ol.l)%2==0   and (  (ob.tz2+oi.tz2)==(oa.tz2+ol.tz2) ) and keep_kja and keep_nmb)
-           {
-            int J1p_min = std::abs(ok.j2-oj.j2)/2;
-            int J1p_max = ( ok.j2+oj.j2 )/2;
-            int J2p_min = std::abs(on.j2-om.j2)/2;
-            int J2p_max = ( on.j2+om.j2 )/2;
-            int Jx_min = std::max( std::abs(ob.j2-oi.j2),std::abs(oa.j2-ol.j2) )/2;
-            int Jx_max = std::min( ob.j2+oi.j2 ,  oa.j2+ol.j2 )/2;
-            for (int J1p=J1p_min; J1p<=J1p_max; J1p++)
+            // Z4  ~ Pln Z1    Xbkal Y ijanmb
+            if ( (ob.l+ok.l+oa.l+ol.l)%2==0   and (  (ob.tz2+ok.tz2)==(oa.tz2+ol.tz2) ) and keep_ija and keep_nmb)
             {
-              double sixj1 = Z.modelspace->GetSixJ(ji,jj,J1,jk,Jtot,J1p);
-              if (std::abs(sixj1)<1e-6) continue;
+              int J2p_min = std::abs(on.j2-om.j2)/2;
+              int J2p_max = ( on.j2+om.j2 )/2;
+              int Jx_min = std::max( std::abs(ob.j2-ok.j2),std::abs(oa.j2-ol.j2) )/2;
+              int Jx_max = std::min( ob.j2+ok.j2 ,  oa.j2+ol.j2 )/2;
               for (int J2p=J2p_min; J2p<=J2p_max; J2p++)
               {
-                double sixj2 = Z.modelspace->GetSixJ(jl,jm,J2,jn,Jtot,J2p);
-                if (std::abs(sixj2)<1e-6) continue;
-                int twoJJ_min = std::max( std::abs(ob.j2-2*J2p),std::abs(oa.j2-2*J1p) );
-                int twoJJ_max = std::min( ob.j2+2*J2p ,  oa.j2+2*J1p );
-                int phase = -Z.modelspace->phase((oi.j2+ol.j2)/2+J1p+J2p);
+                double sixj = Z.modelspace->GetSixJ(jl,jm,J2,jn,Jtot,J2p);
+                if (std::abs(sixj)<1e-6) continue;
+                int twoJJ_min = std::max( std::abs(ob.j2-2*J2p),std::abs(oa.j2-2*J1) );
+                int twoJJ_max = std::min( ob.j2+2*J2p ,  oa.j2+2*J1 );
+                int phase = Z.modelspace->phase((ok.j2+ol.j2)/2+J1+J2p);
                 for (int twoJJ=twoJJ_min; twoJJ<=twoJJ_max; twoJJ+=2)
                 {
-                  double xkjanmb = X3.GetME_pn( J1p,J2p,twoJJ, k,j,a,n,m,b);
-                  double ykjanmb = Y3.GetME_pn( J1p,J2p,twoJJ, k,j,a,n,m,b);
+                  double xijanmb = X3.GetME_pn( J1,J2p,twoJJ, i,j,a,n,m,b);
+                  double yijanmb = Y3.GetME_pn( J1,J2p,twoJJ, i,j,a,n,m,b);
                   double JJtot = 0.5 * twoJJ;
                   for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
                   {
-                    double xbial = X2.GetTBME_J(Jx, b,i,a,l);
-                    double ybial = Y2.GetTBME_J(Jx, b,i,a,l);
-                    double hats = (twoJJ+1)*(2*Jx+1) * sqrt( (2*J1+1)*(2*J1p+1)*(2*J2+1)*(2*J2p+1));
-                    double ninej = Z.modelspace->GetNineJ(jb,JJtot,J2p,  ji,J1p,Jtot, Jx,ja,jl);
-                    z_ijklmn -= occ_factor * hats * phase * sixj1 * sixj2 * ninej * (xbial*ykjanmb - ybial*xkjanmb);
+                    double xbkal = X2.GetTBME_J(Jx, b,k,a,l);
+                    double ybkal = Y2.GetTBME_J(Jx, b,k,a,l);
+                    double hats = (twoJJ+1)*(2*Jx+1)*sqrt((2*J2+1)*(2*J2p+1));
+                    double ninej = Z.modelspace->GetNineJ(jb,JJtot,J2p,  jk,J1,Jtot, Jx,ja,jl);
+                    z_ijklmn += occ_factor * hats * phase * sixj * ninej * (xbkal*yijanmb - ybkal*xijanmb);
                   }// for Jx
                 }// for twoJ
-              }// for J2p
-            }// for J1p
-           }// Z6 block
-
-
-           // Z7  ~ Pjk Pln Z1     Xbjal Yikanmb
-           if ( (ob.l+oj.l+oa.l+ol.l)%2==0   and (  (ob.tz2+oj.tz2)==(oa.tz2+ol.tz2) )  and keep_ika and keep_nmb)
-           {
-            int J1p_min = std::abs(oi.j2-ok.j2)/2;
-            int J1p_max = ( oi.j2+ok.j2 )/2;
-            int J2p_min = std::abs(on.j2-om.j2)/2;
-            int J2p_max = ( on.j2+om.j2 )/2;
-            int Jx_min = std::max( std::abs(ob.j2-oj.j2),std::abs(oa.j2-ol.j2) )/2;
-            int Jx_max = std::min( ob.j2+oj.j2 ,  oa.j2+ol.j2 )/2;
-            for (int J1p=J1p_min; J1p<=J1p_max; J1p++)
+              }// for J1p
+            }// Z4 block
+
+
+
+            // Z5  ~ Pmn Z1    Xbkam Yijalnb
+            if ( (ob.l+ok.l+oa.l+om.l)%2==0   and (  (ob.tz2+ok.tz2)==(oa.tz2+om.tz2) ) and keep_ija and keep_lnb)
             {
-              double sixj1 = Z.modelspace->GetSixJ(jj,ji,J1,jk,Jtot,J1p);
-              if (std::abs(sixj1)<1e-6) continue;
+              int J2p_min = std::abs(ol.j2-on.j2)/2;
+              int J2p_max = ( ol.j2+on.j2 )/2;
+              int Jx_min = std::max( std::abs(ob.j2-ok.j2),std::abs(oa.j2-om.j2) )/2;
+              int Jx_max = std::min( ob.j2+ok.j2 ,  oa.j2+om.j2 )/2;
               for (int J2p=J2p_min; J2p<=J2p_max; J2p++)
               {
-                double sixj2 = Z.modelspace->GetSixJ(jl,jm,J2,jn,Jtot,J2p);
-                if (std::abs(sixj2)<1e-6) continue;
-                int twoJJ_min = std::max( std::abs(ob.j2-2*J2p),std::abs(oa.j2-2*J1p) );
-                int twoJJ_max = std::min( ob.j2+2*J2p ,  oa.j2+2*J1p );
-                int phase = -Z.modelspace->phase((ok.j2+ol.j2)/2+J1+J2p);
+                double sixj = Z.modelspace->GetSixJ(jm,jl,J2,jn,Jtot,J2p);
+                if (std::abs(sixj)<1e-6) continue;
+                int twoJJ_min = std::max( std::abs(ob.j2-2*J2p),std::abs(oa.j2-2*J1) );
+                int twoJJ_max = std::min( ob.j2+2*J2p ,  oa.j2+2*J1 );
+                int phase = Z.modelspace->phase((ok.j2+on.j2)/2+J1+J2);
                 for (int twoJJ=twoJJ_min; twoJJ<=twoJJ_max; twoJJ+=2)
                 {
-                  double xikanmb = X3.GetME_pn( J1p,J2p,twoJJ, i,k,a,n,m,b);
-                  double yikanmb = Y3.GetME_pn( J1p,J2p,twoJJ, i,k,a,n,m,b);
+                  double xijalnb = X3.GetME_pn( J1,J2p,twoJJ, i,j,a,l,n,b);
+                  double yijalnb = Y3.GetME_pn( J1,J2p,twoJJ, i,j,a,l,n,b);
                   double JJtot = 0.5 * twoJJ;
                   for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
                   {
-                    double xbjal = X2.GetTBME_J(Jx, b,j,a,l);
-                    double ybjal = Y2.GetTBME_J(Jx, b,j,a,l);
-                    double hats = (twoJJ+1)*(2*Jx+1) * sqrt( (2*J1+1)*(2*J1p+1)*(2*J2+1)*(2*J2p+1));
-                    double ninej = Z.modelspace->GetNineJ(jb,JJtot,J2p,  jj,J1p,Jtot, Jx,ja,jl);
-                    z_ijklmn -= occ_factor * hats * phase * sixj1 * sixj2 * ninej * (xbjal*yikanmb - ybjal*xikanmb);
+                    double xbkam = X2.GetTBME_J(Jx, b,k,a,m);
+                    double ybkam = Y2.GetTBME_J(Jx, b,k,a,m);
+                    double hats = (twoJJ+1)*(2*Jx+1)*sqrt((2*J2+1)*(2*J2p+1));
+                    double ninej = Z.modelspace->GetNineJ(jb,JJtot,J2p,  jk,J1,Jtot, Jx,ja,jm);
+                    z_ijklmn += occ_factor * hats * phase * sixj * ninej * (xbkam*yijalnb - ybkam*xijalnb);
                   }// for Jx
                 }// for twoJ
-              }// for J2p
-            }// for J1p
-           }// Z7 block
+              }// for J1p
+            }// Z5 block
+
+
+
+            // Z6  ~ Pik Pln Z1     Xbial Ykjanmb
+            if ( (ob.l+oi.l+oa.l+ol.l)%2==0   and (  (ob.tz2+oi.tz2)==(oa.tz2+ol.tz2) ) and keep_kja and keep_nmb)
+            {
+              int J1p_min = std::abs(ok.j2-oj.j2)/2;
+              int J1p_max = ( ok.j2+oj.j2 )/2;
+              int J2p_min = std::abs(on.j2-om.j2)/2;
+              int J2p_max = ( on.j2+om.j2 )/2;
+              int Jx_min = std::max( std::abs(ob.j2-oi.j2),std::abs(oa.j2-ol.j2) )/2;
+              int Jx_max = std::min( ob.j2+oi.j2 ,  oa.j2+ol.j2 )/2;
+              for (int J1p=J1p_min; J1p<=J1p_max; J1p++)
+              {
+                double sixj1 = Z.modelspace->GetSixJ(ji,jj,J1,jk,Jtot,J1p);
+                if (std::abs(sixj1)<1e-6) continue;
+                for (int J2p=J2p_min; J2p<=J2p_max; J2p++)
+                {
+                  double sixj2 = Z.modelspace->GetSixJ(jl,jm,J2,jn,Jtot,J2p);
+                  if (std::abs(sixj2)<1e-6) continue;
+                  int twoJJ_min = std::max( std::abs(ob.j2-2*J2p),std::abs(oa.j2-2*J1p) );
+                  int twoJJ_max = std::min( ob.j2+2*J2p ,  oa.j2+2*J1p );
+                  int phase = -Z.modelspace->phase((oi.j2+ol.j2)/2+J1p+J2p);
+                  for (int twoJJ=twoJJ_min; twoJJ<=twoJJ_max; twoJJ+=2)
+                  {
+                    double xkjanmb = X3.GetME_pn( J1p,J2p,twoJJ, k,j,a,n,m,b);
+                    double ykjanmb = Y3.GetME_pn( J1p,J2p,twoJJ, k,j,a,n,m,b);
+                    double JJtot = 0.5 * twoJJ;
+                    for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
+                    {
+                      double xbial = X2.GetTBME_J(Jx, b,i,a,l);
+                      double ybial = Y2.GetTBME_J(Jx, b,i,a,l);
+                      double hats = (twoJJ+1)*(2*Jx+1) * sqrt( (2*J1+1)*(2*J1p+1)*(2*J2+1)*(2*J2p+1));
+                      double ninej = Z.modelspace->GetNineJ(jb,JJtot,J2p,  ji,J1p,Jtot, Jx,ja,jl);
+                      z_ijklmn -= occ_factor * hats * phase * sixj1 * sixj2 * ninej * (xbial*ykjanmb - ybial*xkjanmb);
+                    }// for Jx
+                  }// for twoJ
+                }// for J2p
+              }// for J1p
+            }// Z6 block
+
+
+            // Z7  ~ Pjk Pln Z1     Xbjal Yikanmb
+            if ( (ob.l+oj.l+oa.l+ol.l)%2==0   and (  (ob.tz2+oj.tz2)==(oa.tz2+ol.tz2) )  and keep_ika and keep_nmb)
+            {
+              int J1p_min = std::abs(oi.j2-ok.j2)/2;
+              int J1p_max = ( oi.j2+ok.j2 )/2;
+              int J2p_min = std::abs(on.j2-om.j2)/2;
+              int J2p_max = ( on.j2+om.j2 )/2;
+              int Jx_min = std::max( std::abs(ob.j2-oj.j2),std::abs(oa.j2-ol.j2) )/2;
+              int Jx_max = std::min( ob.j2+oj.j2 ,  oa.j2+ol.j2 )/2;
+              for (int J1p=J1p_min; J1p<=J1p_max; J1p++)
+              {
+                double sixj1 = Z.modelspace->GetSixJ(jj,ji,J1,jk,Jtot,J1p);
+                if (std::abs(sixj1)<1e-6) continue;
+                for (int J2p=J2p_min; J2p<=J2p_max; J2p++)
+                {
+                  double sixj2 = Z.modelspace->GetSixJ(jl,jm,J2,jn,Jtot,J2p);
+                  if (std::abs(sixj2)<1e-6) continue;
+                  int twoJJ_min = std::max( std::abs(ob.j2-2*J2p),std::abs(oa.j2-2*J1p) );
+                  int twoJJ_max = std::min( ob.j2+2*J2p ,  oa.j2+2*J1p );
+                  int phase = -Z.modelspace->phase((ok.j2+ol.j2)/2+J1+J2p);
+                  for (int twoJJ=twoJJ_min; twoJJ<=twoJJ_max; twoJJ+=2)
+                  {
+                    double xikanmb = X3.GetME_pn( J1p,J2p,twoJJ, i,k,a,n,m,b);
+                    double yikanmb = Y3.GetME_pn( J1p,J2p,twoJJ, i,k,a,n,m,b);
+                    double JJtot = 0.5 * twoJJ;
+                    for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
+                    {
+                      double xbjal = X2.GetTBME_J(Jx, b,j,a,l);
+                      double ybjal = Y2.GetTBME_J(Jx, b,j,a,l);
+                      double hats = (twoJJ+1)*(2*Jx+1) * sqrt( (2*J1+1)*(2*J1p+1)*(2*J2+1)*(2*J2p+1));
+                      double ninej = Z.modelspace->GetNineJ(jb,JJtot,J2p,  jj,J1p,Jtot, Jx,ja,jl);
+                      z_ijklmn -= occ_factor * hats * phase * sixj1 * sixj2 * ninej * (xbjal*yikanmb - ybjal*xikanmb);
+                    }// for Jx
+                  }// for twoJ
+                }// for J2p
+              }// for J1p
+            }// Z7 block
 
 
 
-           // Z8  ~ Pik mln Z1     Xbiam Ykjalnb
-           if ( (ob.l+oi.l+oa.l+om.l)%2==0   and (  (ob.tz2+oi.tz2)==(oa.tz2+om.tz2) )  and keep_kja and keep_lnb)
-           {
-            int J1p_min = std::abs(ok.j2-oj.j2)/2;
-            int J1p_max = ( ok.j2+oj.j2 )/2;
-            int J2p_min = std::abs(ol.j2-on.j2)/2;
-            int J2p_max = ( ol.j2+on.j2 )/2;
-            int Jx_min = std::max( std::abs(ob.j2-oi.j2),std::abs(oa.j2-om.j2) )/2;
-            int Jx_max = std::min( ob.j2+oi.j2 ,  oa.j2+om.j2 )/2;
-            for (int J1p=J1p_min; J1p<=J1p_max; J1p++)
+            // Z8  ~ Pik mln Z1     Xbiam Ykjalnb
+            if ( (ob.l+oi.l+oa.l+om.l)%2==0   and (  (ob.tz2+oi.tz2)==(oa.tz2+om.tz2) )  and keep_kja and keep_lnb)
             {
-              double sixj1 = Z.modelspace->GetSixJ(ji,jj,J1,jk,Jtot,J1p);
-              if (std::abs(sixj1)<1e-6) continue;
-              for (int J2p=J2p_min; J2p<=J2p_max; J2p++)
+              int J1p_min = std::abs(ok.j2-oj.j2)/2;
+              int J1p_max = ( ok.j2+oj.j2 )/2;
+              int J2p_min = std::abs(ol.j2-on.j2)/2;
+              int J2p_max = ( ol.j2+on.j2 )/2;
+              int Jx_min = std::max( std::abs(ob.j2-oi.j2),std::abs(oa.j2-om.j2) )/2;
+              int Jx_max = std::min( ob.j2+oi.j2 ,  oa.j2+om.j2 )/2;
+              for (int J1p=J1p_min; J1p<=J1p_max; J1p++)
               {
-                double sixj2 = Z.modelspace->GetSixJ(jm,jl,J2,jn,Jtot,J2p);
-                if (std::abs(sixj2)<1e-6) continue;
-                int twoJJ_min = std::max( std::abs(ob.j2-2*J2p),std::abs(oa.j2-2*J1p) );
-                int twoJJ_max = std::min( ob.j2+2*J2p ,  oa.j2+2*J1p );
-                int phase = -Z.modelspace->phase((oi.j2+on.j2)/2+J1p+J2);
-                for (int twoJJ=twoJJ_min; twoJJ<=twoJJ_max; twoJJ+=2)
+                double sixj1 = Z.modelspace->GetSixJ(ji,jj,J1,jk,Jtot,J1p);
+                if (std::abs(sixj1)<1e-6) continue;
+                for (int J2p=J2p_min; J2p<=J2p_max; J2p++)
                 {
-                  double xkjalnb = X3.GetME_pn( J1p,J2p,twoJJ, k,j,a,l,n,b);
-                  double ykjalnb = Y3.GetME_pn( J1p,J2p,twoJJ, k,j,a,l,n,b);
-                  double JJtot = 0.5 * twoJJ;
-                  for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
+                  double sixj2 = Z.modelspace->GetSixJ(jm,jl,J2,jn,Jtot,J2p);
+                  if (std::abs(sixj2)<1e-6) continue;
+                  int twoJJ_min = std::max( std::abs(ob.j2-2*J2p),std::abs(oa.j2-2*J1p) );
+                  int twoJJ_max = std::min( ob.j2+2*J2p ,  oa.j2+2*J1p );
+                  int phase = -Z.modelspace->phase((oi.j2+on.j2)/2+J1p+J2);
+                  for (int twoJJ=twoJJ_min; twoJJ<=twoJJ_max; twoJJ+=2)
                   {
-                    double xbiam = X2.GetTBME_J(Jx, b,i,a,m);
-                    double ybiam = Y2.GetTBME_J(Jx, b,i,a,m);
-                    double hats = (twoJJ+1)*(2*Jx+1) * sqrt( (2*J1+1)*(2*J1p+1)*(2*J2+1)*(2*J2p+1));
-                    double ninej = Z.modelspace->GetNineJ(jb,JJtot,J2p,  ji,J1p,Jtot, Jx,ja,jm);
-                    z_ijklmn -= occ_factor * hats * phase * sixj1 * sixj2 * ninej * (xbiam*ykjalnb - ybiam*xkjalnb);
-                  }// for Jx
-                }// for twoJ
-              }// for J2p
-            }// for J1p
-           }// Z8 block
-
-
-           // Z9  ~ Pjk mln Z1     Xbjam Yikalnb
-           if ( (ob.l+oj.l+oa.l+om.l)%2==0   and (  (ob.tz2+oj.tz2)==(oa.tz2+om.tz2) )  and keep_ika and keep_lnb)
-           {
-            int J1p_min = std::abs(oi.j2-ok.j2)/2;
-            int J1p_max = ( oi.j2+ok.j2 )/2;
-            int J2p_min = std::abs(ol.j2-on.j2)/2;
-            int J2p_max = ( ol.j2+on.j2 )/2;
-            int Jx_min = std::max( std::abs(ob.j2-oj.j2),std::abs(oa.j2-om.j2) )/2;
-            int Jx_max = std::min( ob.j2+oj.j2 ,  oa.j2+om.j2 )/2;
-            for (int J1p=J1p_min; J1p<=J1p_max; J1p++)
+                    double xkjalnb = X3.GetME_pn( J1p,J2p,twoJJ, k,j,a,l,n,b);
+                    double ykjalnb = Y3.GetME_pn( J1p,J2p,twoJJ, k,j,a,l,n,b);
+                    double JJtot = 0.5 * twoJJ;
+                    for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
+                    {
+                      double xbiam = X2.GetTBME_J(Jx, b,i,a,m);
+                      double ybiam = Y2.GetTBME_J(Jx, b,i,a,m);
+                      double hats = (twoJJ+1)*(2*Jx+1) * sqrt( (2*J1+1)*(2*J1p+1)*(2*J2+1)*(2*J2p+1));
+                      double ninej = Z.modelspace->GetNineJ(jb,JJtot,J2p,  ji,J1p,Jtot, Jx,ja,jm);
+                      z_ijklmn -= occ_factor * hats * phase * sixj1 * sixj2 * ninej * (xbiam*ykjalnb - ybiam*xkjalnb);
+                    }// for Jx
+                  }// for twoJ
+                }// for J2p
+              }// for J1p
+            }// Z8 block
+
+
+            // Z9  ~ Pjk mln Z1     Xbjam Yikalnb
+            if ( (ob.l+oj.l+oa.l+om.l)%2==0   and (  (ob.tz2+oj.tz2)==(oa.tz2+om.tz2) )  and keep_ika and keep_lnb)
             {
-              double sixj1 = Z.modelspace->GetSixJ(jj,ji,J1,jk,Jtot,J1p);
-              if (std::abs(sixj1)<1e-6) continue;
-              for (int J2p=J2p_min; J2p<=J2p_max; J2p++)
+              int J1p_min = std::abs(oi.j2-ok.j2)/2;
+              int J1p_max = ( oi.j2+ok.j2 )/2;
+              int J2p_min = std::abs(ol.j2-on.j2)/2;
+              int J2p_max = ( ol.j2+on.j2 )/2;
+              int Jx_min = std::max( std::abs(ob.j2-oj.j2),std::abs(oa.j2-om.j2) )/2;
+              int Jx_max = std::min( ob.j2+oj.j2 ,  oa.j2+om.j2 )/2;
+              for (int J1p=J1p_min; J1p<=J1p_max; J1p++)
               {
-                double sixj2 = Z.modelspace->GetSixJ(jm,jl,J2,jn,Jtot,J2p);
-                if (std::abs(sixj2)<1e-6) continue;
-                int twoJJ_min = std::max( std::abs(ob.j2-2*J2p),std::abs(oa.j2-2*J1p) );
-                int twoJJ_max = std::min( ob.j2+2*J2p ,  oa.j2+2*J1p );
-                int phase = -Z.modelspace->phase((ok.j2+on.j2)/2+J1+J2);
-                for (int twoJJ=twoJJ_min; twoJJ<=twoJJ_max; twoJJ+=2)
+                double sixj1 = Z.modelspace->GetSixJ(jj,ji,J1,jk,Jtot,J1p);
+                if (std::abs(sixj1)<1e-6) continue;
+                for (int J2p=J2p_min; J2p<=J2p_max; J2p++)
                 {
-                  double xikalnb = X3.GetME_pn( J1p,J2p,twoJJ, i,k,a,l,n,b);
-                  double yikalnb = Y3.GetME_pn( J1p,J2p,twoJJ, i,k,a,l,n,b);
-                  double JJtot = 0.5 * twoJJ;
-                  for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
+                  double sixj2 = Z.modelspace->GetSixJ(jm,jl,J2,jn,Jtot,J2p);
+                  if (std::abs(sixj2)<1e-6) continue;
+                  int twoJJ_min = std::max( std::abs(ob.j2-2*J2p),std::abs(oa.j2-2*J1p) );
+                  int twoJJ_max = std::min( ob.j2+2*J2p ,  oa.j2+2*J1p );
+                  int phase = -Z.modelspace->phase((ok.j2+on.j2)/2+J1+J2);
+                  for (int twoJJ=twoJJ_min; twoJJ<=twoJJ_max; twoJJ+=2)
                   {
-                    double xbjam = X2.GetTBME_J(Jx, b,j,a,m);
-                    double ybjam = Y2.GetTBME_J(Jx, b,j,a,m);
-                    double hats = (twoJJ+1)*(2*Jx+1) * sqrt( (2*J1+1)*(2*J1p+1)*(2*J2+1)*(2*J2p+1));
-                    double ninej = Z.modelspace->GetNineJ(jb,JJtot,J2p,  jj,J1p,Jtot, Jx,ja,jm);
-                    z_ijklmn -= occ_factor * hats * phase * sixj1 * sixj2 * ninej * (xbjam*yikalnb - ybjam*xikalnb);
-                  }// for Jx
-                }// for twoJ
-              }// for J2p
-            }// for J1p
-           }// Z9 block
+                    double xikalnb = X3.GetME_pn( J1p,J2p,twoJJ, i,k,a,l,n,b);
+                    double yikalnb = Y3.GetME_pn( J1p,J2p,twoJJ, i,k,a,l,n,b);
+                    double JJtot = 0.5 * twoJJ;
+                    for ( int Jx=Jx_min; Jx<=Jx_max; Jx++)
+                    {
+                      double xbjam = X2.GetTBME_J(Jx, b,j,a,m);
+                      double ybjam = Y2.GetTBME_J(Jx, b,j,a,m);
+                      double hats = (twoJJ+1)*(2*Jx+1) * sqrt( (2*J1+1)*(2*J1p+1)*(2*J2+1)*(2*J2p+1));
+                      double ninej = Z.modelspace->GetNineJ(jb,JJtot,J2p,  jj,J1p,Jtot, Jx,ja,jm);
+                      z_ijklmn -= occ_factor * hats * phase * sixj1 * sixj2 * ninej * (xbjam*yikalnb - ybjam*xikalnb);
+                    }// for Jx
+                  }// for twoJ
+                }// for J2p
+              }// for J1p
+            }// Z9 block
 
-         }// for b
+          }// for b
         }// for a
         Z3.AddToME_pn_PN_ch( ch3, ch3, ibra,iket, z_ijklmn);
       }// for iket
@@ -7453,15 +7677,15 @@ void comm233_phss_debug( const Operator& X, const Operator& Y, Operator& Z )
 //
 //  |    |    |     Uncoupled expression:
 // i|   j|   k|       Z_ijklmn = 1/6 sum_{abc} (nanbnc + n`an`bn`c) ( X_{ijkabc} Y_{abclmn} - Y_{ijkabc} X_{abclmn}
-//  *~~~[X]~~~*                                                                                                                     
-// a|   b|   c| 
+//  *~~~[X]~~~*
+// a|   b|   c|
 //  *~~~[Y]~~~*     Coupled expression:
 // l|   m|   n|     Z_{ijklmn}^{J1,J2,J} = 1/6 sum_{abc} sum_{J'} (nanbnc + n`an`bn`c) ( X_{ijkabc}^{J1,J',J} Y_{abclmn}^{J',J2,J} - X<->Y )
-//  |    |    |                                                                                                                       
-//                                                           
+//  |    |    |
+//
 //  Checked with UnitTest and passed
 //
-void comm333_ppp_hhhss( const Operator& X, const Operator& Y, Operator& Z ) 
+void comm333_ppp_hhhss( const Operator& X, const Operator& Y, Operator& Z )
 {
 
   double tstart = omp_get_wtime();
@@ -7473,7 +7697,7 @@ void comm333_ppp_hhhss( const Operator& X, const Operator& Y, Operator& Z )
   std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
 
   size_t nch3 = Z.modelspace->GetNumberThreeBodyChannels();
-  #pragma omp parallel for schedule(dynamic,1)
+#pragma omp parallel for schedule(dynamic,1)
   for (size_t ch3=0; ch3<nch3; ch3++)
   {
     auto& Tbc = Z.modelspace->GetThreeBodyChannel(ch3);
@@ -7483,28 +7707,28 @@ void comm333_ppp_hhhss( const Operator& X, const Operator& Y, Operator& Z )
 
     for (size_t iket_abc=0; iket_abc<nkets3; iket_abc++)
     {
-       auto& ket_abc = Tbc.GetKet(iket_abc);
-       double na = ket_abc.op->occ;
-       double nb = ket_abc.oq->occ;
-       double nc = ket_abc.oR->occ;
-       double occ_factor = na*nb*nc - (1-na)*(1-nb)*(1-nc);
-       if (std::abs(occ_factor)<1e-6) continue;
-       double d_ea = std::abs( 2*ket_abc.op->n + ket_abc.op->l - e_fermi[ket_abc.op->tz2]);
-       double d_eb = std::abs( 2*ket_abc.oq->n + ket_abc.oq->l - e_fermi[ket_abc.oq->tz2]);
-       double d_ec = std::abs( 2*ket_abc.oR->n + ket_abc.oR->l - e_fermi[ket_abc.oR->tz2]);
-       double occnat_a = ket_abc.op->occ_nat;
-       double occnat_b = ket_abc.oq->occ_nat;
-       double occnat_c = ket_abc.oR->occ_nat;
-       if ( (d_ea + d_eb + d_ec) > Z.modelspace->GetdE3max() ) continue;
-       if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_c*(1-occnat_c) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-       double symm_factor = 1;
-       if ( (ket_abc.p == ket_abc.q ) and (ket_abc.p == ket_abc.r) )
-          symm_factor = 1./6;
-       else if ( (ket_abc.p == ket_abc.q) or ( ket_abc.q == ket_abc.r) )
-          symm_factor = 3./6;
-       abc_kets.push_back(iket_abc);
-//       abc_factors.push_back( sqrt( occ_factor * symm_factor) );
-       abc_factors.push_back( occ_factor * symm_factor );
+      auto& ket_abc = Tbc.GetKet(iket_abc);
+      double na = ket_abc.op->occ;
+      double nb = ket_abc.oq->occ;
+      double nc = ket_abc.oR->occ;
+      double occ_factor = na*nb*nc - (1-na)*(1-nb)*(1-nc);
+      if (std::abs(occ_factor)<1e-6) continue;
+      double d_ea = std::abs( 2*ket_abc.op->n + ket_abc.op->l - e_fermi[ket_abc.op->tz2]);
+      double d_eb = std::abs( 2*ket_abc.oq->n + ket_abc.oq->l - e_fermi[ket_abc.oq->tz2]);
+      double d_ec = std::abs( 2*ket_abc.oR->n + ket_abc.oR->l - e_fermi[ket_abc.oR->tz2]);
+      double occnat_a = ket_abc.op->occ_nat;
+      double occnat_b = ket_abc.oq->occ_nat;
+      double occnat_c = ket_abc.oR->occ_nat;
+      if ( (d_ea + d_eb + d_ec) > Z.modelspace->GetdE3max() ) continue;
+      if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_c*(1-occnat_c) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+      double symm_factor = 1;
+      if ( (ket_abc.p == ket_abc.q ) and (ket_abc.p == ket_abc.r) )
+        symm_factor = 1./6;
+      else if ( (ket_abc.p == ket_abc.q) or ( ket_abc.q == ket_abc.r) )
+        symm_factor = 3./6;
+      abc_kets.push_back(iket_abc);
+      //       abc_factors.push_back( sqrt( occ_factor * symm_factor) );
+      abc_factors.push_back( occ_factor * symm_factor );
     }// for iket_abc
 
     std::vector<size_t> bras_kept;
@@ -7529,14 +7753,14 @@ void comm333_ppp_hhhss( const Operator& X, const Operator& Y, Operator& Z )
     {
       size_t iket_abc = abc_kets[index_abc];
       double factor = abc_factors[index_abc];
-//      for (size_t ibra=0; ibra<nkets3; ibra++)
+      //      for (size_t ibra=0; ibra<nkets3; ibra++)
       for (size_t ibra : bras_kept )
       {
-         double xijkabc = X3.GetME_pn_PN_ch( ch3,ch3, ibra, iket_abc);
-         double yijkabc = Y3.GetME_pn_PN_ch( ch3,ch3, ibra, iket_abc);
-         XMAT(ibra,index_abc) = factor * xijkabc ;
-//         YMAT(ibra,index_abc) = factor * yijkabc ;
-         YMAT(ibra,index_abc) =  yijkabc ;
+        double xijkabc = X3.GetME_pn_PN_ch( ch3,ch3, ibra, iket_abc);
+        double yijkabc = Y3.GetME_pn_PN_ch( ch3,ch3, ibra, iket_abc);
+        XMAT(ibra,index_abc) = factor * xijkabc ;
+        //         YMAT(ibra,index_abc) = factor * yijkabc ;
+        YMAT(ibra,index_abc) =  yijkabc ;
       }// for ibra
     }// for index_abc
 
@@ -7545,15 +7769,15 @@ void comm333_ppp_hhhss( const Operator& X, const Operator& Y, Operator& Z )
     arma::mat ZMAT = hY * XMAT * YMAT.t() - hX*(YMAT * XMAT.t());
 
     // Store the results
-//    for (size_t ibra=0; ibra<nkets3; ibra++)
+    //    for (size_t ibra=0; ibra<nkets3; ibra++)
     for (size_t ibra : bras_kept )
     {
-//      for (size_t iket=ibra; iket<nkets3; iket++)
+      //      for (size_t iket=ibra; iket<nkets3; iket++)
       for (size_t iket : bras_kept )
       {
         if ( iket < ibra ) continue;
         Z3.AddToME_pn_PN_ch( ch3, ch3, ibra,iket, ZMAT(ibra,iket) );
-        
+
       }// for iket
     }// for ibra
   }//for ch3
@@ -7566,19 +7790,19 @@ void comm333_ppp_hhhss( const Operator& X, const Operator& Y, Operator& Z )
 //
 //  |i  |j      k/     Uncoupled expression:
 //  |   |       /      Z_ijklmn =-1/2 P(ij/k)P(lm/n) sum_{abc} (nanbn`c + na`n`bnc) ( X_{ijcabn} Y_{abklmc} - Y_{ijcabn} X_{abklmc} )
-//  *~~[X]~*   /                   
+//  *~~[X]~*   /
 //  |   |  |\ /        Coupled expression:
 // a|  b| c| /         Z_{ijklmn}^{J1,J2,J} = +1/2 P^{J1,J}(ij/k)P^{J2,j}_{lm/n) sum_{abc} (nanbn`c+n`an`bnc) sum_{J',J",J3} (2J'+1)(2J"+1)
 //  |   |  |/ \                                  { k   J1  J  }
-//  *~~[Y]~*   \                               * { J3  J'  n  } * ( X_{ijcabn}^{J1,J3,J'} Y_{abklmc}^{J3,J2,J"} - X<->Y )     
-//  |   |       \                                { J"  c   J2 }                                                                            
+//  *~~[Y]~*   \                               * { J3  J'  n  } * ( X_{ijcabn}^{J1,J3,J'} Y_{abklmc}^{J3,J2,J"} - X<->Y )
+//  |   |       \                                { J"  c   J2 }
 //  |l  |m       \ n
-//                    
-//                    
+//
+//
 //  Checked with UnitTest and passed
 // TODO: Go back and implement the dE3max cut on the internal terms as well
-// 
-void comm333_pph_hhpss( const Operator& X, const Operator& Y, Operator& Z ) 
+//
+void comm333_pph_hhpss( const Operator& X, const Operator& Y, Operator& Z )
 {
 
   double tstart = omp_get_wtime();
@@ -7598,7 +7822,7 @@ void comm333_pph_hhpss( const Operator& X, const Operator& Y, Operator& Z )
   std::map<std::array<int,3>,size_t> channels_pph; // map twoJ_ph, parity_ph, twoTz_ph  -> channel index
   std::vector< std::array<int,3>> channel_list_pph; // vector  channel_index -> twoJ-ph, parity_ph, twoTz_ph.
 
-//  std::vector< std::map<std::array<int,4>, size_t>> ket_lookup_pph; // in a given channel, map  i,j,k,Jij -> matrix index
+  //  std::vector< std::map<std::array<int,4>, size_t>> ket_lookup_pph; // in a given channel, map  i,j,k,Jij -> matrix index
 
   auto hash_key_ijnJ = [](size_t i,size_t j, size_t n, size_t Jij){return ( i + (j<<12) + (n<<24) + (Jij<<36) );};
   auto unhash_key_ijnJ = [](size_t& i,size_t& j, size_t& n, size_t& Jij, size_t key){ i=(key & 0xFFFL);j=((key>>12)&0xFFFL);n=((key>>24)&0xFFFL);Jij=((key>>36)&0xFFFL); }; //  0xF = 15 = 1111 (4bits), so 0xFFF is 12 bits of 1's. 0xFFFL makes it a long
@@ -7616,8 +7840,8 @@ void comm333_pph_hhpss( const Operator& X, const Operator& Y, Operator& Z )
   double occnat_factor_max = 0;
   for ( auto i : Z.modelspace->all_orbits)
   {
-     double occnat_i = Z.modelspace->GetOrbit(i).occ_nat;
-     occnat_factor_max = std::max( occnat_factor_max, occnat_i*(1-occnat_i) );
+    double occnat_i = Z.modelspace->GetOrbit(i).occ_nat;
+    occnat_factor_max = std::max( occnat_factor_max, occnat_i*(1-occnat_i) );
   }
 
   // Generate all the pph type channels J,parity,Tz. Note that these will be
@@ -7631,14 +7855,14 @@ void comm333_pph_hhpss( const Operator& X, const Operator& Y, Operator& Z )
     {
       for (int twoTz_ph=-3; twoTz_ph<=3; twoTz_ph+=2)
       {
-//        std::vector<std::array<int,4>> good_kets_ijn;
+        //        std::vector<std::array<int,4>> good_kets_ijn;
         size_t ngood_ijn=0;
 
         std::unordered_map<size_t, size_t> good_kets_ijn;
-//        std::map<std::array<int,4>, size_t> good_kets_ijn;
+        //        std::map<std::array<int,4>, size_t> good_kets_ijn;
 
         std::vector<std::array<int,4>> good_kets_abc;
-//        std::vector<size_t> kets_abc;
+        //        std::vector<size_t> kets_abc;
         std::vector<double> occs_abc;
         for ( size_t chij=0; chij<nch2; chij++)
         {
@@ -7668,22 +7892,23 @@ void comm333_pph_hhpss( const Operator& X, const Operator& Y, Operator& Z )
               // if i and j cant make it past the OccNat and dE3max cuts, don't bother including it
               if ( (occnat_i*(1-occnat_i) * occnat_j*(1-occnat_j) * occnat_factor_max ) < Z.modelspace->GetOccNat3Cut() ) continue;
               if ( (d_ei+d_ej) > Z.modelspace->dE3max ) continue;
-              
+
               size_t key = hash_key_ijnJ( i,j,n,size_t(Jij));
               good_kets_ijn[ key ] = ngood_ijn;
-//              good_kets_ijn[ {i,j,n,Jij} ] = ngood_ijn;
+              //              good_kets_ijn[ {i,j,n,Jij} ] = ngood_ijn;
               ngood_ijn++;
               double occ_factor = ket_ij.op->occ * ket_ij.oq->occ * (1-on.occ) + (1-ket_ij.op->occ)*(1-ket_ij.oq->occ)*on.occ;
 
               if (i==j) occ_factor *=0.5; // because we only sum b<a
               if (std::abs(occ_factor)>1e-8 )
               {
-                good_kets_abc.push_back( {i,j,n,Jij} );
+                //good_kets_abc.push_back( {i,j,n,Jij} );
+                good_kets_abc.push_back( {(int)i,(int)j,(int)n,Jij} );
                 occs_abc.push_back( occ_factor );
               }
             }
           }
-          
+
         }
         size_t ngood_abc = good_kets_abc.size();
         if ( (ngood_ijn < 1) or (ngood_abc<1)) continue;
@@ -7698,126 +7923,126 @@ void comm333_pph_hhpss( const Operator& X, const Operator& Y, Operator& Z )
       }// for twoTz_ph
     }// for parity_ph
   }// for twoJph
-//  std::cout << "Nominally " << nch_pph << "  pph channels " << std::endl;
+  //  std::cout << "Nominally " << nch_pph << "  pph channels " << std::endl;
 
 
   Z.profiler.timer["comm333_pph_setup_lists"] += omp_get_wtime() - t_internal;
   t_internal = omp_get_wtime();
 
- // Now that we've made our lists and allocated the matrices, we fill the matrices inside the parallel block.
- #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
- for (size_t ch_pph=0; ch_pph<nch_pph; ch_pph++)
- {
-   int twoJph =  channel_list_pph[ch_pph][0];
-   double Jph = 0.5 * twoJph;
-   auto& good_kets_ijn = ket_lookup_pph[ch_pph];
-   auto& good_kets_abc = ket_lookup_abc[ch_pph];
-   auto& occs_abc = occs_abc_list[ch_pph];
-   size_t ngood_ijn = good_kets_ijn.size();
-   size_t ngood_abc = good_kets_abc.size();
-   arma::mat Xbar_ijnabc( ngood_ijn, ngood_abc, arma::fill::zeros );
-   arma::mat Ybar_abcijn( ngood_abc, ngood_ijn, arma::fill::zeros );
-   
-   // now we fill Xbar an Ybar. This is where the heavy lifting is.
-   for (auto& iter_ijn : good_kets_ijn )
-   {
-     size_t Iijn = iter_ijn.second;
-
-     size_t key = iter_ijn.first;
-     size_t i,j,n,Jij_tmp;
-     unhash_key_ijnJ(i,j,n,Jij_tmp, key);
-     int Jij = (int)Jij_tmp;
-//     size_t i = iter_ijn.first[0];
-//     size_t j = iter_ijn.first[1];
-//     size_t n = iter_ijn.first[2];
-//     int  Jij = iter_ijn.first[3];
-
-     Orbit& oi = Z.modelspace->GetOrbit(i);
-     Orbit& oj = Z.modelspace->GetOrbit(j);
-     Orbit& on = Z.modelspace->GetOrbit(n);
-
-     double occnat_i = oi.occ_nat;
-     double occnat_j = oj.occ_nat;
-     double occnat_n = on.occ_nat;
-     double d_ei = std::abs( 2*oi.n + oi.l - e_fermi[oi.tz2]);
-     double d_ej = std::abs( 2*oj.n + oj.l - e_fermi[oj.tz2]);
-     double d_en = std::abs( 2*on.n + on.l - e_fermi[on.tz2]);
-     double jn = 0.5*on.j2;
-     for (size_t Iabc=0; Iabc<ngood_abc; Iabc++)
-     {
-       auto& abc_info = good_kets_abc[Iabc];
-       size_t a = abc_info[0];
-       size_t b = abc_info[1];
-       size_t c = abc_info[2];
-       double occ_factor = occs_abc[Iabc];
-       Orbit& oa = Z.modelspace->GetOrbit(a);
-       Orbit& ob = Z.modelspace->GetOrbit(b);
-       Orbit& oc = Z.modelspace->GetOrbit(c);
-       double jc = 0.5*oc.j2;
-       int Jab  = abc_info[3];
-
-       double occnat_a = oa.occ_nat;
-       double occnat_b = ob.occ_nat;
-       double occnat_c = oc.occ_nat;
-       double d_ea = std::abs( 2*oa.n + oa.l - e_fermi[oa.tz2]);
-       double d_eb = std::abs( 2*ob.n + ob.l - e_fermi[ob.tz2]);
-       double d_ec = std::abs( 2*oc.n + oc.l - e_fermi[oc.tz2]);
-
-       if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_n*(1-occnat_n) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-       if ( (occnat_i*(1-occnat_i) * occnat_j*(1-occnat_j) * occnat_c*(1-occnat_c) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-       if ( (d_ea+d_eb+d_en) > Z.modelspace->dE3max ) continue;
-       if ( (d_ei+d_ej+d_ec) > Z.modelspace->dE3max ) continue;
-
-
-       double xbar = 0;
-       double ybar = 0;
-       int twoJprime_min = std::max( std::abs(2*Jij - oc.j2), std::abs(2*Jab - on.j2) );
-       int twoJprime_max = std::min( (2*Jij + oc.j2), (2*Jab + on.j2) );
-       for (int twoJprime=twoJprime_min; twoJprime<=twoJprime_max; twoJprime+=2)
-       {
-         double sixj_ijn = Z.modelspace->GetSixJ( Jij, jn, Jph,  Jab, jc, 0.5*twoJprime);
-        
-         // TODO This comes up often enough that we should just make ThreeBodyMEpn do this.
-         std::vector<double> xandy = Y3.GetME_pn_PN_TwoOps( Jij,Jab,twoJprime, i,j,c, a,b,n, X3,Y3 );
-         double xijcabn = xandy[0];
-         double yijcabn = xandy[1];
-
-         // this slightly verbose block is equivalent to
-         // xbar += (twoJprime+1) * sixj_ijn * X3.GetME_pn( Jij, Jab, twoJprime, i,j,c, a,b,n);
-         // ybar += (twoJprime+1) * sixj_ijn * Y3.GetME_pn( Jij, Jab, twoJprime, i,j,c, a,b,n) * occ_factor;
-         // but it avoids doing the recoupling twice (if i,j,c and a,b,n aren't in the storage order)
-
-//         std::vector<size_t> ibra_list, iket_list;
-//         std::vector<double> recouple_bra_list, recouple_ket_list;
-//         size_t ch_check_bra = Y.ThreeBody.GetKetIndex_withRecoupling( Jij, twoJprime, i, j, c, ibra_list, recouple_bra_list) ;
-//         size_t ch_check_ket = Y.ThreeBody.GetKetIndex_withRecoupling( Jab, twoJprime, a, b, n, iket_list, recouple_ket_list) ;
-//         double xijcabn = 0;
-//         double yijcabn = 0;
-//         for ( size_t ind_bra=0; ind_bra<ibra_list.size(); ind_bra++)
-//         {
-//           double rec_bra = recouple_bra_list[ind_bra];
-//           size_t Ibra = ibra_list[ind_bra];
-//           for ( size_t ind_ket=0; ind_ket<iket_list.size(); ind_ket++)
-//           {
-//             double rec_ket = recouple_ket_list[ind_ket];
-//             size_t Iket = iket_list[ind_ket];
-//              xijcabn += rec_bra * rec_ket * X3.GetME_pn_PN_ch(ch_check_bra,ch_check_ket,Ibra,Iket);
-//              yijcabn += rec_bra * rec_ket * Y3.GetME_pn_PN_ch(ch_check_bra,ch_check_ket,Ibra,Iket);
-//           }
-//         }
-         xbar += (twoJprime+1) * sixj_ijn * xijcabn;
-         ybar += (twoJprime+1) * sixj_ijn * yijcabn ;
- 
-       }// for twoJprime
-       
-       Xbar_ijnabc( Iijn, Iabc ) = xbar;
-       Ybar_abcijn( Iabc, Iijn ) = hY * ybar * occ_factor;
-     }// for Iabc
-   }// for iter_ijn
-
-   auto& zbar = Zbar[ch_pph];
-   zbar =  Xbar_ijnabc * Ybar_abcijn;
-   zbar -= hX *hY * zbar.t();
+  // Now that we've made our lists and allocated the matrices, we fill the matrices inside the parallel block.
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+  for (size_t ch_pph=0; ch_pph<nch_pph; ch_pph++)
+  {
+    int twoJph =  channel_list_pph[ch_pph][0];
+    double Jph = 0.5 * twoJph;
+    auto& good_kets_ijn = ket_lookup_pph[ch_pph];
+    auto& good_kets_abc = ket_lookup_abc[ch_pph];
+    auto& occs_abc = occs_abc_list[ch_pph];
+    size_t ngood_ijn = good_kets_ijn.size();
+    size_t ngood_abc = good_kets_abc.size();
+    arma::mat Xbar_ijnabc( ngood_ijn, ngood_abc, arma::fill::zeros );
+    arma::mat Ybar_abcijn( ngood_abc, ngood_ijn, arma::fill::zeros );
+
+    // now we fill Xbar an Ybar. This is where the heavy lifting is.
+    for (auto& iter_ijn : good_kets_ijn )
+    {
+      size_t Iijn = iter_ijn.second;
+
+      size_t key = iter_ijn.first;
+      size_t i,j,n,Jij_tmp;
+      unhash_key_ijnJ(i,j,n,Jij_tmp, key);
+      int Jij = (int)Jij_tmp;
+      //     size_t i = iter_ijn.first[0];
+      //     size_t j = iter_ijn.first[1];
+      //     size_t n = iter_ijn.first[2];
+      //     int  Jij = iter_ijn.first[3];
+
+      Orbit& oi = Z.modelspace->GetOrbit(i);
+      Orbit& oj = Z.modelspace->GetOrbit(j);
+      Orbit& on = Z.modelspace->GetOrbit(n);
+
+      double occnat_i = oi.occ_nat;
+      double occnat_j = oj.occ_nat;
+      double occnat_n = on.occ_nat;
+      double d_ei = std::abs( 2*oi.n + oi.l - e_fermi[oi.tz2]);
+      double d_ej = std::abs( 2*oj.n + oj.l - e_fermi[oj.tz2]);
+      double d_en = std::abs( 2*on.n + on.l - e_fermi[on.tz2]);
+      double jn = 0.5*on.j2;
+      for (size_t Iabc=0; Iabc<ngood_abc; Iabc++)
+      {
+        auto& abc_info = good_kets_abc[Iabc];
+        size_t a = abc_info[0];
+        size_t b = abc_info[1];
+        size_t c = abc_info[2];
+        double occ_factor = occs_abc[Iabc];
+        Orbit& oa = Z.modelspace->GetOrbit(a);
+        Orbit& ob = Z.modelspace->GetOrbit(b);
+        Orbit& oc = Z.modelspace->GetOrbit(c);
+        double jc = 0.5*oc.j2;
+        int Jab  = abc_info[3];
+
+        double occnat_a = oa.occ_nat;
+        double occnat_b = ob.occ_nat;
+        double occnat_c = oc.occ_nat;
+        double d_ea = std::abs( 2*oa.n + oa.l - e_fermi[oa.tz2]);
+        double d_eb = std::abs( 2*ob.n + ob.l - e_fermi[ob.tz2]);
+        double d_ec = std::abs( 2*oc.n + oc.l - e_fermi[oc.tz2]);
+
+        if ( (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_n*(1-occnat_n) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+        if ( (occnat_i*(1-occnat_i) * occnat_j*(1-occnat_j) * occnat_c*(1-occnat_c) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+        if ( (d_ea+d_eb+d_en) > Z.modelspace->dE3max ) continue;
+        if ( (d_ei+d_ej+d_ec) > Z.modelspace->dE3max ) continue;
+
+
+        double xbar = 0;
+        double ybar = 0;
+        int twoJprime_min = std::max( std::abs(2*Jij - oc.j2), std::abs(2*Jab - on.j2) );
+        int twoJprime_max = std::min( (2*Jij + oc.j2), (2*Jab + on.j2) );
+        for (int twoJprime=twoJprime_min; twoJprime<=twoJprime_max; twoJprime+=2)
+        {
+          double sixj_ijn = Z.modelspace->GetSixJ( Jij, jn, Jph,  Jab, jc, 0.5*twoJprime);
+
+          // TODO This comes up often enough that we should just make ThreeBodyMEpn do this.
+          std::vector<double> xandy = Y3.GetME_pn_PN_TwoOps( Jij,Jab,twoJprime, i,j,c, a,b,n, X3,Y3 );
+          double xijcabn = xandy[0];
+          double yijcabn = xandy[1];
+
+          // this slightly verbose block is equivalent to
+          // xbar += (twoJprime+1) * sixj_ijn * X3.GetME_pn( Jij, Jab, twoJprime, i,j,c, a,b,n);
+          // ybar += (twoJprime+1) * sixj_ijn * Y3.GetME_pn( Jij, Jab, twoJprime, i,j,c, a,b,n) * occ_factor;
+          // but it avoids doing the recoupling twice (if i,j,c and a,b,n aren't in the storage order)
+
+          //         std::vector<size_t> ibra_list, iket_list;
+          //         std::vector<double> recouple_bra_list, recouple_ket_list;
+          //         size_t ch_check_bra = Y.ThreeBody.GetKetIndex_withRecoupling( Jij, twoJprime, i, j, c, ibra_list, recouple_bra_list) ;
+          //         size_t ch_check_ket = Y.ThreeBody.GetKetIndex_withRecoupling( Jab, twoJprime, a, b, n, iket_list, recouple_ket_list) ;
+          //         double xijcabn = 0;
+          //         double yijcabn = 0;
+          //         for ( size_t ind_bra=0; ind_bra<ibra_list.size(); ind_bra++)
+          //         {
+          //           double rec_bra = recouple_bra_list[ind_bra];
+          //           size_t Ibra = ibra_list[ind_bra];
+          //           for ( size_t ind_ket=0; ind_ket<iket_list.size(); ind_ket++)
+          //           {
+          //             double rec_ket = recouple_ket_list[ind_ket];
+          //             size_t Iket = iket_list[ind_ket];
+          //              xijcabn += rec_bra * rec_ket * X3.GetME_pn_PN_ch(ch_check_bra,ch_check_ket,Ibra,Iket);
+          //              yijcabn += rec_bra * rec_ket * Y3.GetME_pn_PN_ch(ch_check_bra,ch_check_ket,Ibra,Iket);
+          //           }
+          //         }
+          xbar += (twoJprime+1) * sixj_ijn * xijcabn;
+          ybar += (twoJprime+1) * sixj_ijn * yijcabn ;
+
+        }// for twoJprime
+
+        Xbar_ijnabc( Iijn, Iabc ) = xbar;
+        Ybar_abcijn( Iabc, Iijn ) = hY * ybar * occ_factor;
+      }// for Iabc
+    }// for iter_ijn
+
+    auto& zbar = Zbar[ch_pph];
+    zbar =  Xbar_ijnabc * Ybar_abcijn;
+    zbar -= hX *hY * zbar.t();
 
   }// for ch_pph , end of parallel block
 
@@ -7826,7 +8051,7 @@ void comm333_pph_hhpss( const Operator& X, const Operator& Y, Operator& Z )
 
   // Now that we've computed Zbar (i.e. the pph transformed commutator), we need to
   // transform that back to Z, and do all the permutations to ensure antisymmetry
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
   for (size_t ch3=0; ch3<nch3; ch3++)
   {
     auto& Tbc = Z.modelspace->GetThreeBodyChannel(ch3);
@@ -7860,14 +8085,14 @@ void comm333_pph_hhpss( const Operator& X, const Operator& Y, Operator& Z )
 
       std::vector<int> J1p_min = {J1,  std::max(std::abs(ok.j2-oj.j2),std::abs(twoJ-oi.j2) )/2,   std::max(std::abs(oi.j2-ok.j2), std::abs(twoJ-oj.j2) )/2 };
       std::vector<int> J1p_max = {J1,  std::min(ok.j2+oj.j2, twoJ+oi.j2)/2 , std::min(oi.j2+ok.j2, twoJ+oj.j2)/2 };
-//      std::vector<int> J1p_min = {J1,  std::abs(ok.j2-oj.j2)/2,   std::abs(oi.j2-ok.j2)/2 };
-//      std::vector<int> J1p_max = {J1,  (ok.j2+oj.j2)/2 , (oi.j2+ok.j2)/2 };
+      //      std::vector<int> J1p_min = {J1,  std::abs(ok.j2-oj.j2)/2,   std::abs(oi.j2-ok.j2)/2 };
+      //      std::vector<int> J1p_max = {J1,  (ok.j2+oj.j2)/2 , (oi.j2+ok.j2)/2 };
       std::vector<std::vector<double>> recouple_ijk = {{1},{},{} };
       for (int J1p=J1p_min[1]; J1p<=J1p_max[1]; J1p++)
-           recouple_ijk[1].push_back( sqrt( (2*J1+1)*(2*J1p+1)) * Z.modelspace->GetSixJ(ji,jj,J1,jk,Jtot,J1p) );
+        recouple_ijk[1].push_back( sqrt( (2*J1+1)*(2*J1p+1)) * Z.modelspace->GetSixJ(ji,jj,J1,jk,Jtot,J1p) );
 
       for (int J1p=J1p_min[2]; J1p<=J1p_max[2]; J1p++)
-           recouple_ijk[2].push_back( -Z.modelspace->phase((oj.j2+ok.j2)/2+J1+J1p)*sqrt( (2*J1+1)*(2*J1p+1)) * Z.modelspace->GetSixJ(jj,ji,J1,jk,Jtot,J1p) );
+        recouple_ijk[2].push_back( -Z.modelspace->phase((oj.j2+ok.j2)/2+J1+J1p)*sqrt( (2*J1+1)*(2*J1p+1)) * Z.modelspace->GetSixJ(jj,ji,J1,jk,Jtot,J1p) );
 
 
       for (size_t iket=0; iket<=ibra; iket++)
@@ -7897,15 +8122,15 @@ void comm333_pph_hhpss( const Operator& X, const Operator& Y, Operator& Z )
 
         std::vector<int> J2p_min = {J2,  std::max(std::abs(on.j2-om.j2),std::abs(twoJ-ol.j2) )/2,   std::max(std::abs(ol.j2-on.j2), std::abs(twoJ-om.j2) )/2 };
         std::vector<int> J2p_max = {J2,  std::min(on.j2+om.j2, twoJ+ol.j2)/2 , std::min(ol.j2+on.j2, twoJ+om.j2)/2 };
-//        std::vector<int> J2p_min = {J2,  std::abs(on.j2-om.j2)/2,   std::abs(ol.j2-on.j2)/2 };
-//        std::vector<int> J2p_max = {J2,  (on.j2+om.j2)/2 , (ol.j2+on.j2)/2 };
+        //        std::vector<int> J2p_min = {J2,  std::abs(on.j2-om.j2)/2,   std::abs(ol.j2-on.j2)/2 };
+        //        std::vector<int> J2p_max = {J2,  (on.j2+om.j2)/2 , (ol.j2+on.j2)/2 };
         std::vector<std::vector<double>> recouple_lmn = {{1},{},{} };
-            
+
         for (int J2p=J2p_min[1]; J2p<=J2p_max[1]; J2p++)
-           recouple_lmn[1].push_back( sqrt( (2*J2+1)*(2*J2p+1)) * Z.modelspace->GetSixJ(jl,jm,J2,jn,Jtot,J2p) );
+          recouple_lmn[1].push_back( sqrt( (2*J2+1)*(2*J2p+1)) * Z.modelspace->GetSixJ(jl,jm,J2,jn,Jtot,J2p) );
 
         for (int J2p=J2p_min[2]; J2p<=J2p_max[2]; J2p++)
-             recouple_lmn[2].push_back( -Z.modelspace->phase((om.j2+on.j2)/2+J2+J2p)*sqrt( (2*J2+1)*(2*J2p+1)) * Z.modelspace->GetSixJ(jm,jl,J2,jn,Jtot,J2p) );
+          recouple_lmn[2].push_back( -Z.modelspace->phase((om.j2+on.j2)/2+J2+J2p)*sqrt( (2*J2+1)*(2*J2p+1)) * Z.modelspace->GetSixJ(jm,jl,J2,jn,Jtot,J2p) );
 
 
         double z_ijklmn = 0;
@@ -7948,7 +8173,7 @@ void comm333_pph_hhpss( const Operator& X, const Operator& Y, Operator& Z )
                 int twoJph_max = std::min( (2*J1p + o6.j2), (2*J2p+o3.j2) );
                 if ( twoJph_min > twoJph_max) continue;
 
-//                std::vector<double> Zbar_126453 ( (twoJph_max-twoJph_min)/2+1, 0. );
+                //                std::vector<double> Zbar_126453 ( (twoJph_max-twoJph_min)/2+1, 0. );
                 int phase_12 = I1>I2 ? -Z.modelspace->phase( (o1.j2+o2.j2)/2 - J1p) : 1;
                 int phase_45 = I4>I5 ? -Z.modelspace->phase( (o4.j2+o5.j2)/2 - J2p) : 1;
 
@@ -7959,22 +8184,22 @@ void comm333_pph_hhpss( const Operator& X, const Operator& Y, Operator& Z )
                   if ( iter_ch == channels_pph.end() ) continue;
                   size_t ch_pph = iter_ch->second;
 
-                   size_t index_126 = ket_lookup_pph[ch_pph].at(key_126 );
-                   size_t index_453 = ket_lookup_pph[ch_pph].at(key_453 );
-//                  size_t index_126 = ket_lookup_pph[ch_pph].at({ std::min(I1,I2),std::max(I1,I2),I6,J1p} );
-//                  size_t index_453 = ket_lookup_pph[ch_pph].at({ std::min(I4,I5),std::max(I4,I5),I3,J2p} );
+                  size_t index_126 = ket_lookup_pph[ch_pph].at(key_126 );
+                  size_t index_453 = ket_lookup_pph[ch_pph].at(key_453 );
+                  //                  size_t index_126 = ket_lookup_pph[ch_pph].at({ std::min(I1,I2),std::max(I1,I2),I6,J1p} );
+                  //                  size_t index_453 = ket_lookup_pph[ch_pph].at({ std::min(I4,I5),std::max(I4,I5),I3,J2p} );
                   double zbar =  phase_12 * phase_45 * Zbar[ch_pph](index_126,index_453);
 
                   double Jph = 0.5 * twoJph;
                   double sixj_ph = Z.modelspace->GetSixJ( J1p, j3, Jtot,  J2p, j6, Jph );
                   z_123456 += (twoJph+1) * sixj_ph  * zbar ;
-                }// for Jph 
+                }// for Jph
                 z_ijklmn +=  rec_ijk * rec_lmn * z_123456;
 
-                 }// for J2p
-               }// for perm_lmn
-             }// for J1p
-           }// for perm_ijk
+              }// for J2p
+            }// for perm_lmn
+          }// for J1p
+        }// for perm_ijk
 
         Z3.AddToME_pn_PN_ch( ch3, ch3, ibra, iket, z_ijklmn);
       }// for iket
@@ -7991,247 +8216,247 @@ void comm333_pph_hhpss( const Operator& X, const Operator& Y, Operator& Z )
 //
 // The old slow way, just to make sure we didn't screw anything up by going faster
 //
-void comm333_pph_hhpss_debug( const Operator& X, const Operator& Y, Operator& Z ) 
+void comm333_pph_hhpss_debug( const Operator& X, const Operator& Y, Operator& Z )
 {
 
-  double tstart = omp_get_wtime();
-
-  auto& X3 = X.ThreeBody;
-  auto& Y3 = Y.ThreeBody;
-  auto& Z3 = Z.ThreeBody;
-  std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
-
-  size_t nch2 = Z.modelspace->GetNumberTwoBodyChannels();
-  size_t nch3 = Z.modelspace->GetNumberThreeBodyChannels();
-
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
-  for (size_t ch3=0; ch3<nch3; ch3++)
-  {
-    auto& Tbc = Z.modelspace->GetThreeBodyChannel(ch3);
-    size_t nkets3 = Tbc.GetNumberKets();
-    int twoJ = Tbc.twoJ;
-    double Jtot = 0.5 * twoJ;
-    for (size_t ibra=0; ibra<nkets3; ibra++)
-    {
-      auto& bra = Tbc.GetKet(ibra);
-      size_t i = bra.p;
-      size_t j = bra.q;
-      size_t k = bra.r;
-      Orbit& oi = Z.modelspace->GetOrbit(i);
-      Orbit& oj = Z.modelspace->GetOrbit(j);
-      Orbit& ok = Z.modelspace->GetOrbit(k);
-      double ji = 0.5 * oi.j2;
-      double jj = 0.5 * oj.j2;
-      double jk = 0.5 * ok.j2;
-      double d_ei = std::abs( 2*oi.n + oi.l - e_fermi[oi.tz2]);
-      double d_ej = std::abs( 2*oj.n + oj.l - e_fermi[oj.tz2]);
-      double d_ek = std::abs( 2*ok.n + ok.l - e_fermi[ok.tz2]);
-      double occnat_i = oi.occ_nat;
-      double occnat_j = oj.occ_nat;
-      double occnat_k = ok.occ_nat;
-      if ( (d_ei + d_ej + d_ek) > Z.modelspace->dE3max ) continue;
-      if ( (occnat_i*(1-occnat_i) * occnat_j*(1-occnat_j) * occnat_k*(1-occnat_k) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-      int J1 = bra.Jpq;
-
+double tstart = omp_get_wtime();
 
+auto& X3 = X.ThreeBody;
+auto& Y3 = Y.ThreeBody;
+auto& Z3 = Z.ThreeBody;
+std::map<int,double> e_fermi = Z.modelspace->GetEFermi();
 
-      std::vector<std::array<size_t,3>> ijk = { {i,j,k}, {k,j,i}, {i,k,j} };
-      std::vector<int> J1p_min = {J1,  std::abs(ok.j2-oj.j2)/2,   std::abs(oi.j2-ok.j2)/2 };
-      std::vector<int> J1p_max = {J1,  (ok.j2+oj.j2)/2 , (oi.j2+ok.j2)/2 };
-      std::vector<std::vector<double>> recouple_ijk = {{1},{},{} };
-      for (int J1p=J1p_min[1]; J1p<=J1p_max[1]; J1p++)
-           recouple_ijk[1].push_back( sqrt( (2*J1+1)*(2*J1p+1)) * Z.modelspace->GetSixJ(ji,jj,J1,jk,Jtot,J1p) );
+size_t nch2 = Z.modelspace->GetNumberTwoBodyChannels();
+size_t nch3 = Z.modelspace->GetNumberThreeBodyChannels();
 
-      for (int J1p=J1p_min[2]; J1p<=J1p_max[2]; J1p++)
-           recouple_ijk[2].push_back( -Z.modelspace->phase((oj.j2+ok.j2)/2+J1+J1p)*sqrt( (2*J1+1)*(2*J1p+1)) * Z.modelspace->GetSixJ(jj,ji,J1,jk,Jtot,J1p) );
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+for (size_t ch3=0; ch3<nch3; ch3++)
+{
+auto& Tbc = Z.modelspace->GetThreeBodyChannel(ch3);
+size_t nkets3 = Tbc.GetNumberKets();
+int twoJ = Tbc.twoJ;
+double Jtot = 0.5 * twoJ;
+for (size_t ibra=0; ibra<nkets3; ibra++)
+{
+auto& bra = Tbc.GetKet(ibra);
+size_t i = bra.p;
+size_t j = bra.q;
+size_t k = bra.r;
+Orbit& oi = Z.modelspace->GetOrbit(i);
+Orbit& oj = Z.modelspace->GetOrbit(j);
+Orbit& ok = Z.modelspace->GetOrbit(k);
+double ji = 0.5 * oi.j2;
+double jj = 0.5 * oj.j2;
+double jk = 0.5 * ok.j2;
+double d_ei = std::abs( 2*oi.n + oi.l - e_fermi[oi.tz2]);
+double d_ej = std::abs( 2*oj.n + oj.l - e_fermi[oj.tz2]);
+double d_ek = std::abs( 2*ok.n + ok.l - e_fermi[ok.tz2]);
+double occnat_i = oi.occ_nat;
+double occnat_j = oj.occ_nat;
+double occnat_k = ok.occ_nat;
+if ( (d_ei + d_ej + d_ek) > Z.modelspace->dE3max ) continue;
+if ( (occnat_i*(1-occnat_i) * occnat_j*(1-occnat_j) * occnat_k*(1-occnat_k) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+int J1 = bra.Jpq;
+
+
+
+std::vector<std::array<size_t,3>> ijk = { {i,j,k}, {k,j,i}, {i,k,j} };
+std::vector<int> J1p_min = {J1,  std::abs(ok.j2-oj.j2)/2,   std::abs(oi.j2-ok.j2)/2 };
+std::vector<int> J1p_max = {J1,  (ok.j2+oj.j2)/2 , (oi.j2+ok.j2)/2 };
+std::vector<std::vector<double>> recouple_ijk = {{1},{},{} };
+for (int J1p=J1p_min[1]; J1p<=J1p_max[1]; J1p++)
+recouple_ijk[1].push_back( sqrt( (2*J1+1)*(2*J1p+1)) * Z.modelspace->GetSixJ(ji,jj,J1,jk,Jtot,J1p) );
+
+for (int J1p=J1p_min[2]; J1p<=J1p_max[2]; J1p++)
+recouple_ijk[2].push_back( -Z.modelspace->phase((oj.j2+ok.j2)/2+J1+J1p)*sqrt( (2*J1+1)*(2*J1p+1)) * Z.modelspace->GetSixJ(jj,ji,J1,jk,Jtot,J1p) );
 
 
 //      for (size_t iket=ibra; iket<nkets3; iket++)
-      for (size_t iket=0; iket<=ibra; iket++)
+for (size_t iket=0; iket<=ibra; iket++)
+{
+auto& ket = Tbc.GetKet(iket);
+size_t l = ket.p;
+size_t m = ket.q;
+size_t n = ket.r;
+Orbit& ol = Z.modelspace->GetOrbit(l);
+Orbit& om = Z.modelspace->GetOrbit(m);
+Orbit& on = Z.modelspace->GetOrbit(n);
+double jl = 0.5 * ol.j2;
+double jm = 0.5 * om.j2;
+double jn = 0.5 * on.j2;
+double d_el = std::abs( 2*ol.n + ol.l - e_fermi[ol.tz2]);
+double d_em = std::abs( 2*om.n + om.l - e_fermi[om.tz2]);
+double d_en = std::abs( 2*on.n + on.l - e_fermi[on.tz2]);
+double occnat_l = ol.occ_nat;
+double occnat_m = om.occ_nat;
+double occnat_n = on.occ_nat;
+if ( (d_el + d_em + d_en) > Z.modelspace->dE3max ) continue;
+if ( (occnat_l*(1-occnat_l) * occnat_m*(1-occnat_m) * occnat_n*(1-occnat_n) ) < Z.modelspace->GetOccNat3Cut() ) continue;
+int J2 = ket.Jpq;
+
+
+std::vector<std::array<size_t,3>> lmn = { {l,m,n}, {n,m,l}, {l,n,m} };
+std::vector<int> J2p_min = {J2,  std::abs(on.j2-om.j2)/2,   std::abs(ol.j2-on.j2)/2 };
+std::vector<int> J2p_max = {J2,  (on.j2+om.j2)/2 , (ol.j2+on.j2)/2 };
+std::vector<std::vector<double>> recouple_lmn = {{1},{},{} };
+
+for (int J2p=J2p_min[1]; J2p<=J2p_max[1]; J2p++)
+recouple_lmn[1].push_back( sqrt( (2*J2+1)*(2*J2p+1)) * Z.modelspace->GetSixJ(jl,jm,J2,jn,Jtot,J2p) );
+
+for (int J2p=J2p_min[2]; J2p<=J2p_max[2]; J2p++)
+recouple_lmn[2].push_back( -Z.modelspace->phase((om.j2+on.j2)/2+J2+J2p)*sqrt( (2*J2+1)*(2*J2p+1)) * Z.modelspace->GetSixJ(jm,jl,J2,jn,Jtot,J2p) );
+
+
+double z_ijklmn = 0;
+
+
+for ( int perm_ijk=0; perm_ijk<3; perm_ijk++ )
+{
+  size_t I1 = ijk[perm_ijk][0];
+  size_t I2 = ijk[perm_ijk][1];
+  size_t I3 = ijk[perm_ijk][2];
+  Orbit& o1 = Z.modelspace->GetOrbit( I1 );
+  Orbit& o2 = Z.modelspace->GetOrbit( I2 );
+  Orbit& o3 = Z.modelspace->GetOrbit( I3 );
+  double occnat_1 = o1.occ_nat;
+  double occnat_2 = o2.occ_nat;
+  double occnat_3 = o3.occ_nat;
+  double d_e1 = std::abs( 2*o1.n + o1.l - e_fermi[o1.tz2]);
+  double d_e2 = std::abs( 2*o2.n + o2.l - e_fermi[o2.tz2]);
+  double d_e3 = std::abs( 2*o3.n + o3.l - e_fermi[o3.tz2]);
+  double j3 = 0.5*o3.j2;
+  for (int J1p=J1p_min[perm_ijk]; J1p<=J1p_max[perm_ijk]; J1p++)
+  {
+    double rec_ijk = recouple_ijk[perm_ijk].at(J1p-J1p_min[perm_ijk]);
+    for ( int perm_lmn=0; perm_lmn<3; perm_lmn++ )
+    {
+      size_t I4 = lmn[perm_lmn][0];
+      size_t I5 = lmn[perm_lmn][1];
+      size_t I6 = lmn[perm_lmn][2];
+      Orbit& o4 = Z.modelspace->GetOrbit( I4 );
+      Orbit& o5 = Z.modelspace->GetOrbit( I5 );
+      Orbit& o6 = Z.modelspace->GetOrbit( I6 );
+      double occnat_4 = o4.occ_nat;
+      double occnat_5 = o5.occ_nat;
+      double occnat_6 = o6.occ_nat;
+      double d_e4 = std::abs( 2*o4.n + o4.l - e_fermi[o4.tz2]);
+      double d_e5 = std::abs( 2*o5.n + o5.l - e_fermi[o5.tz2]);
+      double d_e6 = std::abs( 2*o6.n + o6.l - e_fermi[o6.tz2]);
+      double j6 = 0.5*o6.j2;
+      for (int J2p=J2p_min[perm_lmn]; J2p<=J2p_max[perm_lmn]; J2p++)
       {
-        auto& ket = Tbc.GetKet(iket);
-        size_t l = ket.p;
-        size_t m = ket.q;
-        size_t n = ket.r;
-        Orbit& ol = Z.modelspace->GetOrbit(l);
-        Orbit& om = Z.modelspace->GetOrbit(m);
-        Orbit& on = Z.modelspace->GetOrbit(n);
-        double jl = 0.5 * ol.j2;
-        double jm = 0.5 * om.j2;
-        double jn = 0.5 * on.j2;
-        double d_el = std::abs( 2*ol.n + ol.l - e_fermi[ol.tz2]);
-        double d_em = std::abs( 2*om.n + om.l - e_fermi[om.tz2]);
-        double d_en = std::abs( 2*on.n + on.l - e_fermi[on.tz2]);
-        double occnat_l = ol.occ_nat;
-        double occnat_m = om.occ_nat;
-        double occnat_n = on.occ_nat;
-        if ( (d_el + d_em + d_en) > Z.modelspace->dE3max ) continue;
-        if ( (occnat_l*(1-occnat_l) * occnat_m*(1-occnat_m) * occnat_n*(1-occnat_n) ) < Z.modelspace->GetOccNat3Cut() ) continue;
-        int J2 = ket.Jpq;
+        double rec_lmn = recouple_lmn[perm_lmn].at(J2p-J2p_min[perm_lmn]);
 
+        for (size_t ch2=0; ch2<nch2; ch2++)
+        {
+          auto& tbc_ab = Z.modelspace->GetTwoBodyChannel(ch2);
+          if ( std::abs(Tbc.twoTz-2*tbc_ab.Tz)==5) continue; // TODO there are probably other checks at the channel level...
+          size_t nkets_ab = tbc_ab.GetNumberKets();
+          int Jab = tbc_ab.J;
 
-        std::vector<std::array<size_t,3>> lmn = { {l,m,n}, {n,m,l}, {l,n,m} };
-        std::vector<int> J2p_min = {J2,  std::abs(on.j2-om.j2)/2,   std::abs(ol.j2-on.j2)/2 };
-        std::vector<int> J2p_max = {J2,  (on.j2+om.j2)/2 , (ol.j2+on.j2)/2 };
-        std::vector<std::vector<double>> recouple_lmn = {{1},{},{} };
-            
-        for (int J2p=J2p_min[1]; J2p<=J2p_max[1]; J2p++)
-           recouple_lmn[1].push_back( sqrt( (2*J2+1)*(2*J2p+1)) * Z.modelspace->GetSixJ(jl,jm,J2,jn,Jtot,J2p) );
+          for (size_t iket_ab=0; iket_ab<nkets_ab; iket_ab++)
+          {
+            Ket& ket_ab = tbc_ab.GetKet(iket_ab);
+            size_t a = ket_ab.p;
+            size_t b = ket_ab.q;
+            Orbit& oa = Z.modelspace->GetOrbit(a);
+            Orbit& ob = Z.modelspace->GetOrbit(b);
+            if (std::abs(oa.occ * ob.occ)<1e-6 and std::abs( (1-oa.occ)*(1-ob.occ))<1e-6) continue;
 
-        for (int J2p=J2p_min[2]; J2p<=J2p_max[2]; J2p++)
-             recouple_lmn[2].push_back( -Z.modelspace->phase((om.j2+on.j2)/2+J2+J2p)*sqrt( (2*J2+1)*(2*J2p+1)) * Z.modelspace->GetSixJ(jm,jl,J2,jn,Jtot,J2p) );
+            double occnat_a = oa.occ_nat;
+            double occnat_b = ob.occ_nat;
+            double d_ea = std::abs( 2*oa.n + oa.l - e_fermi[oa.tz2]);
+            double d_eb = std::abs( 2*ob.n + ob.l - e_fermi[ob.tz2]);
+            bool keep_ab3 = (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_3*(1-occnat_3) ) >= Z.modelspace->GetOccNat3Cut();
+            bool keep_ab6 = (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_6*(1-occnat_6) ) >= Z.modelspace->GetOccNat3Cut();
+            keep_ab3 = keep_ab3 and (d_ea+d_eb+d_e3 <= Z.modelspace->dE3max );
+            keep_ab6 = keep_ab6 and (d_ea+d_eb+d_e6 <= Z.modelspace->dE3max );
 
+            if ( not ( keep_ab3 or keep_ab6) ) continue;
 
-        double z_ijklmn = 0;
+            for (auto c : Z.modelspace->all_orbits)
+            {
+              Orbit& oc = Z.modelspace->GetOrbit(c);
+              double occ_factor = oa.occ * ob.occ * (1-oc.occ) + (1-oa.occ)*(1-ob.occ)*oc.occ;
+              if (std::abs(occ_factor)<1e-6) continue;
+              if (a==b) occ_factor *=0.5; // because we only sum b<a
+              double occnat_c = oc.occ_nat;
+              double d_ec = std::abs( 2*oc.n + oc.l - e_fermi[oc.tz2]);
+              double jc = 0.5 * oc.j2;
+              bool keep_12c = (occnat_1*(1-occnat_1) * occnat_2*(1-occnat_2) * occnat_c*(1-occnat_c) ) >= Z.modelspace->GetOccNat3Cut();
+              bool keep_45c = (occnat_4*(1-occnat_4) * occnat_5*(1-occnat_5) * occnat_c*(1-occnat_c) ) >= Z.modelspace->GetOccNat3Cut();
+              keep_12c = keep_12c and (d_e1+d_e2+d_ec <= Z.modelspace->dE3max );
+              keep_45c = keep_45c and (d_e4+d_e5+d_ec <= Z.modelspace->dE3max );
 
 
-        for ( int perm_ijk=0; perm_ijk<3; perm_ijk++ )
-        {
-          size_t I1 = ijk[perm_ijk][0];
-          size_t I2 = ijk[perm_ijk][1];
-          size_t I3 = ijk[perm_ijk][2];
-          Orbit& o1 = Z.modelspace->GetOrbit( I1 );
-          Orbit& o2 = Z.modelspace->GetOrbit( I2 );
-          Orbit& o3 = Z.modelspace->GetOrbit( I3 );
-          double occnat_1 = o1.occ_nat;
-          double occnat_2 = o2.occ_nat;
-          double occnat_3 = o3.occ_nat;
-          double d_e1 = std::abs( 2*o1.n + o1.l - e_fermi[o1.tz2]);
-          double d_e2 = std::abs( 2*o2.n + o2.l - e_fermi[o2.tz2]);
-          double d_e3 = std::abs( 2*o3.n + o3.l - e_fermi[o3.tz2]);
-          double j3 = 0.5*o3.j2;
-          for (int J1p=J1p_min[perm_ijk]; J1p<=J1p_max[perm_ijk]; J1p++)
-          {
-            double rec_ijk = recouple_ijk[perm_ijk].at(J1p-J1p_min[perm_ijk]);
-            for ( int perm_lmn=0; perm_lmn<3; perm_lmn++ )
-            {
-              size_t I4 = lmn[perm_lmn][0];
-              size_t I5 = lmn[perm_lmn][1];
-              size_t I6 = lmn[perm_lmn][2];
-              Orbit& o4 = Z.modelspace->GetOrbit( I4 );
-              Orbit& o5 = Z.modelspace->GetOrbit( I5 );
-              Orbit& o6 = Z.modelspace->GetOrbit( I6 );
-              double occnat_4 = o4.occ_nat;
-              double occnat_5 = o5.occ_nat;
-              double occnat_6 = o6.occ_nat;
-              double d_e4 = std::abs( 2*o4.n + o4.l - e_fermi[o4.tz2]);
-              double d_e5 = std::abs( 2*o5.n + o5.l - e_fermi[o5.tz2]);
-              double d_e6 = std::abs( 2*o6.n + o6.l - e_fermi[o6.tz2]);
-              double j6 = 0.5*o6.j2;
-              for (int J2p=J2p_min[perm_lmn]; J2p<=J2p_max[perm_lmn]; J2p++)
+              if ( ((oa.l+ob.l+o3.l+o4.l+o5.l+oc.l)%2==0) and ((o1.l+o2.l+oc.l+oa.l+ob.l+o6.l)%2==0)
+                  and  ( (oa.tz2+ob.tz2+o3.tz2)==(o4.tz2+o5.tz2+oc.tz2) ) and ( (o1.tz2+o2.tz2+oc.tz2)==(oa.tz2+ob.tz2+o6.tz2))
+                  and keep_ab3 and keep_45c and keep_12c and keep_ab6)
+                //                        )//and keep_ab3 and keep_45c and keep_12c and keep_ab6)
               {
-                double rec_lmn = recouple_lmn[perm_lmn].at(J2p-J2p_min[perm_lmn]);
 
-                for (size_t ch2=0; ch2<nch2; ch2++)
+                int twoJx_min = std::max( std::abs(2*Jab - o3.j2), std::abs(2*J2p - oc.j2) );
+                int twoJx_max = std::min( 2*Jab+o3.j2 , 2*J2p + oc.j2 );
+                int twoJy_min = std::max( std::abs(2*J1p - oc.j2), std::abs(2*Jab - o6.j2) );
+                int twoJy_max = std::min( 2*J1p+oc.j2 , 2*Jab + o6.j2 );
+                if (twoJx_min <= twoJx_max and twoJy_min<=twoJy_max)
                 {
-                  auto& tbc_ab = Z.modelspace->GetTwoBodyChannel(ch2);
-                  if ( std::abs(Tbc.twoTz-2*tbc_ab.Tz)==5) continue; // TODO there are probably other checks at the channel level...
-                  size_t nkets_ab = tbc_ab.GetNumberKets();
-                  int Jab = tbc_ab.J;
-
-                  for (size_t iket_ab=0; iket_ab<nkets_ab; iket_ab++)
+                  std::vector<double> xab345c( (twoJx_max-twoJx_min)/2+1, 0);
+                  std::vector<double> yab345c( (twoJx_max-twoJx_min)/2+1, 0);
+                  std::vector<double> x12cab6( (twoJy_max-twoJy_min)/2+1, 0);
+                  std::vector<double> y12cab6( (twoJy_max-twoJy_min)/2+1, 0);
+                  for (int twoJx=twoJx_min; twoJx<=twoJx_max; twoJx+=2)
+                  {
+                    size_t iJx = (twoJx-twoJx_min)/2;
+                    xab345c[iJx] = X3.GetME_pn(Jab,J2p,twoJx, a,b,I3,I4,I5,c);
+                    yab345c[iJx] = Y3.GetME_pn(Jab,J2p,twoJx, a,b,I3,I4,I5,c);
+                  }
+                  for (int twoJy=twoJy_min; twoJy<=twoJy_max; twoJy+=2)
                   {
-                    Ket& ket_ab = tbc_ab.GetKet(iket_ab);
-                    size_t a = ket_ab.p;
-                    size_t b = ket_ab.q;
-                    Orbit& oa = Z.modelspace->GetOrbit(a);
-                    Orbit& ob = Z.modelspace->GetOrbit(b);
-                    if (std::abs(oa.occ * ob.occ)<1e-6 and std::abs( (1-oa.occ)*(1-ob.occ))<1e-6) continue;
-
-                    double occnat_a = oa.occ_nat;
-                    double occnat_b = ob.occ_nat;
-                    double d_ea = std::abs( 2*oa.n + oa.l - e_fermi[oa.tz2]);
-                    double d_eb = std::abs( 2*ob.n + ob.l - e_fermi[ob.tz2]);
-                    bool keep_ab3 = (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_3*(1-occnat_3) ) >= Z.modelspace->GetOccNat3Cut(); 
-                    bool keep_ab6 = (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_6*(1-occnat_6) ) >= Z.modelspace->GetOccNat3Cut(); 
-                    keep_ab3 = keep_ab3 and (d_ea+d_eb+d_e3 <= Z.modelspace->dE3max );
-                    keep_ab6 = keep_ab6 and (d_ea+d_eb+d_e6 <= Z.modelspace->dE3max );
-
-                    if ( not ( keep_ab3 or keep_ab6) ) continue;
-                    
-                    for (auto c : Z.modelspace->all_orbits)
+                    size_t iJy = (twoJy-twoJy_min)/2;
+                    x12cab6[iJy] = X3.GetME_pn(J1p,Jab,twoJy, I1,I2,c,a,b,I6);
+                    y12cab6[iJy] = Y3.GetME_pn(J1p,Jab,twoJy, I1,I2,c,a,b,I6);
+                  }
+                  for (int twoJx=twoJx_min; twoJx<=twoJx_max; twoJx+=2)
+                  {
+                    double JJx = 0.5 * twoJx;
+                    size_t iJx = (twoJx-twoJx_min)/2;
+                    for (int twoJy=twoJy_min; twoJy<=twoJy_max; twoJy+=2)
                     {
-                      Orbit& oc = Z.modelspace->GetOrbit(c);
-                      double occ_factor = oa.occ * ob.occ * (1-oc.occ) + (1-oa.occ)*(1-ob.occ)*oc.occ;
-                      if (std::abs(occ_factor)<1e-6) continue;
-                      if (a==b) occ_factor *=0.5; // because we only sum b<a
-                      double occnat_c = oc.occ_nat;
-                      double d_ec = std::abs( 2*oc.n + oc.l - e_fermi[oc.tz2]);
-                      double jc = 0.5 * oc.j2;
-                      bool keep_12c = (occnat_1*(1-occnat_1) * occnat_2*(1-occnat_2) * occnat_c*(1-occnat_c) ) >= Z.modelspace->GetOccNat3Cut(); 
-                      bool keep_45c = (occnat_4*(1-occnat_4) * occnat_5*(1-occnat_5) * occnat_c*(1-occnat_c) ) >= Z.modelspace->GetOccNat3Cut(); 
-                      keep_12c = keep_12c and (d_e1+d_e2+d_ec <= Z.modelspace->dE3max );
-                      keep_45c = keep_45c and (d_e4+d_e5+d_ec <= Z.modelspace->dE3max );
-
-
-                      if ( ((oa.l+ob.l+o3.l+o4.l+o5.l+oc.l)%2==0) and ((o1.l+o2.l+oc.l+oa.l+ob.l+o6.l)%2==0)
-                       and  ( (oa.tz2+ob.tz2+o3.tz2)==(o4.tz2+o5.tz2+oc.tz2) ) and ( (o1.tz2+o2.tz2+oc.tz2)==(oa.tz2+ob.tz2+o6.tz2))
-                        and keep_ab3 and keep_45c and keep_12c and keep_ab6)
-//                        )//and keep_ab3 and keep_45c and keep_12c and keep_ab6)
-                      {
+                      double JJy = 0.5 * twoJy;
+                      size_t iJy = (twoJy-twoJy_min)/2;
+                      double hats = (twoJx+1)*(twoJy+1);
+                      double ninej = Z.modelspace->GetNineJ( j3,Jab,JJx, J1p,JJy,jc, Jtot,j6,J2p);
+                      z_ijklmn +=  rec_ijk * rec_lmn * occ_factor * hats * ninej * ( xab345c[iJx]*y12cab6[iJy] - yab345c[iJx]*x12cab6[iJy] );
+                    }// for twoJy
+                  }// for twoJx
+                }
+              }// Z1 block
 
-                        int twoJx_min = std::max( std::abs(2*Jab - o3.j2), std::abs(2*J2p - oc.j2) );
-                        int twoJx_max = std::min( 2*Jab+o3.j2 , 2*J2p + oc.j2 );
-                        int twoJy_min = std::max( std::abs(2*J1p - oc.j2), std::abs(2*Jab - o6.j2) );
-                        int twoJy_max = std::min( 2*J1p+oc.j2 , 2*Jab + o6.j2 );
-                        if (twoJx_min <= twoJx_max and twoJy_min<=twoJy_max) 
-                        {
-                          std::vector<double> xab345c( (twoJx_max-twoJx_min)/2+1, 0);
-                          std::vector<double> yab345c( (twoJx_max-twoJx_min)/2+1, 0);
-                          std::vector<double> x12cab6( (twoJy_max-twoJy_min)/2+1, 0);
-                          std::vector<double> y12cab6( (twoJy_max-twoJy_min)/2+1, 0);
-                          for (int twoJx=twoJx_min; twoJx<=twoJx_max; twoJx+=2)
-                          {
-                            size_t iJx = (twoJx-twoJx_min)/2;
-                            xab345c[iJx] = X3.GetME_pn(Jab,J2p,twoJx, a,b,I3,I4,I5,c);
-                            yab345c[iJx] = Y3.GetME_pn(Jab,J2p,twoJx, a,b,I3,I4,I5,c);
-                          }
-                          for (int twoJy=twoJy_min; twoJy<=twoJy_max; twoJy+=2)
-                          {
-                             size_t iJy = (twoJy-twoJy_min)/2;
-                             x12cab6[iJy] = X3.GetME_pn(J1p,Jab,twoJy, I1,I2,c,a,b,I6);
-                             y12cab6[iJy] = Y3.GetME_pn(J1p,Jab,twoJy, I1,I2,c,a,b,I6);
-                          }
-                          for (int twoJx=twoJx_min; twoJx<=twoJx_max; twoJx+=2)
-                          {
-                            double JJx = 0.5 * twoJx;
-                            size_t iJx = (twoJx-twoJx_min)/2;
-                            for (int twoJy=twoJy_min; twoJy<=twoJy_max; twoJy+=2)
-                            {
-                               double JJy = 0.5 * twoJy;
-                               size_t iJy = (twoJy-twoJy_min)/2;
-                               double hats = (twoJx+1)*(twoJy+1);
-                               double ninej = Z.modelspace->GetNineJ( j3,Jab,JJx, J1p,JJy,jc, Jtot,j6,J2p);
-                                z_ijklmn +=  rec_ijk * rec_lmn * occ_factor * hats * ninej * ( xab345c[iJx]*y12cab6[iJy] - yab345c[iJx]*x12cab6[iJy] );
-                            }// for twoJy
-                          }// for twoJx
-                        }
-                      }// Z1 block
-
-                     }// for c
-                   }// for iket_ab
-                 }// for ch2
-
-
-                    }// for J2p
-                  }// for perm_lmn
-                }// for J1p
-              }// for perm_ijk
+            }// for c
+          }// for iket_ab
+        }// for ch2
 
-        Z3.AddToME_pn_PN_ch( ch3, ch3, ibra, iket, z_ijklmn);
-      }// for iket
-    }// for ibra
-  }//for ch3
 
-  Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
+      }// for J2p
+    }// for perm_lmn
+  }// for J1p
+}// for perm_ijk
+
+Z3.AddToME_pn_PN_ch( ch3, ch3, ibra, iket, z_ijklmn);
+}// for iket
+}// for ibra
+}//for ch3
+
+Z.profiler.timer[__func__] += omp_get_wtime() - tstart;
 }
 */
 
 
 
 
-//void comm333_pph_hhpss( const Operator& X, const Operator& Y, Operator& Z ) 
-void comm333_pph_hhpss_debug( const Operator& X, const Operator& Y, Operator& Z ) 
+//void comm333_pph_hhpss( const Operator& X, const Operator& Y, Operator& Z )
+void comm333_pph_hhpss_debug( const Operator& X, const Operator& Y, Operator& Z )
 {
 
   double tstart = omp_get_wtime();
@@ -8244,7 +8469,7 @@ void comm333_pph_hhpss_debug( const Operator& X, const Operator& Y, Operator& Z
   size_t nch2 = Z.modelspace->GetNumberTwoBodyChannels();
   size_t nch3 = Z.modelspace->GetNumberThreeBodyChannels();
 
-  #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar3b_transform_first_pass)
   for (size_t ch3=0; ch3<nch3; ch3++)
   {
     auto& Tbc = Z.modelspace->GetThreeBodyChannel(ch3);
@@ -8272,7 +8497,7 @@ void comm333_pph_hhpss_debug( const Operator& X, const Operator& Y, Operator& Z
       if ( (d_ei + d_ej + d_ek) > Z.modelspace->dE3max ) continue;
       if ( (occnat_i*(1-occnat_i) * occnat_j*(1-occnat_j) * occnat_k*(1-occnat_k) ) < Z.modelspace->GetOccNat3Cut() ) continue;
       int J1 = bra.Jpq;
-//      for (size_t iket=ibra; iket<nkets3; iket++)
+      //      for (size_t iket=ibra; iket<nkets3; iket++)
       for (size_t iket=0; iket<=ibra; iket++)
       {
         auto& ket = Tbc.GetKet(iket);
@@ -8295,9 +8520,9 @@ void comm333_pph_hhpss_debug( const Operator& X, const Operator& Y, Operator& Z
         if ( (occnat_l*(1-occnat_l) * occnat_m*(1-occnat_m) * occnat_n*(1-occnat_n) ) < Z.modelspace->GetOccNat3Cut() ) continue;
         int J2 = ket.Jpq;
 
-//              if ( not ((i==2 and j==4 and k==5 and l==4 and m==4 and n==5) 
-//              if ( not ((i==4 and j==4 and k==5 and l==2 and m==4 and n==5) 
-//               or (i==5 and j==4 and k==2 and l==5 and m==4 and n==4)) ) continue;
+        //              if ( not ((i==2 and j==4 and k==5 and l==4 and m==4 and n==5)
+        //              if ( not ((i==4 and j==4 and k==5 and l==2 and m==4 and n==5)
+        //               or (i==5 and j==4 and k==2 and l==5 and m==4 and n==4)) ) continue;
         double z_ijklmn = 0;
 
         for (size_t ch2=0; ch2<nch2; ch2++)
@@ -8320,19 +8545,19 @@ void comm333_pph_hhpss_debug( const Operator& X, const Operator& Y, Operator& Z
             double occnat_b = ob.occ_nat;
             double d_ea = std::abs( 2*oa.n + oa.l - e_fermi[oa.tz2]);
             double d_eb = std::abs( 2*ob.n + ob.l - e_fermi[ob.tz2]);
-            bool keep_abi = (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_i*(1-occnat_i) ) >= Z.modelspace->GetOccNat3Cut(); 
-            bool keep_abj = (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_j*(1-occnat_j) ) >= Z.modelspace->GetOccNat3Cut(); 
-            bool keep_abk = (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_k*(1-occnat_k) ) >= Z.modelspace->GetOccNat3Cut(); 
-            bool keep_abl = (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_l*(1-occnat_l) ) >= Z.modelspace->GetOccNat3Cut(); 
-            bool keep_abm = (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_m*(1-occnat_m) ) >= Z.modelspace->GetOccNat3Cut(); 
-            bool keep_abn = (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_n*(1-occnat_n) ) >= Z.modelspace->GetOccNat3Cut(); 
+            bool keep_abi = (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_i*(1-occnat_i) ) >= Z.modelspace->GetOccNat3Cut();
+            bool keep_abj = (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_j*(1-occnat_j) ) >= Z.modelspace->GetOccNat3Cut();
+            bool keep_abk = (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_k*(1-occnat_k) ) >= Z.modelspace->GetOccNat3Cut();
+            bool keep_abl = (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_l*(1-occnat_l) ) >= Z.modelspace->GetOccNat3Cut();
+            bool keep_abm = (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_m*(1-occnat_m) ) >= Z.modelspace->GetOccNat3Cut();
+            bool keep_abn = (occnat_a*(1-occnat_a) * occnat_b*(1-occnat_b) * occnat_n*(1-occnat_n) ) >= Z.modelspace->GetOccNat3Cut();
             keep_abi = keep_abi and (d_ea+d_eb+d_ei <= Z.modelspace->dE3max );
             keep_abj = keep_abj and (d_ea+d_eb+d_ej <= Z.modelspace->dE3max );
             keep_abk = keep_abk and (d_ea+d_eb+d_ek <= Z.modelspace->dE3max );
             keep_abl = keep_abl and (d_ea+d_eb+d_el <= Z.modelspace->dE3max );
             keep_abm = keep_abm and (d_ea+d_eb+d_em <= Z.modelspace->dE3max );
             keep_abn = keep_abn and (d_ea+d_eb+d_en <= Z.modelspace->dE3max );
-            
+
             for (auto c : Z.modelspace->all_orbits)
             {
               Orbit& oc = Z.modelspace->GetOrbit(c);
@@ -8342,12 +8567,12 @@ void comm333_pph_hhpss_debug( const Operator& X, const Operator& Y, Operator& Z
               double occnat_c = oc.occ_nat;
               double d_ec = std::abs( 2*oc.n + oc.l - e_fermi[oc.tz2]);
               double jc = 0.5 * oc.j2;
-              bool keep_ijc = (occnat_i*(1-occnat_i) * occnat_j*(1-occnat_j) * occnat_c*(1-occnat_c) ) >= Z.modelspace->GetOccNat3Cut(); 
-              bool keep_kjc = (occnat_k*(1-occnat_k) * occnat_j*(1-occnat_j) * occnat_c*(1-occnat_c) ) >= Z.modelspace->GetOccNat3Cut(); 
-              bool keep_ikc = (occnat_i*(1-occnat_i) * occnat_k*(1-occnat_k) * occnat_c*(1-occnat_c) ) >= Z.modelspace->GetOccNat3Cut(); 
-              bool keep_lmc = (occnat_l*(1-occnat_l) * occnat_m*(1-occnat_m) * occnat_c*(1-occnat_c) ) >= Z.modelspace->GetOccNat3Cut(); 
-              bool keep_nmc = (occnat_n*(1-occnat_n) * occnat_m*(1-occnat_m) * occnat_c*(1-occnat_c) ) >= Z.modelspace->GetOccNat3Cut(); 
-              bool keep_lnc = (occnat_l*(1-occnat_l) * occnat_n*(1-occnat_n) * occnat_c*(1-occnat_c) ) >= Z.modelspace->GetOccNat3Cut(); 
+              bool keep_ijc = (occnat_i*(1-occnat_i) * occnat_j*(1-occnat_j) * occnat_c*(1-occnat_c) ) >= Z.modelspace->GetOccNat3Cut();
+              bool keep_kjc = (occnat_k*(1-occnat_k) * occnat_j*(1-occnat_j) * occnat_c*(1-occnat_c) ) >= Z.modelspace->GetOccNat3Cut();
+              bool keep_ikc = (occnat_i*(1-occnat_i) * occnat_k*(1-occnat_k) * occnat_c*(1-occnat_c) ) >= Z.modelspace->GetOccNat3Cut();
+              bool keep_lmc = (occnat_l*(1-occnat_l) * occnat_m*(1-occnat_m) * occnat_c*(1-occnat_c) ) >= Z.modelspace->GetOccNat3Cut();
+              bool keep_nmc = (occnat_n*(1-occnat_n) * occnat_m*(1-occnat_m) * occnat_c*(1-occnat_c) ) >= Z.modelspace->GetOccNat3Cut();
+              bool keep_lnc = (occnat_l*(1-occnat_l) * occnat_n*(1-occnat_n) * occnat_c*(1-occnat_c) ) >= Z.modelspace->GetOccNat3Cut();
               keep_ijc = keep_ijc and (d_ei+d_ej+d_ec <= Z.modelspace->dE3max );
               keep_kjc = keep_kjc and (d_ek+d_ej+d_ec <= Z.modelspace->dE3max );
               keep_ikc = keep_ikc and (d_ei+d_ek+d_ec <= Z.modelspace->dE3max );
@@ -8358,14 +8583,14 @@ void comm333_pph_hhpss_debug( const Operator& X, const Operator& Y, Operator& Z
 
               // Direct Z1 term
               if ( ((oa.l+ob.l+ok.l+ol.l+om.l+oc.l)%2==0) and ((oi.l+oj.l+oc.l+oa.l+ob.l+on.l)%2==0)
-               and  ( (oa.tz2+ob.tz2+ok.tz2)==(ol.tz2+om.tz2+oc.tz2) ) and ( (oi.tz2+oj.tz2+oc.tz2)==(oa.tz2+ob.tz2+on.tz2))
-                and keep_abk and keep_lmc and keep_ijc and keep_abn)
+                  and  ( (oa.tz2+ob.tz2+ok.tz2)==(ol.tz2+om.tz2+oc.tz2) ) and ( (oi.tz2+oj.tz2+oc.tz2)==(oa.tz2+ob.tz2+on.tz2))
+                  and keep_abk and keep_lmc and keep_ijc and keep_abn)
               {
                 int twoJx_min = std::max( std::abs(2*Jab - ok.j2), std::abs(2*J2 - oc.j2) );
                 int twoJx_max = std::min( 2*Jab+ok.j2 , 2*J2 + oc.j2 );
                 int twoJy_min = std::max( std::abs(2*J1 - oc.j2), std::abs(2*Jab - on.j2) );
                 int twoJy_max = std::min( 2*J1+oc.j2 , 2*Jab + on.j2 );
-                if (twoJx_min <= twoJx_max and twoJy_min<=twoJy_max) 
+                if (twoJx_min <= twoJx_max and twoJy_min<=twoJy_max)
                 {
                   std::vector<double> xabklmc( (twoJx_max-twoJx_min)/2+1, 0);
                   std::vector<double> yabklmc( (twoJx_max-twoJx_min)/2+1, 0);
@@ -8373,18 +8598,18 @@ void comm333_pph_hhpss_debug( const Operator& X, const Operator& Y, Operator& Z
                   std::vector<double> yijcabn( (twoJy_max-twoJy_min)/2+1, 0);
                   for (int twoJx=twoJx_min; twoJx<=twoJx_max; twoJx+=2)
                   {
-  //                  double JJx = 0.5 * twoJx;
+                    //                  double JJx = 0.5 * twoJx;
                     size_t iJx = (twoJx-twoJx_min)/2;
                     xabklmc[iJx] = X3.GetME_pn(Jab,J2,twoJx, a,b,k,l,m,c);
                     yabklmc[iJx] = Y3.GetME_pn(Jab,J2,twoJx, a,b,k,l,m,c);
-  //                  double xabklmc = X3.GetME_pn(Jab,J2,twoJx, a,b,k,l,m,c);
-  //                  double yabklmc = Y3.GetME_pn(Jab,J2,twoJx, a,b,k,l,m,c);
+                    //                  double xabklmc = X3.GetME_pn(Jab,J2,twoJx, a,b,k,l,m,c);
+                    //                  double yabklmc = Y3.GetME_pn(Jab,J2,twoJx, a,b,k,l,m,c);
                   }
                   for (int twoJy=twoJy_min; twoJy<=twoJy_max; twoJy+=2)
                   {
-                     size_t iJy = (twoJy-twoJy_min)/2;
-                     xijcabn[iJy] = X3.GetME_pn(J1,Jab,twoJy, i,j,c,a,b,n);
-                     yijcabn[iJy] = Y3.GetME_pn(J1,Jab,twoJy, i,j,c,a,b,n);
+                    size_t iJy = (twoJy-twoJy_min)/2;
+                    xijcabn[iJy] = X3.GetME_pn(J1,Jab,twoJy, i,j,c,a,b,n);
+                    yijcabn[iJy] = Y3.GetME_pn(J1,Jab,twoJy, i,j,c,a,b,n);
                   }
                   for (int twoJx=twoJx_min; twoJx<=twoJx_max; twoJx+=2)
                   {
@@ -8392,25 +8617,25 @@ void comm333_pph_hhpss_debug( const Operator& X, const Operator& Y, Operator& Z
                     size_t iJx = (twoJx-twoJx_min)/2;
                     for (int twoJy=twoJy_min; twoJy<=twoJy_max; twoJy+=2)
                     {
-                       double JJy = 0.5 * twoJy;
-                       size_t iJy = (twoJy-twoJy_min)/2;
-                       double hats = (twoJx+1)*(twoJy+1);
-                       double ninej = Z.modelspace->GetNineJ( jk,Jab,JJx, J1,JJy,jc, Jtot,jn,J2);
-  //                     double xijcabn = X3.GetME_pn(J1,Jab,twoJy, i,j,c,a,b,n);
-  //                     double yijcabn = Y3.GetME_pn(J1,Jab,twoJy, i,j,c,a,b,n);
-  //                     z_ijklmn +=  occ_factor * hats * ninej * ( xabklmc*yijcabn - yabklmc*xijcabn );
-                       z_ijklmn +=  occ_factor * hats * ninej * ( xabklmc[iJx]*yijcabn[iJy] - yabklmc[iJx]*xijcabn[iJy] );
+                      double JJy = 0.5 * twoJy;
+                      size_t iJy = (twoJy-twoJy_min)/2;
+                      double hats = (twoJx+1)*(twoJy+1);
+                      double ninej = Z.modelspace->GetNineJ( jk,Jab,JJx, J1,JJy,jc, Jtot,jn,J2);
+                      //                     double xijcabn = X3.GetME_pn(J1,Jab,twoJy, i,j,c,a,b,n);
+                      //                     double yijcabn = Y3.GetME_pn(J1,Jab,twoJy, i,j,c,a,b,n);
+                      //                     z_ijklmn +=  occ_factor * hats * ninej * ( xabklmc*yijcabn - yabklmc*xijcabn );
+                      z_ijklmn +=  occ_factor * hats * ninej * ( xabklmc[iJx]*yijcabn[iJy] - yabklmc[iJx]*xijcabn[iJy] );
                     }// for twoJy
                   }// for twoJx
                 }
               }// Z1 block
-//              std::cout << "  after Z1  " << z_ijklmn << std::endl;
+              //              std::cout << "  after Z1  " << z_ijklmn << std::endl;
 
 
               // Z2 term  Pik    Xabilmc Ykjcabn
               if ( ((oa.l+ob.l+oi.l+ol.l+om.l+oc.l)%2==0) and ((ok.l+oj.l+oc.l+oa.l+ob.l+on.l)%2==0)
-               and  ( (oa.tz2+ob.tz2+oi.tz2)==(ol.tz2+om.tz2+oc.tz2) ) and ( (ok.tz2+oj.tz2+oc.tz2)==(oa.tz2+ob.tz2+on.tz2)) 
-                and keep_abi and keep_lmc and keep_kjc and keep_abn )
+                  and  ( (oa.tz2+ob.tz2+oi.tz2)==(ol.tz2+om.tz2+oc.tz2) ) and ( (ok.tz2+oj.tz2+oc.tz2)==(oa.tz2+ob.tz2+on.tz2))
+                  and keep_abi and keep_lmc and keep_kjc and keep_abn )
               {
                 int twoJx_min = std::max( std::abs(2*Jab - oi.j2), std::abs(2*J2 - oc.j2) );
                 int twoJx_max = std::min( 2*Jab+oi.j2 , 2*J2 + oc.j2 );
@@ -8431,23 +8656,23 @@ void comm333_pph_hhpss_debug( const Operator& X, const Operator& Y, Operator& Z
                     int phase = -1;
                     for (int twoJy=twoJy_min; twoJy<=twoJy_max; twoJy+=2)
                     {
-                       double JJy = 0.5 * twoJy;
-                       double hats = (twoJx+1)*(twoJy+1) * sqrt( (2*J1+1)*(2*J1p+1));
-                       double ninej = Z.modelspace->GetNineJ( ji,Jab,JJx, J1p,JJy,jc, Jtot,jn,J2);
-                       double xkjcabn = X3.GetME_pn(J1p,Jab,twoJy, k,j,c,a,b,n);
-                       double ykjcabn = Y3.GetME_pn(J1p,Jab,twoJy, k,j,c,a,b,n);
-                       z_ijklmn -=  occ_factor * phase * hats * sixj * ninej * ( xabilmc*ykjcabn - yabilmc*xkjcabn );
+                      double JJy = 0.5 * twoJy;
+                      double hats = (twoJx+1)*(twoJy+1) * sqrt( (2*J1+1)*(2*J1p+1));
+                      double ninej = Z.modelspace->GetNineJ( ji,Jab,JJx, J1p,JJy,jc, Jtot,jn,J2);
+                      double xkjcabn = X3.GetME_pn(J1p,Jab,twoJy, k,j,c,a,b,n);
+                      double ykjcabn = Y3.GetME_pn(J1p,Jab,twoJy, k,j,c,a,b,n);
+                      z_ijklmn -=  occ_factor * phase * hats * sixj * ninej * ( xabilmc*ykjcabn - yabilmc*xkjcabn );
                     }// for twoJy
                   }// for J1p
                 }// for twoJx
               }// Z2 block
-//              std::cout << "  after Z2  " << z_ijklmn << std::endl;
+              //              std::cout << "  after Z2  " << z_ijklmn << std::endl;
 
 
               // Z3 term  Pjk    Xabjlmc Yikcabn
               if ( ((oa.l+ob.l+oj.l+ol.l+om.l+oc.l)%2==0) and ((oi.l+ok.l+oc.l+oa.l+ob.l+on.l)%2==0)
-               and  ( (oa.tz2+ob.tz2+oj.tz2)==(ol.tz2+om.tz2+oc.tz2) ) and ( (oi.tz2+ok.tz2+oc.tz2)==(oa.tz2+ob.tz2+on.tz2)) 
-                and keep_abj and keep_lmc and keep_ikc and keep_abn )
+                  and  ( (oa.tz2+ob.tz2+oj.tz2)==(ol.tz2+om.tz2+oc.tz2) ) and ( (oi.tz2+ok.tz2+oc.tz2)==(oa.tz2+ob.tz2+on.tz2))
+                  and keep_abj and keep_lmc and keep_ikc and keep_abn )
               {
                 int twoJx_min = std::max( std::abs(2*Jab - oj.j2), std::abs(2*J2 - oc.j2) );
                 int twoJx_max = std::min( 2*Jab+oj.j2 , 2*J2 + oc.j2 );
@@ -8468,23 +8693,23 @@ void comm333_pph_hhpss_debug( const Operator& X, const Operator& Y, Operator& Z
                     int phase = Z.modelspace->phase( (oj.j2+ok.j2)/2+J1+J1p);
                     for (int twoJy=twoJy_min; twoJy<=twoJy_max; twoJy+=2)
                     {
-                       double JJy = 0.5 * twoJy;
-                       double hats = (twoJx+1)*(twoJy+1) * sqrt( (2*J1+1)*(2*J1p+1));
-                       double ninej = Z.modelspace->GetNineJ( jj,Jab,JJx, J1p,JJy,jc, Jtot,jn,J2);
-                       double xikcabn = X3.GetME_pn(J1p,Jab,twoJy, i,k,c,a,b,n);
-                       double yikcabn = Y3.GetME_pn(J1p,Jab,twoJy, i,k,c,a,b,n);
-                       z_ijklmn -=  occ_factor * phase * hats * sixj * ninej * ( xabjlmc*yikcabn - yabjlmc*xikcabn );
+                      double JJy = 0.5 * twoJy;
+                      double hats = (twoJx+1)*(twoJy+1) * sqrt( (2*J1+1)*(2*J1p+1));
+                      double ninej = Z.modelspace->GetNineJ( jj,Jab,JJx, J1p,JJy,jc, Jtot,jn,J2);
+                      double xikcabn = X3.GetME_pn(J1p,Jab,twoJy, i,k,c,a,b,n);
+                      double yikcabn = Y3.GetME_pn(J1p,Jab,twoJy, i,k,c,a,b,n);
+                      z_ijklmn -=  occ_factor * phase * hats * sixj * ninej * ( xabjlmc*yikcabn - yabjlmc*xikcabn );
                     }// for twoJy
                   }// for J1p
                 }// for twoJx
               }// Z3 block
-//              std::cout << "  after Z3  " << z_ijklmn << std::endl;
+              //              std::cout << "  after Z3  " << z_ijklmn << std::endl;
 
 
               // Z4 term  Pln    Xabknmc Yijcabl
               if ( ((oa.l+ob.l+ok.l+on.l+om.l+oc.l)%2==0) and ((oi.l+oj.l+oc.l+oa.l+ob.l+ol.l)%2==0)
-               and  ( (oa.tz2+ob.tz2+ok.tz2)==(on.tz2+om.tz2+oc.tz2) ) and ( (oi.tz2+oj.tz2+oc.tz2)==(oa.tz2+ob.tz2+ol.tz2)) 
-                and keep_abk and keep_nmc and keep_ijc and keep_abl )
+                  and  ( (oa.tz2+ob.tz2+ok.tz2)==(on.tz2+om.tz2+oc.tz2) ) and ( (oi.tz2+oj.tz2+oc.tz2)==(oa.tz2+ob.tz2+ol.tz2))
+                  and keep_abk and keep_nmc and keep_ijc and keep_abl )
               {
                 int twoJy_min = std::max( std::abs(2*J1 - oc.j2), std::abs(2*Jab - ol.j2) );
                 int twoJy_max = std::min( 2*J1+oc.j2 , 2*Jab + ol.j2 );
@@ -8514,13 +8739,13 @@ void comm333_pph_hhpss_debug( const Operator& X, const Operator& Y, Operator& Z
                   }// for J2p
                 }// for twoJy
               }// Z4 block
-//              std::cout << "  after Z4  " << z_ijklmn << std::endl;
+              //              std::cout << "  after Z4  " << z_ijklmn << std::endl;
 
 
               // Z5 term  Pmn    Xabklnc Yijcabm
               if ( ((oa.l+ob.l+ok.l+ol.l+on.l+oc.l)%2==0) and ((oi.l+oj.l+oc.l+oa.l+ob.l+om.l)%2==0)
-               and  ( (oa.tz2+ob.tz2+ok.tz2)==(ol.tz2+on.tz2+oc.tz2) ) and ( (oi.tz2+oj.tz2+oc.tz2)==(oa.tz2+ob.tz2+om.tz2)) 
-                and keep_abk and keep_lnc and keep_ijc and keep_abm )
+                  and  ( (oa.tz2+ob.tz2+ok.tz2)==(ol.tz2+on.tz2+oc.tz2) ) and ( (oi.tz2+oj.tz2+oc.tz2)==(oa.tz2+ob.tz2+om.tz2))
+                  and keep_abk and keep_lnc and keep_ijc and keep_abm )
               {
                 int twoJy_min = std::max( std::abs(2*J1 - oc.j2), std::abs(2*Jab - om.j2) );
                 int twoJy_max = std::min( 2*J1+oc.j2 , 2*Jab + om.j2 );
@@ -8550,13 +8775,13 @@ void comm333_pph_hhpss_debug( const Operator& X, const Operator& Y, Operator& Z
                   }// for J2p
                 }// for twoJy
               }// Z5 block
-//              std::cout << "  after Z5  " << z_ijklmn << std::endl;
+              //              std::cout << "  after Z5  " << z_ijklmn << std::endl;
 
 
               // Z6 term  Pik Pln    Xabinmc Ykjcabl
               if ( ((oa.l+ob.l+oi.l+on.l+om.l+oc.l)%2==0) and ((ok.l+oj.l+oc.l+oa.l+ob.l+ol.l)%2==0)
-               and  ( (oa.tz2+ob.tz2+oi.tz2)==(on.tz2+om.tz2+oc.tz2) ) and ( (ok.tz2+oj.tz2+oc.tz2)==(oa.tz2+ob.tz2+ol.tz2)) 
-                and keep_abi and keep_nmc and keep_kjc and keep_abl )
+                  and  ( (oa.tz2+ob.tz2+oi.tz2)==(on.tz2+om.tz2+oc.tz2) ) and ( (ok.tz2+oj.tz2+oc.tz2)==(oa.tz2+ob.tz2+ol.tz2))
+                  and keep_abi and keep_nmc and keep_kjc and keep_abl )
               {
                 int J1p_min = std::abs( ok.j2 - oj.j2 )/2;
                 int J1p_max = ( ok.j2 + oj.j2 )/2;
@@ -8583,25 +8808,25 @@ void comm333_pph_hhpss_debug( const Operator& X, const Operator& Y, Operator& Z
                       int phase = 1;
                       for (int twoJy=twoJy_min; twoJy<=twoJy_max; twoJy+=2)
                       {
-//                         if (twoJy==5) continue;
-                         double JJy = 0.5 * twoJy;
-                         double hats = (twoJx+1)*(twoJy+1) * sqrt( (2*J1+1)*(2*J1p+1)*(2*J2+1)*(2*J2p+1) );
-                         double ninej = Z.modelspace->GetNineJ( ji,Jab,JJx, J1p,JJy,jc, Jtot,jl,J2p);
-                         double xkjcabl = X3.GetME_pn(J1p,Jab,twoJy, k,j,c,a,b,l);
-                         double ykjcabl = Y3.GetME_pn(J1p,Jab,twoJy, k,j,c,a,b,l);
-                         z_ijklmn +=  occ_factor * phase * hats * sixj1 * sixj2 * ninej * ( xabinmc*ykjcabl - yabinmc*xkjcabl );
+                        //                         if (twoJy==5) continue;
+                        double JJy = 0.5 * twoJy;
+                        double hats = (twoJx+1)*(twoJy+1) * sqrt( (2*J1+1)*(2*J1p+1)*(2*J2+1)*(2*J2p+1) );
+                        double ninej = Z.modelspace->GetNineJ( ji,Jab,JJx, J1p,JJy,jc, Jtot,jl,J2p);
+                        double xkjcabl = X3.GetME_pn(J1p,Jab,twoJy, k,j,c,a,b,l);
+                        double ykjcabl = Y3.GetME_pn(J1p,Jab,twoJy, k,j,c,a,b,l);
+                        z_ijklmn +=  occ_factor * phase * hats * sixj1 * sixj2 * ninej * ( xabinmc*ykjcabl - yabinmc*xkjcabl );
                       }// for twoJy
                     }// for J1p
                   }// for twoJx
                 }// for J2p
               }// Z6 block
-//              std::cout << "  after Z6  " << z_ijklmn << std::endl;
+              //              std::cout << "  after Z6  " << z_ijklmn << std::endl;
 
 
               // Z7 term  Pjk Pln    Xabjnmc Yikcabl
               if ( ((oa.l+ob.l+oj.l+on.l+om.l+oc.l)%2==0) and ((oi.l+ok.l+oc.l+oa.l+ob.l+ol.l)%2==0)
-               and  ( (oa.tz2+ob.tz2+oj.tz2)==(on.tz2+om.tz2+oc.tz2) ) and ( (oi.tz2+ok.tz2+oc.tz2)==(oa.tz2+ob.tz2+ol.tz2)) 
-                and keep_abj and keep_nmc and keep_ikc and keep_abl )
+                  and  ( (oa.tz2+ob.tz2+oj.tz2)==(on.tz2+om.tz2+oc.tz2) ) and ( (oi.tz2+ok.tz2+oc.tz2)==(oa.tz2+ob.tz2+ol.tz2))
+                  and keep_abj and keep_nmc and keep_ikc and keep_abl )
               {
                 int J1p_min = std::abs( oi.j2 - ok.j2 )/2;
                 int J1p_max = ( oi.j2 + ok.j2 )/2;
@@ -8628,18 +8853,18 @@ void comm333_pph_hhpss_debug( const Operator& X, const Operator& Y, Operator& Z
                       int phase = -Z.modelspace->phase( (oj.j2+ok.j2)/2+J1+J1p);
                       for (int twoJy=twoJy_min; twoJy<=twoJy_max; twoJy+=2)
                       {
-                         double JJy = 0.5 * twoJy;
-                         double hats = (twoJx+1)*(twoJy+1) * sqrt( (2*J1+1)*(2*J1p+1)*(2*J2+1)*(2*J2p+1) );
-                         double ninej = Z.modelspace->GetNineJ( jj,Jab,JJx, J1p,JJy,jc, Jtot,jl,J2p);
-                         double xikcabl = X3.GetME_pn(J1p,Jab,twoJy, i,k,c,a,b,l);
-                         double yikcabl = Y3.GetME_pn(J1p,Jab,twoJy, i,k,c,a,b,l);
-                         z_ijklmn +=  occ_factor * phase * hats * sixj1 * sixj2 * ninej * ( xabjnmc*yikcabl - yabjnmc*xikcabl );
+                        double JJy = 0.5 * twoJy;
+                        double hats = (twoJx+1)*(twoJy+1) * sqrt( (2*J1+1)*(2*J1p+1)*(2*J2+1)*(2*J2p+1) );
+                        double ninej = Z.modelspace->GetNineJ( jj,Jab,JJx, J1p,JJy,jc, Jtot,jl,J2p);
+                        double xikcabl = X3.GetME_pn(J1p,Jab,twoJy, i,k,c,a,b,l);
+                        double yikcabl = Y3.GetME_pn(J1p,Jab,twoJy, i,k,c,a,b,l);
+                        z_ijklmn +=  occ_factor * phase * hats * sixj1 * sixj2 * ninej * ( xabjnmc*yikcabl - yabjnmc*xikcabl );
                       }// for twoJy
                     }// for J1p
                   }// for twoJx
                 }// for J2p
               }// Z7 block
-//              std::cout << "  after Z7  " << z_ijklmn << std::endl;
+              //              std::cout << "  after Z7  " << z_ijklmn << std::endl;
 
 
 
@@ -8647,8 +8872,8 @@ void comm333_pph_hhpss_debug( const Operator& X, const Operator& Y, Operator& Z
 
               // Z8 term  Pik Pmn    Xabilnc Ykjcabm
               if ( ((oa.l+ob.l+oi.l+ol.l+on.l+oc.l)%2==0) and ((ok.l+oj.l+oc.l+oa.l+ob.l+om.l)%2==0)
-               and  ( (oa.tz2+ob.tz2+oi.tz2)==(ol.tz2+on.tz2+oc.tz2) ) and ( (ok.tz2+oj.tz2+oc.tz2)==(oa.tz2+ob.tz2+om.tz2)) 
-                and keep_abi and keep_lnc and keep_kjc and keep_abm )
+                  and  ( (oa.tz2+ob.tz2+oi.tz2)==(ol.tz2+on.tz2+oc.tz2) ) and ( (ok.tz2+oj.tz2+oc.tz2)==(oa.tz2+ob.tz2+om.tz2))
+                  and keep_abi and keep_lnc and keep_kjc and keep_abm )
               {
                 int J1p_min = std::abs( ok.j2 - oj.j2 )/2;
                 int J1p_max = ( ok.j2 + oj.j2 )/2;
@@ -8675,18 +8900,18 @@ void comm333_pph_hhpss_debug( const Operator& X, const Operator& Y, Operator& Z
                       int phase = -Z.modelspace->phase( (om.j2+on.j2)/2+J2+J2p);
                       for (int twoJy=twoJy_min; twoJy<=twoJy_max; twoJy+=2)
                       {
-                         double JJy = 0.5 * twoJy;
-                         double hats = (twoJx+1)*(twoJy+1) * sqrt( (2*J1+1)*(2*J1p+1)*(2*J2+1)*(2*J2p+1) );
-                         double ninej = Z.modelspace->GetNineJ( ji,Jab,JJx, J1p,JJy,jc, Jtot,jm,J2p);
-                         double xkjcabm = X3.GetME_pn(J1p,Jab,twoJy, k,j,c,a,b,m);
-                         double ykjcabm = Y3.GetME_pn(J1p,Jab,twoJy, k,j,c,a,b,m);
-                         z_ijklmn +=  occ_factor * phase * hats * sixj1 * sixj2 * ninej * ( xabilnc*ykjcabm - yabilnc*xkjcabm );
+                        double JJy = 0.5 * twoJy;
+                        double hats = (twoJx+1)*(twoJy+1) * sqrt( (2*J1+1)*(2*J1p+1)*(2*J2+1)*(2*J2p+1) );
+                        double ninej = Z.modelspace->GetNineJ( ji,Jab,JJx, J1p,JJy,jc, Jtot,jm,J2p);
+                        double xkjcabm = X3.GetME_pn(J1p,Jab,twoJy, k,j,c,a,b,m);
+                        double ykjcabm = Y3.GetME_pn(J1p,Jab,twoJy, k,j,c,a,b,m);
+                        z_ijklmn +=  occ_factor * phase * hats * sixj1 * sixj2 * ninej * ( xabilnc*ykjcabm - yabilnc*xkjcabm );
                       }// for twoJy
                     }// for J1p
                   }// for twoJx
                 }// for J2p
               }// Z8 block
-//              std::cout << "  after Z8  " << z_ijklmn << std::endl;
+              //              std::cout << "  after Z8  " << z_ijklmn << std::endl;
 
 
 
@@ -8694,8 +8919,8 @@ void comm333_pph_hhpss_debug( const Operator& X, const Operator& Y, Operator& Z
 
               // Z9 term  Pjk Pmn    Xabjlnc Yikcabm
               if ( ((oa.l+ob.l+oj.l+ol.l+on.l+oc.l)%2==0) and ((oi.l+ok.l+oc.l+oa.l+ob.l+om.l)%2==0)
-               and  ( (oa.tz2+ob.tz2+oj.tz2)==(ol.tz2+on.tz2+oc.tz2) ) and ( (oi.tz2+ok.tz2+oc.tz2)==(oa.tz2+ob.tz2+om.tz2)) 
-                and keep_abj and keep_lnc and keep_ikc and keep_abm )
+                  and  ( (oa.tz2+ob.tz2+oj.tz2)==(ol.tz2+on.tz2+oc.tz2) ) and ( (oi.tz2+ok.tz2+oc.tz2)==(oa.tz2+ob.tz2+om.tz2))
+                  and keep_abj and keep_lnc and keep_ikc and keep_abm )
               {
                 int J1p_min = std::abs( oi.j2 - ok.j2 )/2;
                 int J1p_max = ( oi.j2 + ok.j2 )/2;
@@ -8722,25 +8947,25 @@ void comm333_pph_hhpss_debug( const Operator& X, const Operator& Y, Operator& Z
                       int phase = Z.modelspace->phase( (oj.j2+ok.j2+om.j2+on.j2)/2+J1+J1p+J2+J2p);
                       for (int twoJy=twoJy_min; twoJy<=twoJy_max; twoJy+=2)
                       {
-                         double JJy = 0.5 * twoJy;
-                         double hats = (twoJx+1)*(twoJy+1) * sqrt( (2*J1+1)*(2*J1p+1)*(2*J2+1)*(2*J2p+1) );
-                         double ninej = Z.modelspace->GetNineJ( jj,Jab,JJx, J1p,JJy,jc, Jtot,jm,J2p);
-                         double xikcabm = X3.GetME_pn(J1p,Jab,twoJy, i,k,c,a,b,m);
-                         double yikcabm = Y3.GetME_pn(J1p,Jab,twoJy, i,k,c,a,b,m);
-                         z_ijklmn +=  occ_factor * phase * hats * sixj1 * sixj2 * ninej * ( xabjlnc*yikcabm - yabjlnc*xikcabm );
+                        double JJy = 0.5 * twoJy;
+                        double hats = (twoJx+1)*(twoJy+1) * sqrt( (2*J1+1)*(2*J1p+1)*(2*J2+1)*(2*J2p+1) );
+                        double ninej = Z.modelspace->GetNineJ( jj,Jab,JJx, J1p,JJy,jc, Jtot,jm,J2p);
+                        double xikcabm = X3.GetME_pn(J1p,Jab,twoJy, i,k,c,a,b,m);
+                        double yikcabm = Y3.GetME_pn(J1p,Jab,twoJy, i,k,c,a,b,m);
+                        z_ijklmn +=  occ_factor * phase * hats * sixj1 * sixj2 * ninej * ( xabjlnc*yikcabm - yabjlnc*xikcabm );
                       }// for twoJy
                     }// for J1p
                   }// for twoJx
                 }// for J2p
               }// Z9 block
-//              std::cout << "  after Z9  " << z_ijklmn << std::endl;
+              //              std::cout << "  after Z9  " << z_ijklmn << std::endl;
 
 
 
             }// for c
           }// for iket_ab
         }// for ch2
-//        std::cout << "  " << i << " " << j << " " << k << " " << l << " " << m << " " << n << "  J1 J2 two J " << J1 << " " << J2 << " " << twoJ << "   Z = " << z_ijklmn << std::endl;
+        //        std::cout << "  " << i << " " << j << " " << k << " " << l << " " << m << " " << n << "  J1 J2 two J " << J1 << " " << J2 << " " << twoJ << "   Z = " << z_ijklmn << std::endl;
         Z3.AddToME_pn_PN_ch( ch3, ch3, ibra, iket, z_ijklmn);
       }// for iket
     }// for ibra
@@ -8769,9 +8994,9 @@ void comm333_pph_hhpss_debug( const Operator& X, const Operator& Y, Operator& Z
 // This is no different from the scalar-scalar version
 void comm111st( const Operator & X, const Operator& Y, Operator& Z)
 {
-   double tstart = omp_get_wtime();
-   comm111ss(X,Y,Z);
-   X.profiler.timer["comm111st"] += omp_get_wtime() - tstart;
+  double tstart = omp_get_wtime();
+  comm111ss(X,Y,Z);
+  X.profiler.timer["comm111st"] += omp_get_wtime() - tstart;
 }
 
 
@@ -8779,94 +9004,94 @@ void comm111st( const Operator & X, const Operator& Y, Operator& Z)
 //                                       |
 //      i |              i |             |
 //        |    ___.Y       |__X__        |
-//        |___(_)    _     |   (_)__.    |  [X2,Y1](1)  =  1/(2j_i+1) sum_ab(n_a-n_b)y_ab 
-//      j | X            j |        Y    |        * sum_J (2J+1) x_biaj^(J)  
-//                                       |      
+//        |___(_)    _     |   (_)__.    |  [X2,Y1](1)  =  1/(2j_i+1) sum_ab(n_a-n_b)y_ab
+//      j | X            j |        Y    |        * sum_J (2J+1) x_biaj^(J)
+//                                       |
 //---------------------------------------*        = 1/(2j+1) sum_a n_a sum_J (2J+1)
 //                                                  * sum_b y_ab x_biaj - yba x_aibj
 //
 // X is scalar one-body, Y is tensor two-body
-// There must be a better way to do this looping. 
+// There must be a better way to do this looping.
 //
-//void Operator::comm121st( Operator& Y, Operator& Z) 
-void comm121st( const Operator& X, const Operator& Y, Operator& Z) 
+//void Operator::comm121st( Operator& Y, Operator& Z)
+void comm121st( const Operator& X, const Operator& Y, Operator& Z)
 {
 
-   double tstart = omp_get_wtime();
-//   int norbits = Z.modelspace->GetNumberOrbits();
-   int norbits = Z.modelspace->all_orbits.size();
-   int Lambda = Z.GetJRank();
-   Z.modelspace->PreCalculateSixJ();
-   std::vector<index_t> allorb_vec(Z.modelspace->all_orbits.begin(), Z.modelspace->all_orbits.end());
-   #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->tensor_transform_first_pass.at(Z.rank_J))
-   for (int indexi=0;indexi<norbits;++indexi)
-//   for (int i=0;i<norbits;++i)
-   {
-//      auto i = Z.modelspace->all_orbits[indexi];
-      auto i = allorb_vec[indexi];
-      Orbit &oi = Z.modelspace->GetOrbit(i);
-      double ji = 0.5*oi.j2;
-      for (auto j : Z.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) ) 
+  double tstart = omp_get_wtime();
+  //   int norbits = Z.modelspace->GetNumberOrbits();
+  int norbits = Z.modelspace->all_orbits.size();
+  int Lambda = Z.GetJRank();
+  Z.modelspace->PreCalculateSixJ();
+  std::vector<index_t> allorb_vec(Z.modelspace->all_orbits.begin(), Z.modelspace->all_orbits.end());
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->tensor_transform_first_pass.at(Z.rank_J))
+  for (int indexi=0;indexi<norbits;++indexi)
+    //   for (int i=0;i<norbits;++i)
+  {
+    //      auto i = Z.modelspace->all_orbits[indexi];
+    auto i = allorb_vec[indexi];
+    Orbit &oi = Z.modelspace->GetOrbit(i);
+    double ji = 0.5*oi.j2;
+    for (auto j : Z.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) )
+    {
+      Orbit &oj = Z.modelspace->GetOrbit(j);
+      double jj = 0.5*oj.j2;
+      if (j<i) continue; // only calculate upper triangle
+      double& Zij = Z.OneBody(i,j);
+      for (auto a : Z.modelspace->holes)  // C++11 syntax
       {
-          Orbit &oj = Z.modelspace->GetOrbit(j);
-          double jj = 0.5*oj.j2;
-          if (j<i) continue; // only calculate upper triangle
-          double& Zij = Z.OneBody(i,j);
-          for (auto a : Z.modelspace->holes)  // C++11 syntax
+        Orbit &oa = Z.modelspace->GetOrbit(a);
+        double ja = 0.5*oa.j2;
+        for (auto b : X.OneBodyChannels.at({oa.l,oa.j2,oa.tz2}) )
+        {
+          Orbit &ob = Z.modelspace->GetOrbit(b);
+          double nanb = oa.occ * (1-ob.occ);
+          int J1min = std::abs(ji-ja);
+          int J1max = ji + ja;
+          for (int J1=J1min; J1<=J1max; ++J1)
           {
-             Orbit &oa = Z.modelspace->GetOrbit(a);
-             double ja = 0.5*oa.j2;
-             for (auto b : X.OneBodyChannels.at({oa.l,oa.j2,oa.tz2}) ) 
-             {
-                Orbit &ob = Z.modelspace->GetOrbit(b);
-                double nanb = oa.occ * (1-ob.occ);
-                  int J1min = std::abs(ji-ja);
-                  int J1max = ji + ja;
-                  for (int J1=J1min; J1<=J1max; ++J1)
-                  {
-                    int phasefactor = Z.modelspace->phase(jj+ja+J1+Lambda);
-                    int J2min = std::max(std::abs(Lambda - J1),std::abs(int(ja-jj)));
-                    int J2max = std::min(Lambda + J1,int(ja+jj));
-                    for (int J2=J2min; J2<=J2max; ++J2)
-                    {
-                      if ( ! ( J2>=std::abs(ja-jj) and J2<=ja+jj )) continue;
-                      double prefactor = nanb*phasefactor * sqrt((2*J1+1)*(2*J2+1)) * Z.modelspace->GetSixJ(J1,J2,Lambda,jj,ji,ja);
-                      Zij +=  prefactor * ( X.OneBody(a,b) * Y.TwoBody.GetTBME_J(J1,J2,b,i,a,j) - X.OneBody(b,a) * Y.TwoBody.GetTBME_J(J1,J2,a,i,b,j ));
-                    }
-                  }
-             }
-             // Now, X is scalar two-body and Y is tensor one-body
-             for (auto& b : Y.OneBodyChannels.at({oa.l,oa.j2,oa.tz2}) ) 
-             {
+            int phasefactor = Z.modelspace->phase(jj+ja+J1+Lambda);
+            int J2min = std::max(std::abs(Lambda - J1),std::abs(int(ja-jj)));
+            int J2max = std::min(Lambda + J1,int(ja+jj));
+            for (int J2=J2min; J2<=J2max; ++J2)
+            {
+              if ( ! ( J2>=std::abs(ja-jj) and J2<=ja+jj )) continue;
+              double prefactor = nanb*phasefactor * sqrt((2*J1+1)*(2*J2+1)) * Z.modelspace->GetSixJ(J1,J2,Lambda,jj,ji,ja);
+              Zij +=  prefactor * ( X.OneBody(a,b) * Y.TwoBody.GetTBME_J(J1,J2,b,i,a,j) - X.OneBody(b,a) * Y.TwoBody.GetTBME_J(J1,J2,a,i,b,j ));
+            }
+          }
+        }
+        // Now, X is scalar two-body and Y is tensor one-body
+        for (auto& b : Y.OneBodyChannels.at({oa.l,oa.j2,oa.tz2}) )
+        {
+
+          Orbit &ob = Z.modelspace->GetOrbit(b);
+          double jb = 0.5*ob.j2;
+          if (std::abs(ob.occ-1) < ModelSpace::OCC_CUT) continue;
+          double nanb = oa.occ * (1-ob.occ);
+          int J1min = std::max(std::abs(ji-jb),std::abs(jj-ja));
+          int J1max = std::min(ji+jb,jj+ja);
+          double zij = 0;
+          for (int J1=J1min; J1<=J1max; ++J1)
+          {
+            zij -= Z.modelspace->phase(ji+jb+J1) * (2*J1+1) * Z.modelspace->GetSixJ(ja,jb,Lambda,ji,jj,J1) * X.TwoBody.GetTBME_J(J1,J1,b,i,a,j);
+          }
 
-                Orbit &ob = Z.modelspace->GetOrbit(b);
-                double jb = 0.5*ob.j2;
-                if (std::abs(ob.occ-1) < ModelSpace::OCC_CUT) continue;
-                double nanb = oa.occ * (1-ob.occ);
-                int J1min = std::max(std::abs(ji-jb),std::abs(jj-ja));
-                int J1max = std::min(ji+jb,jj+ja);
-                double zij = 0;
-                for (int J1=J1min; J1<=J1max; ++J1)
-                {
-                  zij -= Z.modelspace->phase(ji+jb+J1) * (2*J1+1) * Z.modelspace->GetSixJ(ja,jb,Lambda,ji,jj,J1) * X.TwoBody.GetTBME_J(J1,J1,b,i,a,j);
-                }
+          J1min = std::max(std::abs(ji-ja),std::abs(jj-jb));
+          J1max = std::min(ji+ja,jj+jb);
+          for (int J1=J1min; J1<=J1max; ++J1)
+          {
+            zij += Z.modelspace->phase(ji+jb+J1) * (2*J1+1) * Z.modelspace->GetSixJ(jb,ja,Lambda,ji,jj,J1) * X.TwoBody.GetTBME_J(J1,J1,a,i,b,j) ;
+          }
 
-                J1min = std::max(std::abs(ji-ja),std::abs(jj-jb));
-                J1max = std::min(ji+ja,jj+jb);
-                for (int J1=J1min; J1<=J1max; ++J1)
-                {
-                  zij += Z.modelspace->phase(ji+jb+J1) * (2*J1+1) * Z.modelspace->GetSixJ(jb,ja,Lambda,ji,jj,J1) * X.TwoBody.GetTBME_J(J1,J1,a,i,b,j) ;
-                }
+          Zij += nanb * Y.OneBody(a,b) * zij;
+        }
 
-                Zij += nanb * Y.OneBody(a,b) * zij;
-             }
 
-             
-          }
       }
-   }
-   
-   X.profiler.timer["comm121st"] += omp_get_wtime() - tstart;
+    }
+  }
+
+  X.profiler.timer["comm121st"] += omp_get_wtime() - tstart;
 }
 
 
@@ -8875,191 +9100,191 @@ void comm121st( const Operator& X, const Operator& Y, Operator& Z)
 //*****************************************************************************************
 //
 //    |     |               |      |           [X2,Y1](2) = sum_a ( Y_ia X_ajkl + Y_ja X_iakl - Y_ak X_ijal - Y_al X_ijka )
-//    |     |___.Y          |__X___|         
-//    |     |         _     |      |          
-//    |_____|               |      |_____.Y        
-//    |  X  |               |      |            
+//    |     |___.Y          |__X___|
+//    |     |         _     |      |
+//    |_____|               |      |_____.Y
+//    |  X  |               |      |
 //
 // -- AGREES WITH NATHAN'S RESULTS
 // Right now, this is the slowest one...
 // Agrees with previous code in the scalar-scalar limit
-//void Operator::comm122st( Operator& Y, Operator& Z ) 
-//void Operator::comm122st( const Operator& X, const Operator& Y ) 
-void comm122st( const Operator& X, const Operator& Y , Operator& Z) 
+//void Operator::comm122st( Operator& Y, Operator& Z )
+//void Operator::comm122st( const Operator& X, const Operator& Y )
+void comm122st( const Operator& X, const Operator& Y , Operator& Z)
 {
-   double tstart = omp_get_wtime();
-   int Lambda = Z.rank_J;
+  double tstart = omp_get_wtime();
+  int Lambda = Z.rank_J;
 
-    std::vector< int > bra_channels;
-    std::vector< int > ket_channels;
-    for ( auto& itmat : Z.TwoBody.MatEl )
-    {
-      bra_channels.push_back( itmat.first[0] );
-      ket_channels.push_back( itmat.first[1] );
-    }
-    int nmat = bra_channels.size();
-   #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->tensor_transform_first_pass.at(Z.rank_J))
-    for (int ii=0; ii<nmat; ++ii)
-    {
-     int ch_bra = bra_channels[ii];
-     int ch_ket = ket_channels[ii];
+  std::vector< int > bra_channels;
+  std::vector< int > ket_channels;
+  for ( auto& itmat : Z.TwoBody.MatEl )
+  {
+    bra_channels.push_back( itmat.first[0] );
+    ket_channels.push_back( itmat.first[1] );
+  }
+  int nmat = bra_channels.size();
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->tensor_transform_first_pass.at(Z.rank_J))
+  for (int ii=0; ii<nmat; ++ii)
+  {
+    int ch_bra = bra_channels[ii];
+    int ch_ket = ket_channels[ii];
 
-      TwoBodyChannel& tbc_bra = Z.modelspace->GetTwoBodyChannel(ch_bra);
-      TwoBodyChannel& tbc_ket = Z.modelspace->GetTwoBodyChannel(ch_ket);
-      int J1 = tbc_bra.J;
-      int J2 = tbc_ket.J;
-      int nbras = tbc_bra.GetNumberKets();
-      int nkets = tbc_ket.GetNumberKets();
-      double hatfactor = sqrt((2*J1+1)*(2*J2+1));
-      arma::mat& Z2 = Z.TwoBody.GetMatrix(ch_bra,ch_ket);
+    TwoBodyChannel& tbc_bra = Z.modelspace->GetTwoBodyChannel(ch_bra);
+    TwoBodyChannel& tbc_ket = Z.modelspace->GetTwoBodyChannel(ch_ket);
+    int J1 = tbc_bra.J;
+    int J2 = tbc_ket.J;
+    int nbras = tbc_bra.GetNumberKets();
+    int nkets = tbc_ket.GetNumberKets();
+    double hatfactor = sqrt((2*J1+1)*(2*J2+1));
+    arma::mat& Z2 = Z.TwoBody.GetMatrix(ch_bra,ch_ket);
 
-      for (int ibra = 0;ibra<nbras; ++ibra)
+    for (int ibra = 0;ibra<nbras; ++ibra)
+    {
+      Ket & bra = tbc_bra.GetKet(ibra);
+      int i = bra.p;
+      int j = bra.q;
+      Orbit& oi = Z.modelspace->GetOrbit(i);
+      Orbit& oj = Z.modelspace->GetOrbit(j);
+      double ji = oi.j2/2.0;
+      double jj = oj.j2/2.0;
+      for (int iket=0;iket<nkets; ++iket)
       {
-         Ket & bra = tbc_bra.GetKet(ibra);
-         int i = bra.p;
-         int j = bra.q;
-         Orbit& oi = Z.modelspace->GetOrbit(i);
-         Orbit& oj = Z.modelspace->GetOrbit(j);
-         double ji = oi.j2/2.0;
-         double jj = oj.j2/2.0;
-         for (int iket=0;iket<nkets; ++iket)
-         {
-            Ket & ket = tbc_ket.GetKet(iket);
-            int k = ket.p;
-            int l = ket.q;
-            Orbit& ok = Z.modelspace->GetOrbit(k);
-            Orbit& ol = Z.modelspace->GetOrbit(l);
-            double jk = ok.j2/2.0;
-            double jl = ol.j2/2.0;
-
-            double cijkl = 0;
-            double c1 = 0;
-            double c2 = 0;
-            double c3 = 0;
-            double c4 = 0;
-
-            for ( int a : X.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) )
-            {
-              c1 += X.OneBody(i,a) * Y.TwoBody.GetTBME(ch_bra,ch_ket,a,j,k,l);
-            }
-            if (i==j)
-            {
-              c2 = c1; // there should be a phase here, but if the ket exists, it'd better be +1.
-            }
-            else
-            {
-              for ( int a : X.OneBodyChannels.at({oj.l,oj.j2,oj.tz2}) )
-              {
-                 c2 += X.OneBody(j,a) * Y.TwoBody.GetTBME(ch_bra,ch_ket,i,a,k,l);
-              }
-            }
-            for ( int a : X.OneBodyChannels.at({ok.l,ok.j2,ok.tz2}) )
-            {
-               c3 += X.OneBody(a,k) * Y.TwoBody.GetTBME(ch_bra,ch_ket,i,j,a,l);
-            }
-            if (k==l)
-            {
-              c4 = c3 ;
-            }
-            else
-            {
-              for ( int a : X.OneBodyChannels.at({ol.l,ol.j2,ol.tz2}) )
-              {
-                 c4 += X.OneBody(a,l) * Y.TwoBody.GetTBME(ch_bra,ch_ket,i,j,k,a);
-              }
-            }
+        Ket & ket = tbc_ket.GetKet(iket);
+        int k = ket.p;
+        int l = ket.q;
+        Orbit& ok = Z.modelspace->GetOrbit(k);
+        Orbit& ol = Z.modelspace->GetOrbit(l);
+        double jk = ok.j2/2.0;
+        double jl = ol.j2/2.0;
+
+        double cijkl = 0;
+        double c1 = 0;
+        double c2 = 0;
+        double c3 = 0;
+        double c4 = 0;
+
+        for ( int a : X.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) )
+        {
+          c1 += X.OneBody(i,a) * Y.TwoBody.GetTBME(ch_bra,ch_ket,a,j,k,l);
+        }
+        if (i==j)
+        {
+          c2 = c1; // there should be a phase here, but if the ket exists, it'd better be +1.
+        }
+        else
+        {
+          for ( int a : X.OneBodyChannels.at({oj.l,oj.j2,oj.tz2}) )
+          {
+            c2 += X.OneBody(j,a) * Y.TwoBody.GetTBME(ch_bra,ch_ket,i,a,k,l);
+          }
+        }
+        for ( int a : X.OneBodyChannels.at({ok.l,ok.j2,ok.tz2}) )
+        {
+          c3 += X.OneBody(a,k) * Y.TwoBody.GetTBME(ch_bra,ch_ket,i,j,a,l);
+        }
+        if (k==l)
+        {
+          c4 = c3 ;
+        }
+        else
+        {
+          for ( int a : X.OneBodyChannels.at({ol.l,ol.j2,ol.tz2}) )
+          {
+            c4 += X.OneBody(a,l) * Y.TwoBody.GetTBME(ch_bra,ch_ket,i,j,k,a);
+          }
+        }
 
-            cijkl = c1 + c2 - c3 - c4;
+        cijkl = c1 + c2 - c3 - c4;
 
 
-            c1=0;
-            c2=0;
-            c3=0;
-            c4=0;
-            int phase1 = Z.modelspace->phase(ji+jj+J2+Lambda);
-            int phase2 = Z.modelspace->phase(J1-J2+Lambda);
-            int phase3 = Z.modelspace->phase(J1-J2+Lambda);
-            int phase4 = Z.modelspace->phase(jk+jl-J1+Lambda);
+        c1=0;
+        c2=0;
+        c3=0;
+        c4=0;
+        int phase1 = Z.modelspace->phase(ji+jj+J2+Lambda);
+        int phase2 = Z.modelspace->phase(J1-J2+Lambda);
+        int phase3 = Z.modelspace->phase(J1-J2+Lambda);
+        int phase4 = Z.modelspace->phase(jk+jl-J1+Lambda);
 
 
-            for ( int a : Y.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) )
-            {
-               double ja = Z.modelspace->GetOrbit(a).j2*0.5;
-               c1 -=   Z.modelspace->GetSixJ(J2,J1,Lambda,ji,ja,jj) * Y.OneBody(i,a) * X.TwoBody.GetTBME(ch_ket,ch_ket,a,j,k,l) ;
-            }
-            if (i==j)
-            {
-              c2 = -c1;
-            }
-            else
-            {
-              for ( int a : Y.OneBodyChannels.at({oj.l,oj.j2,oj.tz2}) )
-              {
-                 double ja = Z.modelspace->GetOrbit(a).j2*0.5;
-                 c2 +=  Z.modelspace->GetSixJ(J2,J1,Lambda,jj,ja,ji) * Y.OneBody(j,a) * X.TwoBody.GetTBME(ch_ket,ch_ket,a,i,k,l);
-              }
-            }
-            for ( int a : Y.OneBodyChannels.at({ok.l,ok.j2,ok.tz2}) )
-            {
-               double ja = Z.modelspace->GetOrbit(a).j2*0.5;
-               c3 -=  Z.modelspace->GetSixJ(J1,J2,Lambda,jk,ja,jl) * Y.OneBody(a,k) * X.TwoBody.GetTBME(ch_bra,ch_bra,i,j,l,a) ;
-            }
-            if (k==l)
-            {
-              c4 = -c3;
-            }
-            else
-            {
-              for ( int a : Y.OneBodyChannels.at({ol.l,ol.j2,ol.tz2}) )
-              {
-                 double ja = Z.modelspace->GetOrbit(a).j2*0.5;
-                 c4 +=  Z.modelspace->GetSixJ(J1,J2,Lambda,jl,ja,jk) * Y.OneBody(a,l) * X.TwoBody.GetTBME(ch_bra,ch_bra,i,j,k,a) ;
-              }
-            }
-            cijkl += hatfactor*(phase1*c1+phase2*c2+phase3*c3+phase4*c4);
+        for ( int a : Y.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) )
+        {
+          double ja = Z.modelspace->GetOrbit(a).j2*0.5;
+          c1 -=   Z.modelspace->GetSixJ(J2,J1,Lambda,ji,ja,jj) * Y.OneBody(i,a) * X.TwoBody.GetTBME(ch_ket,ch_ket,a,j,k,l) ;
+        }
+        if (i==j)
+        {
+          c2 = -c1;
+        }
+        else
+        {
+          for ( int a : Y.OneBodyChannels.at({oj.l,oj.j2,oj.tz2}) )
+          {
+            double ja = Z.modelspace->GetOrbit(a).j2*0.5;
+            c2 +=  Z.modelspace->GetSixJ(J2,J1,Lambda,jj,ja,ji) * Y.OneBody(j,a) * X.TwoBody.GetTBME(ch_ket,ch_ket,a,i,k,l);
+          }
+        }
+        for ( int a : Y.OneBodyChannels.at({ok.l,ok.j2,ok.tz2}) )
+        {
+          double ja = Z.modelspace->GetOrbit(a).j2*0.5;
+          c3 -=  Z.modelspace->GetSixJ(J1,J2,Lambda,jk,ja,jl) * Y.OneBody(a,k) * X.TwoBody.GetTBME(ch_bra,ch_bra,i,j,l,a) ;
+        }
+        if (k==l)
+        {
+          c4 = -c3;
+        }
+        else
+        {
+          for ( int a : Y.OneBodyChannels.at({ol.l,ol.j2,ol.tz2}) )
+          {
+            double ja = Z.modelspace->GetOrbit(a).j2*0.5;
+            c4 +=  Z.modelspace->GetSixJ(J1,J2,Lambda,jl,ja,jk) * Y.OneBody(a,l) * X.TwoBody.GetTBME(ch_bra,ch_bra,i,j,k,a) ;
+          }
+        }
+        cijkl += hatfactor*(phase1*c1+phase2*c2+phase3*c3+phase4*c4);
 
 
-            double norm = bra.delta_pq()==ket.delta_pq() ? 1+bra.delta_pq() : PhysConst::SQRT2;
-            Z2(ibra,iket) += cijkl /norm;
-         }
+        double norm = bra.delta_pq()==ket.delta_pq() ? 1+bra.delta_pq() : PhysConst::SQRT2;
+        Z2(ibra,iket) += cijkl /norm;
       }
-   }
-   X.profiler.timer["comm122st"] += omp_get_wtime() - tstart;
+    }
+  }
+  X.profiler.timer["comm122st"] += omp_get_wtime() - tstart;
 }
 
 
 
 
 
-// Since comm222_pp_hh and comm211 both require the construction of 
+// Since comm222_pp_hh and comm211 both require the construction of
 // the intermediate matrices Mpp and Mhh, we can combine them and
 // only calculate the intermediates once.
 // X is a scalar, Y is a tensor
-//void Operator::comm222_pp_hh_221st( Operator& Y, Operator& Z )  
-//void Operator::comm222_pp_hh_221st( const Operator& X, const Operator& Y )  
-void comm222_pp_hh_221st( const Operator& X, const Operator& Y, Operator& Z )  
+//void Operator::comm222_pp_hh_221st( Operator& Y, Operator& Z )
+//void Operator::comm222_pp_hh_221st( const Operator& X, const Operator& Y )
+void comm222_pp_hh_221st( const Operator& X, const Operator& Y, Operator& Z )
 {
 
-   double tstart = omp_get_wtime();
-   int Lambda = Z.GetJRank();
+  double tstart = omp_get_wtime();
+  int Lambda = Z.GetJRank();
 
-   TwoBodyME Mpp = Y.TwoBody;
-   TwoBodyME Mhh = Y.TwoBody;
-   TwoBodyME Mff = Y.TwoBody;
+  TwoBodyME Mpp = Y.TwoBody;
+  TwoBodyME Mhh = Y.TwoBody;
+  TwoBodyME Mff = Y.TwoBody;
 
-   std::vector<int> vch_bra;
-   std::vector<int> vch_ket;
-   std::vector<const arma::mat*> vmtx;
-   for ( auto& itmat : Y.TwoBody.MatEl )
-   {
-     vch_bra.push_back(itmat.first[0]);
-     vch_ket.push_back(itmat.first[1]);
-     vmtx.push_back(&(itmat.second));
-   }
-   size_t nchan = vch_bra.size();
-   #pragma omp parallel for schedule(dynamic,1)
-   for (size_t i=0;i<nchan; ++i)
-   {
+  std::vector<int> vch_bra;
+  std::vector<int> vch_ket;
+  std::vector<const arma::mat*> vmtx;
+  for ( auto& itmat : Y.TwoBody.MatEl )
+  {
+    vch_bra.push_back(itmat.first[0]);
+    vch_ket.push_back(itmat.first[1]);
+    vmtx.push_back(&(itmat.second));
+  }
+  size_t nchan = vch_bra.size();
+#pragma omp parallel for schedule(dynamic,1)
+  for (size_t i=0;i<nchan; ++i)
+  {
     int ch_bra = vch_bra[i];
     int ch_ket = vch_ket[i];
 
@@ -9073,7 +9298,7 @@ void comm222_pp_hh_221st( const Operator& X, const Operator& Y, Operator& Z )
 
     arma::mat& Matrixpp =  Mpp.GetMatrix(ch_bra,ch_ket);
     arma::mat& Matrixhh =  Mhh.GetMatrix(ch_bra,ch_ket);
-   
+
     const arma::uvec& bras_pp = tbc_bra.GetKetIndex_pp();
     const arma::uvec& bras_hh = tbc_bra.GetKetIndex_hh();
     const arma::uvec& bras_ph = tbc_bra.GetKetIndex_ph();
@@ -9085,93 +9310,93 @@ void comm222_pp_hh_221st( const Operator& X, const Operator& Y, Operator& Z )
 
     arma::mat MLeft  = join_horiz( LHS1.cols(bras_hh) , -RHS.cols(kets_hh) );
     arma::mat MRight = join_vert( RHS.rows(bras_hh)  % tbc_bra.Ket_occ_hh.cols( arma::uvec(RHS.n_cols,arma::fill::zeros ) ),
-                                 LHS2.rows(kets_hh)  % tbc_ket.Ket_occ_hh.cols( arma::uvec(LHS2.n_cols,arma::fill::zeros) ));
+        LHS2.rows(kets_hh)  % tbc_ket.Ket_occ_hh.cols( arma::uvec(LHS2.n_cols,arma::fill::zeros) ));
 
     Matrixhh = MLeft * MRight;
 
 
     MLeft  = join_horiz( LHS1.cols(join_vert(bras_pp,join_vert(bras_hh,bras_ph))), -RHS.cols(join_vert(kets_pp,join_vert(kets_hh,kets_ph))) );
-    MRight = join_vert( join_vert(     RHS.rows(bras_pp), 
-                          join_vert( RHS.rows(bras_hh)  % tbc_bra.Ket_unocc_hh.cols( arma::uvec(RHS.n_cols,arma::fill::zeros) )  ,
-                                     RHS.rows(bras_ph)  % tbc_bra.Ket_unocc_ph.cols( arma::uvec(RHS.n_cols,arma::fill::zeros) ) )),
-                      join_vert(     LHS2.rows(kets_pp),
-                          join_vert( LHS2.rows(kets_hh) % tbc_ket.Ket_unocc_hh.cols( arma::uvec(LHS2.n_cols,arma::fill::zeros) ),
-                                     LHS2.rows(kets_ph) % tbc_ket.Ket_unocc_ph.cols( arma::uvec(LHS2.n_cols,arma::fill::zeros) )))
-                     );
+    MRight = join_vert( join_vert(     RHS.rows(bras_pp),
+          join_vert( RHS.rows(bras_hh)  % tbc_bra.Ket_unocc_hh.cols( arma::uvec(RHS.n_cols,arma::fill::zeros) )  ,
+            RHS.rows(bras_ph)  % tbc_bra.Ket_unocc_ph.cols( arma::uvec(RHS.n_cols,arma::fill::zeros) ) )),
+        join_vert(     LHS2.rows(kets_pp),
+          join_vert( LHS2.rows(kets_hh) % tbc_ket.Ket_unocc_hh.cols( arma::uvec(LHS2.n_cols,arma::fill::zeros) ),
+            LHS2.rows(kets_ph) % tbc_ket.Ket_unocc_ph.cols( arma::uvec(LHS2.n_cols,arma::fill::zeros) )))
+        );
 
     Matrixpp = MLeft * MRight;
-                                
+
 
     if (Z.GetParticleRank()>1)
     {
       Z.TwoBody.GetMatrix(ch_bra,ch_ket) += Matrixpp - Matrixhh;
     }
 
-   }// for itmat
+  }// for itmat
 
-      // The one body part takes some additional work
+  // The one body part takes some additional work
 
-//   int norbits = Z.modelspace->GetNumberOrbits();
-   int norbits = Z.modelspace->all_orbits.size();
-   std::vector<index_t> allorb_vec(Z.modelspace->all_orbits.begin(),Z.modelspace->all_orbits.end());
-   #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->tensor_transform_first_pass.at(Z.rank_J))
-   for (int indexi=0;indexi<norbits;++indexi)
-//   for (int i=0;i<norbits;++i)
-   {
-//      auto i = Z.modelspace->all_orbits[indexi];
-      auto i = allorb_vec[indexi];
-      Orbit &oi = Z.modelspace->GetOrbit(i);
-      double ji = oi.j2/2.0;
-      for (auto j : Z.OneBodyChannels.at({oi.l, oi.j2, oi.tz2}) )
+  //   int norbits = Z.modelspace->GetNumberOrbits();
+  int norbits = Z.modelspace->all_orbits.size();
+  std::vector<index_t> allorb_vec(Z.modelspace->all_orbits.begin(),Z.modelspace->all_orbits.end());
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->tensor_transform_first_pass.at(Z.rank_J))
+  for (int indexi=0;indexi<norbits;++indexi)
+    //   for (int i=0;i<norbits;++i)
+  {
+    //      auto i = Z.modelspace->all_orbits[indexi];
+    auto i = allorb_vec[indexi];
+    Orbit &oi = Z.modelspace->GetOrbit(i);
+    double ji = oi.j2/2.0;
+    for (auto j : Z.OneBodyChannels.at({oi.l, oi.j2, oi.tz2}) )
+    {
+      if (j<i) continue;
+      Orbit &oj = Z.modelspace->GetOrbit(j);
+      double jj = oj.j2/2.0;
+      double cijJ = 0;
+      // Sum c over holes and include the nbar_a * nbar_b terms
+      for (auto& c : Z.modelspace->holes)
       {
-         if (j<i) continue;
-         Orbit &oj = Z.modelspace->GetOrbit(j);
-         double jj = oj.j2/2.0;
-         double cijJ = 0;
-         // Sum c over holes and include the nbar_a * nbar_b terms
-           for (auto& c : Z.modelspace->holes)
-           {
-              Orbit &oc = Z.modelspace->GetOrbit(c);
-              double jc = oc.j2/2.0;
-              int j1min = std::abs(jc-ji);
-              int j1max = jc+ji;
-              for (int J1=j1min; J1<=j1max; ++J1)
-              {
-               int j2min = std::max( int(std::abs(jc-jj)), std::abs(Lambda-J1) );
-               int j2max = std::min( int(jc+jj), J1+Lambda ); 
-               for (int J2=j2min; J2<=j2max; ++J2)
-               {
-                double hatfactor = sqrt( (2*J1+1)*(2*J2+1) );
-                double sixj = Z.modelspace->GetSixJ(J1, J2, Lambda, jj, ji, jc);
-                cijJ += hatfactor * sixj * Z.modelspace->phase(jj + jc + J1 + Lambda)
-                        * ( oc.occ * Mpp.GetTBME_J(J1,J2,c,i,c,j) + (1-oc.occ) * Mhh.GetTBME_J(J1,J2,c,i,c,j));
-               }
-              }
-           // Sum c over particles and include the n_a * n_b terms
-           }
-           for (auto& c : Z.modelspace->particles)
-           {
-              Orbit &oc = Z.modelspace->GetOrbit(c);
-              double jc = oc.j2/2.0;
-              int j1min = std::abs(jc-ji);
-              int j1max = jc+ji;
-              for (int J1=j1min; J1<=j1max; ++J1)
-              {
-               int j2min = std::max( int(std::abs(jc-jj)), std::abs(Lambda-J1) );
-               int j2max = std::min( int(jc+jj), J1+Lambda ); 
-               for (int J2=j2min; J2<=j2max; ++J2)
-               {
-                double hatfactor = sqrt( (2*J1+1)*(2*J2+1) );
-                double sixj = Z.modelspace->GetSixJ(J1, J2, Lambda, jj, ji, jc);
-                cijJ += hatfactor * sixj * Z.modelspace->phase(jj + jc + J1 + Lambda) * Mhh.GetTBME_J(J1,J2,c,i,c,j);
-               }
-              }
-           }
-//         #pragma omp critical
-         Z.OneBody(i,j) += cijJ ;
-      } // for j
-    } // for i
-    X.profiler.timer["comm222_pp_hh_221st"] += omp_get_wtime() - tstart;
+        Orbit &oc = Z.modelspace->GetOrbit(c);
+        double jc = oc.j2/2.0;
+        int j1min = std::abs(jc-ji);
+        int j1max = jc+ji;
+        for (int J1=j1min; J1<=j1max; ++J1)
+        {
+          int j2min = std::max( int(std::abs(jc-jj)), std::abs(Lambda-J1) );
+          int j2max = std::min( int(jc+jj), J1+Lambda );
+          for (int J2=j2min; J2<=j2max; ++J2)
+          {
+            double hatfactor = sqrt( (2*J1+1)*(2*J2+1) );
+            double sixj = Z.modelspace->GetSixJ(J1, J2, Lambda, jj, ji, jc);
+            cijJ += hatfactor * sixj * Z.modelspace->phase(jj + jc + J1 + Lambda)
+              * ( oc.occ * Mpp.GetTBME_J(J1,J2,c,i,c,j) + (1-oc.occ) * Mhh.GetTBME_J(J1,J2,c,i,c,j));
+          }
+        }
+        // Sum c over particles and include the n_a * n_b terms
+      }
+      for (auto& c : Z.modelspace->particles)
+      {
+        Orbit &oc = Z.modelspace->GetOrbit(c);
+        double jc = oc.j2/2.0;
+        int j1min = std::abs(jc-ji);
+        int j1max = jc+ji;
+        for (int J1=j1min; J1<=j1max; ++J1)
+        {
+          int j2min = std::max( int(std::abs(jc-jj)), std::abs(Lambda-J1) );
+          int j2max = std::min( int(jc+jj), J1+Lambda );
+          for (int J2=j2min; J2<=j2max; ++J2)
+          {
+            double hatfactor = sqrt( (2*J1+1)*(2*J2+1) );
+            double sixj = Z.modelspace->GetSixJ(J1, J2, Lambda, jj, ji, jc);
+            cijJ += hatfactor * sixj * Z.modelspace->phase(jj + jc + J1 + Lambda) * Mhh.GetTBME_J(J1,J2,c,i,c,j);
+          }
+        }
+      }
+      //         #pragma omp critical
+      Z.OneBody(i,j) += cijJ ;
+    } // for j
+  } // for i
+  X.profiler.timer["comm222_pp_hh_221st"] += omp_get_wtime() - tstart;
 }
 
 
@@ -9200,112 +9425,112 @@ void comm222_pp_hh_221st( const Operator& X, const Operator& Y, Operator& Z )
 //void Operator::DoTensorPandyaTransformation(map<array<int,2>,arma::mat>& TwoBody_CC_hp, map<array<int,2>,arma::mat>& TwoBody_CC_ph) const
 void DoTensorPandyaTransformation( const Operator& Z, std::map<std::array<index_t,2>,arma::mat>& TwoBody_CC_ph)
 {
-   int Lambda = Z.rank_J;
-   // loop over cross-coupled channels
-   index_t nch = Z.modelspace->SortedTwoBodyChannels_CC.size();
+  int Lambda = Z.rank_J;
+  // loop over cross-coupled channels
+  index_t nch = Z.modelspace->SortedTwoBodyChannels_CC.size();
 
-   // Allocate map for matrices -- this needs to be serial.
-   for ( index_t ch_bra_cc : Z.modelspace->SortedTwoBodyChannels_CC )
-   {
-      TwoBodyChannel& tbc_bra_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_bra_cc);
-      arma::uvec bras_ph = arma::join_cols( tbc_bra_cc.GetKetIndex_hh(), tbc_bra_cc.GetKetIndex_ph() );
-      index_t nph_bras = bras_ph.n_rows;
-      for ( index_t ch_ket_cc : Z.modelspace->SortedTwoBodyChannels_CC )
-      {
-        TwoBodyChannel& tbc_ket_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_ket_cc);
-        index_t nKets_cc = tbc_ket_cc.GetNumberKets();
+  // Allocate map for matrices -- this needs to be serial.
+  for ( index_t ch_bra_cc : Z.modelspace->SortedTwoBodyChannels_CC )
+  {
+    TwoBodyChannel& tbc_bra_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_bra_cc);
+    arma::uvec bras_ph = arma::join_cols( tbc_bra_cc.GetKetIndex_hh(), tbc_bra_cc.GetKetIndex_ph() );
+    index_t nph_bras = bras_ph.n_rows;
+    for ( index_t ch_ket_cc : Z.modelspace->SortedTwoBodyChannels_CC )
+    {
+      TwoBodyChannel& tbc_ket_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_ket_cc);
+      index_t nKets_cc = tbc_ket_cc.GetNumberKets();
 
-         TwoBody_CC_ph[{ch_bra_cc,ch_ket_cc}] =  arma::mat(2*nph_bras,   nKets_cc, arma::fill::zeros);
-      }
-   }
+      TwoBody_CC_ph[{ch_bra_cc,ch_ket_cc}] =  arma::mat(2*nph_bras,   nKets_cc, arma::fill::zeros);
+    }
+  }
 
-   #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->tensor_transform_first_pass.at(Lambda))
-   for (index_t ich=0;ich<nch;++ich)
-   {
-      index_t ch_bra_cc = Z.modelspace->SortedTwoBodyChannels_CC[ich];
-      TwoBodyChannel& tbc_bra_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_bra_cc);
-      int Jbra_cc = tbc_bra_cc.J;
-      arma::uvec bras_ph = arma::join_cols( tbc_bra_cc.GetKetIndex_hh(), tbc_bra_cc.GetKetIndex_ph() );
-//      arma::uvec& bras_ph = tbc_bra_cc.GetKetIndex_ph();
-      index_t nph_bras = bras_ph.size();
-
-      for ( index_t ch_ket_cc : Z.modelspace->SortedTwoBodyChannels_CC )
-      {
-        TwoBodyChannel& tbc_ket_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_ket_cc);
-        int Jket_cc = tbc_ket_cc.J;
-        if ( (Jbra_cc+Jket_cc < Z.GetJRank()) or std::abs(Jbra_cc-Jket_cc)>Z.GetJRank() ) continue;
-        if ( (tbc_bra_cc.parity + tbc_ket_cc.parity + Z.GetParity())%2>0 ) continue;
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->tensor_transform_first_pass.at(Lambda))
+  for (index_t ich=0;ich<nch;++ich)
+  {
+    index_t ch_bra_cc = Z.modelspace->SortedTwoBodyChannels_CC[ich];
+    TwoBodyChannel& tbc_bra_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_bra_cc);
+    int Jbra_cc = tbc_bra_cc.J;
+    arma::uvec bras_ph = arma::join_cols( tbc_bra_cc.GetKetIndex_hh(), tbc_bra_cc.GetKetIndex_ph() );
+    //      arma::uvec& bras_ph = tbc_bra_cc.GetKetIndex_ph();
+    index_t nph_bras = bras_ph.size();
+
+    for ( index_t ch_ket_cc : Z.modelspace->SortedTwoBodyChannels_CC )
+    {
+      TwoBodyChannel& tbc_ket_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_ket_cc);
+      int Jket_cc = tbc_ket_cc.J;
+      if ( (Jbra_cc+Jket_cc < Z.GetJRank()) or std::abs(Jbra_cc-Jket_cc)>Z.GetJRank() ) continue;
+      if ( (tbc_bra_cc.parity + tbc_ket_cc.parity + Z.GetParity())%2>0 ) continue;
 
-        index_t nKets_cc = tbc_ket_cc.GetNumberKets();
+      index_t nKets_cc = tbc_ket_cc.GetNumberKets();
+
+      //        arma::mat& MatCC_hp = TwoBody_CC_hp[{ch_bra_cc,ch_ket_cc}];
+      arma::mat& MatCC_ph = TwoBody_CC_ph[{ch_bra_cc,ch_ket_cc}];
+      // loop over ph bras <ad| in this channel
+      for (index_t ibra=0; ibra<nph_bras; ++ibra)
+      {
+        Ket & bra_cc = tbc_bra_cc.GetKet( bras_ph[ibra] );
+        index_t a = bra_cc.p;
+        index_t b = bra_cc.q;
+        Orbit & oa = Z.modelspace->GetOrbit(a);
+        Orbit & ob = Z.modelspace->GetOrbit(b);
+        double ja = oa.j2*0.5;
+        double jb = ob.j2*0.5;
 
-//        arma::mat& MatCC_hp = TwoBody_CC_hp[{ch_bra_cc,ch_ket_cc}];
-        arma::mat& MatCC_ph = TwoBody_CC_ph[{ch_bra_cc,ch_ket_cc}];
-        // loop over ph bras <ad| in this channel
-        for (index_t ibra=0; ibra<nph_bras; ++ibra)
+        // loop over kets |bc> in this channel
+        index_t iket_max =  nKets_cc ;
+        for (index_t iket_cc=0; iket_cc<iket_max; ++iket_cc)
         {
-           Ket & bra_cc = tbc_bra_cc.GetKet( bras_ph[ibra] );
-           index_t a = bra_cc.p;
-           index_t b = bra_cc.q;
-           Orbit & oa = Z.modelspace->GetOrbit(a);
-           Orbit & ob = Z.modelspace->GetOrbit(b);
-           double ja = oa.j2*0.5;
-           double jb = ob.j2*0.5;
-
-           // loop over kets |bc> in this channel
-           index_t iket_max =  nKets_cc ;
-           for (index_t iket_cc=0; iket_cc<iket_max; ++iket_cc)
-           {
-              Ket & ket_cc = tbc_ket_cc.GetKet(iket_cc%nKets_cc);
-              index_t c = iket_cc < nKets_cc ? ket_cc.p : ket_cc.q;
-              index_t d = iket_cc < nKets_cc ? ket_cc.q : ket_cc.p;
-              Orbit & oc = Z.modelspace->GetOrbit(c);
-              Orbit & od = Z.modelspace->GetOrbit(d);
-              double jc = oc.j2*0.5;
-              double jd = od.j2*0.5;
-
-
-              int j1min = std::abs(ja-jd);
-              int j1max = ja+jd;
-              double sm = 0;
-              for (int J1=j1min; J1<=j1max; ++J1)
-              {
-                int j2min = std::max( int(std::abs(jc-jb)), std::abs(J1-Lambda) );
-                int j2max = std::min(int(jc+jb),J1+Lambda);
-                for (int J2=j2min; J2<=j2max; ++J2)
-                {
-                  double ninej = Z.modelspace->GetNineJ(ja,jd,J1,jb,jc,J2,Jbra_cc,Jket_cc,Lambda);
-                  if (std::abs(ninej) < 1e-8) continue;
-                  double hatfactor = sqrt( (2*J1+1)*(2*J2+1)*(2*Jbra_cc+1)*(2*Jket_cc+1) );
-                  double tbme = Z.TwoBody.GetTBME_J(J1,J2,a,d,c,b);
-                  sm -= hatfactor * Z.modelspace->phase(jb+jd+Jket_cc+J2) * ninej * tbme ;
-                }
-              }
-              MatCC_ph(ibra,iket_cc) = sm;
-
-              // Exchange (a <-> b) to account for the (n_a - n_b) term
-              // Get Tz,parity and range of J for <bd || ca > coupling
-              j1min = std::abs(jb-jd);
-              j1max = jb+jd;
-              sm = 0;
-              for (int J1=j1min; J1<=j1max; ++J1)
-              {
-                int j2min = std::max( int(std::abs(jc-ja)), std::abs(J1-Lambda) );
-                int j2max = std::min(int(jc+ja),J1+Lambda);
-                for (int J2=j2min; J2<=j2max; ++J2)
-                {
-                  double ninej = Z.modelspace->GetNineJ(jb,jd,J1,ja,jc,J2,Jbra_cc,Jket_cc,Lambda);
-                  if (std::abs(ninej) < 1e-8) continue;
-                  double hatfactor = sqrt( (2*J1+1)*(2*J2+1)*(2*Jbra_cc+1)*(2*Jket_cc+1) );
-                  double tbme = Z.TwoBody.GetTBME_J(J1,J2,b,d,c,a);
-                  sm -= hatfactor * Z.modelspace->phase(ja+jd+Jket_cc+J2) * ninej * tbme ;
-                }
-              }
-              MatCC_ph(ibra+nph_bras,iket_cc) = sm;
+          Ket & ket_cc = tbc_ket_cc.GetKet(iket_cc%nKets_cc);
+          index_t c = iket_cc < nKets_cc ? ket_cc.p : ket_cc.q;
+          index_t d = iket_cc < nKets_cc ? ket_cc.q : ket_cc.p;
+          Orbit & oc = Z.modelspace->GetOrbit(c);
+          Orbit & od = Z.modelspace->GetOrbit(d);
+          double jc = oc.j2*0.5;
+          double jd = od.j2*0.5;
+
+
+          int j1min = std::abs(ja-jd);
+          int j1max = ja+jd;
+          double sm = 0;
+          for (int J1=j1min; J1<=j1max; ++J1)
+          {
+            int j2min = std::max( int(std::abs(jc-jb)), std::abs(J1-Lambda) );
+            int j2max = std::min(int(jc+jb),J1+Lambda);
+            for (int J2=j2min; J2<=j2max; ++J2)
+            {
+              double ninej = Z.modelspace->GetNineJ(ja,jd,J1,jb,jc,J2,Jbra_cc,Jket_cc,Lambda);
+              if (std::abs(ninej) < 1e-8) continue;
+              double hatfactor = sqrt( (2*J1+1)*(2*J2+1)*(2*Jbra_cc+1)*(2*Jket_cc+1) );
+              double tbme = Z.TwoBody.GetTBME_J(J1,J2,a,d,c,b);
+              sm -= hatfactor * Z.modelspace->phase(jb+jd+Jket_cc+J2) * ninej * tbme ;
+            }
+          }
+          MatCC_ph(ibra,iket_cc) = sm;
+
+          // Exchange (a <-> b) to account for the (n_a - n_b) term
+          // Get Tz,parity and range of J for <bd || ca > coupling
+          j1min = std::abs(jb-jd);
+          j1max = jb+jd;
+          sm = 0;
+          for (int J1=j1min; J1<=j1max; ++J1)
+          {
+            int j2min = std::max( int(std::abs(jc-ja)), std::abs(J1-Lambda) );
+            int j2max = std::min(int(jc+ja),J1+Lambda);
+            for (int J2=j2min; J2<=j2max; ++J2)
+            {
+              double ninej = Z.modelspace->GetNineJ(jb,jd,J1,ja,jc,J2,Jbra_cc,Jket_cc,Lambda);
+              if (std::abs(ninej) < 1e-8) continue;
+              double hatfactor = sqrt( (2*J1+1)*(2*J2+1)*(2*Jbra_cc+1)*(2*Jket_cc+1) );
+              double tbme = Z.TwoBody.GetTBME_J(J1,J2,b,d,c,a);
+              sm -= hatfactor * Z.modelspace->phase(ja+jd+Jket_cc+J2) * ninej * tbme ;
+            }
+          }
+          MatCC_ph(ibra+nph_bras,iket_cc) = sm;
 
-           }
         }
+      }
     }
-   }
+  }
 }
 
 
@@ -9316,96 +9541,96 @@ void DoTensorPandyaTransformation( const Operator& Z, std::map<std::array<index_
 //void Operator::DoTensorPandyaTransformation_SingleChannel( arma::mat& MatCC_ph, int ch_bra_cc, int ch_ket_cc) const
 void DoTensorPandyaTransformation_SingleChannel( const Operator& Z, arma::mat& MatCC_ph, int ch_bra_cc, int ch_ket_cc)
 {
-   int Lambda = Z.rank_J;
+  int Lambda = Z.rank_J;
 
-   TwoBodyChannel& tbc_bra_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_bra_cc);
-   arma::uvec bras_ph = arma::join_cols( tbc_bra_cc.GetKetIndex_hh(), tbc_bra_cc.GetKetIndex_ph() );
-   int nph_bras = bras_ph.n_rows;
+  TwoBodyChannel& tbc_bra_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_bra_cc);
+  arma::uvec bras_ph = arma::join_cols( tbc_bra_cc.GetKetIndex_hh(), tbc_bra_cc.GetKetIndex_ph() );
+  int nph_bras = bras_ph.n_rows;
 
-   TwoBodyChannel& tbc_ket_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_ket_cc);
-   int nKets_cc = tbc_ket_cc.GetNumberKets();
+  TwoBodyChannel& tbc_ket_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_ket_cc);
+  int nKets_cc = tbc_ket_cc.GetNumberKets();
 
-   // The Pandya-transformed (formerly cross-coupled) particle-hole type matrix elements
-   // (this is the output of this method)
-   MatCC_ph =  arma::mat(2*nph_bras,   nKets_cc, arma::fill::zeros);
+  // The Pandya-transformed (formerly cross-coupled) particle-hole type matrix elements
+  // (this is the output of this method)
+  MatCC_ph =  arma::mat(2*nph_bras,   nKets_cc, arma::fill::zeros);
 
-   int Jbra_cc = tbc_bra_cc.J;
-   int Jket_cc = tbc_ket_cc.J;
-   if ( (Jbra_cc+Jket_cc < Z.GetJRank() ) or std::abs(Jbra_cc-Jket_cc)>Z.GetJRank() ) return;
-   if ( (tbc_bra_cc.parity + tbc_ket_cc.parity + Z.GetParity())%2>0 ) return;
+  int Jbra_cc = tbc_bra_cc.J;
+  int Jket_cc = tbc_ket_cc.J;
+  if ( (Jbra_cc+Jket_cc < Z.GetJRank() ) or std::abs(Jbra_cc-Jket_cc)>Z.GetJRank() ) return;
+  if ( (tbc_bra_cc.parity + tbc_ket_cc.parity + Z.GetParity())%2>0 ) return;
 
 
-   // loop over ph bras <ad| in this channel
-   for (int ibra=0; ibra<nph_bras; ++ibra)
-   {
-      Ket & bra_cc = tbc_bra_cc.GetKet( bras_ph[ibra] );
-      int a = bra_cc.p;
-      int b = bra_cc.q;
-      Orbit & oa = Z.modelspace->GetOrbit(a);
-      Orbit & ob = Z.modelspace->GetOrbit(b);
-      double ja = oa.j2*0.5;
-      double jb = ob.j2*0.5;
-
-      // loop over kets |bc> in this channel
-      int iket_max =  nKets_cc ;
-      for (int iket_cc=0; iket_cc<iket_max; ++iket_cc)
+  // loop over ph bras <ad| in this channel
+  for (int ibra=0; ibra<nph_bras; ++ibra)
+  {
+    Ket & bra_cc = tbc_bra_cc.GetKet( bras_ph[ibra] );
+    int a = bra_cc.p;
+    int b = bra_cc.q;
+    Orbit & oa = Z.modelspace->GetOrbit(a);
+    Orbit & ob = Z.modelspace->GetOrbit(b);
+    double ja = oa.j2*0.5;
+    double jb = ob.j2*0.5;
+
+    // loop over kets |bc> in this channel
+    int iket_max =  nKets_cc ;
+    for (int iket_cc=0; iket_cc<iket_max; ++iket_cc)
+    {
+      Ket & ket_cc = tbc_ket_cc.GetKet(iket_cc%nKets_cc);
+      int c = iket_cc < nKets_cc ? ket_cc.p : ket_cc.q;
+      int d = iket_cc < nKets_cc ? ket_cc.q : ket_cc.p;
+      Orbit & oc = Z.modelspace->GetOrbit(c);
+      Orbit & od = Z.modelspace->GetOrbit(d);
+      double jc = oc.j2*0.5;
+      double jd = od.j2*0.5;
+
+
+      int j1min = std::abs(ja-jd);
+      int j1max = ja+jd;
+      double sm = 0;
+      for (int J1=j1min; J1<=j1max; ++J1)
+      {
+        int j2min = std::max( int(std::abs(jc-jb)), std::abs(J1-Lambda) );
+        int j2max = std::min( int(jc+jb), J1+Lambda) ;
+        for (int J2=j2min; J2<=j2max; ++J2)
+        {
+          double ninej = Z.modelspace->GetNineJ(ja,jd,J1,jb,jc,J2,Jbra_cc,Jket_cc,Lambda);
+          if (std::abs(ninej) < 1e-8) continue;
+          double hatfactor = sqrt( (2*J1+1)*(2*J2+1)*(2*Jbra_cc+1)*(2*Jket_cc+1) );
+          double tbme = Z.TwoBody.GetTBME_J(J1,J2,a,d,c,b);
+          sm -= hatfactor * Z.modelspace->phase(jb+jd+Jket_cc+J2) * ninej * tbme ;
+        }
+      }
+      MatCC_ph(ibra,iket_cc) = sm;
+
+      // Exchange (a <-> b) to account for the (n_a - n_b) term
+      if (a==b)
       {
-         Ket & ket_cc = tbc_ket_cc.GetKet(iket_cc%nKets_cc);
-         int c = iket_cc < nKets_cc ? ket_cc.p : ket_cc.q;
-         int d = iket_cc < nKets_cc ? ket_cc.q : ket_cc.p;
-         Orbit & oc = Z.modelspace->GetOrbit(c);
-         Orbit & od = Z.modelspace->GetOrbit(d);
-         double jc = oc.j2*0.5;
-         double jd = od.j2*0.5;
-
-
-         int j1min = std::abs(ja-jd);
-         int j1max = ja+jd;
-         double sm = 0;
-         for (int J1=j1min; J1<=j1max; ++J1)
-         {
-           int j2min = std::max( int(std::abs(jc-jb)), std::abs(J1-Lambda) );
-           int j2max = std::min( int(jc+jb), J1+Lambda) ;
-           for (int J2=j2min; J2<=j2max; ++J2)
-           {
-             double ninej = Z.modelspace->GetNineJ(ja,jd,J1,jb,jc,J2,Jbra_cc,Jket_cc,Lambda);
-             if (std::abs(ninej) < 1e-8) continue;
-             double hatfactor = sqrt( (2*J1+1)*(2*J2+1)*(2*Jbra_cc+1)*(2*Jket_cc+1) );
-             double tbme = Z.TwoBody.GetTBME_J(J1,J2,a,d,c,b);
-             sm -= hatfactor * Z.modelspace->phase(jb+jd+Jket_cc+J2) * ninej * tbme ;
-           }
-         }
-         MatCC_ph(ibra,iket_cc) = sm;
-
-         // Exchange (a <-> b) to account for the (n_a - n_b) term
-         if (a==b)
-         {
-           MatCC_ph(ibra+nph_bras,iket_cc) = sm;
-         }
-         else
-         {
-
-           // Get Tz,parity and range of J for <bd || ca > coupling
-           j1min = std::abs(jb-jd);
-           j1max = jb+jd;
-           sm = 0;
-           for (int J1=j1min; J1<=j1max; ++J1)
-           {
-             int j2min = std::max( int(std::abs(jc-ja)), std::abs(J1-Lambda) );
-             int j2max = std::min( int(jc+ja), J1+Lambda );
-             for (int J2=j2min; J2<=j2max; ++J2)
-             {
-               double ninej = Z.modelspace->GetNineJ(jb,jd,J1,ja,jc,J2,Jbra_cc,Jket_cc,Lambda);
-               if (std::abs(ninej) < 1e-8) continue;
-               double hatfactor = sqrt( (2*J1+1)*(2*J2+1)*(2*Jbra_cc+1)*(2*Jket_cc+1) );
-               double tbme = Z.TwoBody.GetTBME_J(J1,J2,b,d,c,a);
-               sm -= hatfactor * Z.modelspace->phase(ja+jd+Jket_cc+J2) * ninej * tbme ;
-             }
-           }
-           MatCC_ph(ibra+nph_bras,iket_cc) = sm;
-         }
+        MatCC_ph(ibra+nph_bras,iket_cc) = sm;
+      }
+      else
+      {
+
+        // Get Tz,parity and range of J for <bd || ca > coupling
+        j1min = std::abs(jb-jd);
+        j1max = jb+jd;
+        sm = 0;
+        for (int J1=j1min; J1<=j1max; ++J1)
+        {
+          int j2min = std::max( int(std::abs(jc-ja)), std::abs(J1-Lambda) );
+          int j2max = std::min( int(jc+ja), J1+Lambda );
+          for (int J2=j2min; J2<=j2max; ++J2)
+          {
+            double ninej = Z.modelspace->GetNineJ(jb,jd,J1,ja,jc,J2,Jbra_cc,Jket_cc,Lambda);
+            if (std::abs(ninej) < 1e-8) continue;
+            double hatfactor = sqrt( (2*J1+1)*(2*J2+1)*(2*Jbra_cc+1)*(2*Jket_cc+1) );
+            double tbme = Z.TwoBody.GetTBME_J(J1,J2,b,d,c,a);
+            sm -= hatfactor * Z.modelspace->phase(ja+jd+Jket_cc+J2) * ninej * tbme ;
+          }
+        }
+        MatCC_ph(ibra+nph_bras,iket_cc) = sm;
       }
-   }
+    }
+  }
 }
 
 
@@ -9417,166 +9642,166 @@ void DoTensorPandyaTransformation_SingleChannel( const Operator& Z, arma::mat& M
 //void AddInverseTensorPandyaTransformation_SingleChannel(Operator& Z, arma::mat& Zbar, int ch_bra_cc, int ch_ket_cc)
 void AddInverseTensorPandyaTransformation_SingleChannel(Operator& Z, arma::mat& Zbar, size_t ch_bra_cc, size_t ch_ket_cc)
 {
-    // Do the inverse Pandya transform
-   if (ch_bra_cc > ch_ket_cc)  // hopefully this won't happen
-   {
-      std::cout << "WARNING: Called Operator::AddInverseTensorPandyaTransformation_SingleChannel with ch_bra_cc > ch_ket_cc : " << ch_bra_cc << " > " << ch_ket_cc << std::endl;
-      std::cout << " Skipping this channel." << std::endl;
-      return;
-   }
-//   int n_channels_kept = 0;
-   const auto& pandya_lookup = Z.modelspace->GetPandyaLookup(Z.GetJRank(), Z.GetTRank(),Z.GetParity())[{ch_bra_cc,ch_ket_cc}];
-   int Lambda = Z.rank_J;
-   int hZ = Z.IsHermitian() ? 1 : -1;
-   TwoBodyChannel_CC& tbc_bra_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_bra_cc);
-   TwoBodyChannel_CC& tbc_ket_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_ket_cc);
-   int J3 = tbc_bra_cc.J;
-   int J4 = tbc_ket_cc.J;
-   int Tz_bra_cc = tbc_bra_cc.Tz;
-   int Tz_ket_cc = tbc_ket_cc.Tz;
-   int parity_bra_cc = tbc_bra_cc.parity;
-   int parity_ket_cc = tbc_ket_cc.parity;
-   int nkets_cc = tbc_ket_cc.GetNumberKets();
-
-   int nchannels = pandya_lookup[0].size();
-   for (int ich=0;ich<nchannels;++ich)
-   {
-      int ch_bra = pandya_lookup[0][ich];
-      int ch_ket = pandya_lookup[1][ich];
-      TwoBodyChannel& tbc_bra = Z.modelspace->GetTwoBodyChannel(ch_bra);
-      TwoBodyChannel& tbc_ket = Z.modelspace->GetTwoBodyChannel(ch_ket);
-      int J1 = tbc_bra.J;
-      int J2 = tbc_ket.J;
-      int nBras = tbc_bra.GetNumberKets();
-      int nKets = tbc_ket.GetNumberKets();
-      arma::mat& Zijkl = Z.TwoBody.GetMatrix(ch_bra,ch_ket);
-//      bool inner_loop = false;
-
-      double hatfactor = sqrt( (2*J1+1)*(2*J2+1)*(2*J3+1)*(2*J4+1) );
-
-      for (int ibra=0; ibra<nBras; ++ibra)
+  // Do the inverse Pandya transform
+  if (ch_bra_cc > ch_ket_cc)  // hopefully this won't happen
+  {
+    std::cout << "WARNING: Called Operator::AddInverseTensorPandyaTransformation_SingleChannel with ch_bra_cc > ch_ket_cc : " << ch_bra_cc << " > " << ch_ket_cc << std::endl;
+    std::cout << " Skipping this channel." << std::endl;
+    return;
+  }
+  //   int n_channels_kept = 0;
+  const auto& pandya_lookup = Z.modelspace->GetPandyaLookup(Z.GetJRank(), Z.GetTRank(),Z.GetParity())[{ch_bra_cc,ch_ket_cc}];
+  int Lambda = Z.rank_J;
+  int hZ = Z.IsHermitian() ? 1 : -1;
+  TwoBodyChannel_CC& tbc_bra_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_bra_cc);
+  TwoBodyChannel_CC& tbc_ket_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_ket_cc);
+  int J3 = tbc_bra_cc.J;
+  int J4 = tbc_ket_cc.J;
+  int Tz_bra_cc = tbc_bra_cc.Tz;
+  int Tz_ket_cc = tbc_ket_cc.Tz;
+  int parity_bra_cc = tbc_bra_cc.parity;
+  int parity_ket_cc = tbc_ket_cc.parity;
+  int nkets_cc = tbc_ket_cc.GetNumberKets();
+
+  int nchannels = pandya_lookup[0].size();
+  for (int ich=0;ich<nchannels;++ich)
+  {
+    int ch_bra = pandya_lookup[0][ich];
+    int ch_ket = pandya_lookup[1][ich];
+    TwoBodyChannel& tbc_bra = Z.modelspace->GetTwoBodyChannel(ch_bra);
+    TwoBodyChannel& tbc_ket = Z.modelspace->GetTwoBodyChannel(ch_ket);
+    int J1 = tbc_bra.J;
+    int J2 = tbc_ket.J;
+    int nBras = tbc_bra.GetNumberKets();
+    int nKets = tbc_ket.GetNumberKets();
+    arma::mat& Zijkl = Z.TwoBody.GetMatrix(ch_bra,ch_ket);
+    //      bool inner_loop = false;
+
+    double hatfactor = sqrt( (2*J1+1)*(2*J2+1)*(2*J3+1)*(2*J4+1) );
+
+    for (int ibra=0; ibra<nBras; ++ibra)
+    {
+      Ket & bra = tbc_bra.GetKet(ibra);
+      int i = bra.p;
+      int j = bra.q;
+      Orbit & oi = Z.modelspace->GetOrbit(i);
+      Orbit & oj = Z.modelspace->GetOrbit(j);
+      double ji = 0.5*oi.j2;
+      double jj = 0.5*oj.j2;
+      int ketmin = ch_bra==ch_ket ? ibra : 0;
+      for (int iket=ketmin; iket<nKets; ++iket)
       {
-         Ket & bra = tbc_bra.GetKet(ibra);
-         int i = bra.p;
-         int j = bra.q;
-         Orbit & oi = Z.modelspace->GetOrbit(i);
-         Orbit & oj = Z.modelspace->GetOrbit(j);
-         double ji = 0.5*oi.j2;
-         double jj = 0.5*oj.j2;
-         int ketmin = ch_bra==ch_ket ? ibra : 0;
-         for (int iket=ketmin; iket<nKets; ++iket)
-         {
-            Ket & ket = tbc_ket.GetKet(iket);
-            int k = ket.p;
-            int l = ket.q;
-            Orbit & ok = Z.modelspace->GetOrbit(k);
-            Orbit & ol = Z.modelspace->GetOrbit(l);
-            double jk = 0.5*ok.j2;
-            double jl = 0.5*ol.j2;
+        Ket & ket = tbc_ket.GetKet(iket);
+        int k = ket.p;
+        int l = ket.q;
+        Orbit & ok = Z.modelspace->GetOrbit(k);
+        Orbit & ol = Z.modelspace->GetOrbit(l);
+        double jk = 0.5*ok.j2;
+        double jl = 0.5*ol.j2;
 
-            double commij = 0;
-            double commji = 0;
+        double commij = 0;
+        double commji = 0;
 
-            // Transform Z_ilkj
-            int j3min = std::abs(int(ji-jl));
-            int j3max = ji+jl;
-            int j4min = std::abs(int(jk-jj));
-            int j4max = int(jk+jj);
+        // Transform Z_ilkj
+        int j3min = std::abs(int(ji-jl));
+        int j3max = ji+jl;
+        int j4min = std::abs(int(jk-jj));
+        int j4max = int(jk+jj);
 
-            if (   (oi.l+ol.l)%2==parity_bra_cc             and (ok.l+oj.l)%2==parity_ket_cc
-//                      and std::abs(oi.tz2+ol.tz2)==2*Tz_bra_cc   and std::abs(ok.tz2+oj.tz2)==2*Tz_ket_cc
-                      and std::abs(oi.tz2-ol.tz2)==2*Tz_bra_cc   and std::abs(ok.tz2-oj.tz2)==2*Tz_ket_cc
-                      and j3min<=J3 and J3<=j3max           and j4min<=J4 and J4<=j4max )
-            {
-               int indx_il = tbc_bra_cc.GetLocalIndex( std::min(i,l), std::max(i,l) );
-               int indx_kj = tbc_ket_cc.GetLocalIndex( std::min(j,k), std::max(j,k) );
+        if (   (oi.l+ol.l)%2==parity_bra_cc             and (ok.l+oj.l)%2==parity_ket_cc
+            //                      and std::abs(oi.tz2+ol.tz2)==2*Tz_bra_cc   and std::abs(ok.tz2+oj.tz2)==2*Tz_ket_cc
+            and std::abs(oi.tz2-ol.tz2)==2*Tz_bra_cc   and std::abs(ok.tz2-oj.tz2)==2*Tz_ket_cc
+            and j3min<=J3 and J3<=j3max           and j4min<=J4 and J4<=j4max )
+        {
+          int indx_il = tbc_bra_cc.GetLocalIndex( std::min(i,l), std::max(i,l) );
+          int indx_kj = tbc_ket_cc.GetLocalIndex( std::min(j,k), std::max(j,k) );
 
-               double ninej = Z.modelspace->GetNineJ(ji,jl,J3,jj,jk,J4,J1,J2,Lambda);
-               double tbme = 0;
+          double ninej = Z.modelspace->GetNineJ(ji,jl,J3,jj,jk,J4,J1,J2,Lambda);
+          double tbme = 0;
 
-               if (i<=l) tbme = Zbar( indx_il ,indx_kj+(k>j?nkets_cc:0) );
-               else      tbme = Zbar( indx_il ,indx_kj+(k>j?0:nkets_cc) ) * hZ * Z.modelspace->phase(J3-J4 + ji+jj+jk+jl);
-               commij += hatfactor * Z.modelspace->phase(jj+jl+J2+J4) * ninej * tbme ;
-//               inner_loop = true;
-            }
+          if (i<=l) tbme = Zbar( indx_il ,indx_kj+(k>j?nkets_cc:0) );
+          else      tbme = Zbar( indx_il ,indx_kj+(k>j?0:nkets_cc) ) * hZ * Z.modelspace->phase(J3-J4 + ji+jj+jk+jl);
+          commij += hatfactor * Z.modelspace->phase(jj+jl+J2+J4) * ninej * tbme ;
+          //               inner_loop = true;
+        }
 
-            if (  (ch_bra_cc != ch_ket_cc)  and ((oi.l+ol.l)%2==parity_ket_cc)           and ((ok.l+oj.l)%2==parity_bra_cc)
-//                                            and (std::abs(oi.tz2+ol.tz2)==2*Tz_ket_cc)   and (std::abs(ok.tz2+oj.tz2)==2*Tz_bra_cc)
-                                            and (std::abs(oi.tz2-ol.tz2)==2*Tz_ket_cc)   and (std::abs(ok.tz2-oj.tz2)==2*Tz_bra_cc)
-                                            and (j3min<=J4) and (J4<=j3max)  and  (j4min<=J3) and (J3<=j4max )    )
-              {
-                 int indx_kj = tbc_bra_cc.GetLocalIndex( std::min(j,k), std::max(j,k));
-                 int indx_il = tbc_ket_cc.GetLocalIndex( std::min(i,l), std::max(i,l));
+        if (  (ch_bra_cc != ch_ket_cc)  and ((oi.l+ol.l)%2==parity_ket_cc)           and ((ok.l+oj.l)%2==parity_bra_cc)
+            //                                            and (std::abs(oi.tz2+ol.tz2)==2*Tz_ket_cc)   and (std::abs(ok.tz2+oj.tz2)==2*Tz_bra_cc)
+            and (std::abs(oi.tz2-ol.tz2)==2*Tz_ket_cc)   and (std::abs(ok.tz2-oj.tz2)==2*Tz_bra_cc)
+            and (j3min<=J4) and (J4<=j3max)  and  (j4min<=J3) and (J3<=j4max )    )
+        {
+          int indx_kj = tbc_bra_cc.GetLocalIndex( std::min(j,k), std::max(j,k));
+          int indx_il = tbc_ket_cc.GetLocalIndex( std::min(i,l), std::max(i,l));
 
-                 double ninej = Z.modelspace->GetNineJ(ji,jl,J4,jj,jk,J3,J1,J2,Lambda);
-                 double tbme = 0;
+          double ninej = Z.modelspace->GetNineJ(ji,jl,J4,jj,jk,J3,J1,J2,Lambda);
+          double tbme = 0;
 
-                 if(k<=j) tbme = Zbar(indx_kj, indx_il+(i>l?nkets_cc:0) ) * hZ * Z.modelspace->phase(J3-J4); // Z_ilkj = Z_kjil * (phase)
-                 else     tbme = Zbar(indx_kj, indx_il+(i>l?0:nkets_cc) ) * Z.modelspace->phase( ji+jj+jk+jl) ; // Z_ilkj = Z_kjil * (phase)
+          if(k<=j) tbme = Zbar(indx_kj, indx_il+(i>l?nkets_cc:0) ) * hZ * Z.modelspace->phase(J3-J4); // Z_ilkj = Z_kjil * (phase)
+          else     tbme = Zbar(indx_kj, indx_il+(i>l?0:nkets_cc) ) * Z.modelspace->phase( ji+jj+jk+jl) ; // Z_ilkj = Z_kjil * (phase)
 
-                 commij += hatfactor * Z.modelspace->phase(jj+jl+J2+J3) * ninej * tbme ;
-//               inner_loop = true;
-              }
+          commij += hatfactor * Z.modelspace->phase(jj+jl+J2+J3) * ninej * tbme ;
+          //               inner_loop = true;
+        }
 
 
-            if (i==j)
-            {
-              commji = commij;
-            }
-            else
-            {
-              j3min = std::abs(int(jj-jl));
-              j3max = jj+jl;
-              j4min = std::abs(int(jk-ji));
-              j4max = int(jk+ji);
-              if (   ((oj.l+ol.l)%2==parity_bra_cc) and ((ok.l+oi.l)%2==parity_ket_cc)
-//                      and (std::abs(oj.tz2+ol.tz2)==2*Tz_bra_cc) and (std::abs(ok.tz2+oi.tz2)==2*Tz_ket_cc)
-                      and (std::abs(oj.tz2-ol.tz2)==2*Tz_bra_cc) and (std::abs(ok.tz2-oi.tz2)==2*Tz_ket_cc)
-                      and (J3>=j3min) and (J3<=j3max) and (J4>=j4min) and (J4<=j4max)   )
-              {
-                // Transform Z_jlki
-                int indx_jl = tbc_bra_cc.GetLocalIndex( std::min(j,l), std::max(j,l) );
-                int indx_ki = tbc_ket_cc.GetLocalIndex( std::min(k,i), std::max(k,i) );
-                double ninej = Z.modelspace->GetNineJ(jj,jl,J3,ji,jk,J4,J1,J2,Lambda);
-                double tbme = 0;
-                if (j<=l) tbme = Zbar( indx_jl ,indx_ki+(k>i?nkets_cc:0) );
-                else      tbme = Zbar( indx_jl ,indx_ki+(k>i?0:nkets_cc) ) * hZ * Z.modelspace->phase(J3-J4 + ji+jj+jk+jl);
-                commji += hatfactor * Z.modelspace->phase(ji+jl+J2+J4) * ninej * tbme ;
-//               inner_loop = true;
-              }
-              if ( (ch_bra_cc!=ch_ket_cc) and ((oj.l+ol.l)%2==parity_ket_cc) and ((ok.l+oi.l)%2==parity_bra_cc)
-//                                       and (std::abs(oj.tz2+ol.tz2)==2*Tz_ket_cc) and (std::abs(ok.tz2+oi.tz2)==2*Tz_bra_cc)
-                                       and (std::abs(oj.tz2-ol.tz2)==2*Tz_ket_cc) and (std::abs(ok.tz2-oi.tz2)==2*Tz_bra_cc)
-                                       and (J4>=j3min) and (J4<=j3max) and (J3>=j4min) and (J3<=j4max)   )
-              {
-                int indx_jl = tbc_ket_cc.GetLocalIndex( std::min(j,l), std::max(j,l));
-                int indx_ki = tbc_bra_cc.GetLocalIndex( std::min(k,i), std::max(k,i));
-                double ninej = Z.modelspace->GetNineJ(jj,jl,J4,ji,jk,J3,J1,J2,Lambda);
-                double tbme = 0;
-
-                if(k<=i) tbme = Zbar(indx_ki, indx_jl+(j>l?nkets_cc:0) ) * hZ * Z.modelspace->phase(J3-J4); // Z_ilkj = Z_kjil * (phase)
-                else     tbme = Zbar(indx_ki, indx_jl+(j>l?0:nkets_cc) ) * Z.modelspace->phase( ji+jj+jk+jl) ; // Z_ilkj = Z_kjil * (phase)
-                commji += hatfactor * Z.modelspace->phase(ji+jl+J2+J3) * ninej * tbme ;
-//               inner_loop = true;
-              }
-            }
+        if (i==j)
+        {
+          commji = commij;
+        }
+        else
+        {
+          j3min = std::abs(int(jj-jl));
+          j3max = jj+jl;
+          j4min = std::abs(int(jk-ji));
+          j4max = int(jk+ji);
+          if (   ((oj.l+ol.l)%2==parity_bra_cc) and ((ok.l+oi.l)%2==parity_ket_cc)
+              //                      and (std::abs(oj.tz2+ol.tz2)==2*Tz_bra_cc) and (std::abs(ok.tz2+oi.tz2)==2*Tz_ket_cc)
+              and (std::abs(oj.tz2-ol.tz2)==2*Tz_bra_cc) and (std::abs(ok.tz2-oi.tz2)==2*Tz_ket_cc)
+              and (J3>=j3min) and (J3<=j3max) and (J4>=j4min) and (J4<=j4max)   )
+          {
+            // Transform Z_jlki
+            int indx_jl = tbc_bra_cc.GetLocalIndex( std::min(j,l), std::max(j,l) );
+            int indx_ki = tbc_ket_cc.GetLocalIndex( std::min(k,i), std::max(k,i) );
+            double ninej = Z.modelspace->GetNineJ(jj,jl,J3,ji,jk,J4,J1,J2,Lambda);
+            double tbme = 0;
+            if (j<=l) tbme = Zbar( indx_jl ,indx_ki+(k>i?nkets_cc:0) );
+            else      tbme = Zbar( indx_jl ,indx_ki+(k>i?0:nkets_cc) ) * hZ * Z.modelspace->phase(J3-J4 + ji+jj+jk+jl);
+            commji += hatfactor * Z.modelspace->phase(ji+jl+J2+J4) * ninej * tbme ;
+            //               inner_loop = true;
+          }
+          if ( (ch_bra_cc!=ch_ket_cc) and ((oj.l+ol.l)%2==parity_ket_cc) and ((ok.l+oi.l)%2==parity_bra_cc)
+              //                                       and (std::abs(oj.tz2+ol.tz2)==2*Tz_ket_cc) and (std::abs(ok.tz2+oi.tz2)==2*Tz_bra_cc)
+              and (std::abs(oj.tz2-ol.tz2)==2*Tz_ket_cc) and (std::abs(ok.tz2-oi.tz2)==2*Tz_bra_cc)
+              and (J4>=j3min) and (J4<=j3max) and (J3>=j4min) and (J3<=j4max)   )
+          {
+            int indx_jl = tbc_ket_cc.GetLocalIndex( std::min(j,l), std::max(j,l));
+            int indx_ki = tbc_bra_cc.GetLocalIndex( std::min(k,i), std::max(k,i));
+            double ninej = Z.modelspace->GetNineJ(jj,jl,J4,ji,jk,J3,J1,J2,Lambda);
+            double tbme = 0;
+
+            if(k<=i) tbme = Zbar(indx_ki, indx_jl+(j>l?nkets_cc:0) ) * hZ * Z.modelspace->phase(J3-J4); // Z_ilkj = Z_kjil * (phase)
+            else     tbme = Zbar(indx_ki, indx_jl+(j>l?0:nkets_cc) ) * Z.modelspace->phase( ji+jj+jk+jl) ; // Z_ilkj = Z_kjil * (phase)
+            commji += hatfactor * Z.modelspace->phase(ji+jl+J2+J3) * ninej * tbme ;
+            //               inner_loop = true;
+          }
+        }
 
 
-            double norm = bra.delta_pq()==ket.delta_pq() ? 1+bra.delta_pq() : PhysConst::SQRT2;
-            #pragma omp atomic
-            Zijkl(ibra,iket) +=  (commij - Z.modelspace->phase(ji+jj-J1)*commji) / norm;
-            if (ch_bra==ch_ket) 
-            {
-               #pragma omp atomic write
-               Zijkl(iket,ibra) = hZ * Zijkl(ibra,iket);
-            }
-         }
+        double norm = bra.delta_pq()==ket.delta_pq() ? 1+bra.delta_pq() : PhysConst::SQRT2;
+#pragma omp atomic
+        Zijkl(ibra,iket) +=  (commij - Z.modelspace->phase(ji+jj-J1)*commji) / norm;
+        if (ch_bra==ch_ket)
+        {
+#pragma omp atomic write
+          Zijkl(iket,ibra) = hZ * Zijkl(ibra,iket);
+        }
       }
-//      if (inner_loop)  // if we made it to the inner loop, count it.
-//      {
-//        n_channels_kept++;
-//      }
-   }
+    }
+    //      if (inner_loop)  // if we made it to the inner loop, count it.
+    //      {
+    //        n_channels_kept++;
+    //      }
+  }
 }
 
 
@@ -9586,163 +9811,163 @@ void AddInverseTensorPandyaTransformation_SingleChannel(Operator& Z, arma::mat&
 //void Operator::AddInverseTensorPandyaTransformation( const std::map<std::array<index_t,2>,arma::mat>&  Zbar )
 void AddInverseTensorPandyaTransformation( Operator& Z, const std::map<std::array<index_t,2>,arma::mat>&  Zbar )
 {
-    // Do the inverse Pandya transform
-   int Lambda = Z.rank_J;
-//   std::vector<std::map<std::array<int,2>,arma::mat>::iterator> iteratorlist;
-   std::vector<std::map<std::array<size_t,2>,arma::mat>::iterator> iteratorlist;
-//   for (std::map<std::array<int,2>,arma::mat>::iterator iter= Z.TwoBody.MatEl.begin(); iter!= Z.TwoBody.MatEl.end(); ++iter) iteratorlist.push_back(iter);
-   for (auto iter= Z.TwoBody.MatEl.begin(); iter!= Z.TwoBody.MatEl.end(); ++iter) iteratorlist.push_back(iter);
-   int niter = iteratorlist.size();
-   int hZ = Z.IsHermitian() ? 1 : -1;
-    // Only go parallel if we've previously calculated the SixJs/NineJs. Otherwise, it's not thread safe.
-   #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->tensor_transform_first_pass.at(Lambda))
-   for (int i=0; i<niter; ++i)
-   {
-      const auto iter = iteratorlist[i];
-      int ch_bra = iter->first[0];
-      int ch_ket = iter->first[1];
-      arma::mat& Zijkl = iter->second;
-      const TwoBodyChannel& tbc_bra = Z.modelspace->GetTwoBodyChannel(ch_bra);
-      const TwoBodyChannel& tbc_ket = Z.modelspace->GetTwoBodyChannel(ch_ket);
-      int J1 = tbc_bra.J;
-      int J2 = tbc_ket.J;
-      index_t nBras = tbc_bra.GetNumberKets();
-      index_t nKets = tbc_ket.GetNumberKets();
-
-      for (index_t ibra=0; ibra<nBras; ++ibra)
+  // Do the inverse Pandya transform
+  int Lambda = Z.rank_J;
+  //   std::vector<std::map<std::array<int,2>,arma::mat>::iterator> iteratorlist;
+  std::vector<std::map<std::array<size_t,2>,arma::mat>::iterator> iteratorlist;
+  //   for (std::map<std::array<int,2>,arma::mat>::iterator iter= Z.TwoBody.MatEl.begin(); iter!= Z.TwoBody.MatEl.end(); ++iter) iteratorlist.push_back(iter);
+  for (auto iter= Z.TwoBody.MatEl.begin(); iter!= Z.TwoBody.MatEl.end(); ++iter) iteratorlist.push_back(iter);
+  int niter = iteratorlist.size();
+  int hZ = Z.IsHermitian() ? 1 : -1;
+  // Only go parallel if we've previously calculated the SixJs/NineJs. Otherwise, it's not thread safe.
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->tensor_transform_first_pass.at(Lambda))
+  for (int i=0; i<niter; ++i)
+  {
+    const auto iter = iteratorlist[i];
+    int ch_bra = iter->first[0];
+    int ch_ket = iter->first[1];
+    arma::mat& Zijkl = iter->second;
+    const TwoBodyChannel& tbc_bra = Z.modelspace->GetTwoBodyChannel(ch_bra);
+    const TwoBodyChannel& tbc_ket = Z.modelspace->GetTwoBodyChannel(ch_ket);
+    int J1 = tbc_bra.J;
+    int J2 = tbc_ket.J;
+    index_t nBras = tbc_bra.GetNumberKets();
+    index_t nKets = tbc_ket.GetNumberKets();
+
+    for (index_t ibra=0; ibra<nBras; ++ibra)
+    {
+      const Ket & bra = tbc_bra.GetKet(ibra);
+      int i = bra.p;
+      int j = bra.q;
+      const Orbit & oi = Z.modelspace->GetOrbit(i);
+      const Orbit & oj = Z.modelspace->GetOrbit(j);
+      double ji = oi.j2/2.;
+      double jj = oj.j2/2.;
+      index_t ketmin = ch_bra==ch_ket ? ibra : 0;
+      for (index_t iket=ketmin; iket<nKets; ++iket)
       {
-         const Ket & bra = tbc_bra.GetKet(ibra);
-         int i = bra.p;
-         int j = bra.q;
-         const Orbit & oi = Z.modelspace->GetOrbit(i);
-         const Orbit & oj = Z.modelspace->GetOrbit(j);
-         double ji = oi.j2/2.;
-         double jj = oj.j2/2.;
-         index_t ketmin = ch_bra==ch_ket ? ibra : 0;
-         for (index_t iket=ketmin; iket<nKets; ++iket)
-         {
-            const Ket & ket = tbc_ket.GetKet(iket);
-            int k = ket.p;
-            int l = ket.q;
-            const Orbit & ok = Z.modelspace->GetOrbit(k);
-            const Orbit & ol = Z.modelspace->GetOrbit(l);
-            double jk = ok.j2/2.;
-            double jl = ol.j2/2.;
-
-            double commij = 0;
-            double commji = 0;
-
-            // Transform Z_ilkj
-            int parity_bra_cc = (oi.l+ol.l)%2;
-            int parity_ket_cc = (ok.l+oj.l)%2;
-//            int Tz_bra_cc = std::abs(oi.tz2+ol.tz2)/2;
-//            int Tz_ket_cc = std::abs(ok.tz2+oj.tz2)/2;
-            int Tz_bra_cc = std::abs(oi.tz2-ol.tz2)/2;
-            int Tz_ket_cc = std::abs(ok.tz2-oj.tz2)/2;
-            int j3min = std::abs(int(ji-jl));
-            int j3max = ji+jl;
-            for (int J3=j3min; J3<=j3max; ++J3)
+        const Ket & ket = tbc_ket.GetKet(iket);
+        int k = ket.p;
+        int l = ket.q;
+        const Orbit & ok = Z.modelspace->GetOrbit(k);
+        const Orbit & ol = Z.modelspace->GetOrbit(l);
+        double jk = ok.j2/2.;
+        double jl = ol.j2/2.;
+
+        double commij = 0;
+        double commji = 0;
+
+        // Transform Z_ilkj
+        int parity_bra_cc = (oi.l+ol.l)%2;
+        int parity_ket_cc = (ok.l+oj.l)%2;
+        //            int Tz_bra_cc = std::abs(oi.tz2+ol.tz2)/2;
+        //            int Tz_ket_cc = std::abs(ok.tz2+oj.tz2)/2;
+        int Tz_bra_cc = std::abs(oi.tz2-ol.tz2)/2;
+        int Tz_ket_cc = std::abs(ok.tz2-oj.tz2)/2;
+        int j3min = std::abs(int(ji-jl));
+        int j3max = ji+jl;
+        for (int J3=j3min; J3<=j3max; ++J3)
+        {
+          index_t ch_bra_cc = Z.modelspace->GetTwoBodyChannelIndex(J3,parity_bra_cc,Tz_bra_cc);
+          const TwoBodyChannel_CC& tbc_bra_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_bra_cc);
+          index_t nbras = tbc_bra_cc.GetNumberKets();
+          index_t indx_il = tbc_bra_cc.GetLocalIndex( std::min(i,l), std::max(i,l) );
+          int j4min = std::max( std::abs(int(jk-jj)), std::abs(J3-Lambda) );
+          int j4max = std::min( int(jk+jj), J3+Lambda );
+          for (int J4=j4min; J4<=j4max; ++J4)
+          {
+            index_t ch_ket_cc = Z.modelspace->GetTwoBodyChannelIndex(J4,parity_ket_cc,Tz_ket_cc);
+            const TwoBodyChannel_CC& tbc_ket_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_ket_cc);
+            index_t nkets = tbc_ket_cc.GetNumberKets();
+            index_t indx_kj = tbc_ket_cc.GetLocalIndex( std::min(j,k), std::max(j,k) );
+
+            double ninej = Z.modelspace->GetNineJ(ji,jl,J3,jj,jk,J4,J1,J2,Lambda);
+            if (std::abs(ninej) < 1e-8) continue;
+            double hatfactor = sqrt( (2*J1+1)*(2*J2+1)*(2*J3+1)*(2*J4+1) );
+            double tbme = 0;
+            index_t ch_lo = std::min(ch_bra_cc,ch_ket_cc);
+            index_t ch_hi = std::max(ch_bra_cc,ch_ket_cc);
+            auto zbar_iter = Zbar.find({ch_lo,ch_hi});
+            if (zbar_iter == Zbar.end()) continue;
+            const auto& Zmat = zbar_iter->second;
+
+            if (ch_bra_cc <= ch_ket_cc)
             {
-              index_t ch_bra_cc = Z.modelspace->GetTwoBodyChannelIndex(J3,parity_bra_cc,Tz_bra_cc);
-              const TwoBodyChannel_CC& tbc_bra_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_bra_cc);
-              index_t nbras = tbc_bra_cc.GetNumberKets();
-              index_t indx_il = tbc_bra_cc.GetLocalIndex( std::min(i,l), std::max(i,l) );
-              int j4min = std::max( std::abs(int(jk-jj)), std::abs(J3-Lambda) );
-              int j4max = std::min( int(jk+jj), J3+Lambda );
-              for (int J4=j4min; J4<=j4max; ++J4)
-              {
-                 index_t ch_ket_cc = Z.modelspace->GetTwoBodyChannelIndex(J4,parity_ket_cc,Tz_ket_cc);
-                 const TwoBodyChannel_CC& tbc_ket_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_ket_cc);
-                 index_t nkets = tbc_ket_cc.GetNumberKets();
-                 index_t indx_kj = tbc_ket_cc.GetLocalIndex( std::min(j,k), std::max(j,k) );
-
-                  double ninej = Z.modelspace->GetNineJ(ji,jl,J3,jj,jk,J4,J1,J2,Lambda);
-                  if (std::abs(ninej) < 1e-8) continue;
-                  double hatfactor = sqrt( (2*J1+1)*(2*J2+1)*(2*J3+1)*(2*J4+1) );
-                  double tbme = 0;
-                  index_t ch_lo = std::min(ch_bra_cc,ch_ket_cc);
-                  index_t ch_hi = std::max(ch_bra_cc,ch_ket_cc);
-                  auto zbar_iter = Zbar.find({ch_lo,ch_hi});
-                  if (zbar_iter == Zbar.end()) continue;
-                  const auto& Zmat = zbar_iter->second;
-
-                  if (ch_bra_cc <= ch_ket_cc)
-                  {
-                    if (i<=l) tbme = Zmat( indx_il ,indx_kj+(k>j?nkets:0) );
-                    else      tbme = Zmat( indx_il ,indx_kj+(k>j?0:nkets) ) * hZ * Z.modelspace->phase(J3-J4 + ji+jj+jk+jl);
-                  }
-                  else
-                  {
-                      if(k<=j) tbme = Zmat(indx_kj, indx_il+(i>l?nbras:0) ) * hZ * Z.modelspace->phase(J3-J4); // Z_ilkj = Z_kjil * (phase)
-                      else     tbme = Zmat(indx_kj, indx_il+(i>l?0:nbras) ) * Z.modelspace->phase( ji+jj+jk+jl) ; // Z_ilkj = Z_kjil * (phase)
-                  }
-                  commij += hatfactor * Z.modelspace->phase(jj+jl+J2+J4) * ninej * tbme ;
-              }
+              if (i<=l) tbme = Zmat( indx_il ,indx_kj+(k>j?nkets:0) );
+              else      tbme = Zmat( indx_il ,indx_kj+(k>j?0:nkets) ) * hZ * Z.modelspace->phase(J3-J4 + ji+jj+jk+jl);
             }
-
-            if (i==j)
+            else
             {
-              commji = commij;
+              if(k<=j) tbme = Zmat(indx_kj, indx_il+(i>l?nbras:0) ) * hZ * Z.modelspace->phase(J3-J4); // Z_ilkj = Z_kjil * (phase)
+              else     tbme = Zmat(indx_kj, indx_il+(i>l?0:nbras) ) * Z.modelspace->phase( ji+jj+jk+jl) ; // Z_ilkj = Z_kjil * (phase)
             }
-            else
+            commij += hatfactor * Z.modelspace->phase(jj+jl+J2+J4) * ninej * tbme ;
+          }
+        }
+
+        if (i==j)
+        {
+          commji = commij;
+        }
+        else
+        {
+          // Transform Z_jlki
+          parity_bra_cc = (oj.l+ol.l)%2;
+          parity_ket_cc = (ok.l+oi.l)%2;
+          //              Tz_bra_cc = std::abs(oj.tz2+ol.tz2)/2;
+          //              Tz_ket_cc = std::abs(ok.tz2+oi.tz2)/2;
+          Tz_bra_cc = std::abs(oj.tz2-ol.tz2)/2;
+          Tz_ket_cc = std::abs(ok.tz2-oi.tz2)/2;
+          j3min = std::abs(int(jj-jl));
+          j3max = jj+jl;
+
+          for (int J3=j3min; J3<=j3max; ++J3)
+          {
+            int ch_bra_cc = Z.modelspace->GetTwoBodyChannelIndex(J3,parity_bra_cc,Tz_bra_cc);
+            const TwoBodyChannel_CC& tbc_bra_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_bra_cc);
+            int nbras = tbc_bra_cc.GetNumberKets();
+            int indx_jl = tbc_bra_cc.GetLocalIndex( std::min(j,l), std::max(j,l) );
+            int j4min = std::max( std::abs(int(jk-ji)), std::abs(J3-Lambda) );
+            int j4max = std::min( int(jk+ji), J3+Lambda );
+            for (int J4=j4min; J4<=j4max; ++J4)
             {
-              // Transform Z_jlki
-              parity_bra_cc = (oj.l+ol.l)%2;
-              parity_ket_cc = (ok.l+oi.l)%2;
-//              Tz_bra_cc = std::abs(oj.tz2+ol.tz2)/2;
-//              Tz_ket_cc = std::abs(ok.tz2+oi.tz2)/2;
-              Tz_bra_cc = std::abs(oj.tz2-ol.tz2)/2;
-              Tz_ket_cc = std::abs(ok.tz2-oi.tz2)/2;
-              j3min = std::abs(int(jj-jl));
-              j3max = jj+jl;
-  
-              for (int J3=j3min; J3<=j3max; ++J3)
+              int ch_ket_cc = Z.modelspace->GetTwoBodyChannelIndex(J4,parity_ket_cc,Tz_ket_cc);
+              const TwoBodyChannel_CC& tbc_ket_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_ket_cc);
+              int nkets = tbc_ket_cc.GetNumberKets();
+              int indx_ki = tbc_ket_cc.GetLocalIndex( std::min(k,i), std::max(k,i) );
+              double ninej = Z.modelspace->GetNineJ(jj,jl,J3,ji,jk,J4,J1,J2,Lambda);
+              if (std::abs(ninej) < 1e-8) continue;
+              double hatfactor = sqrt( (2*J1+1)*(2*J2+1)*(2*J3+1)*(2*J4+1) );
+
+              index_t ch_lo = std::min(ch_bra_cc,ch_ket_cc);
+              index_t ch_hi = std::max(ch_bra_cc,ch_ket_cc);
+              auto zbar_iter = Zbar.find({ch_lo,ch_hi});
+              if (zbar_iter == Zbar.end()) continue;
+              const auto& Zmat = zbar_iter->second;
+              double tbme = 0;
+              if (ch_bra_cc <= ch_ket_cc)
               {
-                int ch_bra_cc = Z.modelspace->GetTwoBodyChannelIndex(J3,parity_bra_cc,Tz_bra_cc);
-                const TwoBodyChannel_CC& tbc_bra_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_bra_cc);
-                int nbras = tbc_bra_cc.GetNumberKets();
-                int indx_jl = tbc_bra_cc.GetLocalIndex( std::min(j,l), std::max(j,l) );
-                int j4min = std::max( std::abs(int(jk-ji)), std::abs(J3-Lambda) );
-                int j4max = std::min( int(jk+ji), J3+Lambda );
-                for (int J4=j4min; J4<=j4max; ++J4)
-                {
-                   int ch_ket_cc = Z.modelspace->GetTwoBodyChannelIndex(J4,parity_ket_cc,Tz_ket_cc);
-                   const TwoBodyChannel_CC& tbc_ket_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_ket_cc);
-                   int nkets = tbc_ket_cc.GetNumberKets();
-                   int indx_ki = tbc_ket_cc.GetLocalIndex( std::min(k,i), std::max(k,i) );
-                    double ninej = Z.modelspace->GetNineJ(jj,jl,J3,ji,jk,J4,J1,J2,Lambda);
-                    if (std::abs(ninej) < 1e-8) continue;
-                    double hatfactor = sqrt( (2*J1+1)*(2*J2+1)*(2*J3+1)*(2*J4+1) );
-  
-                    index_t ch_lo = std::min(ch_bra_cc,ch_ket_cc);
-                    index_t ch_hi = std::max(ch_bra_cc,ch_ket_cc);
-                    auto zbar_iter = Zbar.find({ch_lo,ch_hi});
-                    if (zbar_iter == Zbar.end()) continue;
-                    const auto& Zmat = zbar_iter->second;
-                    double tbme = 0;
-                    if (ch_bra_cc <= ch_ket_cc)
-                    {
-                      if (j<=l) tbme = Zmat( indx_jl ,indx_ki+(k>i?nkets:0) );
-                      else      tbme = Zmat( indx_jl ,indx_ki+(k>i?0:nkets) ) * hZ * Z.modelspace->phase(J3-J4 + ji+jj+jk+jl);
-                    }
-                    else
-                    {
-                        if(k<=i) tbme = Zmat(indx_ki, indx_jl+(j>l?nbras:0) ) * hZ * Z.modelspace->phase(J3-J4); // Z_ilkj = Z_kjil * (phase)
-                        else     tbme = Zmat(indx_ki, indx_jl+(j>l?0:nbras) ) * Z.modelspace->phase( ji+jj+jk+jl) ; // Z_ilkj = Z_kjil * (phase)
-                    }
-  
-  
-                      commji += hatfactor * Z.modelspace->phase(ji+jl+J2+J4) * ninej * tbme ;
-                }
+                if (j<=l) tbme = Zmat( indx_jl ,indx_ki+(k>i?nkets:0) );
+                else      tbme = Zmat( indx_jl ,indx_ki+(k>i?0:nkets) ) * hZ * Z.modelspace->phase(J3-J4 + ji+jj+jk+jl);
               }
+              else
+              {
+                if(k<=i) tbme = Zmat(indx_ki, indx_jl+(j>l?nbras:0) ) * hZ * Z.modelspace->phase(J3-J4); // Z_ilkj = Z_kjil * (phase)
+                else     tbme = Zmat(indx_ki, indx_jl+(j>l?0:nbras) ) * Z.modelspace->phase( ji+jj+jk+jl) ; // Z_ilkj = Z_kjil * (phase)
+              }
+
+
+              commji += hatfactor * Z.modelspace->phase(ji+jl+J2+J4) * ninej * tbme ;
             }
+          }
+        }
 
-            double norm = bra.delta_pq()==ket.delta_pq() ? 1+bra.delta_pq() : PhysConst::SQRT2;
-            Zijkl(ibra,iket) +=  (commij - Z.modelspace->phase(ji+jj-J1)*commji) / norm;
-            if (ch_bra==ch_ket) Zijkl(iket,ibra) = hZ * Zijkl(ibra,iket);
-         }
+        double norm = bra.delta_pq()==ket.delta_pq() ? 1+bra.delta_pq() : PhysConst::SQRT2;
+        Zijkl(ibra,iket) +=  (commij - Z.modelspace->phase(ji+jj-J1)*commji) / norm;
+        if (ch_bra==ch_ket) Zijkl(iket,ibra) = hZ * Zijkl(ibra,iket);
       }
-   }
+    }
+  }
 }
 
 
@@ -9750,16 +9975,16 @@ void AddInverseTensorPandyaTransformation( Operator& Z, const std::map<std::arra
 
 //*****************************************************************************************
 //
-//  THIS IS THE BIG UGLY ONE.     
-//                                             
-//   |          |      |          |           
-//   |     __Y__|      |     __X__|            
+//  THIS IS THE BIG UGLY ONE.
+//
+//   |          |      |          |
+//   |     __Y__|      |     __X__|
 //   |    /\    |      |    /\    |
-//   |   (  )   |  _   |   (  )   |            
-//   |____\/    |      |____\/    |            
-//   |  X       |      |  Y       |            
-//           
-//            
+//   |   (  )   |  _   |   (  )   |
+//   |____\/    |      |____\/    |
+//   |  X       |      |  Y       |
+//
+//
 // -- This appears to agree with Nathan's results
 //
 /// Calculates the part of \f$ [X_{(2)},\mathbb{Y}^{\Lambda}_{(2)}]_{ijkl} \f$ which involves ph intermediate states, here indicated by \f$ \mathbb{Z}^{J_1J_2\Lambda}_{ijkl} \f$
@@ -9771,7 +9996,7 @@ void AddInverseTensorPandyaTransformation( Operator& Z, const std::map<std::arra
 ///  j_j  &  j_k  &  J_4 \\
 ///  J_1  &  J_2  &  \Lambda \\
 ///  \end{array} \right\}
-/// \left( \bar{X}^{J3}_{i\bar{l}a\bar{b}}\bar{\mathbb{Y}}^{J_3J_4\Lambda}_{a\bar{b}k\bar{j}} - 
+/// \left( \bar{X}^{J3}_{i\bar{l}a\bar{b}}\bar{\mathbb{Y}}^{J_3J_4\Lambda}_{a\bar{b}k\bar{j}} -
 ///   \bar{\mathbb{Y}}^{J_3J_4\Lambda}_{i\bar{l}a\bar{b}}\bar{X}^{J_4}_{a\bar{b}k\bar{j}} \right)
 ///  -(-1)^{j_i+j_j-J_1}
 ///  \left\{ \begin{array}{lll}
@@ -9779,16 +10004,16 @@ void AddInverseTensorPandyaTransformation( Operator& Z, const std::map<std::arra
 ///  j_i  &  j_k  &  J_4 \\
 ///  J_1  &  J_2  &  \Lambda \\
 ///  \end{array} \right\}
-/// \left( \bar{X}^{J_3}_{i\bar{l}a\bar{b}}\bar{\mathbb{Y}}^{J_3J_4\Lambda}_{a\bar{b}k\bar{j}} - 
+/// \left( \bar{X}^{J_3}_{i\bar{l}a\bar{b}}\bar{\mathbb{Y}}^{J_3J_4\Lambda}_{a\bar{b}k\bar{j}} -
 ///   \bar{\mathbb{Y}}^{J_3J_4\Lambda}_{i\bar{l}a\bar{b}}\bar{X}^{J_4}_{a\bar{b}k\bar{j}} \right)
 /// \right]
 /// \f]
 /// This is implemented by defining an intermediate matrix
 /// \f[
 /// \bar{\mathbb{Z}}^{J_3J_4\Lambda}_{i\bar{l}k\bar{j}} \equiv \sum_{ab}(n_a\bar{n}_b)
-/// \left[ \left( \bar{X}^{J3}_{i\bar{l}a\bar{b}}\bar{\mathbb{Y}}^{J_3J_4\Lambda}_{a\bar{b}k\bar{j}} - 
+/// \left[ \left( \bar{X}^{J3}_{i\bar{l}a\bar{b}}\bar{\mathbb{Y}}^{J_3J_4\Lambda}_{a\bar{b}k\bar{j}} -
 ///   \bar{\mathbb{Y}}^{J_3J_4\Lambda}_{i\bar{l}a\bar{b}}\bar{X}^{J_4}_{a\bar{b}k\bar{j}} \right)
-/// -\left( \bar{X}^{J_3}_{i\bar{l}b\bar{a}}\bar{\mathbb{Y}}^{J_3J_4\Lambda}_{b\bar{a}k\bar{j}} - 
+/// -\left( \bar{X}^{J_3}_{i\bar{l}b\bar{a}}\bar{\mathbb{Y}}^{J_3J_4\Lambda}_{b\bar{a}k\bar{j}} -
 ///    \bar{\mathbb{Y}}^{J_3J_4\Lambda}_{i\bar{l}b\bar{a}}\bar{X}^{J_4}_{b\bar{a}k\bar{j}} \right)\right]
 /// \f]
 /// The Pandya-transformed matrix elements are obtained with DoTensorPandyaTransformation().
@@ -9816,153 +10041,153 @@ void AddInverseTensorPandyaTransformation( Operator& Z, const std::map<std::arra
 ///  \right]
 ///  \f]
 ///
-//void Operator::comm222_phst( Operator& Y, Operator& Z ) 
-//void Operator::comm222_phst( const Operator& X, const Operator& Y ) 
-void comm222_phst( const Operator& X, const Operator& Y, Operator& Z ) 
+//void Operator::comm222_phst( Operator& Y, Operator& Z )
+//void Operator::comm222_phst( const Operator& X, const Operator& Y )
+void comm222_phst( const Operator& X, const Operator& Y, Operator& Z )
 {
 
-   int hX = X.IsHermitian() ? 1 : -1;
-   int hY = Y.IsHermitian() ? 1 : -1;
+  int hX = X.IsHermitian() ? 1 : -1;
+  int hY = Y.IsHermitian() ? 1 : -1;
 
-   double t_start = omp_get_wtime();
-   // We reuse Xt_bar multiple times, so it makes sense to calculate them once and store them in a deque.
-   std::deque<arma::mat> Xt_bar_ph = InitializePandya( Z, Z.nChannels, "transpose"); // We re-use the scalar part multiple times, so there's a significant speed gain for saving it
-   std::map<std::array<index_t,2>,arma::mat> Y_bar_ph;
-   DoPandyaTransformation(X, Xt_bar_ph, "transpose" );
-   X.profiler.timer["DoTensorPandyaTransformation"] += omp_get_wtime() - t_start;
+  double t_start = omp_get_wtime();
+  // We reuse Xt_bar multiple times, so it makes sense to calculate them once and store them in a deque.
+  std::deque<arma::mat> Xt_bar_ph = InitializePandya( Z, Z.nChannels, "transpose"); // We re-use the scalar part multiple times, so there's a significant speed gain for saving it
+  std::map<std::array<index_t,2>,arma::mat> Y_bar_ph;
+  DoPandyaTransformation(X, Xt_bar_ph, "transpose" );
+  X.profiler.timer["DoTensorPandyaTransformation"] += omp_get_wtime() - t_start;
 
 
-   t_start = omp_get_wtime();
-   // Construct the intermediate matrix Z_bar
-   // First, we initialize the map Z_bar with empty matrices
-   // to avoid problems in the parallel loop -- (do we even want a parallel loop here?)
-   std::map<std::array<index_t,2>,arma::mat> Z_bar;
+  t_start = omp_get_wtime();
+  // Construct the intermediate matrix Z_bar
+  // First, we initialize the map Z_bar with empty matrices
+  // to avoid problems in the parallel loop -- (do we even want a parallel loop here?)
+  std::map<std::array<index_t,2>,arma::mat> Z_bar;
 
-   t_start = omp_get_wtime();
-   const auto& pandya_lookup = Z.modelspace->GetPandyaLookup(Z.GetJRank(), Z.GetTRank(), Z.GetParity() );
-   X.profiler.timer["PandyaLookup"] += omp_get_wtime() - t_start;
+  t_start = omp_get_wtime();
+  const auto& pandya_lookup = Z.modelspace->GetPandyaLookup(Z.GetJRank(), Z.GetTRank(), Z.GetParity() );
+  X.profiler.timer["PandyaLookup"] += omp_get_wtime() - t_start;
 
-   std::vector<index_t> ybras;
-   std::vector<index_t> ykets;
-   for (auto ich_bra : Z.modelspace->SortedTwoBodyChannels_CC)
-   {
-     int n_rows = Z.modelspace->GetTwoBodyChannel_CC(ich_bra).GetNumberKets();
-     for (auto ich_ket : Z.modelspace->SortedTwoBodyChannels_CC)
-     {
-       if (ich_bra>ich_ket) continue;
-//       if (pandya_lookup.at({(int)ich_bra,(int)ich_ket})[0].size()<1) continue;
-       if (pandya_lookup.at({ich_bra,ich_ket})[0].size()<1) continue;
-         int n_cols = 2*Z.modelspace->GetTwoBodyChannel_CC(ich_ket).GetNumberKets();
-         ybras.push_back(ich_bra);
-         ykets.push_back(ich_ket);
-         Z_bar[{ich_bra,ich_ket}] = arma::mat(n_rows,n_cols);
-     }
-   }
-   int counter = ybras.size();
-//  std::cout << "Done allocating" << std::endl;
-
-
-   X.profiler.timer["Allocate Z_bar_tensor"] += omp_get_wtime() - t_start;
-
-   t_start = omp_get_wtime();
-
-   #ifndef OPENBLAS_NOUSEOMP
-   #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->tensor_transform_first_pass.at(Z.GetJRank()))
-   #endif
-   for(int i=0;i<counter;++i)
-   {
-      index_t ch_bra_cc = ybras[i];
-      index_t ch_ket_cc = ykets[i];
-//      const auto plookup = pandya_lookup.find({(int)ch_bra_cc,(int)ch_ket_cc});
-      const auto plookup = pandya_lookup.find({ch_bra_cc,ch_ket_cc});
-      if ( plookup == pandya_lookup.end() or plookup->second[0].size()<1 )
-      {
-       continue;
-      }
+  std::vector<index_t> ybras;
+  std::vector<index_t> ykets;
+  for (auto ich_bra : Z.modelspace->SortedTwoBodyChannels_CC)
+  {
+    int n_rows = Z.modelspace->GetTwoBodyChannel_CC(ich_bra).GetNumberKets();
+    for (auto ich_ket : Z.modelspace->SortedTwoBodyChannels_CC)
+    {
+      if (ich_bra>ich_ket) continue;
+      //       if (pandya_lookup.at({(int)ich_bra,(int)ich_ket})[0].size()<1) continue;
+      if (pandya_lookup.at({ich_bra,ich_ket})[0].size()<1) continue;
+      int n_cols = 2*Z.modelspace->GetTwoBodyChannel_CC(ich_ket).GetNumberKets();
+      ybras.push_back(ich_bra);
+      ykets.push_back(ich_ket);
+      Z_bar[{ich_bra,ich_ket}] = arma::mat(n_rows,n_cols);
+    }
+  }
+  int counter = ybras.size();
+  //  std::cout << "Done allocating" << std::endl;
 
-      const auto& tbc_bra_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_bra_cc);
-      const auto& tbc_ket_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_ket_cc);
-      int Jbra = tbc_bra_cc.J;
-      int Jket = tbc_ket_cc.J;
 
-      arma::mat YJ1J2;
-      arma::mat YJ2J1;
-      const auto& XJ1 = Xt_bar_ph[ch_bra_cc];
-      const auto& XJ2 = Xt_bar_ph[ch_ket_cc];
+  X.profiler.timer["Allocate Z_bar_tensor"] += omp_get_wtime() - t_start;
 
-      arma::uvec kets_ph = arma::join_cols( tbc_ket_cc.GetKetIndex_hh(), tbc_ket_cc.GetKetIndex_ph() );
-      arma::uvec bras_ph = arma::join_cols( tbc_bra_cc.GetKetIndex_hh(), tbc_bra_cc.GetKetIndex_ph() );
+  t_start = omp_get_wtime();
 
-      DoTensorPandyaTransformation_SingleChannel(Y, YJ1J2, ch_bra_cc, ch_ket_cc);
-      if (ch_bra_cc==ch_ket_cc)
-      {
-         YJ2J1 = YJ1J2;
-      }
-      else
-      {
-         DoTensorPandyaTransformation_SingleChannel(Y, YJ2J1, ch_ket_cc, ch_bra_cc);
-      }
+#ifndef OPENBLAS_NOUSEOMP
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->tensor_transform_first_pass.at(Z.GetJRank()))
+#endif
+  for(int i=0;i<counter;++i)
+  {
+    index_t ch_bra_cc = ybras[i];
+    index_t ch_ket_cc = ykets[i];
+    //      const auto plookup = pandya_lookup.find({(int)ch_bra_cc,(int)ch_ket_cc});
+    const auto plookup = pandya_lookup.find({ch_bra_cc,ch_ket_cc});
+    if ( plookup == pandya_lookup.end() or plookup->second[0].size()<1 )
+    {
+      continue;
+    }
 
-      int flipphaseY = hY * Z.modelspace->phase( Jbra - Jket ) ;
-      // construct a matrix of phases (-1)^{k+j+p+h} used below to generate X_phkj for k>j
-      arma::mat PhaseMatXJ2( tbc_ket_cc.GetNumberKets(), kets_ph.size(), arma::fill::ones) ;
-      arma::mat PhaseMatYJ1J2( bras_ph.size(), tbc_ket_cc.GetNumberKets(), arma::fill::ones) ;
-      for ( index_t iket=0;iket<(index_t)tbc_ket_cc.GetNumberKets();iket++)
-      {
-        const Ket& ket = tbc_ket_cc.GetKet(iket);
-        if ( Z.modelspace->phase((ket.op->j2+ket.oq->j2)/2)<0)
-        {
-           PhaseMatXJ2.row(iket) *=-1;
-           PhaseMatYJ1J2.col(iket) *=-1;
-        }
-      }
-      for (index_t iph=0;iph<kets_ph.size();iph++)
-      {
-        const Ket& ket_ph = tbc_ket_cc.GetKet( kets_ph[iph] );
-        if ( Z.modelspace->phase((ket_ph.op->j2+ket_ph.oq->j2)/2)<0)   PhaseMatXJ2.col(iph) *=-1;
-      }
-      for (index_t iph=0;iph<bras_ph.size();iph++)
+    const auto& tbc_bra_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_bra_cc);
+    const auto& tbc_ket_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_ket_cc);
+    int Jbra = tbc_bra_cc.J;
+    int Jket = tbc_ket_cc.J;
+
+    arma::mat YJ1J2;
+    arma::mat YJ2J1;
+    const auto& XJ1 = Xt_bar_ph[ch_bra_cc];
+    const auto& XJ2 = Xt_bar_ph[ch_ket_cc];
+
+    arma::uvec kets_ph = arma::join_cols( tbc_ket_cc.GetKetIndex_hh(), tbc_ket_cc.GetKetIndex_ph() );
+    arma::uvec bras_ph = arma::join_cols( tbc_bra_cc.GetKetIndex_hh(), tbc_bra_cc.GetKetIndex_ph() );
+
+    DoTensorPandyaTransformation_SingleChannel(Y, YJ1J2, ch_bra_cc, ch_ket_cc);
+    if (ch_bra_cc==ch_ket_cc)
+    {
+      YJ2J1 = YJ1J2;
+    }
+    else
+    {
+      DoTensorPandyaTransformation_SingleChannel(Y, YJ2J1, ch_ket_cc, ch_bra_cc);
+    }
+
+    int flipphaseY = hY * Z.modelspace->phase( Jbra - Jket ) ;
+    // construct a matrix of phases (-1)^{k+j+p+h} used below to generate X_phkj for k>j
+    arma::mat PhaseMatXJ2( tbc_ket_cc.GetNumberKets(), kets_ph.size(), arma::fill::ones) ;
+    arma::mat PhaseMatYJ1J2( bras_ph.size(), tbc_ket_cc.GetNumberKets(), arma::fill::ones) ;
+    for ( index_t iket=0;iket<(index_t)tbc_ket_cc.GetNumberKets();iket++)
+    {
+      const Ket& ket = tbc_ket_cc.GetKet(iket);
+      if ( Z.modelspace->phase((ket.op->j2+ket.oq->j2)/2)<0)
       {
-        const Ket& bra_ph = tbc_bra_cc.GetKet( bras_ph[iph] );
-        if ( Z.modelspace->phase((bra_ph.op->j2+bra_ph.oq->j2)/2)<0)   PhaseMatYJ1J2.row(iph) *=-1;
+        PhaseMatXJ2.row(iket) *=-1;
+        PhaseMatYJ1J2.col(iket) *=-1;
       }
-      PhaseMatYJ1J2 *= flipphaseY;
+    }
+    for (index_t iph=0;iph<kets_ph.size();iph++)
+    {
+      const Ket& ket_ph = tbc_ket_cc.GetKet( kets_ph[iph] );
+      if ( Z.modelspace->phase((ket_ph.op->j2+ket_ph.oq->j2)/2)<0)   PhaseMatXJ2.col(iph) *=-1;
+    }
+    for (index_t iph=0;iph<bras_ph.size();iph++)
+    {
+      const Ket& bra_ph = tbc_bra_cc.GetKet( bras_ph[iph] );
+      if ( Z.modelspace->phase((bra_ph.op->j2+bra_ph.oq->j2)/2)<0)   PhaseMatYJ1J2.row(iph) *=-1;
+    }
+    PhaseMatYJ1J2 *= flipphaseY;
 
 
 
-//                J2                       J1         J2                       J2          J2
-//             k<=j     k>=j                hp  -ph    hp   ph                 k<=j       k<=j
-//      J1   [       |       ]       J1   [           |          ]         [hp        |ph        ]
-//     i<=j  [  Zbar | Zbar  ]  =   i<=j  [   Xbar    | -Ybar    ]   * J1  [   Ybar   |   Ybar'  ]
-//           [       |       ]            [           |          ]         [ph        |hp        ]      where Ybar'_phkj = Ybar_hpkj * (-1)^{p+h+k+j}*(-1)^{J1-J2}*hY
-//                                                                         [----------|----------]       and
-//                                                                     J2  [hp        |ph        ]            Xbar'_phkj = Xbar_hpkj * (-1)^{p+h+k+j}*hX
-//                                                                         [   Xbar   |   Xbar'  ]
-//                                                                         [-ph       |-hp       ]
-//    
-//
-      int halfncx2 = XJ2.n_cols/2;
-      int halfnry12 = YJ1J2.n_rows/2;
-      auto& Zmat = Z_bar.at({ch_bra_cc,ch_ket_cc});
+    //                J2                       J1         J2                       J2          J2
+    //             k<=j     k>=j                hp  -ph    hp   ph                 k<=j       k<=j
+    //      J1   [       |       ]       J1   [           |          ]         [hp        |ph        ]
+    //     i<=j  [  Zbar | Zbar  ]  =   i<=j  [   Xbar    | -Ybar    ]   * J1  [   Ybar   |   Ybar'  ]
+    //           [       |       ]            [           |          ]         [ph        |hp        ]      where Ybar'_phkj = Ybar_hpkj * (-1)^{p+h+k+j}*(-1)^{J1-J2}*hY
+    //                                                                         [----------|----------]       and
+    //                                                                     J2  [hp        |ph        ]            Xbar'_phkj = Xbar_hpkj * (-1)^{p+h+k+j}*hX
+    //                                                                         [   Xbar   |   Xbar'  ]
+    //                                                                         [-ph       |-hp       ]
+    //
+    //
+    int halfncx2 = XJ2.n_cols/2;
+    int halfnry12 = YJ1J2.n_rows/2;
+    auto& Zmat = Z_bar.at({ch_bra_cc,ch_ket_cc});
 
-      arma::mat Mleft = join_horiz( XJ1,  -flipphaseY * YJ2J1.t() );
-      arma::mat Mright = join_vert( join_horiz( YJ1J2 ,  join_vert( YJ1J2.tail_rows(halfnry12)%PhaseMatYJ1J2 ,
-                                                                    YJ1J2.head_rows(halfnry12)%PhaseMatYJ1J2  )   ), 
-                                  hX*join_vert( XJ2,    join_horiz(   XJ2.tail_cols(halfncx2)%PhaseMatXJ2 ,
-                                                                      XJ2.head_cols(halfncx2)%PhaseMatXJ2     )   ).t() );
+    arma::mat Mleft = join_horiz( XJ1,  -flipphaseY * YJ2J1.t() );
+    arma::mat Mright = join_vert( join_horiz( YJ1J2 ,  join_vert( YJ1J2.tail_rows(halfnry12)%PhaseMatYJ1J2 ,
+            YJ1J2.head_rows(halfnry12)%PhaseMatYJ1J2  )   ),
+        hX*join_vert( XJ2,    join_horiz(   XJ2.tail_cols(halfncx2)%PhaseMatXJ2 ,
+            XJ2.head_cols(halfncx2)%PhaseMatXJ2     )   ).t() );
 
-      Zmat = Mleft * Mright;
+    Zmat = Mleft * Mright;
 
-   }
-   X.profiler.timer["Build Z_bar_tensor"] += omp_get_wtime() - t_start;
+  }
+  X.profiler.timer["Build Z_bar_tensor"] += omp_get_wtime() - t_start;
 
 
-   t_start = omp_get_wtime();
-   AddInverseTensorPandyaTransformation(Z, Z_bar);
+  t_start = omp_get_wtime();
+  AddInverseTensorPandyaTransformation(Z, Z_bar);
 
-   X.profiler.timer["InverseTensorPandyaTransformation"] += omp_get_wtime() - t_start;
+  X.profiler.timer["InverseTensorPandyaTransformation"] += omp_get_wtime() - t_start;
 
-   Z.modelspace->tensor_transform_first_pass.at( Z.GetJRank() ) = false;
+  Z.modelspace->tensor_transform_first_pass.at( Z.GetJRank() ) = false;
 
 }
 
@@ -9985,21 +10210,21 @@ void comm222_phst( const Operator& X, const Operator& Y, Operator& Z )
 //*****************************************************************************************
 // [X^(2), Y^(1)]^(1)
 //
-//      |i                 i|   
-//      |                   |   
+//      |i                 i|
+//      |                   |
 //     (X)         ---      |  (Y)
 //       a\                 |  /a
 //         (Y)             (X)/
-//           
+//
 //
 // Sum_ia X_ia Y_a^{lambda}
 // Adapted from
-//    void Operator::comm111ss( const Operator & X, const Operator& Y) 
+//    void Operator::comm111ss( const Operator & X, const Operator& Y)
 // This could be modified to be more efficent since we only need one column from Y to go to one column in Z.
 // But this is so far from being the bottleneck that it makes more sense to be clear.
 void comm211sd( const Operator& X, const Operator& Y, Operator& Z )
 {
-   Z.OneBody += X.OneBody*Y.OneBody;
+  Z.OneBody += X.OneBody*Y.OneBody;
 }
 
 
@@ -10017,45 +10242,45 @@ void comm211sd( const Operator& X, const Operator& Y, Operator& Z )
 // Sum_ab Sum_J (2J+1)/(2lambda+1)  (na n`b) ( X_ab Y_bia - X_ba Y_aib )
 //
 // Adapted from
-//    void Operator::comm121ss( const Operator& X, const Operator& Y) 
-void comm231sd( const Operator& X, const Operator& Y, Operator& Z) 
+//    void Operator::comm121ss( const Operator& X, const Operator& Y)
+void comm231sd( const Operator& X, const Operator& Y, Operator& Z)
 {
-   double t_start = omp_get_wtime();
-   if (Y.legs<3) return;
-//   index_t norbits = Z.modelspace->GetNumberOrbits();
-   index_t Q = Z.GetQSpaceOrbit();
-   Orbit& oQ = Z.modelspace->GetOrbit(Q);
-//   for (index_t i=0;i<norbits;++i)
-//   #pragma omp parallel for 
-   for (auto i : Z.OneBodyChannels.at({oQ.l,oQ.j2,oQ.tz2}) )
-   {
-          for (auto& a : Z.modelspace->holes)  // C++11 syntax
-          {
-             Orbit &oa = Z.modelspace->GetOrbit(a);
-//             for (index_t b=0; b<norbits; ++b)
-             for (auto b : X.OneBodyChannels.at({oa.l,oa.j2,oa.tz2} ))
-             {
-                Orbit &ob = Z.modelspace->GetOrbit(b);
-                double nanb = oa.occ * (1-ob.occ); // despite what the name suggests, nanb is n_a * (1-n_b).
-                if (std::abs(nanb)<ModelSpace::OCC_CUT) continue;
-                int Jmin = std::abs(oa.j2 - oQ.j2)/2;
-                int Jmax = (oa.j2+oQ.j2)/2;
-                double Ymon_bia = 0;
-                double Ymon_aib = 0;
-                for (int J=Jmin;J<=Jmax;J++)
-                {
-                  Ymon_bia += (2*J+1.0) / (oQ.j2+1.0) * Y.ThreeLeg.GetME_J(J,b,i,a);
-                  Ymon_aib += (2*J+1.0) / (oQ.j2+1.0) * Y.ThreeLeg.GetME_J(J,a,i,b);
-                }
-//                Z.OneBody(i,Q) += nanb * X.OneBody(a,b) * Ymon_bia - X.OneBody(b,a) * Ymon_aib;
-                Z.OneBody(i,0) += nanb * X.OneBody(a,b) * Ymon_bia - X.OneBody(b,a) * Ymon_aib;
-//                  Z.OneBody(i,Q) += (ob.j2+1) * nanb *  X.OneBody(a,b) * Y.TwoBody.GetTBMEmonopole(b,i,a,Q) ;  // Is this still the right way to do this? Do we need to worry about normalization? (It looks ok).
-//                  Z.OneBody(i,Q) -= (oa.j2+1) * nanb *  X.OneBody(b,a) * Y.TwoBody.GetTBMEmonopole(a,i,b,Q) ;  // GetTBMEmonopole returns unnormalized TBME summed over J times (2J+1)/((2ji+1)*(2jj+1))
-                
-             }
-          }
-   }
-   Z.profiler.timer[__func__] += omp_get_wtime() - t_start;
+  double t_start = omp_get_wtime();
+  if (Y.legs<3) return;
+  //   index_t norbits = Z.modelspace->GetNumberOrbits();
+  index_t Q = Z.GetQSpaceOrbit();
+  Orbit& oQ = Z.modelspace->GetOrbit(Q);
+  //   for (index_t i=0;i<norbits;++i)
+  //   #pragma omp parallel for
+  for (auto i : Z.OneBodyChannels.at({oQ.l,oQ.j2,oQ.tz2}) )
+  {
+    for (auto& a : Z.modelspace->holes)  // C++11 syntax
+    {
+      Orbit &oa = Z.modelspace->GetOrbit(a);
+      //             for (index_t b=0; b<norbits; ++b)
+      for (auto b : X.OneBodyChannels.at({oa.l,oa.j2,oa.tz2} ))
+      {
+        Orbit &ob = Z.modelspace->GetOrbit(b);
+        double nanb = oa.occ * (1-ob.occ); // despite what the name suggests, nanb is n_a * (1-n_b).
+        if (std::abs(nanb)<ModelSpace::OCC_CUT) continue;
+        int Jmin = std::abs(oa.j2 - oQ.j2)/2;
+        int Jmax = (oa.j2+oQ.j2)/2;
+        double Ymon_bia = 0;
+        double Ymon_aib = 0;
+        for (int J=Jmin;J<=Jmax;J++)
+        {
+          Ymon_bia += (2*J+1.0) / (oQ.j2+1.0) * Y.ThreeLeg.GetME_J(J,b,i,a);
+          Ymon_aib += (2*J+1.0) / (oQ.j2+1.0) * Y.ThreeLeg.GetME_J(J,a,i,b);
+        }
+        //                Z.OneBody(i,Q) += nanb * X.OneBody(a,b) * Ymon_bia - X.OneBody(b,a) * Ymon_aib;
+        Z.OneBody(i,0) += nanb * X.OneBody(a,b) * Ymon_bia - X.OneBody(b,a) * Ymon_aib;
+        //                  Z.OneBody(i,Q) += (ob.j2+1) * nanb *  X.OneBody(a,b) * Y.TwoBody.GetTBMEmonopole(b,i,a,Q) ;  // Is this still the right way to do this? Do we need to worry about normalization? (It looks ok).
+        //                  Z.OneBody(i,Q) -= (oa.j2+1) * nanb *  X.OneBody(b,a) * Y.TwoBody.GetTBMEmonopole(a,i,b,Q) ;  // GetTBMEmonopole returns unnormalized TBME summed over J times (2J+1)/((2ji+1)*(2jj+1))
+
+      }
+    }
+  }
+  Z.profiler.timer[__func__] += omp_get_wtime() - t_start;
 }
 
 
@@ -10066,103 +10291,103 @@ void comm231sd( const Operator& X, const Operator& Y, Operator& Z)
 // [X^(2),Y^(3)]^(3)  and [X^(4),Y^(1)]^(3), combined
 //
 //     |   |  /       |  | /             \ /         \ |  (Y)
-//    (X)  | /   __   | (Y)              (X)    __    \| / 
+//    (X)  | /   __   | (Y)              (X)    __    \| /
 //      \  |/         | /        and     / \          (X)
-//       (Y)         (X)                /  (Y)         | 
+//       (Y)         (X)                /  (Y)         |
 //
 //  ZJ_ijkQ = sum_a  X_ia YJ_ajkQ  + X_ja YJ_iakQ + X_ak YJ_ijaQ + XJ_ijka Y_aQ
 //
 //  I adapted this, but then gave up and brute forced it because the intermediate matrix
 //  stuff was too obfuscated, and I'm the one who wrote it... -SRS 14/04/2018
 // Adapted from
-//  void Operator::comm122ss( const Operator& X, const Operator& Y ) 
-void comm413_233sd( const Operator& X, const Operator& Y, Operator& Z) 
+//  void Operator::comm122ss( const Operator& X, const Operator& Y )
+void comm413_233sd( const Operator& X, const Operator& Y, Operator& Z)
 {
-   double t_start = omp_get_wtime();
-   auto& X1 = X.OneBody;
-   auto& Y1 = Y.OneBody;
+  double t_start = omp_get_wtime();
+  auto& X1 = X.OneBody;
+  auto& Y1 = Y.OneBody;
 
-   index_t Qorbit = Z.GetQSpaceOrbit();
-   Orbit& oQ = Z.modelspace->GetOrbit(Qorbit);
-//   int norb = Z.modelspace->GetNumberOrbits();
+  index_t Qorbit = Z.GetQSpaceOrbit();
+  Orbit& oQ = Z.modelspace->GetOrbit(Qorbit);
+  //   int norb = Z.modelspace->GetNumberOrbits();
 
-   int n_nonzero = Z.modelspace->SortedTwoBodyChannels.size();
-//   #pragma omp parallel for schedule(dynamic,1)
-   for (int ich=0; ich<n_nonzero; ++ich)
-   {
-      int ch = Z.modelspace->SortedTwoBodyChannels[ich];
-      TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
+  int n_nonzero = Z.modelspace->SortedTwoBodyChannels.size();
+  //   #pragma omp parallel for schedule(dynamic,1)
+  for (int ich=0; ich<n_nonzero; ++ich)
+  {
+    int ch = Z.modelspace->SortedTwoBodyChannels[ich];
+    TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
 
-      int npq = tbc.GetNumberKets();
-      for (int indx_ij = 0;indx_ij<npq; ++indx_ij)
+    int npq = tbc.GetNumberKets();
+    for (int indx_ij = 0;indx_ij<npq; ++indx_ij)
+    {
+      Ket & bra = tbc.GetKet(indx_ij);
+      int i = bra.p;
+      int j = bra.q;
+      Orbit& oi = Z.modelspace->GetOrbit(i);
+      Orbit& oj = Z.modelspace->GetOrbit(j);
+      double norm_ij = (i==j) ? PhysConst::INVSQRT2 : 1.0;
+      //         for ( int k=0; k<norb; ++k )
+      for ( auto k : Z.modelspace->all_orbits )
       {
-         Ket & bra = tbc.GetKet(indx_ij);
-         int i = bra.p;
-         int j = bra.q;
-         Orbit& oi = Z.modelspace->GetOrbit(i);
-         Orbit& oj = Z.modelspace->GetOrbit(j);
-         double norm_ij = (i==j) ? PhysConst::INVSQRT2 : 1.0;
-//         for ( int k=0; k<norb; ++k )
-         for ( auto k : Z.modelspace->all_orbits )
-         {
-           Orbit& ok = Z.modelspace->GetOrbit(k);
-//           if (not tbc.CheckChannel_ket(&ok,&oQ)) continue;
-//           if ( ( (ok.tz2+oQ.tz2)!=2*tbc.Tz ) or ( (ok.l+oQ.l)%2!=tbc.parity ) or ( (ok.j2+oQ.j2)<2*tbc.J) or ( std::abs(ok.j2-oQ.j2)>2*tbc.J) ) continue;
-           if ( ( (ok.tz2-oQ.tz2)!=2*tbc.Tz ) or ( (ok.l+oQ.l)%2!=tbc.parity ) or ( (ok.j2+oQ.j2)<2*tbc.J) or ( std::abs(ok.j2-oQ.j2)>2*tbc.J) ) continue;
-
-//           double norm_kQ = (k==Qorbit) ? PhysConst::INVSQRT2 : 1.0;
-           double norm_kQ = 1.0;
-           double cijk = 0;
-
-//           std::cout << "INNER LOOPs ijk = " << i << " " << j << " " << k << " Z has " << Z.GetNumberLegs() << " legs " << " and there are " << Z.ThreeLeg.MatEl.size() << " 3 leg channels " << std::endl;
-           // The first three loops are the [2,3]->3 bit
-           for ( int a : X.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) )
-           {
-//             cijk += X1(i,a) * Y.TwoBody.GetTBME_norm(ch,ch,a,j,k,Qorbit);
-//             cijk += X1(i,a) * Y.TwoBody.GetTBME(ch,ch,a,j,k,Qorbit);
-             cijk += X1(i,a) * Y.ThreeLeg.GetME(ch,a,j,k);
-           }
-//           std::cout << "check 1. size of X.OneBodyChannels is " << X.OneBodyChannels.Size() << std::endl;
-           for ( int a : X.OneBodyChannels.at({oj.l,oj.j2,oj.tz2}) )
-           {
-//             cijk += X1(j,a) * Y.TwoBody.GetTBME_norm(ch,ch,i,a,k,Qorbit);
-//             cijk += X1(j,a) * Y.TwoBody.GetTBME(ch,ch,i,a,k,Qorbit);
-             cijk += X1(j,a) * Y.ThreeLeg.GetME(ch,i,a,k);
-           }
-//           std::cout << "check 2" << std::endl;
-           for ( int a : X.OneBodyChannels.at({ok.l,ok.j2,ok.tz2}) )
-           {
-//             cijk += X1(a,k) * Y.TwoBody.GetTBME_norm(ch,ch,i,j,a,Qorbit); // should this have a minus sign?
-//             cijk -= X1(a,k) * Y.TwoBody.GetTBME_norm(ch,ch,i,j,a,Qorbit); 
-//             cijk -= X1(a,k) * Y.TwoBody.GetTBME(ch,ch,i,j,a,Qorbit); 
-             cijk -=  Y.ThreeLeg.GetME(ch,i,j,a) * X1(a,k); 
-           }
-
-//           std::cout << " DOING 413 bit "  << std::endl;
-           // This here loop is the [4,1]->3 bit
-           for ( int a : Y.OneBodyChannels.at({oQ.l,oQ.j2,oQ.tz2}) )
-           {
-//             cijk += Y1(a,Qorbit) * X.TwoBody.GetTBME_norm(ch,ch,i,j,k,a);   // This determines the normalization for the (adagger adagger a) term.
-//             cijk +=  X.TwoBody.GetTBME(ch,ch,i,j,k,a) * Y1(a,Qorbit) ;   // This determines the normalization for the (adagger adagger a) term.
-             cijk +=  X.TwoBody.GetTBME(ch,ch,i,j,k,a) * Y1(a,0) ;   // This determines the normalization for the (adagger adagger a) term.
-//             if (i==0 and j==8 and k==0)
-//             {
-//                std::cout << "   " << __func__ << "  a = " << a << "  Xijka, Ya = " << X.TwoBody.GetTBME(ch,ch,i,j,k,a) << " , " << Y1(a,Qorbit) << "  cijk = " << cijk << std::endl;
-//             }
-
-           }
-
-//           Z.TwoBody.SetTBME(ch,ch,i,j,k,Qorbit, cijk);   // SetTBME  directly sets the matrix element, i.e. it assumes a normalized matrix element.
-
-           cijk *= (norm_ij * norm_kQ);  // We normalize like a scalar TBME so that the setter/getters make sense. We'll fix the wrong |kQ> normalization when writing to file.
-//           Z.TwoBody.SetTBME(ch,ch,i,j,k,Qorbit, cijk);   // SetTBME  directly sets the matrix element, i.e. it assumes a normalized matrix element.
-//           Z.TwoBody.AddToTBME(ch,ch,i,j,k,Qorbit, cijk);   // SetTBME  directly sets the matrix element, i.e. it assumes a normalized matrix element.
-
-           Z.ThreeLeg.AddToME(ch,i,j,k, cijk);   // AddToME  assumes a normalized matrix element.
-         }
+        Orbit& ok = Z.modelspace->GetOrbit(k);
+        //           if (not tbc.CheckChannel_ket(&ok,&oQ)) continue;
+        //           if ( ( (ok.tz2+oQ.tz2)!=2*tbc.Tz ) or ( (ok.l+oQ.l)%2!=tbc.parity ) or ( (ok.j2+oQ.j2)<2*tbc.J) or ( std::abs(ok.j2-oQ.j2)>2*tbc.J) ) continue;
+        if ( ( (ok.tz2-oQ.tz2)!=2*tbc.Tz ) or ( (ok.l+oQ.l)%2!=tbc.parity ) or ( (ok.j2+oQ.j2)<2*tbc.J) or ( std::abs(ok.j2-oQ.j2)>2*tbc.J) ) continue;
+
+        //           double norm_kQ = (k==Qorbit) ? PhysConst::INVSQRT2 : 1.0;
+        double norm_kQ = 1.0;
+        double cijk = 0;
+
+        //           std::cout << "INNER LOOPs ijk = " << i << " " << j << " " << k << " Z has " << Z.GetNumberLegs() << " legs " << " and there are " << Z.ThreeLeg.MatEl.size() << " 3 leg channels " << std::endl;
+        // The first three loops are the [2,3]->3 bit
+        for ( int a : X.OneBodyChannels.at({oi.l,oi.j2,oi.tz2}) )
+        {
+          //             cijk += X1(i,a) * Y.TwoBody.GetTBME_norm(ch,ch,a,j,k,Qorbit);
+          //             cijk += X1(i,a) * Y.TwoBody.GetTBME(ch,ch,a,j,k,Qorbit);
+          cijk += X1(i,a) * Y.ThreeLeg.GetME(ch,a,j,k);
+        }
+        //           std::cout << "check 1. size of X.OneBodyChannels is " << X.OneBodyChannels.Size() << std::endl;
+        for ( int a : X.OneBodyChannels.at({oj.l,oj.j2,oj.tz2}) )
+        {
+          //             cijk += X1(j,a) * Y.TwoBody.GetTBME_norm(ch,ch,i,a,k,Qorbit);
+          //             cijk += X1(j,a) * Y.TwoBody.GetTBME(ch,ch,i,a,k,Qorbit);
+          cijk += X1(j,a) * Y.ThreeLeg.GetME(ch,i,a,k);
+        }
+        //           std::cout << "check 2" << std::endl;
+        for ( int a : X.OneBodyChannels.at({ok.l,ok.j2,ok.tz2}) )
+        {
+          //             cijk += X1(a,k) * Y.TwoBody.GetTBME_norm(ch,ch,i,j,a,Qorbit); // should this have a minus sign?
+          //             cijk -= X1(a,k) * Y.TwoBody.GetTBME_norm(ch,ch,i,j,a,Qorbit);
+          //             cijk -= X1(a,k) * Y.TwoBody.GetTBME(ch,ch,i,j,a,Qorbit);
+          cijk -=  Y.ThreeLeg.GetME(ch,i,j,a) * X1(a,k);
+        }
+
+        //           std::cout << " DOING 413 bit "  << std::endl;
+        // This here loop is the [4,1]->3 bit
+        for ( int a : Y.OneBodyChannels.at({oQ.l,oQ.j2,oQ.tz2}) )
+        {
+          //             cijk += Y1(a,Qorbit) * X.TwoBody.GetTBME_norm(ch,ch,i,j,k,a);   // This determines the normalization for the (adagger adagger a) term.
+          //             cijk +=  X.TwoBody.GetTBME(ch,ch,i,j,k,a) * Y1(a,Qorbit) ;   // This determines the normalization for the (adagger adagger a) term.
+          cijk +=  X.TwoBody.GetTBME(ch,ch,i,j,k,a) * Y1(a,0) ;   // This determines the normalization for the (adagger adagger a) term.
+          //             if (i==0 and j==8 and k==0)
+          //             {
+          //                std::cout << "   " << __func__ << "  a = " << a << "  Xijka, Ya = " << X.TwoBody.GetTBME(ch,ch,i,j,k,a) << " , " << Y1(a,Qorbit) << "  cijk = " << cijk << std::endl;
+          //             }
+
+        }
+
+        //           Z.TwoBody.SetTBME(ch,ch,i,j,k,Qorbit, cijk);   // SetTBME  directly sets the matrix element, i.e. it assumes a normalized matrix element.
+
+        cijk *= (norm_ij * norm_kQ);  // We normalize like a scalar TBME so that the setter/getters make sense. We'll fix the wrong |kQ> normalization when writing to file.
+        //           Z.TwoBody.SetTBME(ch,ch,i,j,k,Qorbit, cijk);   // SetTBME  directly sets the matrix element, i.e. it assumes a normalized matrix element.
+        //           Z.TwoBody.AddToTBME(ch,ch,i,j,k,Qorbit, cijk);   // SetTBME  directly sets the matrix element, i.e. it assumes a normalized matrix element.
+
+        Z.ThreeLeg.AddToME(ch,i,j,k, cijk);   // AddToME  assumes a normalized matrix element.
       }
-   }
-   Z.profiler.timer[__func__] += omp_get_wtime() - t_start;
+    }
+  }
+  Z.profiler.timer[__func__] += omp_get_wtime() - t_start;
 }
 
 
@@ -10174,101 +10399,101 @@ void comm413_233sd( const Operator& X, const Operator& Y, Operator& Z)
 
 void ConstructDaggerMpp_Mhh(const Operator& X, const Operator& Y, const Operator& Z, ThreeLegME& Mpp, ThreeLegME& Mhh)
 {
-   int nch = Z.modelspace->SortedTwoBodyChannels.size();
-   #ifndef OPENBLAS_NOUSEOMP
-   #pragma omp parallel for schedule(dynamic,1)
-   #endif
-   for (int ich=0; ich<nch; ++ich)
-   {
-      int ch = Z.modelspace->SortedTwoBodyChannels[ich];
-      TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
+  int nch = Z.modelspace->SortedTwoBodyChannels.size();
+#ifndef OPENBLAS_NOUSEOMP
+#pragma omp parallel for schedule(dynamic,1)
+#endif
+  for (int ich=0; ich<nch; ++ich)
+  {
+    int ch = Z.modelspace->SortedTwoBodyChannels[ich];
+    TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
 
-      auto& LHS = X.TwoBody.GetMatrix(ch,ch);
-      auto& RHS = Y.ThreeLeg.GetMatrix(ch);
+    auto& LHS = X.TwoBody.GetMatrix(ch,ch);
+    auto& RHS = Y.ThreeLeg.GetMatrix(ch);
 
-      auto& Matrixpp = Mpp.GetMatrix(ch);
-      auto& Matrixhh = Mhh.GetMatrix(ch);
+    auto& Matrixpp = Mpp.GetMatrix(ch);
+    auto& Matrixhh = Mhh.GetMatrix(ch);
 
-      auto& kets_pp = tbc.GetKetIndex_pp();
-      auto& kets_hh = tbc.GetKetIndex_hh();
-      auto& kets_ph = tbc.GetKetIndex_ph();
-      auto& nanb    = tbc.Ket_occ_hh;
-      auto& nbarnbar_hh = tbc.Ket_unocc_hh;
-      auto& nbarnbar_ph = tbc.Ket_unocc_ph;
-      
-      Matrixpp =  LHS.cols(kets_pp) * RHS.rows(kets_pp);
-      Matrixhh =  LHS.cols(kets_hh) * arma::diagmat(nanb) *  RHS.rows(kets_hh) ;
-      if (kets_hh.size()>0)
-        Matrixpp +=  LHS.cols(kets_hh) * arma::diagmat(nbarnbar_hh) *  RHS.rows(kets_hh); 
-      if (kets_ph.size()>0)
-        Matrixpp += LHS.cols(kets_ph) * arma::diagmat(nbarnbar_ph) *  RHS.rows(kets_ph) ;
+    auto& kets_pp = tbc.GetKetIndex_pp();
+    auto& kets_hh = tbc.GetKetIndex_hh();
+    auto& kets_ph = tbc.GetKetIndex_ph();
+    auto& nanb    = tbc.Ket_occ_hh;
+    auto& nbarnbar_hh = tbc.Ket_unocc_hh;
+    auto& nbarnbar_ph = tbc.Ket_unocc_ph;
 
+    Matrixpp =  LHS.cols(kets_pp) * RHS.rows(kets_pp);
+    Matrixhh =  LHS.cols(kets_hh) * arma::diagmat(nanb) *  RHS.rows(kets_hh) ;
+    if (kets_hh.size()>0)
+      Matrixpp +=  LHS.cols(kets_hh) * arma::diagmat(nbarnbar_hh) *  RHS.rows(kets_hh);
+    if (kets_ph.size()>0)
+      Matrixpp += LHS.cols(kets_ph) * arma::diagmat(nbarnbar_ph) *  RHS.rows(kets_ph) ;
 
-   } //for ch
+
+  } //for ch
 
 }
 
 
-/// Since comm443_pp_hhsd() and comm431sd() both require the construction of 
+/// Since comm443_pp_hhsd() and comm431sd() both require the construction of
 /// the intermediate matrices \f$\mathcal{M}_{pp} \f$ and \f$ \mathcal{M}_{hh} \f$, we can combine them and
 /// only calculate the intermediates once.
 /// We do the same thing in the standard scalar-scalar commutators.
-void comm433_pp_hh_431sd( const Operator& X, const Operator& Y, Operator& Z )  
+void comm433_pp_hh_431sd( const Operator& X, const Operator& Y, Operator& Z )
 {
 
-   double t = omp_get_wtime();
+  double t = omp_get_wtime();
 
-//   static TwoBodyME Mpp = Z.TwoBody;
-//   static TwoBodyME Mhh = Z.TwoBody;
-   ThreeLegME Mpp = Z.ThreeLeg;
-   ThreeLegME Mhh = Z.ThreeLeg;
-   Mpp *= 0;
-   Mhh *= 0;
+  //   static TwoBodyME Mpp = Z.TwoBody;
+  //   static TwoBodyME Mhh = Z.TwoBody;
+  ThreeLegME Mpp = Z.ThreeLeg;
+  ThreeLegME Mhh = Z.ThreeLeg;
+  Mpp *= 0;
+  Mhh *= 0;
 
-   ConstructDaggerMpp_Mhh( X, Y, Z, Mpp, Mhh);
+  ConstructDaggerMpp_Mhh( X, Y, Z, Mpp, Mhh);
 
-   Z.ThreeLeg += Mpp;
-   Z.ThreeLeg -= Mhh;
+  Z.ThreeLeg += Mpp;
+  Z.ThreeLeg -= Mhh;
 
-   Z.profiler.timer["pphh TwoBody bit"] += omp_get_wtime() - t;
+  Z.profiler.timer["pphh TwoBody bit"] += omp_get_wtime() - t;
 
-   // Now, the one body part
-   t = omp_get_wtime();
-   int Q = Z.GetQSpaceOrbit();
-   Orbit& oQ = Z.modelspace->GetOrbit(Q);
-//   auto ilist = Z.OneBodyChannels.at({oQ.l,oQ.j2,oQ.tz2});
-   std::vector<index_t> ilist(Z.OneBodyChannels.at({oQ.l,oQ.j2,oQ.tz2}).begin(), Z.OneBodyChannels.at({oQ.l,oQ.j2,oQ.tz2}).end());
-   int ni = ilist.size();
-   #pragma omp parallel for schedule(dynamic,1)
-   for (int i_ind=0; i_ind<ni; ++i_ind)
-   {
-      int i = ilist[i_ind];
-      Orbit &oi = Z.modelspace->GetOrbit(i);
-      double cijJ = 0;
-      for (int ch=0;ch<Z.nChannels;++ch)
+  // Now, the one body part
+  t = omp_get_wtime();
+  int Q = Z.GetQSpaceOrbit();
+  Orbit& oQ = Z.modelspace->GetOrbit(Q);
+  //   auto ilist = Z.OneBodyChannels.at({oQ.l,oQ.j2,oQ.tz2});
+  std::vector<index_t> ilist(Z.OneBodyChannels.at({oQ.l,oQ.j2,oQ.tz2}).begin(), Z.OneBodyChannels.at({oQ.l,oQ.j2,oQ.tz2}).end());
+  int ni = ilist.size();
+#pragma omp parallel for schedule(dynamic,1)
+  for (int i_ind=0; i_ind<ni; ++i_ind)
+  {
+    int i = ilist[i_ind];
+    Orbit &oi = Z.modelspace->GetOrbit(i);
+    double cijJ = 0;
+    for (int ch=0;ch<Z.nChannels;++ch)
+    {
+      TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
+      double Jfactor = (2*tbc.J+1.0);
+      // Sum c over holes and include the nbar_a * nbar_b terms
+      for (auto& c : Z.modelspace->holes)
       {
-         TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
-         double Jfactor = (2*tbc.J+1.0);
-         // Sum c over holes and include the nbar_a * nbar_b terms
-         for (auto& c : Z.modelspace->holes)
-         {
-            Orbit& oc = Z.modelspace->GetOrbit(c);
-//            cijJ += Jfactor * oc.occ * Mpp.GetTBME(ch,c,i,c,Q);     // We use the GetTBME, which returns an unnormalized matrix element, as required.
-//            cijJ += Jfactor * (1-oc.occ) * Mhh.GetTBME(ch,c,i,c,Q); 
-            cijJ += Jfactor * oc.occ * Mpp.GetME(ch,c,i,c);     // We use the GetTBME, which returns an unnormalized matrix element, as required.
-            cijJ += Jfactor * (1-oc.occ) * Mhh.GetME(ch,c,i,c); 
-         }
-         // Sum c over particles and include the n_a * n_b terms
-         for (auto& c : Z.modelspace->particles)
-         {
-//            cijJ += Jfactor * Mhh.GetTBME(ch,c,i,c,Q);
-            cijJ += Jfactor * Mhh.GetME(ch,c,i,c);
-         }
+        Orbit& oc = Z.modelspace->GetOrbit(c);
+        //            cijJ += Jfactor * oc.occ * Mpp.GetTBME(ch,c,i,c,Q);     // We use the GetTBME, which returns an unnormalized matrix element, as required.
+        //            cijJ += Jfactor * (1-oc.occ) * Mhh.GetTBME(ch,c,i,c,Q);
+        cijJ += Jfactor * oc.occ * Mpp.GetME(ch,c,i,c);     // We use the GetTBME, which returns an unnormalized matrix element, as required.
+        cijJ += Jfactor * (1-oc.occ) * Mhh.GetME(ch,c,i,c);
+      }
+      // Sum c over particles and include the n_a * n_b terms
+      for (auto& c : Z.modelspace->particles)
+      {
+        //            cijJ += Jfactor * Mhh.GetTBME(ch,c,i,c,Q);
+        cijJ += Jfactor * Mhh.GetME(ch,c,i,c);
       }
-      Z.OneBody(i,0) += cijJ /(oi.j2+1.0);   // The factor of 1/2 in the formula is absorbed by the fact that the mat-mult only sums a<=b.
-//      Z.OneBody(i,Q) += cijJ /(oi.j2+1.0);   // The factor of 1/2 in the formula is absorbed by the fact that the mat-mult only sums a<=b.
-   } // for i
-   Z.profiler.timer["pphh 413sd"] += omp_get_wtime() - t;
+    }
+    Z.OneBody(i,0) += cijJ /(oi.j2+1.0);   // The factor of 1/2 in the formula is absorbed by the fact that the mat-mult only sums a<=b.
+    //      Z.OneBody(i,Q) += cijJ /(oi.j2+1.0);   // The factor of 1/2 in the formula is absorbed by the fact that the mat-mult only sums a<=b.
+  } // for i
+  Z.profiler.timer["pphh 413sd"] += omp_get_wtime() - t;
 }
 
 
@@ -10276,155 +10501,155 @@ void comm433_pp_hh_431sd( const Operator& X, const Operator& Y, Operator& Z )
 
 //*****************************************************************************************
 // [X^(4),Y^(3)]^(3)]  ph piece, the slow way
-//                                             
-//   |           |       |           |           
-//   |      _(Y)_|       |_(X)_      |            
+//
+//   |           |       |           |
+//   |      _(Y)_|       |_(X)_      |
 //   |     /\            |    /\     |
-//   |    (  )      __   |   (  )    |            
-//   |_(X)_\/            |    \/_(Y)_|            
-//   |                   |            
+//   |    (  )      __   |   (  )    |
+//   |_(X)_\/            |    \/_(Y)_|
+//   |                   |
 //
 //  Straightfoward and very slow implementation, only used for unit testing the
-//  faster mat-mult implementation.  The two implementations agree as of Nov 2, 2018 - SRS 
+//  faster mat-mult implementation.  The two implementations agree as of Nov 2, 2018 - SRS
 //  Benchmarked against the m-scheme version in UnitTest.cc, and it agrees (although
 //  some changes were required compared to the impoementation tested in Nov 2018).
 //  So this again agrees with the more efficient way, and with the m-scheme verion as of Sep 30 2019 - SRS
 void comm433sd_ph_dumbway( const Operator& X, const Operator& Y, Operator& Z)
 {
 
-   double t_start = omp_get_wtime();
-//   int norb = Z.modelspace->GetNumberOrbits();
-   int nch = Z.modelspace->SortedTwoBodyChannels.size();
-   index_t Q = Y.GetQSpaceOrbit();
-   Orbit& oQ = Z.modelspace->GetOrbit(Q);
-   double jQ = 0.5*oQ.j2;
-   auto kets_ph = Z.modelspace->KetIndex_ph;
-   for ( auto khh : Z.modelspace->KetIndex_hh ) // ph kets needs to include hh list in case there are fractionally occupied states
-   {
-     kets_ph.push_back(khh);
-   }
+  double t_start = omp_get_wtime();
+  //   int norb = Z.modelspace->GetNumberOrbits();
+  int nch = Z.modelspace->SortedTwoBodyChannels.size();
+  index_t Q = Y.GetQSpaceOrbit();
+  Orbit& oQ = Z.modelspace->GetOrbit(Q);
+  double jQ = 0.5*oQ.j2;
+  auto kets_ph = Z.modelspace->KetIndex_ph;
+  for ( auto khh : Z.modelspace->KetIndex_hh ) // ph kets needs to include hh list in case there are fractionally occupied states
+  {
+    kets_ph.push_back(khh);
+  }
 
-   for (int ich=0; ich<nch; ++ich)
-   {
-      int ch = Z.modelspace->SortedTwoBodyChannels[ich];
-      TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
-      int J = tbc.J;
-      size_t nkets = tbc.GetNumberKets();
-      for (size_t ibra=0; ibra<nkets; ibra++)
-      {
-        auto& bra = tbc.GetKet(ibra);
-        std::vector<index_t> i_cases = { bra.p, bra.q };
-        std::vector<index_t> j_cases = { bra.q, bra.p };
-        std::vector<int> ijsign_cases = { +1, bra.Phase(J)};  // This accounts for the 1 - (-1)^(ji +jj-J) Pij  factor.
-        double norm_ij = (bra.p==bra.q) ? PhysConst::INVSQRT2 : 1.0;
+  for (int ich=0; ich<nch; ++ich)
+  {
+    int ch = Z.modelspace->SortedTwoBodyChannels[ich];
+    TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
+    int J = tbc.J;
+    size_t nkets = tbc.GetNumberKets();
+    for (size_t ibra=0; ibra<nkets; ibra++)
+    {
+      auto& bra = tbc.GetKet(ibra);
+      std::vector<index_t> i_cases = { bra.p, bra.q };
+      std::vector<index_t> j_cases = { bra.q, bra.p };
+      std::vector<int> ijsign_cases = { +1, bra.Phase(J)};  // This accounts for the 1 - (-1)^(ji +jj-J) Pij  factor.
+      double norm_ij = (bra.p==bra.q) ? PhysConst::INVSQRT2 : 1.0;
 
-          for ( auto k : Z.modelspace->all_orbits )
-          {
-            Orbit& ok = Z.modelspace->GetOrbit(k);
-//            if ( not tbc.CheckChannel_ket(&ok,&oQ) ) continue;
-//            if ( ( (ok.tz2+oQ.tz2)!=2*tbc.Tz) or ( (ok.l+oQ.l)%2!=tbc.parity) or ( (ok.j2+oQ.j2)<2*tbc.J) or ( std::abs(ok.j2-oQ.j2)>2*tbc.J) ) continue; // if |kQ> doesn't live in this channel, move along.
-            if ( ( (ok.tz2-oQ.tz2)!=2*tbc.Tz) or ( (ok.l+oQ.l)%2!=tbc.parity) or ( (ok.j2+oQ.j2)<2*tbc.J) or ( std::abs(ok.j2-oQ.j2)>2*tbc.J) ) continue; // if |kQ> doesn't live in this channel, move along.
-            double zijk = 0.;
-//            double norm_kQ = (k==Q) ? PhysConst::INVSQRT2 : 1.0;
-            double norm_kQ =  1.0;
-            double jk = 0.5* ok.j2;
+      for ( auto k : Z.modelspace->all_orbits )
+      {
+        Orbit& ok = Z.modelspace->GetOrbit(k);
+        //            if ( not tbc.CheckChannel_ket(&ok,&oQ) ) continue;
+        //            if ( ( (ok.tz2+oQ.tz2)!=2*tbc.Tz) or ( (ok.l+oQ.l)%2!=tbc.parity) or ( (ok.j2+oQ.j2)<2*tbc.J) or ( std::abs(ok.j2-oQ.j2)>2*tbc.J) ) continue; // if |kQ> doesn't live in this channel, move along.
+        if ( ( (ok.tz2-oQ.tz2)!=2*tbc.Tz) or ( (ok.l+oQ.l)%2!=tbc.parity) or ( (ok.j2+oQ.j2)<2*tbc.J) or ( std::abs(ok.j2-oQ.j2)>2*tbc.J) ) continue; // if |kQ> doesn't live in this channel, move along.
+        double zijk = 0.;
+        //            double norm_kQ = (k==Q) ? PhysConst::INVSQRT2 : 1.0;
+        double norm_kQ =  1.0;
+        double jk = 0.5* ok.j2;
 
 
         for (int ijcase=0; ijcase<=1; ijcase++)
         {
-//         if (ijcase==1) continue;
+          //         if (ijcase==1) continue;
           index_t i = i_cases[ijcase];
           index_t j = j_cases[ijcase];
-//          std::cout << "~~~~ i,j = " << i << " " << j << std::endl;
+          //          std::cout << "~~~~ i,j = " << i << " " << j << std::endl;
           int ijsign = ijsign_cases[ijcase];
           Orbit& oi = Z.modelspace->GetOrbit(i);
           Orbit& oj = Z.modelspace->GetOrbit(j);
           double ji = 0.5* oi.j2;
           double jj = 0.5* oj.j2;
-//          for ( size_t k=0; k<norb; k++)
+          //          for ( size_t k=0; k<norb; k++)
 
 
 
-            int Jprime_min = std::max(  std::abs(ji-jQ), std::abs(jj-jk) );
-            int Jprime_max = std::min(  ji+jQ, jj+jk  );
-            for (int Jprime=Jprime_min; Jprime<=Jprime_max; ++Jprime)
-            {
-              double sixjprime =  Z.modelspace->GetSixJ(ji,jj,J,jk,jQ,Jprime);
-              if (std::abs(sixjprime) < 1e-8) continue;
+          int Jprime_min = std::max(  std::abs(ji-jQ), std::abs(jj-jk) );
+          int Jprime_max = std::min(  ji+jQ, jj+jk  );
+          for (int Jprime=Jprime_min; Jprime<=Jprime_max; ++Jprime)
+          {
+            double sixjprime =  Z.modelspace->GetSixJ(ji,jj,J,jk,jQ,Jprime);
+            if (std::abs(sixjprime) < 1e-8) continue;
 
-              double XYprod = 0;
+            double XYprod = 0;
 
-              for (auto& iketab : kets_ph )
+            for (auto& iketab : kets_ph )
+            {
+              auto& ketab = Z.modelspace->GetKet(iketab);
+              if (  (ketab.op->j2+ketab.oq->j2)<2*Jprime  or  std::abs(ketab.op->j2-ketab.oq->j2)>2*Jprime ) continue;
+              std::vector<index_t> ab_cases = { ketab.p, ketab.q };
+              for (int abcase = 0; abcase<=1; abcase++)
               {
-                auto& ketab = Z.modelspace->GetKet(iketab);
-                  if (  (ketab.op->j2+ketab.oq->j2)<2*Jprime  or  std::abs(ketab.op->j2-ketab.oq->j2)>2*Jprime ) continue;
-                std::vector<index_t> ab_cases = { ketab.p, ketab.q };
-                for (int abcase = 0; abcase<=1; abcase++)
-                {
-                  index_t a  = ab_cases[abcase];
-                  index_t b  = ab_cases[1-abcase];
+                index_t a  = ab_cases[abcase];
+                index_t b  = ab_cases[1-abcase];
 
-                  Orbit& oa = Z.modelspace->GetOrbit(a);
-                  Orbit& ob = Z.modelspace->GetOrbit(b);
-                  double ja = 0.5*oa.j2;
-                  double jb = 0.5*ob.j2;
-                  double nanb = oa.occ - ob.occ;
+                Orbit& oa = Z.modelspace->GetOrbit(a);
+                Orbit& ob = Z.modelspace->GetOrbit(b);
+                double ja = 0.5*oa.j2;
+                double jb = 0.5*ob.j2;
+                double nanb = oa.occ - ob.occ;
 
-//                  if ( not (a==0 and b==10) or (a==10 and b==0) ) continue;
-//                  if ( not ((a==1 and b==8) or (a==8 and b==1)) ) continue;
+                //                  if ( not (a==0 and b==10) or (a==10 and b==0) ) continue;
+                //                  if ( not ((a==1 and b==8) or (a==8 and b==1)) ) continue;
 
-                  // we can probably also check triangle for (a,b,Jprime)
+                // we can probably also check triangle for (a,b,Jprime)
 
 
-                  int JA_min = std::max(  std::abs(ja-jj), std::abs(jk-jb)  );
-                  int JA_max = std::min( ja+jj,  jk+jb );
+                int JA_min = std::max(  std::abs(ja-jj), std::abs(jk-jb)  );
+                int JA_max = std::min( ja+jj,  jk+jb );
 
-                  int JB_min = std::max(  std::abs(ja-jQ), std::abs(ji-jb)  );
-                  int JB_max = std::min( ja+jQ,  ji+jb );
-                  double matelX = 0;
-                  double matelY = 0;
-                  for (int JA = JA_min; JA<=JA_max; ++JA)
-                  {
-                    double sixjA = Z.modelspace->GetSixJ( ja, jb, Jprime, jk, jj, JA );
-                    matelX -= (2*JA+1) * sixjA * X.TwoBody.GetTBME_J(JA,a,j,k,b);   // GetTBME_J returns an un-normalized matrix element
-                  }
-                  for (int JB = JB_min; JB<=JB_max; ++JB)
-                  {
-                    double sixjB = Z.modelspace->GetSixJ( ja, jb, Jprime, ji, jQ, JB );
-//                    matelY -= (2*JB+1) * sixjB * Y.TwoBody.GetTBME_J(JB,i,b,a,Q);   // GetTBME_J returns an un-normalized matrix element
-                    matelY -= (2*JB+1) * sixjB * Y.ThreeLeg.GetME_J(JB,i,b,a);   // GetTBME_J returns an un-normalized matrix element
-                  }
-                  XYprod += nanb * matelX * matelY;
-//                  if ( ( (i==0 and j==1) or (i==1 and j==0)) and k==1  and std::abs(nanb)>0)
-//                  if ( ( (i==0 and j==1) or (i==1 and j==0)) and k==1 and ((a==0 and b==10) or (b==0 and a==10)) )
-//                  if ( ( (i==0 and j==1) or (i==1 and j==0)) and k==1 and ((a==1 and b==8) or (b==1 and a==8)) )
-//                  {
-//                    std::cout << "   J = " << J << "  a,b = " << a << " " << b << "  Jprime = " << Jprime << "  nanb " << nanb 
-//                              << "  Xbar_abkj Ybar_iQab " << matelX << " " << matelY << " => XYprod = " << XYprod << std::endl;
-//                  }
+                int JB_min = std::max(  std::abs(ja-jQ), std::abs(ji-jb)  );
+                int JB_max = std::min( ja+jQ,  ji+jb );
+                double matelX = 0;
+                double matelY = 0;
+                for (int JA = JA_min; JA<=JA_max; ++JA)
+                {
+                  double sixjA = Z.modelspace->GetSixJ( ja, jb, Jprime, jk, jj, JA );
+                  matelX -= (2*JA+1) * sixjA * X.TwoBody.GetTBME_J(JA,a,j,k,b);   // GetTBME_J returns an un-normalized matrix element
+                }
+                for (int JB = JB_min; JB<=JB_max; ++JB)
+                {
+                  double sixjB = Z.modelspace->GetSixJ( ja, jb, Jprime, ji, jQ, JB );
+                  //                    matelY -= (2*JB+1) * sixjB * Y.TwoBody.GetTBME_J(JB,i,b,a,Q);   // GetTBME_J returns an un-normalized matrix element
+                  matelY -= (2*JB+1) * sixjB * Y.ThreeLeg.GetME_J(JB,i,b,a);   // GetTBME_J returns an un-normalized matrix element
                 }
-              } // loop over ab cases
-               zijk -= ijsign * (2*Jprime+1) * sixjprime * XYprod;
-//                  if (( (i==0 and j==1) or (i==1 and j==0)) and k==1)
-//                  {
-//                    std::cout << "i,j = " << i << " " << j << " ijsign(J=" << J << ") = " << ijsign << "  2Jprime+1 " << 2*Jprime+1 << "  sixjprime " << sixjprime << "  XYprod " << XYprod << "  => zijk " << zijk
-//                               <<  std::endl;
-//                  }
-            }  // loop over ab kets
- 
-//                  if (( (i==0 and j==1) or (i==1 and j==0)) and k==1)
-//                  {
-//                    std::cout << " zijk = " << zijk <<  " norm_ij norm_kQ = " << norm_ij << " " << norm_kQ << "    before setting, the ME is " << Z.ThreeLeg.GetME_J(J,i,j,k) << std::endl << std::endl;
-//                  }
+                XYprod += nanb * matelX * matelY;
+                //                  if ( ( (i==0 and j==1) or (i==1 and j==0)) and k==1  and std::abs(nanb)>0)
+                //                  if ( ( (i==0 and j==1) or (i==1 and j==0)) and k==1 and ((a==0 and b==10) or (b==0 and a==10)) )
+                //                  if ( ( (i==0 and j==1) or (i==1 and j==0)) and k==1 and ((a==1 and b==8) or (b==1 and a==8)) )
+                //                  {
+                //                    std::cout << "   J = " << J << "  a,b = " << a << " " << b << "  Jprime = " << Jprime << "  nanb " << nanb
+                //                              << "  Xbar_abkj Ybar_iQab " << matelX << " " << matelY << " => XYprod = " << XYprod << std::endl;
+                //                  }
+              }
+            } // loop over ab cases
+            zijk -= ijsign * (2*Jprime+1) * sixjprime * XYprod;
+            //                  if (( (i==0 and j==1) or (i==1 and j==0)) and k==1)
+            //                  {
+            //                    std::cout << "i,j = " << i << " " << j << " ijsign(J=" << J << ") = " << ijsign << "  2Jprime+1 " << 2*Jprime+1 << "  sixjprime " << sixjprime << "  XYprod " << XYprod << "  => zijk " << zijk
+            //                               <<  std::endl;
+            //                  }
+          }  // loop over ab kets
+
+          //                  if (( (i==0 and j==1) or (i==1 and j==0)) and k==1)
+          //                  {
+          //                    std::cout << " zijk = " << zijk <<  " norm_ij norm_kQ = " << norm_ij << " " << norm_kQ << "    before setting, the ME is " << Z.ThreeLeg.GetME_J(J,i,j,k) << std::endl << std::endl;
+          //                  }
 
         } // loop over ij cases
 
-//            Z.TwoBody.AddToTBME_J(J,i,j,k,Q,  zijk * norm_ij*norm_kQ);   // AddToTBME_J assumes a normalized matrix element.
-            Z.ThreeLeg.AddToME_J(J,bra.p,bra.q,k,  zijk * norm_ij*norm_kQ);   // AddToTBME_J assumes a normalized matrix element.
-          }  // loop over k 
-      } // for ibra
-   } // for ich
-   Z.profiler.timer[__func__] += omp_get_wtime() - t_start;
+        //            Z.TwoBody.AddToTBME_J(J,i,j,k,Q,  zijk * norm_ij*norm_kQ);   // AddToTBME_J assumes a normalized matrix element.
+        Z.ThreeLeg.AddToME_J(J,bra.p,bra.q,k,  zijk * norm_ij*norm_kQ);   // AddToTBME_J assumes a normalized matrix element.
+      }  // loop over k
+    } // for ibra
+  } // for ich
+  Z.profiler.timer[__func__] += omp_get_wtime() - t_start;
 
 }
 
@@ -10433,126 +10658,126 @@ void comm433sd_ph_dumbway( const Operator& X, const Operator& Y, Operator& Z)
 
 //*****************************************************************************************
 // [X^(4),Y^(3)]^(3)]  ph piece
-//                                             
-//   |           |       |           |           
-//   |      _(Y)_|       |_(X)_      |            
+//
+//   |           |       |           |
+//   |      _(Y)_|       |_(X)_      |
 //   |     /\            |    /\     |
-//   |    (  )      __   |   (  )    |            
-//   |_(X)_\/            |    \/_(Y)_|            
-//   |                   |            
+//   |    (  )      __   |   (  )    |
+//   |_(X)_\/            |    \/_(Y)_|
+//   |                   |
 //
 // For formula and details of implementation, see Operator::comm222_phss. The only change
 // made here to accommodate a dagger operator is to replace XY - YX  with -YX. This
 // ensures that we don't include contributions from the Qspace orbit to X.
 // Adapted from
-//    void Operator::comm222_phss( const Operator& X, const Operator& Y ) 
+//    void Operator::comm222_phss( const Operator& X, const Operator& Y )
 
 
-void comm433sd_ph( const Operator& X, const Operator& Y, Operator& Z)  
+void comm433sd_ph( const Operator& X, const Operator& Y, Operator& Z)
 {
 
-   double t_start = omp_get_wtime();
+  double t_start = omp_get_wtime();
 
-   int hx = X.IsHermitian() ? 1 : -1; // assuming X is either hermitian or antihermitian. I'm sure this will come back to bite me some day.
+  int hx = X.IsHermitian() ? 1 : -1; // assuming X is either hermitian or antihermitian. I'm sure this will come back to bite me some day.
 
-   // Construct the intermediate matrix Z_bar and fill it with zeros.
-   const auto& pandya_lookup = Z.modelspace->GetPandyaLookup( Z.GetJRank(), Z.GetTRank(), Z.GetParity() );
-   size_t nch = Z.modelspace->SortedTwoBodyChannels_CC.size();
-   size_t norb = Z.modelspace->GetNumberOrbits();
-   std::deque<arma::mat> Z_bar (Z.nChannels );
-   std::vector<bool> lookup_empty(Z.nChannels,true);
-   for (size_t ich=0;ich<nch;++ich)
-   {
-      size_t ch = Z.modelspace->SortedTwoBodyChannels_CC[ich];
-      index_t nKets_cc = Z.modelspace->GetTwoBodyChannel_CC(ch).GetNumberKets();
-      Z_bar[ch].zeros( norb, 2*nKets_cc );  // Z_iQ`kj`   we want both orderings of k and j, but Q is fixed.
-      if ( pandya_lookup.at({ch,ch})[0].size()>0 ) lookup_empty[ich] = false;
-   }
-
-
-   // loop over channels for Z_bar
-   #ifndef OPENBLAS_NOUSEOMP
-   #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar_transform_first_pass)
-   #endif
-   for (size_t ich=0; ich<nch; ++ich )
-   {
-      if (lookup_empty.at(ich)) continue;
-      size_t ch = Z.modelspace->SortedTwoBodyChannels_CC.at(ich);
-      const TwoBodyChannel& tbc_cc = Z.modelspace->GetTwoBodyChannel_CC(ch);
-      index_t nKets_cc = tbc_cc.GetNumberKets();
-      size_t nph_kets = tbc_cc.GetKetIndex_hh().size() + tbc_cc.GetKetIndex_ph().size();
-
-      arma::mat Y_bar_ph;
-      arma::mat X_bar_ph;
-
-      DoPandyaTransformation_SingleChannel_Dagger(Y,Y_bar_ph,ch);      // Generate  YbarJ'_iQ`ab` * (na-nb)      for a<=b and a>b
-      DoPandyaTransformation_SingleChannel(X,X_bar_ph,ch,"normal");  // Generate XbarJ'_ab`kj`                  for a<=b and a>b
-      auto& Zbar_ch = Z_bar.at(ch); // Marginally useful aliasing to avoid lookups...
-
-     // Zbar will be
-     // ZbarJ'_iQ`kj` = Sum_ab   (na-nb) <iQ`|YbarJ'|ab`> <ab`|XbarJ'|kj`>
-     // So then we can perform an inverse Pandya transform (which is really just another Pandya transform) to get
-     // ZJ_ijkQ = - Sum_J' (2J'+1) { ji  jj  J  }  ZbarJ'_iQ`kj`
-     //                            { jk  jQ  J' }
-
-
-     // The shape of Xt_bar_ph is  ( rows, columns) = ( 2*nph_kets,  nKets_cc)  =>    [     Xbar    ]  |  ab`, element of nph_kets, which has ph` and hp`
-     //                                                                               [             ]  v
-     //                                                                                    -> 
-     //                                                                                    kj` is an element of kets_cc
-     //
-     // The shape of Y_bar_ph is   (rows, columns) = (norb, 2*nph_kets)         =>    [     Ybar    ]  | iQ`  runs over all orbits i, with Q fixed.
-     //                                                                               [             ]  v
-     //                                                                                    -> 
-     //                                                                                    ab` is an element of nph_kets, here we have ph` and hp`
-     //
-     // So we should multiply Ybar * Xbar to sum over ab` and get out Zbar      =>      [     Zbar    ]  |  iQ`
-     //                                                                                 [             ]  v
-     //                                                                                      -> 
-     //                                                                                      kj`
-     //
-     // Really, we need  <iQ`|Zbar|kj`> and <iQ`|Zbar|jk`> 
-
-
-
-      if (Y_bar_ph.size()<1 or X_bar_ph.size()<1)   // for an armadillo matrix, .size()  gives the total number of elements, i.e. n_rows * n_cols
-      {
-//        Zbar_ch = arma::zeros( norb, 2*nKets_cc );  // This seems unnecessary since we initialized things earlier... try getting rid of it and see if things break.
-        continue;
-      }
+  // Construct the intermediate matrix Z_bar and fill it with zeros.
+  const auto& pandya_lookup = Z.modelspace->GetPandyaLookup( Z.GetJRank(), Z.GetTRank(), Z.GetParity() );
+  size_t nch = Z.modelspace->SortedTwoBodyChannels_CC.size();
+  size_t norb = Z.modelspace->GetNumberOrbits();
+  std::deque<arma::mat> Z_bar (Z.nChannels );
+  std::vector<bool> lookup_empty(Z.nChannels,true);
+  for (size_t ich=0;ich<nch;++ich)
+  {
+    size_t ch = Z.modelspace->SortedTwoBodyChannels_CC[ich];
+    index_t nKets_cc = Z.modelspace->GetTwoBodyChannel_CC(ch).GetNumberKets();
+    Z_bar[ch].zeros( norb, 2*nKets_cc );  // Z_iQ`kj`   we want both orderings of k and j, but Q is fixed.
+    if ( pandya_lookup.at({ch,ch})[0].size()>0 ) lookup_empty[ich] = false;
+  }
 
-      // get the phases for taking the transpose
-      arma::mat PhaseMat(nKets_cc, nKets_cc, arma::fill::ones );
-      for (index_t iket=0;iket<nKets_cc;iket++)
-      {
-         const Ket& ket = tbc_cc.GetKet(iket);
-         if ( Z.modelspace->phase( (ket.op->j2 + ket.oq->j2)/2 ) > 0) continue;
-         PhaseMat.col( iket ) *= -1;
-         PhaseMat.row( iket ) *= -1;
-      }
-      arma::uvec phkets = arma::join_cols(tbc_cc.GetKetIndex_hh(), tbc_cc.GetKetIndex_ph() );
-      auto PhaseMatX = PhaseMat.rows(phkets) * hx;
 
-//                                           [      |     ]
-//     create full Y matrix from the half:   [  Yhp | Y'ph]   where the prime indicates multiplication by (-1)^(i+j+k+l) h_x
-//                                           [      |     ]   Flipping hp <-> ph and multiplying by the phase is equivalent to
-//                                           [  Yph | Y'hp]   having kets |kj> with k>j.
-      Zbar_ch =  Y_bar_ph * join_horiz(X_bar_ph, join_vert(   X_bar_ph.tail_rows(nph_kets)%PhaseMatX,
-                                                              X_bar_ph.head_rows(nph_kets)%PhaseMatX) );
+  // loop over channels for Z_bar
+#ifndef OPENBLAS_NOUSEOMP
+#pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar_transform_first_pass)
+#endif
+  for (size_t ich=0; ich<nch; ++ich )
+  {
+    if (lookup_empty.at(ich)) continue;
+    size_t ch = Z.modelspace->SortedTwoBodyChannels_CC.at(ich);
+    const TwoBodyChannel& tbc_cc = Z.modelspace->GetTwoBodyChannel_CC(ch);
+    index_t nKets_cc = tbc_cc.GetNumberKets();
+    size_t nph_kets = tbc_cc.GetKetIndex_hh().size() + tbc_cc.GetKetIndex_ph().size();
+
+    arma::mat Y_bar_ph;
+    arma::mat X_bar_ph;
+
+    DoPandyaTransformation_SingleChannel_Dagger(Y,Y_bar_ph,ch);      // Generate  YbarJ'_iQ`ab` * (na-nb)      for a<=b and a>b
+    DoPandyaTransformation_SingleChannel(X,X_bar_ph,ch,"normal");  // Generate XbarJ'_ab`kj`                  for a<=b and a>b
+    auto& Zbar_ch = Z_bar.at(ch); // Marginally useful aliasing to avoid lookups...
+
+    // Zbar will be
+    // ZbarJ'_iQ`kj` = Sum_ab   (na-nb) <iQ`|YbarJ'|ab`> <ab`|XbarJ'|kj`>
+    // So then we can perform an inverse Pandya transform (which is really just another Pandya transform) to get
+    // ZJ_ijkQ = - Sum_J' (2J'+1) { ji  jj  J  }  ZbarJ'_iQ`kj`
+    //                            { jk  jQ  J' }
+
+
+    // The shape of Xt_bar_ph is  ( rows, columns) = ( 2*nph_kets,  nKets_cc)  =>    [     Xbar    ]  |  ab`, element of nph_kets, which has ph` and hp`
+    //                                                                               [             ]  v
+    //                                                                                    ->
+    //                                                                                    kj` is an element of kets_cc
+    //
+    // The shape of Y_bar_ph is   (rows, columns) = (norb, 2*nph_kets)         =>    [     Ybar    ]  | iQ`  runs over all orbits i, with Q fixed.
+    //                                                                               [             ]  v
+    //                                                                                    ->
+    //                                                                                    ab` is an element of nph_kets, here we have ph` and hp`
+    //
+    // So we should multiply Ybar * Xbar to sum over ab` and get out Zbar      =>      [     Zbar    ]  |  iQ`
+    //                                                                                 [             ]  v
+    //                                                                                      ->
+    //                                                                                      kj`
+    //
+    // Really, we need  <iQ`|Zbar|kj`> and <iQ`|Zbar|jk`>
+
 
-   }
 
-   Z.profiler.timer["Build Z_bar_Dagger"] += omp_get_wtime() - t_start;
-//   std::cout << "Done building Z_bar_dagger" << std::endl;
+    if (Y_bar_ph.size()<1 or X_bar_ph.size()<1)   // for an armadillo matrix, .size()  gives the total number of elements, i.e. n_rows * n_cols
+    {
+      //        Zbar_ch = arma::zeros( norb, 2*nKets_cc );  // This seems unnecessary since we initialized things earlier... try getting rid of it and see if things break.
+      continue;
+    }
+
+    // get the phases for taking the transpose
+    arma::mat PhaseMat(nKets_cc, nKets_cc, arma::fill::ones );
+    for (index_t iket=0;iket<nKets_cc;iket++)
+    {
+      const Ket& ket = tbc_cc.GetKet(iket);
+      if ( Z.modelspace->phase( (ket.op->j2 + ket.oq->j2)/2 ) > 0) continue;
+      PhaseMat.col( iket ) *= -1;
+      PhaseMat.row( iket ) *= -1;
+    }
+    arma::uvec phkets = arma::join_cols(tbc_cc.GetKetIndex_hh(), tbc_cc.GetKetIndex_ph() );
+    auto PhaseMatX = PhaseMat.rows(phkets) * hx;
+
+    //                                           [      |     ]
+    //     create full Y matrix from the half:   [  Yhp | Y'ph]   where the prime indicates multiplication by (-1)^(i+j+k+l) h_x
+    //                                           [      |     ]   Flipping hp <-> ph and multiplying by the phase is equivalent to
+    //                                           [  Yph | Y'hp]   having kets |kj> with k>j.
+    Zbar_ch =  Y_bar_ph * join_horiz(X_bar_ph, join_vert(   X_bar_ph.tail_rows(nph_kets)%PhaseMatX,
+          X_bar_ph.head_rows(nph_kets)%PhaseMatX) );
+
+  }
 
-   // Perform inverse Pandya transform on Z_bar to get Z
-   t_start = omp_get_wtime();
-   AddInversePandyaTransformation_Dagger(Z_bar, Z);
+  Z.profiler.timer["Build Z_bar_Dagger"] += omp_get_wtime() - t_start;
+  //   std::cout << "Done building Z_bar_dagger" << std::endl;
 
-//   Z.modelspace->scalar_transform_first_pass = false;
-   Z.profiler.timer["InversePandyaTransformation_Dagger"] += omp_get_wtime() - t_start;
+  // Perform inverse Pandya transform on Z_bar to get Z
+  t_start = omp_get_wtime();
+  AddInversePandyaTransformation_Dagger(Z_bar, Z);
 
-   Z.profiler.timer[__func__] += omp_get_wtime() - t_start;
+  //   Z.modelspace->scalar_transform_first_pass = false;
+  Z.profiler.timer["InversePandyaTransformation_Dagger"] += omp_get_wtime() - t_start;
+
+  Z.profiler.timer[__func__] += omp_get_wtime() - t_start;
 }
 
 
@@ -10582,70 +10807,70 @@ void comm433sd_ph( const Operator& X, const Operator& Y, Operator& Z)
 /// in the output matrix.
 void DoPandyaTransformation_SingleChannel_Dagger(const Operator& Z, arma::mat& TwoBody_CC_ph, int ch_cc)
 {
-   TwoBodyChannel& tbc_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_cc);
-//   int nKets_cc = tbc_cc.GetNumberKets();
-   size_t norb = Z.modelspace->GetNumberOrbits();
-   arma::uvec kets_ph = arma::join_cols(tbc_cc.GetKetIndex_hh(), tbc_cc.GetKetIndex_ph() );
-   int nph_kets = kets_ph.n_rows;
-   int J_cc = tbc_cc.J;
-
-//   TwoBody_CC_ph.zeros( nKets_cc, 2*nph_kets);
-   TwoBody_CC_ph.zeros( norb, 2*nph_kets);   // factor 2 because we want both orderings ab and ba.
-
-   index_t Q = Z.GetQSpaceOrbit();
-   Orbit& oQ = Z.modelspace->GetOrbit(Q);
-   double jQ = oQ.j2*0.5;
-
-   // loop over cross-coupled ph kets |ab> in this channel
-   // (this is the side that gets summed over in the matrix multiplication)
-   for (int iket=0; iket<nph_kets; ++iket)
-   {
-     Ket & ket_cc = tbc_cc.GetKet( kets_ph[iket] );
-     int a = ket_cc.p;
-     int b = ket_cc.q;
-     Orbit & oa = Z.modelspace->GetOrbit(a);
-     Orbit & ob = Z.modelspace->GetOrbit(b);
-     double ja = oa.j2*0.5;
-     double jb = ob.j2*0.5;
-
-     // Here we make some lists so that we don't need to repeat code when switching (a,b) -> (b,a).
-     // Instead we can just iterate over the two cases.
-     std::vector<int> ab     = { a, b };
-     std::vector<double>jab  = { ja, jb };
-     std::vector<double>nanb = { (oa.occ-ob.occ),  (ob.occ-oa.occ) };
-
-     // we loop over both orderings, a<b and a>b. Here, this is done by exchanging a<->b and taking a minus sign due to the (na-nb) factor.
-     for ( int ab_case=0; ab_case<=1; ab_case++)
-     {
-       size_t ab1 = ab[ab_case];
-       size_t ab2 = ab[1-ab_case];
-       double jab1  = jab[ab_case];
-       double jab2  = jab[1-ab_case];
-       size_t indx_ab = iket + ab_case*nph_kets;
-
-       // loop over orbits i, and check if <iQ| is in the desired channel.
-       for (size_t i=0; i<norb; i++)
-       {
-          Orbit& oi = Z.modelspace->GetOrbit(i);
-          if (not tbc_cc.CheckChannel_ket( &oi, &oQ ) ) continue;  //  <iQ|  isn't in this channel, so move along. (Note, for this check, the ordering of i,Q doesn't matter).
-          size_t indx_iQ = i;   // since Q is fixed, we can label the bra <iQ| by the index i.
-          double ji = oi.j2*0.5;
-
-          int Jmin = std::max( std::abs(jab1-jQ), std::abs(ji-jab2) );
-          int Jmax = std::min( jab1+jQ, ji+jab2 );
-          double Xbar = 0;
-          for (int J_std=Jmin; J_std<=Jmax; ++J_std)
-          {
-             double sixj = Z.modelspace->GetSixJ(ji,jQ,J_cc,jab1,jab2,J_std);
-             if (std::abs(sixj) < 1e-8) continue;
-//             double tbme = Z.TwoBody.GetTBME_J(J_std,i,ab2,ab1,Q);
-             double tbme = Z.ThreeLeg.GetME_J(J_std,i,ab2,ab1);
-             Xbar -= (2*J_std+1) * sixj * tbme ;
-          }
-          TwoBody_CC_ph(indx_iQ, indx_ab) = Xbar * nanb[ab_case] ;
-       }
-     }
-   }
+  TwoBodyChannel& tbc_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_cc);
+  //   int nKets_cc = tbc_cc.GetNumberKets();
+  size_t norb = Z.modelspace->GetNumberOrbits();
+  arma::uvec kets_ph = arma::join_cols(tbc_cc.GetKetIndex_hh(), tbc_cc.GetKetIndex_ph() );
+  int nph_kets = kets_ph.n_rows;
+  int J_cc = tbc_cc.J;
+
+  //   TwoBody_CC_ph.zeros( nKets_cc, 2*nph_kets);
+  TwoBody_CC_ph.zeros( norb, 2*nph_kets);   // factor 2 because we want both orderings ab and ba.
+
+  index_t Q = Z.GetQSpaceOrbit();
+  Orbit& oQ = Z.modelspace->GetOrbit(Q);
+  double jQ = oQ.j2*0.5;
+
+  // loop over cross-coupled ph kets |ab> in this channel
+  // (this is the side that gets summed over in the matrix multiplication)
+  for (int iket=0; iket<nph_kets; ++iket)
+  {
+    Ket & ket_cc = tbc_cc.GetKet( kets_ph[iket] );
+    int a = ket_cc.p;
+    int b = ket_cc.q;
+    Orbit & oa = Z.modelspace->GetOrbit(a);
+    Orbit & ob = Z.modelspace->GetOrbit(b);
+    double ja = oa.j2*0.5;
+    double jb = ob.j2*0.5;
+
+    // Here we make some lists so that we don't need to repeat code when switching (a,b) -> (b,a).
+    // Instead we can just iterate over the two cases.
+    std::vector<int> ab     = { a, b };
+    std::vector<double>jab  = { ja, jb };
+    std::vector<double>nanb = { (oa.occ-ob.occ),  (ob.occ-oa.occ) };
+
+    // we loop over both orderings, a<b and a>b. Here, this is done by exchanging a<->b and taking a minus sign due to the (na-nb) factor.
+    for ( int ab_case=0; ab_case<=1; ab_case++)
+    {
+      size_t ab1 = ab[ab_case];
+      size_t ab2 = ab[1-ab_case];
+      double jab1  = jab[ab_case];
+      double jab2  = jab[1-ab_case];
+      size_t indx_ab = iket + ab_case*nph_kets;
+
+      // loop over orbits i, and check if <iQ| is in the desired channel.
+      for (size_t i=0; i<norb; i++)
+      {
+        Orbit& oi = Z.modelspace->GetOrbit(i);
+        if (not tbc_cc.CheckChannel_ket( &oi, &oQ ) ) continue;  //  <iQ|  isn't in this channel, so move along. (Note, for this check, the ordering of i,Q doesn't matter).
+        size_t indx_iQ = i;   // since Q is fixed, we can label the bra <iQ| by the index i.
+        double ji = oi.j2*0.5;
+
+        int Jmin = std::max( std::abs(jab1-jQ), std::abs(ji-jab2) );
+        int Jmax = std::min( jab1+jQ, ji+jab2 );
+        double Xbar = 0;
+        for (int J_std=Jmin; J_std<=Jmax; ++J_std)
+        {
+          double sixj = Z.modelspace->GetSixJ(ji,jQ,J_cc,jab1,jab2,J_std);
+          if (std::abs(sixj) < 1e-8) continue;
+          //             double tbme = Z.TwoBody.GetTBME_J(J_std,i,ab2,ab1,Q);
+          double tbme = Z.ThreeLeg.GetME_J(J_std,i,ab2,ab1);
+          Xbar -= (2*J_std+1) * sixj * tbme ;
+        }
+        TwoBody_CC_ph(indx_iQ, indx_ab) = Xbar * nanb[ab_case] ;
+      }
+    }
+  }
 }
 
 
@@ -10656,85 +10881,85 @@ void DoPandyaTransformation_SingleChannel_Dagger(const Operator& Z, arma::mat& T
 // Otherwise, it should look pretty similar.
 void AddInversePandyaTransformation_Dagger( const std::deque<arma::mat>& Zbar, Operator& Z )
 {
-    // Do the inverse Pandya transform
-   int n_nonzeroChannels = Z.modelspace->SortedTwoBodyChannels.size();
-   size_t norb = Z.modelspace->GetNumberOrbits();
-   size_t Q = Z.GetQSpaceOrbit();
-   Orbit& oQ = Z.modelspace->GetOrbit(Q);
-   double jQ = 0.5 * oQ.j2;
-
-    // Only go parallel if we've previously calculated the SixJ's. Otherwise, it's not thread safe.
-//   #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar_transform_first_pass)
-   for (int ich = 0; ich < n_nonzeroChannels; ++ich)
-   {
-      size_t ch = Z.modelspace->SortedTwoBodyChannels[ich];
-      TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
-      int J = tbc.J;
-      size_t nKets = tbc.GetNumberKets();
+  // Do the inverse Pandya transform
+  int n_nonzeroChannels = Z.modelspace->SortedTwoBodyChannels.size();
+  size_t norb = Z.modelspace->GetNumberOrbits();
+  size_t Q = Z.GetQSpaceOrbit();
+  Orbit& oQ = Z.modelspace->GetOrbit(Q);
+  double jQ = 0.5 * oQ.j2;
 
-      // the bra is the <ij| part of Z_ijkQ
-      for (size_t ibra=0; ibra<nKets; ++ibra)
-      {
-        Ket & bra = tbc.GetKet(ibra);
+  // Only go parallel if we've previously calculated the SixJ's. Otherwise, it's not thread safe.
+  //   #pragma omp parallel for schedule(dynamic,1) if (not Z.modelspace->scalar_transform_first_pass)
+  for (int ich = 0; ich < n_nonzeroChannels; ++ich)
+  {
+    size_t ch = Z.modelspace->SortedTwoBodyChannels[ich];
+    TwoBodyChannel& tbc = Z.modelspace->GetTwoBodyChannel(ch);
+    int J = tbc.J;
+    size_t nKets = tbc.GetNumberKets();
 
-        // Two-element lists for use below, because we need to antisymmetrize with 1-Pij, including a phase factor (-1)^(ji+jj-J)
-        // The code would look like the exact same thing copy-pasted twice, with i and j exchanged in the second copy.
-        std::vector<size_t> ij_switcheroo = {bra.p , bra.q};
-        std::vector<int> phaseij = { +1, bra.Phase(J) }; 
+    // the bra is the <ij| part of Z_ijkQ
+    for (size_t ibra=0; ibra<nKets; ++ibra)
+    {
+      Ket & bra = tbc.GetKet(ibra);
 
-        double norm_ij = (bra.p==bra.q) ? PhysConst::INVSQRT2 : 1.0;
+      // Two-element lists for use below, because we need to antisymmetrize with 1-Pij, including a phase factor (-1)^(ji+jj-J)
+      // The code would look like the exact same thing copy-pasted twice, with i and j exchanged in the second copy.
+      std::vector<size_t> ij_switcheroo = {bra.p , bra.q};
+      std::vector<int> phaseij = { +1, bra.Phase(J) };
 
-        for (size_t k=0; k<norb; k++)
-        {
-          Orbit & ok = Z.modelspace->GetOrbit(k);
-//          if ( not tbc.CheckChannel_ket(&ok, &oQ) ) continue; // if |kQ> doesn't live in this channel, move along.
-//          if ( ( (ok.tz2+oQ.tz2)!=2*tbc.Tz) or ( (ok.l+oQ.l)%2!=tbc.parity) or ( (ok.j2+oQ.j2)<2*tbc.J) or ( std::abs(ok.j2-oQ.j2)>2*tbc.J) ) continue; // if |kQ> doesn't live in this channel, move along.
-          if ( ( (ok.tz2-oQ.tz2)!=2*tbc.Tz) or ( (ok.l+oQ.l)%2!=tbc.parity) or ( (ok.j2+oQ.j2)<2*tbc.J) or ( std::abs(ok.j2-oQ.j2)>2*tbc.J) ) continue; // if |kQ> doesn't live in this channel, move along.
+      double norm_ij = (bra.p==bra.q) ? PhysConst::INVSQRT2 : 1.0;
+
+      for (size_t k=0; k<norb; k++)
+      {
+        Orbit & ok = Z.modelspace->GetOrbit(k);
+        //          if ( not tbc.CheckChannel_ket(&ok, &oQ) ) continue; // if |kQ> doesn't live in this channel, move along.
+        //          if ( ( (ok.tz2+oQ.tz2)!=2*tbc.Tz) or ( (ok.l+oQ.l)%2!=tbc.parity) or ( (ok.j2+oQ.j2)<2*tbc.J) or ( std::abs(ok.j2-oQ.j2)>2*tbc.J) ) continue; // if |kQ> doesn't live in this channel, move along.
+        if ( ( (ok.tz2-oQ.tz2)!=2*tbc.Tz) or ( (ok.l+oQ.l)%2!=tbc.parity) or ( (ok.j2+oQ.j2)<2*tbc.J) or ( std::abs(ok.j2-oQ.j2)>2*tbc.J) ) continue; // if |kQ> doesn't live in this channel, move along.
 
-          double jk = ok.j2/2.;
-//          double norm_kQ = (k==Q) ? PhysConst::INVSQRT2  : 1.0;
-          double norm_kQ = 1.0;
+        double jk = ok.j2/2.;
+        //          double norm_kQ = (k==Q) ? PhysConst::INVSQRT2  : 1.0;
+        double norm_kQ = 1.0;
 
-          double commijk = 0;  // collect the sum in commijk 
+        double commijk = 0;  // collect the sum in commijk
 
-          for (int ij_case=0; ij_case<=1; ij_case++) // loop over the two cases corresponding to 1-Pij (with the appropriate phase on the exchange term)
+        for (int ij_case=0; ij_case<=1; ij_case++) // loop over the two cases corresponding to 1-Pij (with the appropriate phase on the exchange term)
+        {
+          size_t i = ij_switcheroo[ij_case];
+          size_t j = ij_switcheroo[1-ij_case];
+          int Pij = phaseij[ij_case];
+
+          Orbit & oi = Z.modelspace->GetOrbit(i);
+          Orbit & oj = Z.modelspace->GetOrbit(j);
+          double ji = oi.j2/2.;
+          double jj = oj.j2/2.;
+
+          // now loop over the Jprime entering in the Pandya transformation
+          int parity_cc = (oi.l+oQ.l)%2;
+          //            int Tz_cc = std::abs(oi.tz2+oQ.tz2)/2;
+          int Tz_cc = std::abs(oi.tz2-oQ.tz2)/2;
+          int Jmin = std::max(std::abs(int(ji-jQ)),std::abs(int(jk-jj)));
+          int Jmax =  std::min( ji+jQ, jk+jj );
+          for (int Jprime=Jmin; Jprime<=Jmax; ++Jprime)
           {
-            size_t i = ij_switcheroo[ij_case];
-            size_t j = ij_switcheroo[1-ij_case];
-            int Pij = phaseij[ij_case];
-
-            Orbit & oi = Z.modelspace->GetOrbit(i);
-            Orbit & oj = Z.modelspace->GetOrbit(j);
-            double ji = oi.j2/2.;
-            double jj = oj.j2/2.;
-
-            // now loop over the Jprime entering in the Pandya transformation
-            int parity_cc = (oi.l+oQ.l)%2;
-//            int Tz_cc = std::abs(oi.tz2+oQ.tz2)/2;
-            int Tz_cc = std::abs(oi.tz2-oQ.tz2)/2;
-            int Jmin = std::max(std::abs(int(ji-jQ)),std::abs(int(jk-jj)));
-            int Jmax =  std::min( ji+jQ, jk+jj );
-            for (int Jprime=Jmin; Jprime<=Jmax; ++Jprime)
-            {
-              double sixj = Z.modelspace->GetSixJ(ji,jj,J,jk,jQ,Jprime);
-              if (std::abs(sixj)<1e-8) continue;
-              int ch_cc = Z.modelspace->GetTwoBodyChannelIndex(Jprime,parity_cc,Tz_cc);
-              TwoBodyChannel_CC& tbc_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_cc);
-              int nkets_cc = tbc_cc.GetNumberKets();
-              size_t indx_iQ = i;
-              size_t indx_kj = tbc_cc.GetLocalIndex(std::min(j,k),std::max(j,k)) +(k>j?nkets_cc:0);
-              double me1 = Zbar.at(ch_cc)(indx_iQ,indx_kj);
-              commijk -= (2*Jprime+1.) * sixj * me1  * Pij;
-            }
+            double sixj = Z.modelspace->GetSixJ(ji,jj,J,jk,jQ,Jprime);
+            if (std::abs(sixj)<1e-8) continue;
+            int ch_cc = Z.modelspace->GetTwoBodyChannelIndex(Jprime,parity_cc,Tz_cc);
+            TwoBodyChannel_CC& tbc_cc = Z.modelspace->GetTwoBodyChannel_CC(ch_cc);
+            int nkets_cc = tbc_cc.GetNumberKets();
+            size_t indx_iQ = i;
+            size_t indx_kj = tbc_cc.GetLocalIndex(std::min(j,k),std::max(j,k)) +(k>j?nkets_cc:0);
+            double me1 = Zbar.at(ch_cc)(indx_iQ,indx_kj);
+            commijk -= (2*Jprime+1.) * sixj * me1  * Pij;
+          }
 
-          } // for ij_case
-          commijk *= norm_ij * norm_kQ;
-//            Z.TwoBody.AddToTBME_J(J,i,j,k,Q,  commijk );   // AddToTBME_J assumes a normalized matrix element.
-//            Z.ThreeLeg.AddToME_J(J,i,j,k,  commijk );   // AddToTBME_J assumes a normalized matrix element.
-          Z.ThreeLeg.AddToME_J(J,bra.p,bra.q,k,  commijk );   // AddToTBME_J assumes a normalized matrix element.
-        } // for k
-      } // for ibra, which is <ij|
-   } // for ich, which is J etc
+        } // for ij_case
+        commijk *= norm_ij * norm_kQ;
+        //            Z.TwoBody.AddToTBME_J(J,i,j,k,Q,  commijk );   // AddToTBME_J assumes a normalized matrix element.
+        //            Z.ThreeLeg.AddToME_J(J,i,j,k,  commijk );   // AddToTBME_J assumes a normalized matrix element.
+        Z.ThreeLeg.AddToME_J(J,bra.p,bra.q,k,  commijk );   // AddToTBME_J assumes a normalized matrix element.
+      } // for k
+    } // for ibra, which is <ij|
+  } // for ich, which is J etc
 }
 
 
diff --git a/src/Commutator.hh b/src/Commutator.hh
index db451b2..688c32f 100644
--- a/src/Commutator.hh
+++ b/src/Commutator.hh
@@ -35,6 +35,7 @@ namespace Commutator{
   extern bool use_goose_tank_correction;
   extern bool use_brueckner_bch;
   extern bool use_imsrg3;
+  extern bool use_imsrg3_n7;
   extern bool perturbative_triples;
   extern bool only_2b_omega;
   extern double bch_transform_threshold;
@@ -45,6 +46,7 @@ namespace Commutator{
   void SetUseBruecknerBCH(bool tf);
   void SetUseGooseTank(bool tf);
   void SetUseIMSRG3(bool tf);
+  void SetUseIMSRG3N7(bool tf);
   void SetOnly2bOmega(bool tf);
 
 
@@ -64,6 +66,7 @@ namespace Commutator{
   std::deque<arma::mat> InitializePandya(Operator& Z, size_t nch, std::string orientation);
   void DoPandyaTransformation(const Operator& Z, std::deque<arma::mat>&, std::string orientation) ;
   void DoPandyaTransformation_SingleChannel(const Operator& Z, arma::mat& X, int ch_cc, std::string orientation) ;
+  void DoPandyaTransformation_SingleChannel_XandY(const Operator& X, const Operator& Y, arma::mat& X2_CC_ph, arma::mat& Y2_CC_ph, int ch_cc);
 //  void AddInversePandyaTransformation(Operator& Z, const std::deque<arma::mat>&);
   void AddInversePandyaTransformation(const std::deque<arma::mat>& Zbar, Operator& Z);   // Changed from the above declaration. Not sure how this was compiling...
   void AddInversePandyaTransformation_SingleChannel(Operator& Z, arma::mat& Zbar, int ch_cc);
diff --git a/src/Generator.cc b/src/Generator.cc
index 7c1ffcb..0d185a8 100755
--- a/src/Generator.cc
+++ b/src/Generator.cc
@@ -291,109 +291,6 @@ void Generator::ConstructGenerator_SingleRef_3body(std::function<double (double,
 }
 
 
-/*
-
-
-//void Generator::ConstructGenerator_Atan_3body()
-void Generator::ConstructGenerator_SingleRef_3body(std::function<double (double,double)>& etafunc )
-{
-
-     size_t ncore = modelspace->core.size();
-     std::vector<size_t> corevec;
-     for (auto a : modelspace->core) corevec.push_back(a);
-     std::map<int,double> e_fermi = modelspace->GetEFermi();
-     std::cout << __func__ << "  looping in generator 3-body part .  Size of H3 = " << H->ThreeBodyNorm() << std::endl;
-//    for (auto a : modelspace->core )
-    #pragma omp parallel for schedule(dynamic,1)
-    for (size_t ind_a=0; ind_a<ncore; ind_a++ )
-    {
-     auto a = corevec[ind_a];
-     Orbit& oa = modelspace->GetOrbit(a);
-     double d_ea = std::abs( 2*oa.n + oa.l - e_fermi[oa.tz2]);
-     for (auto b : modelspace->core )
-     {
-//      if (b>a) continue;
-      if (b<a) continue;
-      Orbit& ob = modelspace->GetOrbit(b);
-      double d_eb = std::abs( 2*ob.n + ob.l - e_fermi[ob.tz2]);
-      int Jab_min = std::abs(oa.j2-ob.j2)/2;
-      int Jab_max = (oa.j2+ob.j2)/2;
-      for (int Jab=Jab_min; Jab<=Jab_max; Jab++)
-      {
-       for (auto c : modelspace->core )
-       {
-//        if (c>b) continue;
-        if (c<b) continue;
-        Orbit& oc = modelspace->GetOrbit(c);
-        double d_ec = std::abs( 2*oc.n + oc.l - e_fermi[oc.tz2]);
-//        if ( (2*(oa.n+ob.n+oc.n)+oa.l+ob.l+oc.l) > E3cut ) continue;
-        if ( (2*(oa.n+ob.n+oc.n)+oa.l+ob.l+oc.l) > modelspace->E3max ) continue;
-        if ( d_ea + d_eb + d_ec > modelspace->GetdE3max() ) continue;
-//        std::cout << "  abc " << a << " " << b << " " << c << std::endl;
-
-        for ( auto i : imsrg_util::VectorUnion(modelspace->valence,modelspace->qspace) )
-        {
-         Orbit& oi = modelspace->GetOrbit(i);
-         double d_ei = std::abs( 2*oi.n + oi.l - e_fermi[oi.tz2]);
-         for ( auto j : imsrg_util::VectorUnion(modelspace->valence,modelspace->qspace) )
-         {
-//          if (j>i) continue;
-          if (j<i) continue;
-          Orbit& oj = modelspace->GetOrbit(j);
-          double d_ej = std::abs( 2*oj.n + oj.l - e_fermi[oj.tz2]);
-          int Jij_min = std::abs(oi.j2-oj.j2)/2;
-          int Jij_max = (oi.j2+oj.j2)/2;
-          for (int Jij=Jij_min; Jij<=Jij_max; Jij++)
-          {
-           for ( auto k : imsrg_util::VectorUnion(modelspace->valence,modelspace->qspace) )
-           {
-//            if (k>j) continue;
-            if (k<j) continue;
-            Orbit& ok = modelspace->GetOrbit(k);
-            double d_ek = std::abs( 2*ok.n + ok.l - e_fermi[ok.tz2]);
-            if ( d_ei + d_ej + d_ek > modelspace->GetdE3max() ) continue;
-//            if ( (2*(oi.n+oj.n+ok.n)+oi.l+oj.l+ok.l) > 2*E3cut ) continue;
-            if ( (2*(oi.n+oj.n+ok.n)+oi.l+oj.l+ok.l) > modelspace->E3max ) continue;
-            if ( (oa.l+ob.l+oc.l+oi.l+oj.l+ok.l)%2>0 ) continue;
-            if ( (oa.tz2+ob.tz2+oc.tz2) != (oi.tz2+oj.tz2+ok.tz2) ) continue;
-            double denominator = Get3bDenominator( a,b,c, i,j,k ) ;
-//            std::cout << "  abc  " << a << " " << b << " " << c << "     ijk " << i << " " << j << " " << k << "   denom = " << denominator << std::endl;
-//            std::cout << "       ...  " << oi.l << " "<<  oi.j2 << std::endl;
-
-            int twoJ_min = std::max( std::abs(2*Jab-oc.j2), std::abs(2*Jij-ok.j2) );
-            int twoJ_max = std::min( 2*Jab+oc.j2, 2*Jij+ok.j2 );
-            for (int twoJ=twoJ_min; twoJ<=twoJ_max; twoJ+=2)
-            {
-//              std::cout << "            Jab Jij   twoJ = " << Jab << " " << Jij << " " << twoJ << std::endl;
-              double ME_od = H->ThreeBody.GetME_pn( Jab, Jij, twoJ, a,b,c,i,j,k);
-//              std::cout << "      got ME_od = " << ME_od << std::endl;
-//              double eta = 0.5*atan(2*ME_od / denominator);
-              double eta =  etafunc( ME_od, denominator);  
-//              double eta = (ME_od / denominator);
-//              if (std::abs(eta)>1e-6)
-//              if (std::abs(eta)>1e-3)
-//              {
-//                std::cout << "big eta !  <" << a << " " << b << " " << c << ", " << Jab << " | " << i << " " << j << " " << k << ", " << Jij << " > _ " << twoJ << "  => " << ME_od << " / " << denominator << " = " << eta << std::endl;
-//              }
-//              std::cout << " Calling add  " << Jab << " " << Jij << " " << twoJ << "   " << a << " " << b << " " << c << "  " << i << " " << j << " " << k << "   =>  " << eta << std::endl;
-              Eta->ThreeBody.AddToME_pn( Jab, Jij, twoJ, a,b,c,i,j,k,  eta);
-            }
-           }
-          }
-         }
-        }
-       }
-      } 
-     } 
-    }// for a
-    std::cout << "Size of Eta3 = " << Eta->ThreeBodyNorm() << std::endl;
-//    }// if particle rank >3
-//    H->profiler.timer["Update Eta 3body"] += omp_get_wtime() - t_start;
-}
-
-*/
-
-
 
 
 void Generator::ConstructGenerator_ShellModel(std::function<double (double,double)>& eta_func)
diff --git a/src/HFMBPT.cc b/src/HFMBPT.cc
index d058e93..c481fcf 100644
--- a/src/HFMBPT.cc
+++ b/src/HFMBPT.cc
@@ -60,7 +60,7 @@ void HFMBPT::GetNaturalOrbitals()
 //    trr += (oi.j2+1) * Occ(i);
 //    std::cout << " Occ( " << i << " ) = " << Occ(i) << "   sum = " << trr << std::endl;
   }
-    
+
   if (use_NAT_occupations) // use fractional occupation
   {
 
@@ -69,7 +69,7 @@ void HFMBPT::GetNaturalOrbitals()
     double NfromTr=0;
     double ZfromTr=0;
     std::cout << "Switching to occupation numbers obtained from 2nd order 1b density matrix." << std::endl;
-    std::vector<index_t> holeorbs_tmp; 
+    std::vector<index_t> holeorbs_tmp;
     std::vector<double> hole_occ_tmp;
     // Figure out how many particles are living in orbits with occupations above our threshold.
     // We do this separately for protons and neutrons.
@@ -132,7 +132,7 @@ void HFMBPT::GetNaturalOrbitals()
     UpdateReference();
 
   } // if use_NAT_occupations
-  
+
 }
 
 //*********************************************************************
@@ -163,7 +163,7 @@ void HFMBPT::DiagonalizeRho()
     C_HF2NAT.submat(orbvec, orbvec_d) = vec;
   }
  // Choose ordering and phases so that C_HF2NAT looks as close to the identity as possible
-  ReorderHFMBPTCoefficients(); 
+  ReorderHFMBPTCoefficients();
 }
 
 //*********************************************************************
@@ -312,7 +312,7 @@ Operator HFMBPT::GetNormalOrderedHNAT(int particle_rank)
   arma::mat rho_swap = rho;
   arma::mat tmp = C_HO2NAT.cols(holeorbs);
   rho = (tmp.each_row() % hole_occ) * tmp.t();
-  
+
 
   // fractional occupation
   // rho = C_HO2NAT * diagmat(Occ) * C_HO2NAT.t();
@@ -332,61 +332,82 @@ Operator HFMBPT::GetNormalOrderedHNAT(int particle_rank)
   HNO.OneBody = C_HO2NAT.t() * F * C_HO2NAT;
 
   int nchan = HartreeFock::modelspace->GetNumberTwoBodyChannels();
-  int norb = HartreeFock::modelspace->GetNumberOrbits();
-  for (int ch=0; ch<nchan; ++ch)
+//  int norb = HartreeFock::modelspace->GetNumberOrbits();
+
+//  if( Hbare.ThreeBodyNO2B.initialized ){
+
+
+  // The way we get the NO2B part of the interaction depends on whether we're using the full 3N or if we just
+  // read in the NO2B part of the 3N. Here we wrap the two options in a lambda function so that we only need
+  // to write the whole loop once, and so that we don't have unnecessary if statements at the deepest nested loop.
+  std::function<double (int,int,int,int,int,int,int)> GetVNO2B;
+  if ( Hbare.ThreeBodyNO2B.initialized)
+  {
+    GetVNO2B = [this] (int i,int j, int a, int k, int l, int b, int J){
+                 return this->Hbare.ThreeBodyNO2B.GetThBME(i,j,a,k,l,b,J);
+               };
+  }
+  else
   {
-    TwoBodyChannel& tbc = HartreeFock::modelspace->GetTwoBodyChannel(ch);
-    int J = tbc.J;
-    int npq = tbc.GetNumberKets();
-
-    arma::mat D(npq,npq,arma::fill::zeros);
-    arma::mat V3NO(npq,npq,arma::fill::zeros);
-    #pragma omp parallel for schedule(dynamic,1) // we've got the threads, may as well use them...
-    for (int i=0; i<npq; ++i)
+    GetVNO2B = [this] (int i,int j, int a, int k, int l, int b, int J){
+                 double vno2b = 0;
+                 double j2a = this->modelspace->GetOrbit(a).j2;
+                 for (int J3=std::abs(2*J-j2a); J3<=(2*J+j2a); J3+=2)  vno2b += (J3+1) * this->Hbare.ThreeBody.GetME_pn(J,J,J3,i,j,a,k,l,b);
+                 return vno2b;
+               };
+  }
+
+    for (int ch=0;ch<nchan;++ch)
     {
-      Ket & bra = tbc.GetKet(i);
-      int e2bra = 2*bra.op->n + bra.op->l + 2*bra.oq->n + bra.oq->l;
-      for (int j=0; j<npq; ++j)
+      TwoBodyChannel& tbc = modelspace->GetTwoBodyChannel(ch);
+      int J = tbc.J;
+      int npq = tbc.GetNumberKets();
+
+      arma::mat D(npq,npq,arma::fill::zeros);  // <ij|ab> = <ji|ba>
+      arma::mat V3NO(npq,npq,arma::fill::zeros);  // <ij|ab> = <ji|ba>
+#pragma omp parallel for schedule(dynamic,1)
+      for (int i=0; i<npq; ++i)
       {
-        Ket & ket = tbc.GetKet(j);
-        int e2ket = 2*ket.op->n + ket.op->l + 2*ket.oq->n + ket.oq->l;
-        D(i,j) = C_HO2NAT(bra.p,ket.p) * C_HO2NAT(bra.q,ket.q);
-        if (bra.p!=bra.q)
+        Ket & bra = tbc.GetKet(i);
+        int e2bra = 2*bra.op->n + bra.op->l + 2*bra.oq->n + bra.oq->l;
+        for (int j=0; j<npq; ++j)
         {
-          D(i,j) += C_HO2NAT(bra.q,ket.p) * C_HO2NAT(bra.p,ket.q) * bra.Phase(J);
-        }
-        if (bra.p==bra.q)    D(i,j) *= PhysConst::SQRT2;
-        if (ket.p==ket.q)    D(i,j) /= PhysConst::SQRT2;
+          Ket & ket = tbc.GetKet(j);
+          int e2ket = 2*ket.op->n + ket.op->l + 2*ket.oq->n + ket.oq->l;
+          D(i,j) = C_HO2NAT(bra.p,ket.p) * C_HO2NAT(bra.q,ket.q);
+          if (bra.p!=bra.q)
+          {
+            D(i,j) += C_HO2NAT(bra.q,ket.p) * C_HO2NAT(bra.p,ket.q) * bra.Phase(J);
+          }
+          if (bra.p==bra.q)    D(i,j) *= PhysConst::SQRT2;
+          if (ket.p==ket.q)    D(i,j) /= PhysConst::SQRT2;
 
-        // Now generate the NO2B part of the 3N interaction
-        if (Hbare.GetParticleRank()<3) continue;
-        if (i>j) continue;
-        for (int a=0; a<norb; ++a)
-        {
-          Orbit & oa = HartreeFock::modelspace->GetOrbit(a);
-          if ( 2*oa.n+oa.l+e2bra > Hbare.GetE3max() ) continue;
-          for (int b : Hbare.OneBodyChannels.at({oa.l,oa.j2,oa.tz2}))
+          // Now generate the NO2B part of the 3N interaction
+          if (Hbare.GetParticleRank()<3) continue;
+          if (i>j) continue;
+          for ( auto a : modelspace->all_orbits )
           {
-            Orbit & ob = HartreeFock::modelspace->GetOrbit(b);
-            if ( 2*ob.n+ob.l+e2ket > Hbare.GetE3max() ) continue;
-            int J3min = abs(2*J-oa.j2);
-            int J3max = 2*J + oa.j2;
-            for (int J3=J3min; J3<=J3max; J3+=2)
+            Orbit & oa = modelspace->GetOrbit(a);
+            if ( 2*oa.n+oa.l+e2bra > Hbare.GetE3max() ) continue;
+            for (int b : Hbare.OneBodyChannels.at({oa.l,oa.j2,oa.tz2}))
             {
-              V3NO(i,j) += rho(a,b) * (J3+1) * Hbare.ThreeBody.GetME_pn(J,J,J3,bra.p,bra.q,a,ket.p,ket.q,b);
+              Orbit & ob = HartreeFock::modelspace->GetOrbit(b);
+              if ( 2*ob.n+ob.l+e2ket > Hbare.GetE3max() ) continue;
+              V3NO(i,j) += rho(a,b) * GetVNO2B(bra.p, bra.q, a, ket.p, ket.q, b, J);
             }
           }
+          V3NO(i,j) /= (2*J+1);
+          if (bra.p==bra.q)  V3NO(i,j) /= PhysConst::SQRT2;
+          if (ket.p==ket.q)  V3NO(i,j) /= PhysConst::SQRT2;
+          V3NO(j,i) = V3NO(i,j);
         }
-        V3NO(i,j) /= (2*J+1);
-        if (bra.p==bra.q)  V3NO(i,j) /= PhysConst::SQRT2;
-        if (ket.p==ket.q)  V3NO(i,j) /= PhysConst::SQRT2;
-        V3NO(j,i) = V3NO(i,j);
-      }// for j
-    }// for i
-    auto& V2  =  Hbare.TwoBody.GetMatrix(ch);
-    auto& OUT =  HNO.TwoBody.GetMatrix(ch);
-    OUT  =    D.t() * (V2 + V3NO) * D;
-  }// for ch
+      }
+
+      auto& V2  =  Hbare.TwoBody.GetMatrix(ch);
+      auto& OUT =  HNO.TwoBody.GetMatrix(ch);
+      OUT  =    D.t() * (V2 + V3NO) * D;
+    }
+
 
   if (particle_rank>2)
   {
@@ -414,7 +435,7 @@ void HFMBPT::GetDensityMatrix()
 
 //*********************************************************************
 // Pretty self explanatory. Print the quantum numbers and occupations
-// of all orbits, except that the occupation is the eigenvalue of the 
+// of all orbits, except that the occupation is the eigenvalue of the
 // density matrix, not the value set in modelspace.
 //*********************************************************************
 void HFMBPT::PrintOccupation()
@@ -431,14 +452,14 @@ void HFMBPT::PrintOccupation()
 }
 
 //*********************************************************************
-// Compute the MBPT2 contribution to rho due to < 1| rho |1 > where 
+// Compute the MBPT2 contribution to rho due to < 1| rho |1 > where
 //  |1> is the 1st order correction to the HF ground state.
 // Here we treat the contribution to the particle-particle block.
 //
 //        *~~~~~~~*      <a|rho|b> = 1/2 sum_{cijJ} (2J+1)/(2j_a+1) <ac|V|ij><ij|V|bc> / Delta
-// R0--- / \     / \a           
+// R0--- / \     / \a
 //     c(  i)  j(  (RHO)      with Delta = (ea+ec -ei-ej)(eb+ec-ei-ej)
-// R0--- \ /     \ /b      
+// R0--- \ /     \ /b
 //        *~~~~~~~*        R0---  indicates the MBPT resolvent lines.
 //                         ijk are holes, abc are particles
 //
@@ -452,7 +473,7 @@ void HFMBPT::PrintOccupation()
 // where E*E = 1/4 (e_acij * e_bcij)
 // In the limit V*V << E*E, this coincides with the perturbative expression,
 // so we can make the replacement even if the levels aren't closely spaced.
-// 
+//
 // When using fraction occupations, including the factor (1-na)(1-nb) [ni nj(1-nc)]^2
 // and an equivalent one in the HH term produces a density matrix with the correct
 // particle number, encoded in the 2j+1 weighted trace of rho. However, including
@@ -506,14 +527,14 @@ void HFMBPT::DensityMatrixPP(Operator& H)
 
             double tbme = 0.0;
             for(int J = Jmin; J <= Jmax; ++J){
-              tbme +=  (2*J+1) * H.TwoBody.GetTBME_J(J,a,c,i,j) 
+              tbme +=  (2*J+1) * H.TwoBody.GetTBME_J(J,a,c,i,j)
                                * H.TwoBody.GetTBME_J(J,i,j,b,c);
             }
             tbme *=  (1-oa.occ) * (1-ob.occ) * pow( (1-oc.occ) * oi.occ * oj.occ,2) ;
             if (true)
             {
               double epsilon = 0.5*sqrt(std::abs(e_acij * e_bcij));
-              r += 0.5* ( sqrt(tbme + epsilon*epsilon) - epsilon ) / sqrt(tbme + epsilon*epsilon); 
+              r += 0.5* ( sqrt(tbme + epsilon*epsilon) - epsilon ) / sqrt(tbme + epsilon*epsilon);
             }
             else // the MBPT expression. We don't actually use this.
             {
@@ -530,14 +551,14 @@ void HFMBPT::DensityMatrixPP(Operator& H)
 
 
 //*********************************************************************
-// Compute the MBPT2 contribution to rho due to < 1| rho |1 > where 
+// Compute the MBPT2 contribution to rho due to < 1| rho |1 > where
 //  |1> is the 1st order correction to the HF ground state.
 // Here we treat the contribution to the hole-hole block.
 //
 //        *~~~~~~~*      <i|rho|j> = -1/2 sum_{abkJ} (2J+1)/(2j_i+1) <ab|V|ik><jk|V|ab> / Delta
-// R0--- / \     / \j           
+// R0--- / \     / \j
 //     a(  k)  b(  (RHO)      with Delta = (ea+eb -ei-ek)(ea+eb-ej-ek)
-// R0--- \ /     \ /i      
+// R0--- \ /     \ /i
 //        *~~~~~~~*        R0---  indicates the MBPT resolvent lines.
 //                         ijk are holes, abc are particles
 //
@@ -617,26 +638,26 @@ void HFMBPT::DensityMatrixHH(Operator& H)
 }
 
 //*********************************************************************
-// Compute the MBPT2 contribution to rho due to <0|rho|2> + <2|rho|0> 
+// Compute the MBPT2 contribution to rho due to <0|rho|2> + <2|rho|0>
 //  where |0> is the HF ground state and |2> is the 2nd order correction.
 //
 //      (RHO)           <i|rho|a> = 1/2 sum_{bcjJ} (2J+1)/(2j_i+1) <aj|V|bc><bc|V|ij> / Delta
-// R0--- / \a               
+// R0--- / \a
 //     i(   )~~~~*       with Delta = (ea-ei)(eb+ec-ei-ej)
-// R0--- \ /b  j( )c      
+// R0--- \ /b  j( )c
 //        *~~~~~~*        R0---  indicates the MBPT resolvent lines.
 //                         ijk are holes, abc are particles
 // and
 //
 
 //      (RHO)           <i|rho|a> = -1/2 sum_{bkjJ} (2J+1)/(2j_i+1) <kj|V|ib><ab|V|kj> / Delta
-// R0--- / \i               
+// R0--- / \i
 //     a(   )~~~~*       with Delta = (ea-ei)(ea+eb-ej-ek)
-// R0--- \ /j  b( )k      
-//        *~~~~~~*        
-//                         
+// R0--- \ /j  b( )k
+//        *~~~~~~*
+//
 // Equivalent diagrams can be drawn with rho on the bottom, corresponding to <2|rho|0>,
-// and the formulas are the same.                                                         
+// and the formulas are the same.
 // In (limited) tests, a small gap between particle and hole levels did not appear
 // to be a problem for these diagrams, so the MBPT2 expression is used directly.
 // This may need to be revisited.
@@ -686,7 +707,7 @@ void HFMBPT::DensityMatrixPH(Operator& H)
             double tbme = 0.0;
             for(int J = Jmin; J <= Jmax; ++J)
             {
-              tbme += (2*J+1) * H.TwoBody.GetTBME_J(J,a,j,b,c)  
+              tbme += (2*J+1) * H.TwoBody.GetTBME_J(J,a,j,b,c)
                               * H.TwoBody.GetTBME_J(J,b,c,i,j);
             }
 
@@ -695,7 +716,7 @@ void HFMBPT::DensityMatrixPH(Operator& H)
           }
         }
       }
-      rho(a,i) += r * 0.5 / (oa.j2+1); 
+      rho(a,i) += r * 0.5 / (oa.j2+1);
       rho(i,a) += r * 0.5 / (oa.j2+1);
 //      rho(a,i) += r * 0.5 / (2*oa.j2+1); // <-- typo in original version?
 //      rho(i,a) += r * 0.5 / (2*oa.j2+1);
@@ -745,7 +766,7 @@ void HFMBPT::DensityMatrixPH(Operator& H)
             double tbme = 0.0;
             for(int J = Jmin; J <= Jmax; ++J)
             {
-              tbme += (2*J+1) * H.TwoBody.GetTBME_J(J,k,j,i,b) 
+              tbme += (2*J+1) * H.TwoBody.GetTBME_J(J,k,j,i,b)
                               * H.TwoBody.GetTBME_J(J,a,b,k,j);
             }
             tbme *= (1-oa.occ) * oi.occ * oj.occ * ok.occ * (1-ob.occ);
diff --git a/src/HartreeFock.cc b/src/HartreeFock.cc
index c45bffa..4ce95aa 100755
--- a/src/HartreeFock.cc
+++ b/src/HartreeFock.cc
@@ -12,12 +12,6 @@
 //#include <gsl/gsl_math.h> // for M_SQRTPI
 #include <omp.h>
 
-//#ifndef SQRT2
-//  #define SQRT2 1.4142135623730950488
-//#endif
-//#define HBARC 197.3269718 // hc in MeV * fm
-//#define M_NUCLEON 938.9185 // average nucleon mass in MeV
-
 
 //using namespace std;
 
@@ -37,8 +31,8 @@ HartreeFock::HartreeFock(Operator& hbare)
      for (int parity=0; parity<=1; ++parity)
      {
        int nKetsMon = modelspace->MonopoleKets[Tz+1][parity].size();
-       Vmon[Tz+1][parity] = arma::mat(nKetsMon,nKetsMon);
-       Vmon_exch[Tz+1][parity] = arma::mat(nKetsMon,nKetsMon);
+       Vmon[Tz+1][parity] = arma::mat(nKetsMon,nKetsMon,arma::fill::zeros);
+       Vmon_exch[Tz+1][parity] = arma::mat(nKetsMon,nKetsMon,arma::fill::zeros);
      }
    }
    prev_energies = arma::vec(norbits,arma::fill::zeros);
@@ -47,13 +41,14 @@ HartreeFock::HartreeFock(Operator& hbare)
 //   holeorbs = arma::uvec(modelspace->holes);
    holeorbs = arma::uvec( std::vector<index_t>(modelspace->holes.begin(),modelspace->holes.end()));
    hole_occ = arma::rowvec(occvec);
-   BuildMonopoleV();
-   if (hbare.GetParticleRank()>2)
-   {
-      BuildMonopoleV3();
-   }
-   UpdateDensityMatrix();
-   UpdateF();
+  // Move these to Solve, so that simply constructing isn't so expensive
+//   BuildMonopoleV();
+//   if (hbare.GetParticleRank()>2)
+//   {
+//      BuildMonopoleV3();
+//   }
+//   UpdateDensityMatrix();
+//   UpdateF();
 
 }
 
@@ -72,21 +67,14 @@ void HartreeFock::Solve()
    double density_mixing_factor = 0.2;
    double field_mixing_factor = 0.0;
    int fill_modulus = 5;
-//   double mixing_factor = 0.0;
 
-//   double theta00 = 0.167325;
-//  double theta11 = 0.1747955;
-//           C.eye();
-//          C(0,0) = cos(theta00);
-//          C(10,10) = cos(theta00);
-//          C(10,0) = sin(theta00);
-//          C(0,10) = -sin(theta00);
-//          C(1,1) = cos(theta11);
-//          C(11,11) = cos(theta11);
-//          C(11,1) = sin(theta11);
-//          C(1,11) = -sin(theta11);
-//          UpdateDensityMatrix();
-//          UpdateF();
+   BuildMonopoleV();
+   if (Hbare.GetParticleRank()>2)
+   {
+      BuildMonopoleV3();
+   }
+   UpdateDensityMatrix();
+   UpdateF();
 
 
    for (iterations=0; iterations<maxiter; ++iterations)
diff --git a/src/IMSRGSolver.cc b/src/IMSRGSolver.cc
index cf6c545..7831686 100755
--- a/src/IMSRGSolver.cc
+++ b/src/IMSRGSolver.cc
@@ -19,7 +19,7 @@ IMSRGSolver::IMSRGSolver()
     : rw(NULL),s(0),ds(0.1),ds_max(0.5),
      norm_domega(0.1), omega_norm_max(2.0),eta_criterion(1e-6),method("magnus_euler"),
      flowfile(""), n_omega_written(0),max_omega_written(500),magnus_adaptive(true),hunter_gatherer(false),perturbative_triples(false),
-     ode_monitor(*this),ode_mode("H"),ode_e_abs(1e-6),ode_e_rel(1e-6),pert_triples_this_omega(0),pert_triples_sum(0)
+     pert_triples_this_omega(0),pert_triples_sum(0),ode_monitor(*this),ode_mode("H"),ode_e_abs(1e-6),ode_e_rel(1e-6)
 {}
 
 // Constructor
@@ -28,7 +28,7 @@ IMSRGSolver::IMSRGSolver( Operator &H_in)
     istep(0), s(0),ds(0.1),ds_max(0.5),
     smax(2.0), norm_domega(0.1), omega_norm_max(2.0),eta_criterion(1e-6),method("magnus_euler"),
     flowfile(""), n_omega_written(0),max_omega_written(500),magnus_adaptive(true),hunter_gatherer(false),perturbative_triples(false),
-    ode_monitor(*this),ode_mode("H"),ode_e_abs(1e-6),ode_e_rel(1e-6),pert_triples_this_omega(0),pert_triples_sum(0)
+    pert_triples_this_omega(0),pert_triples_sum(0),ode_monitor(*this),ode_mode("H"),ode_e_abs(1e-6),ode_e_rel(1e-6)
 {
    Eta.Erase();
    Eta.SetAntiHermitian();
diff --git a/src/M0nu.cc b/src/M0nu.cc
new file mode 100755
index 0000000..18ca5a1
--- /dev/null
+++ b/src/M0nu.cc
@@ -0,0 +1,973 @@
+#include "M0nu.hh"
+#include "AngMom.hh"
+
+#include <gsl/gsl_math.h>
+#include <gsl/gsl_sf_laguerre.h>
+#include <gsl/gsl_sf_gamma.h>
+#include <gsl/gsl_sf_bessel.h>
+#include <gsl/gsl_errno.h>
+#include <gsl/gsl_integration.h>
+#include <boost/math/special_functions/gamma.hpp>
+#include <boost/math/special_functions/factorials.hpp>
+
+//makusing namespace AngMom;
+using namespace PhysConst;
+
+
+namespace M0nu
+{
+
+
+  // Converts (a,b,c,d) in base (maxa+1,maxb+1,maxc+1,maxd+1) to an ordered decimal integer
+  // eg: for (maxa,maxb,maxc,maxd) = (1,1,1,1) decimalgen would convert (0,1,1,0) to 6, ie: a binary to decimal converter
+  // NOTE: to make comparisons between such decimals, keep (maxa,maxb,maxc,maxd) consistent
+  // PS: I tots made this thing up, did some testing and it seemed to work...
+  // ... hopefully it's good, but could be a source of weird bugs if anything comes up with missing integrals wrt dq, see GetIntegral(...)
+  int decimalgen(int a, int b, int c, int d, int maxb, int maxc, int maxd)
+  {
+    int coeff1 = maxd + 1;
+    int coeff2 = (maxc + 1)*coeff1;
+    int coeff3 = (maxb + 1)*coeff2;
+    return coeff3*a + coeff2*b + coeff1*c + d; // eg: (0,1,1,0) -> (2*2*2)*0 + (2*2)*1 + (2)*1 + 0 = 6
+  }
+
+  // My personal GSL integration error handling
+  // NOTE: must put "#pragma omp critical" calls around this function when calling it in the code
+  // NOTE: in order to use this, one must set "gsl_set_error_handler_off();" beforehand
+  // NOTE: I'm setting the integral to 0 when it doesn't converge because for the all the case I've encountered so far, the resul was smaller than 1e-5
+  // this might be the cause for weird bug later on so make sure to check the log file afterwards
+  void GSLerror(std::string errstr, int status, size_t limit, double epsabs, double epsrel, double abserr, double result, int n, int l, int np, int lp, double q)
+  {
+    if (status)
+    {
+      std::cout<<"WARNING "<<errstr;
+      if (status == GSL_EMAXITER)
+      {
+        std::cout<<" the maximum number of subdivisions was exceeded."<<std::endl;
+      }
+      else if (status == GSL_EROUND)
+      {
+        std::cout<<" cannot reach tolerance because of roundoff error, or roundoff error was detected in the extrapolation table."<<std::endl;
+      }
+      else if (status == GSL_ESING)
+      {
+        std::cout<<" a non-integrable singularity or other bad integrand behavior was found in the integration interval."<<std::endl;
+      }
+      else if (status == GSL_EDIVERGE)
+      { std::cout<<"result = "<<std::setprecision(12)<<result<<std::endl;
+        std::cout<<" the integral is divergent, or too slowly convergent to be integrated numerically."<<std::endl;
+        std::cout<<"Assuming value is 0"<<std::endl;
+        std::cout<<"q ="<<q<<std::endl;
+        result = 0;
+      }
+      else
+      {
+        std::cout<<"apparently I'm missing a GSL error status handle..."<<std::endl;
+      }
+      std::cout<<"limit  = "<<limit<<std::endl;
+      std::cout<<"epsabs = "<<epsabs<<std::endl;
+      std::cout<<"epsrel = "<<epsrel<<std::endl;
+      std::cout<<"abserr = "<<abserr<<std::endl;
+      std::cout<<"result = "<<std::setprecision(12)<<result<<std::endl;
+      std::cout<<"n = "<<n<<", l = "<<l<<", np = "<<np<<", lp = "<<lp<<std::endl;
+      double errat = abs(abserr/result);
+      if (errat <= epsrel) // this if-else is a last resort, but only seems to rarely trigger for Tensor with high emax for a few n,l,np,lp
+      {
+        std::cout<<"moving forward since abs(abserr/result) = "<<errat<<" <= epsrel..."<<std::endl;
+      }
+      else if (abserr <= epsabs)
+      {
+        std::cout<<"moving forward since abserr <= epsabs..."<<std::endl;
+      }
+      else
+      {
+        std::cout<<"ERROR 37728: my GSL integration failed! :("<<std::endl;
+        std::cout<<"Assuming value is 0"<<std::endl;
+        result = 0;
+      }
+    }
+  }
+
+  //Intgrand function to compute the RBMEs
+  double frRBME(double r, void *params)
+  {
+    struct frparams * p = (struct frparams *)params;
+    int n       = (p->n);
+    int l       = (p->l);
+    int np      = (p->np);
+    int lp      = (p->lp);
+    double hw   = (p->hw);
+    int rho     = (p->rho);
+    double q    = (p->q);
+    q /= HBARC; // put it into [fm^-1] since r is in [fm]
+    q *= SQRT2; // this is to stay consistent with r_{rel} = (r_1 - r_2)/SQRT2 in Moshinksy brackets
+    return r*r*imsrg_util::HO_Radial_psi(n,l,hw,r)*gsl_sf_bessel_jl(rho,q*r)*imsrg_util::HO_Radial_psi(np,lp,hw,r);
+  }
+
+  //Integrand to compute the RBMEs with AV18 SRC
+  double frRBME_AV18(double r, void *params)
+  {
+    struct frparams * p = (struct frparams *)params;
+    int n       = (p->n);
+    int l       = (p->l);
+    int np      = (p->np);
+    int lp      = (p->lp);
+    double hw   = (p->hw);
+    int rho     = (p->rho);
+    double q    = (p->q);
+    double a = 1.49;
+    double b = 1.45; 
+    double c = 0.92;
+    q /= HBARC; // put it into [fm^-1] since r is in [fm]
+    q *= SQRT2; // this is to stay consistent with r_{rel} = (r_1 - r_2)/SQRT2 in Moshinksy brackets
+    a *= 2.0; // " " " " " " " " " " " "
+    b *= 2.0; // " " " " " " " " " " " "
+    double rsq = r*r;
+    double JTF = -c*exp(-a*rsq)*(1 - b*rsq); // the Jastrow-type correlation function
+    return rsq*imsrg_util::HO_Radial_psi(n,l,hw,r)*gsl_sf_bessel_jl(rho,q*r)*imsrg_util::HO_Radial_psi(np,lp,hw,r)*(1 + JTF)*(1 + JTF); // see Equation (6) of PRC.86.067304(2012), for example
+  }
+
+  //Integrand to compute the RBMEs with CDB SRC
+  double frRBME_CDB(double r, void *params)
+  {
+    struct frparams * p = (struct frparams *)params;
+    int n       = (p->n);
+    int l       = (p->l);
+    int np      = (p->np);
+    int lp      = (p->lp);
+    double hw   = (p->hw);
+    int rho     = (p->rho);
+    double q    = (p->q);
+    double a = 1.52;
+    double b = 1.88; 
+    double c = 0.46;
+    q /= HBARC; // put it into [fm^-1] since r is in [fm]
+    q *= SQRT2; // this is to stay consistent with r_{rel} = (r_1 - r_2)/SQRT2 in Moshinksy brackets
+    a *= 2.0; // " " " " " " " " " " " "
+    b *= 2.0; // " " " " " " " " " " " "
+    double rsq = r*r;
+    double JTF = -c*exp(-a*rsq)*(1 - b*rsq); // the Jastrow-type correlation function
+    return rsq*imsrg_util::HO_Radial_psi(n,l,hw,r)*gsl_sf_bessel_jl(rho,q*r)*imsrg_util::HO_Radial_psi(np,lp,hw,r)*(1 + JTF)*(1 + JTF); // see Equation (6) of PRC.86.067304(2012), for example
+  }
+
+    //Integrand to compute the RBMEs with MS SRC
+  double frRBME_MS(double r, void *params)
+  {
+    struct frparams * p = (struct frparams *)params;
+    int n       = (p->n);
+    int l       = (p->l);
+    int np      = (p->np);
+    int lp      = (p->lp);
+    double hw   = (p->hw);
+    int rho     = (p->rho);
+    double q    = (p->q);
+    double a = 1.10;
+    double b = 0.68; 
+    double c = 1;
+    q /= HBARC; // put it into [fm^-1] since r is in [fm]
+    q *= SQRT2; // this is to stay consistent with r_{rel} = (r_1 - r_2)/SQRT2 in Moshinksy brackets
+    a *= 2.0; // " " " " " " " " " " " "
+    b *= 2.0; // " " " " " " " " " " " "
+    double rsq = r*r;
+    double JTF = -c*exp(-a*rsq)*(1 - b*rsq); // the Jastrow-type correlation function
+    return rsq*imsrg_util::HO_Radial_psi(n,l,hw,r)*gsl_sf_bessel_jl(rho,q*r)*imsrg_util::HO_Radial_psi(np,lp,hw,r)*(1 + JTF)*(1 + JTF); // see Equation (6) of PRC.86.067304(2012), for example
+  }
+
+
+  // Calculates the RBMEs by doing the integral
+  //with respect to dr using gsl_integration_qagiu
+  double rbme(int n, int l, int np, int lp, double hw, int rho, double q, std::string src)
+  {
+    gsl_set_error_handler_off(); // set standard GSL error handling off, so I can do my own
+    int statusr; // this will hold the GSL error status
+    std::string errstrr="7828877-1: qagiu dr:"; // a unique GSL error string
+    size_t limitr = 100000; // the number of double precision intervals that can be held by the workspace below
+    gsl_integration_workspace * workspacer = gsl_integration_workspace_alloc(limitr); // GSL: "One workspace may be used multiple times...", "...workspaces should be allocated on a per-thread basis."
+    struct frparams frparams = {n,l,np,lp,hw,rho,q};
+    std::map<std::string, double(*) (double,void *)> frRBMElist = {{"none",frRBME},{"AV18",frRBME_AV18},{"CD-Bonn",frRBME_CDB},{"Miller-Spencer",frRBME_MS}};
+    gsl_function Fr;
+    Fr.function = frRBMElist[src]; // picks up the function to integrate for the src choice
+    Fr.params = &frparams;
+    double r1 = 0; // integrate over the range [r1,Inf)
+    double epsabsr = 1e-7; // absolute error tolerance for the integration
+    double epsrelr = 1e-5; // relative error tolerance for the adaptive integration
+    double rbme = 0; // qagiu integration result
+    double abserrr; // qagiu integration error estimate
+    statusr = gsl_integration_qagiu(&Fr,r1,epsabsr,epsrelr,limitr,workspacer,&rbme,&abserrr); // perform the qagiu integration (over r)
+    #pragma omp critical
+    {
+      GSLerror(errstrr,statusr,limitr,epsabsr,epsrelr,abserrr,rbme,n,l,np,lp,q); // check if the GSL integration worked
+    }
+    gsl_integration_workspace_free(workspacer); // free the allocated memory for the integration workspace, since GSL is written in C
+    return rbme;
+  }
+
+
+  //Form factors of the neutrino potential
+  double GTFormFactor(double q)
+  {
+    double qsq     = q*q; // q squared [MeV^2]
+    double Mprosq  = M_PROTON*M_PROTON; // the proton mass squared [MeV^2]
+    double Mpionsq = M_PION_CHARGED*M_PION_CHARGED; // the pion mass squared [MeV^2]
+    double gV      = NUCLEON_VECTOR_G/pow((1.0 + (qsq/(CUTV*CUTV))),2); // from Equation (4.14) of my thesis
+    double gA      = NUCLEON_AXIAL_G/pow((1.0 + (qsq/(CUTA*CUTA))),2); // " " " " " "
+    double gP      = (2*M_PROTON*gA)/(qsq + Mpionsq); // " " " " " "
+    double gM      = MAGMOM*gV; // " " " " " "
+    double ff      = ((gA*gA) - ((gA*gP*qsq)/(3*M_PROTON)) + (pow(gP*qsq,2)/(12*Mprosq)) + ((gM*gM*qsq)/(6*Mprosq)))/(NUCLEON_AXIAL_G*NUCLEON_AXIAL_G); //Equation (4.12) of Charlie's thesis
+    return ff;
+  }
+
+  double FermiFormFactor(double q)
+  {
+    double qsq     = q*q; // q squared [MeV^2]
+//    double Mprosq  = M_PROTON*M_PROTON; // the proton mass squared [MeV^2]      SRS commented out because not used.
+//    double Mpionsq = M_PION_CHARGED*M_PION_CHARGED; // the pion mass squared [MeV^2]
+    double gV      = NUCLEON_VECTOR_G/pow((1.0 + (qsq/(CUTV*CUTV))),2); // from Equation (4.14) of my thesis
+//    double gA      = NUCLEON_AXIAL_G/pow((1.0 + (qsq/(CUTA*CUTA))),2); // " " " " " "
+//    double gP      = (2*M_PROTON*gA)/(qsq + Mpionsq); // " " " " " "
+//    double gM      = MAGMOM*gV; // " " " " " "
+    double ff      = (gV*gV)/(NUCLEON_VECTOR_G*NUCLEON_VECTOR_G); //Equation (4.11) of Charlie's thesis
+    return ff;
+  }
+
+  double TensorFormFactor(double q)
+  {
+    double qsq     = q*q; // q squared [MeV^2]
+    double Mprosq  = M_PROTON*M_PROTON; // the proton mass squared [MeV^2]
+    double Mpionsq = M_PION_CHARGED*M_PION_CHARGED; // the pion mass squared [MeV^2]
+    double gV      = NUCLEON_VECTOR_G/pow((1.0 + (qsq/(CUTV*CUTV))),2); // from Equation (4.14) of my thesis
+    double gA      = NUCLEON_AXIAL_G/pow((1.0 + (qsq/(CUTA*CUTA))),2); // " " " " " "
+    double gP      = (2*M_PROTON*gA)/(qsq + Mpionsq); // " " " " " "
+    double gM      = MAGMOM*gV; // " " " " " "
+    double ff      = (((gA*gP*qsq)/(3*M_PROTON)) - (pow(gP*qsq,2)/(12*Mprosq)) + ((gM*gM*qsq)/(12*Mprosq)))/(NUCLEON_AXIAL_G*NUCLEON_AXIAL_G); //Equation (4.13) of Charlie's thesis
+    return ff;
+  }
+
+
+  //Integrand for the intgeral with respect to dq
+  //Uses QAGIU for everything, works up to n,l,nr,lr = 30
+  //Haven't  been tested for higher values
+  double fq(double q, void *params)
+  { 
+    struct fqparams * p = (struct fqparams *)params;
+    int n                  = (p->n);
+    int l                  = (p->l);
+    int np                 = (p->np);
+    int lp                 = (p->lp);
+    double hw              = (p->hw);
+    std::string transition = (p->transition); 
+    int rho                = (p->rho);
+    double Eclosure        = (p->Eclosure);
+    std::string src        = (p->src); 
+    std::map<std::string, std::function<double(double)> > FFlist = {{"F",FermiFormFactor},{"GT",GTFormFactor},{"T",TensorFormFactor}}; // make a map from std::string to a function which takes in q and returns a form factor     double ff  = FFlist[transition](q);
+    double ff = FFlist[transition](q);
+    double RBME = rbme(n, l, np, lp, hw, rho, q, src);
+    return (q/(q + Eclosure))*ff*RBME;
+  }
+
+  // //Performs the integrals over q 
+  double integrate_dq(int n, int l, int np, int lp, double hw, std::string transition, int rho, double Eclosure, std::string src)
+  {
+    gsl_set_error_handler_off(); // set standard GSL error handling off, so I can do my own
+    int statusq; // this will hold the GSL error status
+    std::string errstrq="7828877-1: qagiu dq:"; // a unique GSL error string
+    size_t limitq = 10000; // the number of double precision intervals that can be held by the workspace below
+    gsl_integration_workspace * workspacer = gsl_integration_workspace_alloc(limitq); // GSL: "One workspace may be used multiple times...", "...workspaces should be allocated on a per-thread basis."
+    //Define param for the integrand function
+    struct fqparams fqparams = {n,l,np,lp,hw,transition,rho,Eclosure,src};
+    gsl_function Fq;
+    Fq.function = &fq; // fq is defined above
+    Fq.params = &fqparams;
+    double r1 = 0; // integrate over the range [r1,Inf)
+    double epsabsq = 1e-7; // absolute error tolerance for the integration
+    double epsrelq = 1e-4; // relative error tolerance for the adaptive integration
+    double val = 0; // qagiu integration result
+    double abserrq; // qagiu integration error estimate
+    double q = 0;
+    statusq = gsl_integration_qagiu(&Fq,r1,epsabsq,epsrelq,limitq,workspacer,&val,&abserrq); // perform the qagiu integration (over r)
+    #pragma omp critical
+    {
+      GSLerror(errstrq,statusq,limitq,epsabsq,epsrelq,abserrq,val,n,l,np,lp,q); // check if the GSL integration worked
+    }
+    gsl_integration_workspace_free(workspacer); // free the allocated memory for the integration workspace, since GSL is written in C
+    return val;
+  }
+
+
+  
+
+  // Hashtag for the IntList cache
+  uint64_t IntHash(uint64_t n, uint64_t l, uint64_t np, uint64_t lp)
+  {
+    return   (n  << 21)
+           + (l  << 15)
+           + (np <<  8)
+           +  lp;
+  }
+
+  // Inverse Hashtag for the IntList cache
+  void IntUnHash(uint64_t key, uint64_t &n, uint64_t &l, uint64_t &np, uint64_t &lp)
+  {
+    n  = (key >> 21) & 0x7FL;
+    l  = (key >> 15) & 0x3FL;
+    np = (key >>  8) & 0x7FL;
+    lp = (key      ) & 0xFFL;
+  }
+
+
+  std::unordered_map<uint64_t,double> PreCalculateM0nuIntegrals(int e2max, double hw, std::string transition, int rho, double Eclosure, std::string src)
+  {
+    IMSRGProfiler profiler;
+    double t_start_pci = omp_get_wtime(); // profiling (s)
+    //Map declaration to cache required integrals
+    std::unordered_map<uint64_t,double> IntList;
+    std::cout<<"calculating integrals wrt dq and dr..."<<std::endl;
+    int maxn = e2max/2;
+    int maxl = e2max;
+    int maxnp = e2max/2;
+    int maxlp = e2max;
+    std::vector<uint64_t> KEYS;
+    if (transition == "F" or transition == "GT")
+    {
+      for (int n=0; n<=maxn; n++)
+      {
+        for (int l=0; l<=maxl; l++)
+        {
+          int tempminnp = n; // NOTE: need not start from 'int np=0' since IntHash(n,l,np,l) = IntHash(np,l,n,l), by construction
+          for (int np=tempminnp; np<=maxnp; np++)
+          {
+            //long int key = IntHash(n,l,np);
+            uint64_t key = IntHash(n,l,np,l);
+            KEYS.push_back(key);
+            IntList[key] = 0.0; // "Make sure eveything's in there to avoid a rehash in the parallel loop" (RS)
+          }
+        }
+      }
+    }
+    else if (transition == "T")
+    {
+      for (int n=0; n<=maxn; n++)
+      {
+        for (int l=0; l<=maxl; l++)
+        {
+          int tempminnp = n; // NOTE: need not start from 'int np=0' since IntHash(n,l,np,lp) = IntHash(np,lp,n,l), by construction
+          for (int np=tempminnp; np<=maxnp; np++)
+          {
+            int tempminlp = (n==np ? l : 0); // NOTE: need not start from 'int lp=0' since IntHash(n,l,np,lp) = IntHash(np,lp,n,l), by construction
+            for (int lp=tempminlp; lp<=maxlp; lp++)
+            {
+              //long int key = IntHash(n,l,np,lp);
+              uint64_t key = IntHash(n,l,np,lp);
+              KEYS.push_back(key);
+              IntList[key] = 0.0; // "Make sure eveything's in there to avoid a rehash in the parallel loop" (RS)
+            }
+          }
+        }
+      }
+    }
+    std::cout << " In " << __func__ << "  " << transition << "   size of KEYS = " << KEYS.size() << std::endl;
+    #pragma omp parallel for schedule(dynamic, 1)// this works as long as the gsl_function handle is within this for-loop
+    for (size_t i=0; i<KEYS.size(); i++)
+    {
+      uint64_t key = KEYS[i];
+      uint64_t n,l,np,lp;
+      IntUnHash(key, n,l,np,lp);
+      IntList[key] = integrate_dq(n,l,np,lp,hw,transition,rho,Eclosure,src); // these have been ordered by the above loops such that we take the "lowest" value of decimalgen(n,l,np,lp,maxl,maxnp,maxlp), see GetIntegral(...)
+      //Uncomment if you want to verify integrals values
+      // std::stringstream intvalue;
+      // intvalue<<"n = "<<n<<", l = "<<l<<", np = "<<np<<", lp = "<<lp<<"; I = "<<IntList[key];
+      // std::cout<<intvalue.str()<<std::endl; 
+    }
+    std::cout<<"...done calculating the integrals"<<std::endl;
+    std::cout<<"IntList has "<<IntList.bucket_count()<<" buckets and a load factor "<<IntList.load_factor()
+      <<", estimated storage ~= "<<((IntList.bucket_count() + IntList.size())*(sizeof(size_t) + sizeof(void*)))/(1024.0*1024.0*1024.0)<<" GB"<<std::endl; // copied from (RS)
+    profiler.timer["PreCalculateM0nuIntegrals"] += omp_get_wtime() - t_start_pci; // profiling (r)
+    return IntList;
+  }
+
+
+  /// Get an integral from the IntList cache or calculate it (parallelization dependent)
+  double GetM0nuIntegral(int e2max, int n, int l, int np, int lp, double hw, std::string transition, int rho, double Eclosure, std::string src, std::unordered_map<uint64_t,double> IntList)
+  {
+//    int maxn = e2max/2;  // SRS commented out. not used.
+    int maxl = e2max;
+    int maxnp = e2max/2;
+    int maxlp = e2max;
+    int order1 = decimalgen(n,l,np,lp,maxl,maxnp,maxlp);
+    int order2 = decimalgen(np,lp,n,l,maxl,maxnp,maxlp); // notice I was careful here with the order of maxl,maxnp,maxlp to make proper comparison
+    if (order1 > order2)
+    {
+      std::swap(n,np); // using symmetry IntHash(n,l,np,lp) = IntHash(np,lp,n,l)
+      std::swap(l,lp); // " " " " "
+    }
+    //long int key = IntHash(n,l,np,lp); // if I ever get that version working...
+    uint64_t key = IntHash(n,l,np,lp);
+    auto it = IntList.find(key);
+    if (it != IntList.end()) // return what we've found
+    {
+      return it -> second;
+    }
+    else // if we didn't find it, calculate it and add it to the list!
+    {
+      double integral;
+      integral = integrate_dq(n, l, np, lp, hw, transition, rho, Eclosure, src);
+      if (omp_get_num_threads() >= 2)
+      {
+        std::cout << "DANGER!!!!!!!  Updating IntList inside a parellel loop breaks thread safety!" << std::endl;
+        std::cout << "   I shouldn't be here in GetIntegral(" << n << ", " << l << ", " << np << ", " << lp << "):   key = " << key << "   integral = " << integral << std::endl;
+//        printf("DANGER!!!!!!!  Updating IntList inside a parellel loop breaks thread safety!\n");
+//        printf("   I shouldn't be here in GetIntegral(%d, %d, %d, %d):   key =%llx   integral=%f\n",n,l,np,lp,key,integral);
+        exit(EXIT_FAILURE);
+      }
+      IntList[key] = integral;
+      return integral;
+    }
+  }
+
+  /// Hashtag for the T6jList cache
+  uint64_t T6jHash(uint64_t l1, uint64_t L1, uint64_t R, uint64_t L2, uint64_t l2)
+  {
+    return   (l1 << 40)
+           + (L1 << 30)
+           + (R  << 20)
+           + (L2 << 10)
+           +  l2;
+  }
+
+
+  /// Inverse Hashtag for the T6jList cache
+  void T6jUnHash(uint64_t key, uint64_t &l1, uint64_t &L1, uint64_t &R, uint64_t &L2, uint64_t &l2)
+  {
+    l1 = (key >> 40) & 0x3FFL;
+    L1 = (key >> 30) & 0x3FFL;
+    R  = (key >> 20) & 0x3FFL;
+    L2 = (key >> 10) & 0x3FFL;
+    l2 = (key      ) & 0x3FFL;
+  }
+
+
+  /// NDBD member function which caches the relevant 6j-symbols for the Tensor M0nu component
+  /// { l1 L1 R }
+  /// { L2 l2 2 } NOTE: the "2" in the bottom-right entry
+  std::unordered_map<uint64_t,double> PreCalculateM0nuT6j(int e2max)
+  {
+    IMSRGProfiler profiler;
+    double t_start_pctsj = omp_get_wtime(); // profiling (s)
+    std::unordered_map<uint64_t,double> T6jList;
+    std::cout<<"calculating 6j-symbols for the Tensor component..."<<std::endl;
+    std::vector<uint64_t> KEYS;
+    for (int l1=0; l1<=e2max; l1++)
+    {
+      for (int l2=0; l2<=e2max; l2++)
+      {
+        for (int L1=0; L1<=e2max; L1++)
+        {
+          for (int L2=0; L2<=e2max; L2++)
+          {
+            for (int R=0; R<=e2max; R++)
+            {
+              uint64_t key = T6jHash(l1,L1,R,L2,l2);
+              KEYS.push_back(key);
+              T6jList[key] = 0.0; // "Make sure eveything's in there to avoid a rehash in the parallel loop" (RS)
+            }
+          }
+        }
+      }
+    }
+    #pragma omp parallel for schedule(dynamic,1)
+    for (size_t i=0; i<KEYS.size(); i++)
+    {
+      uint64_t l1,l2,L1,L2,R;
+      uint64_t key = KEYS[i];
+      T6jUnHash(key,l1,L1,R,L2,l2);
+      T6jList[key] = AngMom::SixJ(l1,L1,R,L2,l2,2);
+    }
+    std::cout<<"...done calculating the 6j-symbols"<<std::endl;
+    std::cout<<"T6jList has "<<T6jList.bucket_count()<<" buckets and a load factor "<<T6jList.load_factor()
+      <<", estimated storage ~= "<<((T6jList.bucket_count() + T6jList.size())*(sizeof(size_t) + sizeof(void*)))/(1024.0*1024.0*1024.0)<<" GB"<<std::endl; // copied from (RS)
+    profiler.timer["PreCalcT6j"] += omp_get_wtime() - t_start_pctsj; // profiling (r)
+    return T6jList;
+  }
+
+
+  /// Get a 6j from the T6jList cache or calculate it (parallelization dependent)
+  /// { l1 L1 R }
+  /// { L2 l2 2 } NOTE: the "2" in the bottom-right entry
+  double GetM0nuT6j(int l1, int L1, int R, int L2, int l2, std::unordered_map<uint64_t,double> T6jList)
+  {
+    uint64_t key = T6jHash(l1,L1,R,L2,l2);
+    auto it = T6jList.find(key);
+    if (it != T6jList.end()) // return what we've found
+    {
+      return it -> second;
+    }
+    else // if we didn't find it, calculate it and add it to the list!
+    {
+      double sixj = AngMom::SixJ(l1,L1,R,L2,l2,2);
+      if (omp_get_num_threads() >= 2)
+      {
+        std::cout << "DANGER!!!!!!!  Updating T6jList inside a parellel loop breaks thread safety!" << std::endl;
+        std::cout << "   I shouldn't be here in GetT6j(" << l1 << ", " << L1 << ", " << R << ", " << L2 << ", " << l2 << "):   key = " << key << "   sixj = " << sixj << std::endl;
+//        printf("DANGER!!!!!!!  Updating T6jList inside a parellel loop breaks thread safety!\n");
+//        printf("   I shouldn't be here in GetT6j(%d, %d, %d, %d, %d):   key =%lx   sixj=%f\n",l1,L1,R,L2,l2,key,sixj);
+        exit(EXIT_FAILURE);
+      }
+      T6jList[key] = sixj;
+      return sixj;
+    }
+  }
+
+
+
+  Operator GamowTeller(ModelSpace& modelspace, double Eclosure, std::string src)
+  {
+    bool reduced = true;
+    double t_start, t_start_tbme, t_start_omp; // profiling (v)
+    t_start = omp_get_wtime(); // profiling (s)
+    std::string transition = "GT";
+    int rho = 0;
+    double hw = modelspace.GetHbarOmega(); // oscillator basis frequency [MeV]
+    int e2max = modelspace.GetE2max(); // 2*emax
+    Operator M0nuGT_TBME(modelspace,0,2,0,2); // NOTE: from the constructor -- Operator::Operator(ModelSpace& ms, int Jrank, int Trank, int p, int part_rank)
+    std::cout<<"     reduced            =  "<<reduced<<std::endl;
+    M0nuGT_TBME.SetHermitian(); // it should be Hermitian
+    int Anuc = modelspace.GetTargetMass(); // the mass number for the desired nucleus
+    const double Rnuc = (R0/HBARC)*pow(Anuc,1.0/3.0); // the nuclear radius [MeV^-1]
+    const double prefact = 2*(2*Rnuc)/PI; // factor in-front of M0nu TBME, extra global 2 for nutbar (as confirmed by benchmarking with Ca48 NMEs) [MeV^-1]
+    modelspace.PreCalculateMoshinsky(); // pre-calculate the needed Moshinsky brackets, for efficiency
+    std::unordered_map<uint64_t,double> IntList = PreCalculateM0nuIntegrals(e2max,hw,transition, rho, Eclosure, src); // pre-calculate the needed integrals over dq and dr, for efficiency
+    M0nuGT_TBME.profiler.timer["M0nuGT_1_sur"] += omp_get_wtime() - t_start; // profiling (r)
+    // create the TBMEs of M0nu
+    // auto loops over the TBME channels and such
+    std::cout<<"calculating M0nu TBMEs..."<<std::endl;
+    t_start_tbme = omp_get_wtime(); // profiling (s)
+    for (auto& itmat : M0nuGT_TBME.TwoBody.MatEl)
+    {
+      int chbra = itmat.first[0]; // grab the channel count from auto
+      int chket = itmat.first[1]; // " " " " " "
+      TwoBodyChannel& tbc_bra = modelspace.GetTwoBodyChannel(chbra); // grab the two-body channel
+      TwoBodyChannel& tbc_ket = modelspace.GetTwoBodyChannel(chket); // " " " " "
+      int nbras = tbc_bra.GetNumberKets(); // get the number of bras
+      int nkets = tbc_ket.GetNumberKets(); // get the number of kets
+      double J = tbc_bra.J; // NOTE: by construction, J := J_ab == J_cd := J'
+      double Jhat; // set below based on "reduced" variable
+      if (reduced == false)
+      {
+        Jhat = 1.0; // for non-reduced elements, to compare with JE
+      }
+      else //if (reduced == "R")
+      {
+        Jhat = sqrt(2*J + 1); // the hat factor of J
+      }
+      t_start_omp = omp_get_wtime(); // profiling (s)
+//      #pragma omp parallel for schedule(dynamic,100) // need to do: PreCalculateMoshinsky() and PreCalcIntegrals() [above] and then "#pragma omp critical" [below]
+      #pragma omp parallel for schedule(dynamic,1) // need to do: PreCalculateMoshinsky() and PreCalcIntegrals() [above] and then "#pragma omp critical" [below]
+      for (int ibra=0; ibra<nbras; ibra++)
+      {
+        Ket& bra = tbc_bra.GetKet(ibra); // get the final state = <ab|
+        int ia = bra.p; // get the integer label a
+        int ib = bra.q; // get the integer label b
+        Orbit& oa = modelspace.GetOrbit(ia); // get the <a| state orbit
+        Orbit& ob = modelspace.GetOrbit(ib); // get the <b| state orbit
+        for (int iket=0; iket<nkets; iket++)
+        {
+          Ket& ket = tbc_ket.GetKet(iket); // get the initial state = |cd>
+          int ic = ket.p; // get the integer label c
+          int id = ket.q; // get the integer label d
+          Orbit& oc = modelspace.GetOrbit(ic); // get the |c> state orbit
+          Orbit& od = modelspace.GetOrbit(id); // get the |d> state orbit
+          int na = oa.n; // this is just...
+          int nb = ob.n;
+          int nc = oc.n;
+          int nd = od.n;
+          int la = oa.l;
+          int lb = ob.l;
+          int lc = oc.l;
+          int ld = od.l;
+          double ja = oa.j2/2.0;
+          double jb = ob.j2/2.0;
+          double jc = oc.j2/2.0;
+          double jd = od.j2/2.0; // ...for convenience
+          double sumLS = 0; // for the Bessel's Matrix Elemets (BMEs)
+          double sumLSas = 0; // (anti-symmetric part)
+          for (int S=0; S<=1; S++) // sum over total spin...
+          {
+            int Seval;
+            Seval = 2*S*(S + 1) - 3;
+            for (int L = abs(la-lb); L <= la+lb; L++) // ...and sum over angular momentum coupled to l_a and l_b
+            {
+              if ((abs(lc-ld) <= L) and (L <= lc+ld))
+              {
+                double bulk = 0; // this is a bulk product which will only be worth calculating if the Moshinsky brackets are non-zero
+                double bulkas = 0; // (anti-symmetric part)
+                double sumMT = 0; // for the Moshinsky transformation
+                double sumMTas = 0; // (anti-symmetric part)
+                int eps_ab = 2*na + la + 2*nb + lb; // for conservation of energy in the Moshinsky brackets
+                int tempmaxnr = floor((eps_ab - L)/2.0); // just for the limits below
+                for (int nr = 0; nr <= tempmaxnr; nr++)
+                {
+                  int eps_cd = 2*nc + lc + 2*nd + ld; // for conservation of energy in the Moshinsky brackets
+                  double npr = ((eps_cd - eps_ab)/2.0) + nr; // via Equation (4.73) of my thesis
+                  double intnpr = npr - floor(npr); // to check if npr is an integer
+                  if ((npr >= 0) and (intnpr == 0))
+                  {
+                    int tempmaxNcom = tempmaxnr - nr; // just for the limits below
+                    for (int Ncom = 0; Ncom <= tempmaxNcom; Ncom++)
+                    {
+                      int tempminlr = ceil((eps_ab - L)/2.0) - (nr + Ncom); // just for the limits below
+                      int tempmaxlr = floor((eps_ab + L)/2.0) - (nr + Ncom); // " " " " "
+                      for (int lr = tempminlr; lr <= tempmaxlr; lr++)
+                      {
+                        int Lam = eps_ab - 2*(nr + Ncom) - lr; // via Equation (4.73) of my thesis
+                        double tempLS = (2*L + 1)*(2*S + 1); // just for efficiency, only used in the three lines below
+                        double normab = sqrt(tempLS*(2*ja + 1)*(2*jb + 1)); // normalization factor for the 9j-symbol out front
+                        double nNJab = normab*modelspace.GetNineJ(la,lb,L,0.5,0.5,S,ja,jb,J); // the normalized 9j-symbol out front
+                        double normcd = sqrt(tempLS*(2*jc + 1)*(2*jd + 1)); // normalization factor for the second 9j-symbol
+                        double nNJcd = normcd*modelspace.GetNineJ(lc,ld,L,0.5,0.5,S,jc,jd,J); // the second normalized 9j-symbol
+                        double nNJdc = normcd*modelspace.GetNineJ(ld,lc,L,0.5,0.5,S,jd,jc,J); // (anti-symmetric part)
+                        bulk = Seval*nNJab*nNJcd; // bulk product of the above
+                        bulkas = Seval*nNJab*nNJdc; // (anti-symmetric part)
+                        double Df,Di,asDi,integral; // these *will* be set below
+                        #pragma omp critical // SRS WHY SHOULD THIS BE CRITICAL? IT *SHOULD* BE THREAD SAFE...
+                        {
+                          Df = modelspace.GetMoshinsky(Ncom,Lam,nr,lr,na,la,nb,lb,L); // Ragnar has -- double mosh_ab = modelspace.GetMoshinsky(N_ab,Lam_ab,n_ab,lam_ab,na,la,nb,lb,Lab);
+                          Di = modelspace.GetMoshinsky(Ncom,Lam,npr,lr,nc,lc,nd,ld,L); // " " " "
+                          asDi = modelspace.GetMoshinsky(Ncom,Lam,npr,lr,nd,ld,nc,lc,L); // (anti-symmetric part)
+                          integral = GetM0nuIntegral(e2max,nr,lr,npr,lr,hw,transition,rho,Eclosure,src,IntList); // grab the pre-calculated integral wrt dq and dr from the IntList of the modelspace class
+                        }
+                        sumMT += Df*Di*integral; // perform the Moshinsky transformation
+                        sumMTas += Df*asDi*integral; // (anti-symmetric part)
+                      } // end of for-loop over: lr
+                    } // end of for-loop over: Ncom
+                  } // end of if: npr \in \Nat_0
+                } // end of for-loop over: nr
+                sumLS += bulk*sumMT; // perform the LS-coupling sum
+                sumLSas += bulkas*sumMTas; // (anti-symmetric part)
+              } // end of if: |lc - ld| <= L <= lc + ld
+            } // end of for-loop over: L
+          } // end of for-loop over: S
+          double Mtbme = asNorm(ia,ib)*asNorm(ic,id)*prefact*Jhat*(sumLS - modelspace.phase(jc + jd - J)*sumLSas); // compute the final matrix element, anti-symmetrize
+          M0nuGT_TBME.TwoBody.SetTBME(chbra,chket,ibra,iket,Mtbme); // set the two-body matrix elements (TBME) to Mtbme
+        } // end of for-loop over: iket
+      } // end of for-loop over: ibra
+      M0nuGT_TBME.profiler.timer["M0nuGT_3_omp"] += omp_get_wtime() - t_start_omp; // profiling (r)
+    } // end of for-loop over: auto
+    std::cout<<"...done calculating M0nu TBMEs"<<std::endl;
+    M0nuGT_TBME.profiler.timer["M0nuGT_2_tbme"] += omp_get_wtime() - t_start_tbme; // profiling (r)
+    M0nuGT_TBME.profiler.timer["M0nuGT_Op"] += omp_get_wtime() - t_start; // profiling (r)
+    return M0nuGT_TBME;
+  }
+
+  Operator Fermi(ModelSpace& modelspace, double Eclosure, std::string src)
+  {
+    bool reduced = true;
+    double t_start, t_start_tbme, t_start_omp; // profiling (v)
+    t_start = omp_get_wtime(); // profiling (s)
+    std::string transition = "F";
+    int rho = 0;
+    double hw = modelspace.GetHbarOmega(); // oscillator basis frequency [MeV]
+    int e2max = modelspace.GetE2max(); // 2*emax
+    Operator M0nuF_TBME(modelspace,0,2,0,2); // NOTE: from the constructor -- Operator::Operator(ModelSpace& ms, int Jrank, int Trank, int p, int part_rank)
+    std::cout<<"     reduced            =  "<<reduced<<std::endl;
+    M0nuF_TBME.SetHermitian(); // it should be Hermitian
+    int Anuc = modelspace.GetTargetMass(); // the mass number for the desired nucleus
+    const double Rnuc = (R0/HBARC)*pow(Anuc,1.0/3.0); // the nuclear radius [MeV^-1]
+    const double prefact = 2*(2*Rnuc)/PI; // factor in-front of M0nu TBME, extra global 2 for nutbar (as confirmed by benchmarking with Ca48 NMEs) [MeV^-1]
+    modelspace.PreCalculateMoshinsky(); // pre-calculate the needed Moshinsky brackets, for efficiency
+    std::unordered_map<uint64_t,double> IntList = PreCalculateM0nuIntegrals(e2max,hw,transition, rho, Eclosure, src); // pre-calculate the needed integrals over dq and dr, for efficiency
+    M0nuF_TBME.profiler.timer["M0nuF_1_sur"] += omp_get_wtime() - t_start; // profiling (r)
+    // create the TBMEs of M0nu
+    // auto loops over the TBME channels and such
+    std::cout<<"calculating M0nu TBMEs..."<<std::endl;
+    t_start_tbme = omp_get_wtime(); // profiling (s)
+    for (auto& itmat : M0nuF_TBME.TwoBody.MatEl)
+    {
+      int chbra = itmat.first[0]; // grab the channel count from auto
+      int chket = itmat.first[1]; // " " " " " "
+      std::cout<<chbra<<" "<<chket<<std::endl;
+      TwoBodyChannel& tbc_bra = modelspace.GetTwoBodyChannel(chbra); // grab the two-body channel
+      TwoBodyChannel& tbc_ket = modelspace.GetTwoBodyChannel(chket); // " " " " "
+      int nbras = tbc_bra.GetNumberKets(); // get the number of bras
+      int nkets = tbc_ket.GetNumberKets(); // get the number of kets
+      double J = tbc_bra.J; // NOTE: by construction, J := J_ab == J_cd := J'
+      double Jhat; // set below based on "reduced" variable
+      if (reduced == false)
+      {
+        Jhat = 1.0; // for non-reduced elements, to compare with JE
+      }
+      else //if (reduced == "R")
+      {
+        Jhat = sqrt(2*J + 1); // the hat factor of J
+      }
+      t_start_omp = omp_get_wtime(); // profiling (s)
+//      #pragma omp parallel for schedule(dynamic,100) // need to do: PreCalculateMoshinsky() and PreCalcIntegrals() [above] and then "#pragma omp critical" [below]
+      #pragma omp parallel for schedule(dynamic,1) // need to do: PreCalculateMoshinsky() and PreCalcIntegrals() [above] and then "#pragma omp critical" [below]
+      for (int ibra=0; ibra<nbras; ibra++)
+      {
+        Ket& bra = tbc_bra.GetKet(ibra); // get the final state = <ab|
+        int ia = bra.p; // get the integer label a
+        int ib = bra.q; // get the integer label b
+        Orbit& oa = modelspace.GetOrbit(ia); // get the <a| state orbit
+        Orbit& ob = modelspace.GetOrbit(ib); // get the <b| state prbit
+        for (int iket=0; iket<nkets; iket++)
+        {
+          Ket& ket = tbc_ket.GetKet(iket); // get the initial state = |cd>
+          int ic = ket.p; // get the integer label c
+          int id = ket.q; // get the integer label d
+          Orbit& oc = modelspace.GetOrbit(ic); // get the |c> state orbit
+          Orbit& od = modelspace.GetOrbit(id); // get the |d> state orbit
+          int na = oa.n; // this is just...
+          int nb = ob.n;
+          int nc = oc.n;
+          int nd = od.n;
+          int la = oa.l;
+          int lb = ob.l;
+          int lc = oc.l;
+          int ld = od.l;
+          double ja = oa.j2/2.0;
+          double jb = ob.j2/2.0;
+          double jc = oc.j2/2.0;
+          double jd = od.j2/2.0; // ...for convenience
+          double sumLS = 0; // for the Bessel's Matrix Elemets (BMEs)
+          double sumLSas = 0; // (anti-symmetric part)
+          for (int S=0; S<=1; S++) // sum over total spin...
+          {
+            for (int L = abs(la-lb); L <= la+lb; L++) // ...and sum over angular momentum coupled to l_a and l_b
+            {
+              if ((abs(lc-ld) <= L) and (L <= lc+ld))
+              {
+                double bulk = 0; // this is a bulk product which will only be worth calculating if the Moshinsky brackets are non-zero
+                double bulkas = 0; // (anti-symmetric part)
+                double sumMT = 0; // for the Moshinsky transformation
+                double sumMTas = 0; // (anti-symmetric part)
+                int eps_ab = 2*na + la + 2*nb + lb; // for conservation of energy in the Moshinsky brackets
+                int tempmaxnr = floor((eps_ab - L)/2.0); // just for the limits below
+                for (int nr = 0; nr <= tempmaxnr; nr++)
+                {
+                  int eps_cd = 2*nc + lc + 2*nd + ld; // for conservation of energy in the Moshinsky brackets
+                  double npr = ((eps_cd - eps_ab)/2.0) + nr; // via Equation (4.73) of my thesis
+                  double intnpr = npr - floor(npr); // to check if npr is an integer
+                  if ((npr >= 0) and (intnpr == 0))
+                  {
+                    int tempmaxNcom = tempmaxnr - nr; // just for the limits below
+                    for (int Ncom = 0; Ncom <= tempmaxNcom; Ncom++)
+                    {
+                      int tempminlr = ceil((eps_ab - L)/2.0) - (nr + Ncom); // just for the limits below
+                      int tempmaxlr = floor((eps_ab + L)/2.0) - (nr + Ncom); // " " " " "
+                      for (int lr = tempminlr; lr <= tempmaxlr; lr++)
+                      {
+                        int Lam = eps_ab - 2*(nr + Ncom) - lr; // via Equation (4.73) of my thesis
+                        double tempLS = (2*L + 1)*(2*S + 1); // just for efficiency, only used in the three lines below
+                        double normab = sqrt(tempLS*(2*ja + 1)*(2*jb + 1)); // normalization factor for the 9j-symbol out front
+                        double nNJab = normab*modelspace.GetNineJ(la,lb,L,0.5,0.5,S,ja,jb,J); // the normalized 9j-symbol out front
+                        double normcd = sqrt(tempLS*(2*jc + 1)*(2*jd + 1)); // normalization factor for the second 9j-symbol
+                        double nNJcd = normcd*modelspace.GetNineJ(lc,ld,L,0.5,0.5,S,jc,jd,J); // the second normalized 9j-symbol
+                        double nNJdc = normcd*modelspace.GetNineJ(ld,lc,L,0.5,0.5,S,jd,jc,J); // (anti-symmetric part)
+                        bulk = nNJab*nNJcd; // bulk product of the above
+                        bulkas = nNJab*nNJdc; // (anti-symmetric part)
+                        double Df,Di,asDi,integral; // these *will* be set below
+                        #pragma omp critical
+                        {
+                          Df = modelspace.GetMoshinsky(Ncom,Lam,nr,lr,na,la,nb,lb,L); // Ragnar has -- double mosh_ab = modelspace.GetMoshinsky(N_ab,Lam_ab,n_ab,lam_ab,na,la,nb,lb,Lab);
+                          Di = modelspace.GetMoshinsky(Ncom,Lam,npr,lr,nc,lc,nd,ld,L); // " " " "
+                          asDi = modelspace.GetMoshinsky(Ncom,Lam,npr,lr,nd,ld,nc,lc,L); // (anti-symmetric part)
+                          integral = GetM0nuIntegral(e2max,nr,lr,npr,lr,hw,transition,rho,Eclosure,src,IntList); // grab the pre-calculated integral wrt dq and dr from the IntList of the modelspace class
+                        }
+                        sumMT += Df*Di*integral; // perform the Moshinsky transformation
+                        sumMTas += Df*asDi*integral; // (anti-symmetric part)
+                      } // end of for-loop over: lr
+                    } // end of for-loop over: Ncom
+                  } // end of if: npr \in \Nat_0
+                } // end of for-loop over: nr
+                sumLS += bulk*sumMT; // perform the LS-coupling sum
+                sumLSas += bulkas*sumMTas; // (anti-symmetric part)
+              } // end of if: |lc - ld| <= L <= lc + ld
+            } // end of for-loop over: L
+          } // end of for-loop over: S
+          double Mtbme = asNorm(ia,ib)*asNorm(ic,id)*prefact*Jhat*(sumLS - modelspace.phase(jc + jd - J)*sumLSas); // compute the final matrix element, anti-symmetrize
+          M0nuF_TBME.TwoBody.SetTBME(chbra,chket,ibra,iket,Mtbme); // set the two-body matrix elements (TBME) to Mtbme
+        } // end of for-loop over: iket
+      } // end of for-loop over: ibra
+      M0nuF_TBME.profiler.timer["M0nuF_3_omp"] += omp_get_wtime() - t_start_omp; // profiling (r)
+    } // end of for-loop over: auto
+    std::cout<<"...done calculating M0nu TBMEs"<<std::endl;
+    M0nuF_TBME.profiler.timer["M0nuF_2_tbme"] += omp_get_wtime() - t_start_tbme; // profiling (r)
+    M0nuF_TBME.profiler.timer["M0nuF_adpt_Op"] += omp_get_wtime() - t_start; // profiling (r)
+    return M0nuF_TBME;
+  }
+
+
+  Operator Tensor(ModelSpace& modelspace, double Eclosure, std::string src)
+  {
+    bool reduced = true;
+    double t_start, t_start_tbme, t_start_omp; // profiling (v)
+    t_start = omp_get_wtime(); // profiling (s)
+    std::string transition = "T";
+    int rho = 2;
+    // run through the initial set-up routine
+    double hw = modelspace.GetHbarOmega(); // oscillator basis frequency [MeV]
+    int e2max = modelspace.GetE2max(); // 2*emax
+    Operator M0nuT_TBME(modelspace,0,2,0,2); // NOTE: from the constructor -- Operator::Operator(ModelSpace& ms, int Jrank, int Trank, int p, int part_rank)
+    std::cout<<"     reduced            =  "<<reduced<<std::endl;
+    M0nuT_TBME.SetHermitian(); // it should be Hermitian
+    int Anuc = modelspace.GetTargetMass(); // the mass number for the desired nucleus
+    const double Rnuc = (R0/HBARC)*pow(Anuc,1.0/3.0); // the nuclear radius [MeV^-1]
+    const double prefact = 2*(2*Rnuc)/PI; // factor in-front of M0nu TBME, extra global 2 for nutbar (as confirmed by benchmarking with Ca48 NMEs) [MeV^-1]
+    modelspace.PreCalculateMoshinsky(); // pre-calculate the needed Moshinsky brackets, for efficiency
+    std::unordered_map<uint64_t,double> T6jList = PreCalculateM0nuT6j(e2max); // pre-calculate the expected 6j-symbols, for efficiency
+    std::unordered_map<uint64_t,double> IntList = PreCalculateM0nuIntegrals(e2max,hw,transition, rho, Eclosure, src); // pre-calculate the needed integrals over dq and dr, for efficiency 
+    // now we'll precalculate and cache the factors involving the Clebsch-Goradan coefficients, see "factSH" within the TMT
+    double SQRT6 = sqrt(6);
+    double listSH[PairFN(e2max,e2max)];
+    int maxlr = e2max;
+    int maxlpr = e2max;
+    #pragma omp parallel for schedule(dynamic,1)
+    for (int lr=0; lr<=maxlr; lr++)
+    {
+      for (int lpr=0; lpr<=maxlpr; lpr++)
+      {
+        int tempPF = PairFN(lr,lpr);
+        if ((abs(lr-2) <= lpr and lpr <= lr+2) and ((lr+lpr)%2 == 0))
+        {
+          listSH[tempPF] = SQRT6*AngMom::CG(lr,0,2,0,lpr,0)*sqrt(2*lr + 1);
+        }
+        else
+        {
+          listSH[tempPF] = 0; // just to be safe, amirite!?
+        }
+      }
+    }
+    M0nuT_TBME.profiler.timer["M0nuT_1_sur"] += omp_get_wtime() - t_start; // profiling (r)
+    // create the TBMEs of M0nu
+    // auto loops over the TBME channels and such
+    std::cout<<"calculating M0nu TBMEs..."<<std::endl;
+    t_start_tbme = omp_get_wtime(); // profiling (s)
+    double Seval = 2.0*sqrt(5.0); // eigenvalue of S for "T", where the only non-zero one is for Sf = Si = 1
+//    for (auto& itmat : M0nuT_TBME.TwoBody.MatEl)
+    std::vector<int> chbralist,chketlist;
+    for (auto& itmat : M0nuT_TBME.TwoBody.MatEl)
+    {
+      chbralist.push_back( itmat.first[0] );
+      chketlist.push_back( itmat.first[1] );
+    }
+    size_t nch = chbralist.size();
+     #pragma omp parallel for schedule(dynamic,1) 
+    for (size_t ich=0; ich<nch; ich++)
+    {
+      int chbra = chbralist[ich];
+      int chket = chketlist[ich];
+//      int chbra = itmat.first[0]; // grab the channel count from auto
+//      int chket = itmat.first[1]; // " " " " " "
+      TwoBodyChannel& tbc_bra = modelspace.GetTwoBodyChannel(chbra); // grab the two-body channel
+      TwoBodyChannel& tbc_ket = modelspace.GetTwoBodyChannel(chket); // " " " " "
+      int nbras = tbc_bra.GetNumberKets(); // get the number of bras
+      int nkets = tbc_ket.GetNumberKets(); // get the number of kets
+      int J = tbc_bra.J; // NOTE: by construction, J := J_ab == J_cd := J'
+      double Jhat =  reduced  ?  sqrt(2*J+1.0)  :  1.0;
+
+      t_start_omp = omp_get_wtime(); // profiling (s)
+//      #pragma omp parallel for schedule(dynamic,1) // need to do: PreCalculateMoshinsky(), PreCalcT6j, and PreCalcIntegrals() [above] and then "#pragma omp critical" [below]
+      for (int ibra=0; ibra<nbras; ibra++)
+      {
+        Ket& bra = tbc_bra.GetKet(ibra); // get the final state = <ab|
+        int ia = bra.p; // get the integer label a
+        int ib = bra.q; // get the integer label b
+        Orbit& oa = modelspace.GetOrbit(ia); // get the <a| state orbit
+        Orbit& ob = modelspace.GetOrbit(ib); // get the <b| state prbit
+        for (int iket=0; iket<nkets; iket++)
+        {
+          Ket& ket = tbc_ket.GetKet(iket); // get the initial state = |cd>
+          int ic = ket.p; // get the integer label c
+          int id = ket.q; // get the integer label d
+          Orbit& oc = modelspace.GetOrbit(ic); // get the |c> state orbit
+          Orbit& od = modelspace.GetOrbit(id); // get the |d> state orbit
+          int na = oa.n; // this is just...
+          int nb = ob.n;
+          int nc = oc.n;
+          int nd = od.n;
+          int la = oa.l;
+          int lb = ob.l;
+          int lc = oc.l;
+          int ld = od.l;
+          double ja = oa.j2/2.0;
+          double jb = ob.j2/2.0;
+          double jc = oc.j2/2.0;
+          double jd = od.j2/2.0; // ...for convenience
+
+          int eps_ab = 2*na + la + 2*nb + lb; // for conservation of energy in the Moshinsky brackets
+          int eps_cd = 2*nc + lc + 2*nd + ld; // for conservation of energy in the Moshinsky brackets
+          double sumLS = 0; // for the Bessel's Matrix Elemets (BMEs)
+          double sumLSas = 0; // (anti-symmetric part)
+          int Lf_min = std::max( std::abs(la-lb), std::abs(J-1));
+          int Lf_max = std::min( la+lb, J+1);
+          for (int Lf = Lf_min; Lf<=Lf_max; Lf++) // sum over angular momentum coupled to l_a and l_b
+          {
+            double tempLf = (2*Lf + 1); // just for the lines below
+            double normab = sqrt(tempLf*3*(2*ja + 1)*(2*jb + 1)); // normalization factor for the 9j-symbol out front
+            double nNJab = normab*modelspace.GetNineJ(la,lb,Lf,0.5,0.5,1,ja,jb,J); // the normalized 9j-symbol out front
+            int Li_min = std::max( std::abs(lc-ld), std::max( std::abs(J-1),std::abs(Lf-2)));
+            int Li_max = std::min( lc+ld, std::min( J+1, Lf+2) );
+            for (int Li = Li_min; Li <= Li_max; Li++) // sum over angular momentum coupled to l_c and l_d
+            {
+              double tempLi = (2*Li + 1); // " " " " "
+              double factLS = modelspace.phase(1 + J + Li)*GetM0nuT6j(Lf,1,J,1,Li,T6jList); // factor from transforming from jj-coupling to ls-coupling
+              double normcd = sqrt(tempLi*3*(2*jc + 1)*(2*jd + 1)); // normalization factor for the second 9j-symbol
+              double nNJcd = normcd*modelspace.GetNineJ(lc,ld,Li,0.5,0.5,1,jc,jd,J); // the second normalized 9j-symbol
+              double nNJdc = normcd*modelspace.GetNineJ(ld,lc,Li,0.5,0.5,1,jd,jc,J); // (anti-symmetric part)
+              double tempMT = sqrt(tempLf*tempLi); // the hat factor of Lf and Li
+              double bulk = Seval*factLS*nNJab*nNJcd*tempMT; // bulk product of the above
+              double bulkas = Seval*factLS*nNJab*nNJdc*tempMT; // (anti-symmetric part)
+              if ( std::abs(bulk)<1e-9  and std::abs(bulkas)<1e-9) continue;
+
+              double sumMT = 0; // for the Moshinsky transformation
+              double sumMTas = 0; // (anti-symmetric part)
+
+              for ( int lr=0; lr<=eps_ab; lr++)
+              {
+                for (int nr=0; nr<=(eps_ab-lr)/2; nr++ )
+                {
+                  int Lam_min = std::abs( Lf-lr ); // triangle condition
+                  Lam_min += ( eps_ab+Lam_min+lr )%2; //  Moshinsky trans. conserves parity
+                  int Lam_max = std::min( Lf+lr, std::min( eps_ab-lr-2*nr, eps_cd) ); // triangle condition and energy conservation
+                  for (int Lam=Lam_min; Lam<=Lam_max; Lam+=2)
+                  {
+                    int Ncom = (eps_ab - 2*nr - lr - Lam)/2;
+                    double Df = modelspace.GetMoshinsky(Ncom,Lam,nr,lr,na,la,nb,lb,Lf); // Ragnar has -- double mosh_ab = modelspace.GetMoshinsky(N_ab,Lam_ab,n_ab,lam_ab,na,la,nb,lb,Lab);
+                    
+                    for (int npr=0; npr<=(eps_cd-2*Ncom-Lam); npr++)
+                    {
+                        int lpr = eps_cd-2*Ncom-Lam-2*npr;
+                        if (  (lpr+lr)%2 !=0 ) continue;
+                        if ( (std::abs(Lam-lpr)>Li)  or ( (Lam+lpr)<Li) ) continue;
+
+                        double Di = modelspace.GetMoshinsky(Ncom,Lam,npr,lpr,nc,lc,nd,ld,Li); // " " " "
+                        double asDi = modelspace.GetMoshinsky(Ncom,Lam,npr,lpr,nd,ld,nc,lc,Li); // (anti-symmetric part)
+                        double integral = GetM0nuIntegral(e2max,nr,lr,npr,lpr,hw,transition,rho,Eclosure,src,IntList); // grab the pre-calculated integral wrt dq and dr from the IntList of the NDBD class
+                        double factMT = modelspace.phase(Li + lr + Lam)*GetM0nuT6j(Lf,lr,Lam,lpr,Li,T6jList); // factor from TMT
+//                        
+                        double tempfactMTSH = factMT*listSH[PairFN(lr,lpr)]; // just for the lines below, listSH from the spherical harmonics of order 2
+                        sumMT += Df*Di*tempfactMTSH*integral; // perform the Moshinsky transformation
+                        sumMTas += Df*asDi*tempfactMTSH*integral; // (anti-symmetric part)
+
+                      } // end of for-loop over: lpr
+                    } // end of for-loop over: Ncom
+                  } // end of for-loop over: nr
+                } // end of for-loop over: lr
+
+              sumLS += bulk*sumMT; // perform the LS-coupling sum
+              sumLSas += bulkas*sumMTas; // (anti-symmetric part)
+            } // end of for-loop over: Li
+          } // end of for-loop over: Lf
+          double Mtbme = asNorm(ia,ib)*asNorm(ic,id)*prefact*Jhat*(sumLS - modelspace.phase(jc + jd - J)*sumLSas); // compute the final matrix element, anti-symmetrize
+          // std::cout<<"na ="<<na<<"  nb = "<<nb<<"  nc = "<<nc<<"  nd = "<<nd<<std::endl;
+          // std::cout<<"la ="<<la<<"  lb = "<<lb<<"  lc = "<<lc<<"  ld = "<<ld<<std::endl;
+          M0nuT_TBME.TwoBody.SetTBME(chbra,chket,ibra,iket,Mtbme); // set the two-body matrix elements (TBME) to Mtbme
+        } // end of for-loop over: iket
+      } // end of for-loop over: ibra
+      M0nuT_TBME.profiler.timer["M0nuT_3_omp"] += omp_get_wtime() - t_start_omp; // profiling (r)
+    } // end of for-loop over: auto
+    M0nuT_TBME.profiler.timer["M0nuT_2_tbme"] += omp_get_wtime() - t_start_tbme; // profiling (r)
+    M0nuT_TBME.profiler.timer["M0nuT _Op"] += omp_get_wtime() - t_start; // profiling (r)
+    return M0nuT_TBME;
+  }
+}
diff --git a/src/M0nu.hh b/src/M0nu.hh
new file mode 100755
index 0000000..d1a64e8
--- /dev/null
+++ b/src/M0nu.hh
@@ -0,0 +1,56 @@
+#ifndef M0nu_hh
+#define M0nu_hh
+
+#include "ModelSpace.hh"
+#include "Operator.hh"
+#include "imsrg_util.hh"
+#include "omp.h"
+#include <gsl/gsl_math.h>
+#include "PhysicalConstants.hh"
+#include <iostream>
+
+//Code to compute the operators for neutrinoless double beta decay
+//Mainly implementation of operators found in Charlie Payne master
+//thesis found at "file:///Users/antoinebelley/Downloads/ubc_2018_february_payne_charlie.pdf'
+//Implemented by Antoine Belley
+//Date : 05/2020
+namespace M0nu
+{
+  const double MAGMOM = 4.706;  //Magnetic moment
+  const double CUTV = 850.0; //vector cut off
+  const double CUTA = 1086.0; //axial cut off
+  const double R0 = 1.2;
+
+  inline int intPhase(int i) {return (i%2)==0 ? 1 : -1;}; // calculates the phase of an integer
+  inline double asNorm(int i, int j) {return i==j ? PhysConst::INVSQRT2 : 1.0;}; //for anti-symetrization
+  inline int PairFN(int a, int b) {return ((a + b)*(a + b + 1)/2) + b;}; // a Cantor pairing function used for cacheing CG in M0nuT
+
+  struct frparams{int n; int l; int np; int lp; double hw; int rho; double q;};
+  struct fqparams{int n; int l; int np; int lp; double hw; std::string transition; int rho; double Eclosure; std::string src;};
+  
+  //double HO_Radial_psi(int n, int l, double hw, double r);
+  double frRBME(double r, void *params);
+  void   GSLerror(std::string errstr, int status, size_t limit, double epsabs, double epsrel, double abserr, double result, int n, int l, int np, int lp, double q);
+  double rbme(int n, int l, int np, int lp, double hw, int rho, double q, std::string src);
+  double formfactor(double q, int transition);
+  double fq(double q, void *params);
+  double integrate_dq(int n, int l, int np, int lp, double hw, std::string transition, int rho, double Eclosure, std::string src);
+
+  uint64_t IntHash(uint64_t n, uint64_t l, uint64_t np, uint64_t lp);
+  void IntUnHash(uint64_t key, uint64_t &n, uint64_t &l, uint64_t &np, uint64_t &lp);
+  std::unordered_map<uint64_t,double> PreCalculateM0nuIntegrals(int e2max, double hw, std::string transition, int rho, double Eclosure, std::string src);
+  double GetM0nuIntegral(int e2max, int n, int l, int np, int lp, double hw, std::string transition, int rho, double Eclosure, std::string src, std::unordered_map<uint64_t,double> Intlist);
+
+  uint64_t T6jHash(uint64_t l1, uint64_t L1, uint64_t R, uint64_t L2, uint64_t l2);
+  void T6jUnHash(uint64_t key, uint64_t &l1, uint64_t &L1, uint64_t &R, uint64_t &L2, uint64_t &l2);
+  std::unordered_map<uint64_t,double> PreCalculateM0nuT6j(int e2max);
+  double GetM0nuT6j(int l1, int L1, int R, int L2, int l2, std::unordered_map<uint64_t,double> T6jList);
+
+  Operator GamowTeller(ModelSpace& modelspace, double Eclosure, std::string src);
+  Operator Fermi(ModelSpace& modelspace, double Eclosure, std::string src);
+  Operator Tensor(ModelSpace& modelspace, double Eclosure, std::string src);
+
+}
+
+
+#endif
diff --git a/src/Makefile b/src/Makefile
index 0442ec4..3568bab 100755
--- a/src/Makefile
+++ b/src/Makefile
@@ -1,5 +1,5 @@
-CC = g++
-#CC = clang++
+CXX = g++
+#CXX = clang++
 
 # Compiler flags:
 #  -DNO_ODE compiles without boost/ode package used for flow equation solver
@@ -11,8 +11,10 @@ ALL = libIMSRG.so imsrg++
 INSTDIR = $(HOME)
 INCLUDE   = -I./armadillo
 FLAGS     = -O3 -march=native -std=c++11 -fopenmp -fPIC
-LIBS = -lopenblas -lgsl -lz
-#LIBS = -lblas -lgsl -lz
+#LIBS = -lopenblas -lgsl -lz
+LIBS = -lblas -lgsl -lz
+PYTHON=off
+#DEBUG=on
 
 # I assume we're running on linux
 OS = LINUX
@@ -28,41 +30,67 @@ ifneq (,$(findstring detached,$(BUILDVERSION)))
   BUILDVERSION = $(shell git branch -v | grep '*' | awk '{printf "HEAD_%s",$$6}'  )
 endif
 
+FLAGS += -DBUILDVERSION=\"$(BUILDVERSION)\"
+
 ifeq ($(DEBUG),on)
  FLAGS     = -march=native -std=c++11 -fopenmp -fPIC -g
 endif
 
-FLAGS += -DBUILDVERSION=\"$(BUILDVERSION)\"
+#WITHHALF = 1
+
+#ifeq (1,$(WITHHALF))
+  INCLUDE += -I./half/include
+#  FLAGS += -DWITHHALF=1
+#endif
 
 WARNFLAGS = -Wall -Wno-comment -Wno-deprecated-declarations -Wno-missing-braces
 FLAGS    += $(WARNFLAGS)
 
 SOFLAGS = $(FLAGS)
 
-#PYTHONFLAGS = -I/usr/include/python2.7 -lboost_python #-lpython
-PYTHONFLAGS = -I./pybind11/include $(shell python-config --cflags ) -Wl,--no-as-needed
-PYTHONLIBS = -I./pybind11/include $(shell python-config  --ldflags)
+PYTHON_MAJOR_VERSION = $(shell python -c "import sys; sys.stdout.write('{}'.format(sys.version_info.major))")
+PYTHON_CONFIG = python$(PYTHON_MAJOR_VERSION)-config
+ifeq (,$(shell which $(PYTHON_CONFIG) 2> /dev/null))
+  PYTHON_CONFIG = python-config
+endif
+PYTHON_CFLAGS = $(shell $(PYTHON_CONFIG) --cflags )
+PYTHON_LDFLAGS = $(shell $(PYTHON_CONFIG) --ldflags )
+PYTHON_INCLUDE = -I./pybind11/include
+PYTHONFLAGS =  $(PYTHON_CFLAGS) -Wl,--no-as-needed
 
-THEHOST = $(shell if [ `hostname|grep jrl` ]; then echo jureca; elif [ `hostname|grep cougar` ]; then echo cougar; elif [ `hostname|grep cronos` ]; then echo cronos; elif [ `hostname|grep oak` ]; then echo oak; elif [ `hostname|grep cedar` ]; then echo cedar; else echo other; fi)
+THEHOST = $(shell if [ `hostname|grep jrl` ]; then echo jureca; elif [ `hostname|grep cougar` ]; then echo cougar; elif [ `hostname|grep cronos` ]; then echo cronos; elif [ `hostname|grep oak` ]; then echo oak; elif [ `hostname|grep cedar` ]; then echo cedar; elif [ `hostname|grep mox` ]; then echo mox;  else echo other; fi)
 
 
 
 ifeq ($(OS),MACOS)
-#  FLAGS     = -Xpreprocessor -fopenmp -O3 -march=native -std=c++11 -fPIC
   FLAGS     = -Xpreprocessor -fopenmp -O3  -std=c++11 -fPIC
   LIBS += -lomp
-  PYTHONFLAGS = -I./pybind11/include $(shell python-config --cflags | sed -e 's/-arch i386//')
+  PYTHONFLAGS =  $(shell python-config --cflags | sed -e 's/-arch i386//')
 endif
 
 
 ifeq ($(HDF5),on)
- LIBS += -lhdf5_cpp -lhdf5
+ LIBS += -lhdf5_cpp
+ NEWHDF5LOC = $(shell if [ -d /usr/include/hdf5/serial ]; then echo yes; else echo no; fi)
+ ifeq ($(NEWHDF5LOC),yes)
+   INCLUDE += -I/usr/include/hdf5/serial
+   LIBS += -lhdf5_serial
+ else
+  LIBS += -lhdf5
+ endif
 else
  FLAGS += -DNO_HDF5   # By default, don't bother building with HDF5, since it's not used very often and can make building a pain
 endif
 
 
 
+ifeq ($(THEHOST),other)  # default options. assumes boost and python are set up nicely.
+ LIBS += -llapack
+# ifneq ($(PYTHON),off)
+#  ALL += pyIMSRG.so
+# endif
+endif
+
 ifeq ($(THEHOST),jureca) # specific options for jureca cluster
 # FLAGS += -DOPENBLAS_NOUSEOMP=1
  SOFLAGS += -fuse-ld=bfd
@@ -72,136 +100,124 @@ ifeq ($(THEHOST),jureca) # specific options for jureca cluster
  PYTHONFLAGS := $(filter-out source,$(PYTHONFLAGS))
  PYTHONFLAGS := $(filter-out -xHost,$(PYTHONFLAGS))
 endif
+
 ifeq ($(THEHOST),cougar) # specific options for cougar cluster
  LIBS += -llapack
-# PYTHONFLAGS = -I/opt/anaconda/include/python2.7 -L/opt/boost/1.58.0/lib -lboost_python #-lpython
-  PYTHONFLAGS := -L/opt/anaconda/lib $(PYTHONFLAGS)
+ PYTHONFLAGS := -L/opt/anaconda/lib $(PYTHONFLAGS)
 endif
+
 ifeq ($(THEHOST),cronos)
- FLAGS += -DOLD_BOOST=1
+ FLAGS   += -DOLD_BOOST=1
  SOFLAGS += -DOLD_BOOST=1
  INCLUDE += -I$(HOME)/include
- LIBS += -L$(HOME)/lib
- ifneq ($(PYTHON),off)
-  ALL += pyIMSRG.so
-  endif
-endif
-ifeq ($(THEHOST),other)  # default options. assumes boost and python are set up nicely.
- LIBS += -llapack
- ifneq ($(PYTHON),off)
-  ALL += pyIMSRG.so
- endif
+ LIBS    += -L$(HOME)/lib
+
 endif
 
 ifeq ($(THEHOST),oak)
-#  FLAGS += -DOLD_BOOST
-#  FLAGS += -DOPENBLAS_NOUSEOMP=1
   NEWLIBS := $(filter-out -lopenblas -lblas,$(LIBS))
   LIBS = $(NEWLIBS) -lmkl_intel_lp64 -lmkl_gnu_thread -lmkl_core -lgomp -lpthread -lm -ldl
- ifneq ($(PYTHON),off)
-  ALL += pyIMSRG.so
-  endif
+# ifneq ($(PYTHON),off)
+#  ALL += pyIMSRG.so
+#  endif
+endif
+
+ifeq ($(THEHOST),mox)
+  NEWLIBS := $(filter-out -lopenblas -lblas,$(LIBS))
+  LIBS = $(NEWLIBS) -lmkl_intel_lp64 -lmkl_gnu_thread -lmkl_core -lgomp -lpthread -lm -ldl
 endif
 
+
+
 ifeq ($(THEHOST),cedar)
 #  NEWLIBS := $(filter-out -lopenblas,$(LIBS))
-  NEWLIBS := $(filter-out -lblas,$(LIBS))
-  LIBS = $(NEWLIBS) -lopenblas
+#  NEWLIBS := $(filter-out -lblas,$(LIBS))
+#  LIBS = $(NEWLIBS) -lopenblas
 #  LIBS = $(NEWLIBS) -lmkl_intel_lp64 -lmkl_gnu_thread -lmkl_core -lgomp -lpthread -lm -ldl
- ifneq ($(PYTHON),off)
-  ALL += pyIMSRG.so
-  endif
+# ifneq ($(PYTHON),off)
+#  ALL += pyIMSRG.so
+#  endif
 endif
 
 
-ifeq ($(HDF5),on)
-# The new version of Ubuntu puts the hdf5 libraries in a different location
- NEWHDF5LOC = $(shell if [ -d /usr/include/hdf5/serial ]; then echo yes; else echo no; fi)
- ifeq ($(NEWHDF5LOC),yes)
-   INCLUDE += -I/usr/include/hdf5/serial
-   NEWLIBS := $(filter-out -lhdf5,$(LIBS))
-   LIBS = $(NEWLIBS) -lhdf5_serial
+
+
+ifneq ($(PYTHON),off)
+ ALL += pyIMSRG.so
  endif
-endif
+
 
 all: $(ALL)
 	@echo Building with build version $(BUILDVERSION)
 
-install: splashscreen
-	@if [ ! -d $(INSTDIR)/lib ] ; then \
-	  mkdir $(INSTDIR)/lib; \
-	fi
-	@if [ ! -d $(INSTDIR)/include ] ; then \
-	  mkdir $(INSTDIR)/include; \
-	fi
-	@if [ ! -d $(INSTDIR)/bin ] ; then \
-	  mkdir $(INSTDIR)/bin; \
-	fi
-	ln -sf $(PWD)/libIMSRG.so $(INSTDIR)/lib/libIMSRG.so
-	@if [ -f pyIMSRG.so ] ; then\
-	  ln -sf $(PWD)/pyIMSRG.so $(INSTDIR)/lib/pyIMSRG.so;\
-	fi
-	@for x in *.hh; do \
-	 echo linking $(PWD)/$$x  '=>'  $(INSTDIR)/include/$$x;\
-	 ln -sf $(PWD)/$$x $(INSTDIR)/include/$$x; \
-	done
-	@if [ -d $(INSTDIR)/bin ] ; then \
-	  echo linking $(PWD)/imsrg++  '=>' $(INSTRDIR)/bin/imsrg++;\
-	  ln -sf $(PWD)/imsrg++ $(INSTDIR)/bin/imsrg++;\
-	fi
-	ln -nsf $(PWD)/armadillo $(INSTDIR)/include/armadillo
-	@printf "\n\nDone installing.\n\n"
-	@echo '*********************************************************************'
-	@echo '* Make sure libIMSRG.so is in your LIBRARY_PATH and LD_LIBRARY_PATH *'
-	@echo '*********************************************************************'
-
-
 OBJ = ModelSpace.o TwoBodyME.o ThreeBodyME.o Operator.o  ReadWrite.o\
       HartreeFock.o imsrg_util.o Generator.o IMSRGSolver.o AngMom.o\
       IMSRGProfiler.o Commutator.o HFMBPT.o\
-      DarkMatterNREFT.o Jacobi3BME.o UnitTest.o \
+      M0nu.o DarkMatterNREFT.o Jacobi3BME.o UnitTest.o \
       TwoBodyChannel.o ThreeBodyChannel.o \
       ThreeBodyMEpn.o ThreeLegME.o ThreeBodyMENO2B.o \
       boost_src/gzip.o boost_src/zlib.o
 
-mysrg: main.cc $(OBJ)
-	$(CC) $^ -o $@ $(INCLUDE) $(LIBS) $(FLAGS)
-
-boost_src/gzip.o: boost_src/gzip.cpp
-	$(CC) -c $^ -o $@ $(INCLUDE) $(FLAGS)
-#	$(CC) -c $^ -o $@ $(INCLUDE) $(LIBS) $(FLAGS)
 
-boost_src/zlib.o: boost_src/zlib.cpp
-	$(CC) -c $^ -o $@ $(INCLUDE) $(FLAGS)
-#	$(CC) -c $^ -o $@ $(INCLUDE) $(LIBS) $(FLAGS)
+boost_src/%.o: boost_src/%.cpp
+	$(CXX) -c $^ -o $@ $(INCLUDE) $(FLAGS)
 
 
 %.o: %.cc %.hh
-	$(CC) -c $*.cc -o $@ $(INCLUDE) $(FLAGS)
-#	$(CC) -c $*.cc -o $@ $(INCLUDE) $(LIBS) $(FLAGS)
+	$(CXX) -c $*.cc -o $@ $(INCLUDE) $(FLAGS)
 
 %.o: %.cc
-	$(CC) -c $*.cc -o $@ $(INCLUDE) $(FLAGS)
+	$(CXX) -c $*.cc -o $@ $(INCLUDE) $(FLAGS)
 
 
 libIMSRG.so: $(OBJ)
-	$(CC) $^ -shared -o $@ $(SOFLAGS) $(LIBS)
+	$(CXX) $^ -shared -o $@ $(SOFLAGS) $(LIBS)
 
 python: pyIMSRG.so
 
 pyIMSRG.so: $(OBJ)  pyIMSRG.o
-	$(CC) $(FLAGS) $(INCLUDE) $(PYTHONFLAGS) $(PYTHONLIBS) $(LIBS) -shared  $^ -o $@
+	$(CXX) $(FLAGS) $(INCLUDE) $(PYTHON_INCUDE) $(PYTHONFLAGS) $(PYTHONLDFLAGS) $(LIBS) -shared  $^ -o $@
 
 pyIMSRG.o: pyIMSRG.cc
-	$(CC) -c  $(FLAGS) $(INCLUDE) $(PYTHONFLAGS)  $^ -o $@
-#	$(CC) -c  $(FLAGS) $(INCLUDE) $(PYTHONFLAGS) $(LIBS)  $^ -o $@
+	$(CXX) -c  $(FLAGS) $(INCLUDE) $(PYTHON_INCLUDE) $(PYTHONFLAGS)  $^ -o $@
 
 imsrg++: imsrg++.cc libIMSRG.so Parameters.hh
-	$(CC) $(INCLUDE) $< -o $@ $(FLAGS) -L$(PWD) -lIMSRG $(LIBS)
+	$(CXX) $(INCLUDE) $< -o $@ $(FLAGS) -L$(PWD) -lIMSRG $(LIBS)
 
 clean:
 	rm -f *.o *.so boost_src/*.o
 
+test:
+	python -c "import pyIMSRG; ms=pyIMSRG.ModelSpace(2,'He4','He4'); ut=pyIMSRG.UnitTest(ms); passed=ut.SanityCheck()"
+
+install: splashscreen
+	@if [ ! -d $(INSTDIR)/lib ] ; then \
+	  mkdir $(INSTDIR)/lib; \
+	fi
+	@if [ ! -d $(INSTDIR)/include ] ; then \
+	  mkdir $(INSTDIR)/include; \
+	fi
+	@if [ ! -d $(INSTDIR)/bin ] ; then \
+	  mkdir $(INSTDIR)/bin; \
+	fi
+	ln -sf $(PWD)/libIMSRG.so $(INSTDIR)/lib/libIMSRG.so
+	@if [ -f pyIMSRG.so ] ; then\
+	  ln -sf $(PWD)/pyIMSRG.so $(INSTDIR)/lib/pyIMSRG.so;\
+	fi
+	@for x in *.hh; do \
+	 echo linking $(PWD)/$$x  '=>'  $(INSTDIR)/include/$$x;\
+	 ln -sf $(PWD)/$$x $(INSTDIR)/include/$$x; \
+	done
+	@if [ -d $(INSTDIR)/bin ] ; then \
+	  echo linking $(PWD)/imsrg++  '=>' $(INSTRDIR)/bin/imsrg++;\
+	  ln -sf $(PWD)/imsrg++ $(INSTDIR)/bin/imsrg++;\
+	fi
+	ln -nsf $(PWD)/armadillo $(INSTDIR)/include/armadillo
+	@printf "\n\nDone installing.\n\n"
+	@echo '*********************************************************************'
+	@echo '* Make sure libIMSRG.so is in your LIBRARY_PATH and LD_LIBRARY_PATH *'
+	@echo '*********************************************************************'
+
 
 
 splashscreen:
diff --git a/src/ModelSpace.cc b/src/ModelSpace.cc
index f6eddab..9528d2e 100755
--- a/src/ModelSpace.cc
+++ b/src/ModelSpace.cc
@@ -44,17 +44,12 @@ std::map< std::string, std::vector<std::string> > ModelSpace::ValenceSpaces  {
 
 
 
-//ModelSpace::~ModelSpace()
-//{
-////  std::cout << "In ModelSpace destructor. emax = " << Emax << std::endl;
-//}
-
 ModelSpace::ModelSpace()
 :  Emax(0), E2max(0), E3max(0), Lmax(0), Lmax2(0), Lmax3(0), OneBodyJmax(0), TwoBodyJmax(0), ThreeBodyJmax(0), EmaxUnocc(0), dE3max(999), occnat3cut(-1.0), norbits(0),
   hbar_omega(20), target_mass(16), sixj_has_been_precalculated(false), moshinsky_has_been_precalculated(false),
   scalar_transform_first_pass(true),scalar3b_transform_first_pass(true), tensor_transform_first_pass(40,true), single_species(false)
 {
-   SetUpOrbits();
+//   SetUpOrbits();
 //  std::cout << "In default constructor" << std::endl;
 }
 
@@ -140,8 +135,8 @@ ModelSpace::ModelSpace(int emax, std::vector<std::string> hole_list, std::vector
 :  Emax(emax), E2max(2*emax), E3max(std::min(14,3*emax)), Lmax(emax), Lmax2(emax), Lmax3(emax), OneBodyJmax(0), TwoBodyJmax(0), ThreeBodyJmax(0), EmaxUnocc(emax), dE3max(999), occnat3cut(-1.0), norbits(0), hbar_omega(20), target_mass(16),
      moshinsky_has_been_precalculated(false), scalar_transform_first_pass(true), scalar3b_transform_first_pass(true), tensor_transform_first_pass(40,true), single_species(false)
 {
-   SetUpOrbits();
-   Init(emax, hole_list, hole_list, valence_list); 
+//   SetUpOrbits();
+   Init(emax, hole_list, hole_list, valence_list); // Init version 3  (int, vector<string>, vector<string>, vector<string> )
 }
 
 // If we don't want the reference to be the core
@@ -149,8 +144,8 @@ ModelSpace::ModelSpace(int emax, std::vector<std::string> hole_list, std::vector
 : Emax(emax), E2max(2*emax), E3max(std::min(14,3*emax)), Lmax(emax), Lmax2(emax), Lmax3(emax), OneBodyJmax(0), TwoBodyJmax(0), ThreeBodyJmax(0), EmaxUnocc(emax), dE3max(999),  occnat3cut(-1.0), norbits(0), hbar_omega(20), target_mass(16),
      sixj_has_been_precalculated(false),moshinsky_has_been_precalculated(false), scalar_transform_first_pass(true), scalar3b_transform_first_pass(true),tensor_transform_first_pass(40,true),single_species(false)
 {
-   SetUpOrbits();
-   Init(emax, hole_list, core_list, valence_list); 
+//   SetUpOrbits();
+   Init(emax, hole_list, core_list, valence_list); // Init version 3  (int, vector<string>, vector<string>, vector<string> )
 }
 
 // Most conventient interface
@@ -158,8 +153,8 @@ ModelSpace::ModelSpace(int emax, std::string reference, std::string valence)
 : Emax(emax), E2max(2*emax), E3max(std::min(14,3*emax)), Lmax(emax), Lmax2(emax), Lmax3(emax), OneBodyJmax(0), TwoBodyJmax(0), ThreeBodyJmax(0), EmaxUnocc(emax), dE3max(999),  occnat3cut(-1.0), hbar_omega(20),
      sixj_has_been_precalculated(false),moshinsky_has_been_precalculated(false), scalar_transform_first_pass(true), scalar3b_transform_first_pass(true),tensor_transform_first_pass(40,true),single_species(false)
 {
-  SetUpOrbits();
-  Init(emax,reference,valence);
+//  SetUpOrbits();
+  Init(emax,reference,valence); // Init version 1  (int, string, string )
 }
 
 ModelSpace::ModelSpace(int emax, std::string valence)
@@ -168,65 +163,68 @@ ModelSpace::ModelSpace(int emax, std::string valence)
 {
   auto itval = ValenceSpaces.find(valence);
   if ( itval != ValenceSpaces.end() ) // we've got a valence space
-     Init(emax,itval->second[0],valence);
+     Init(emax,itval->second[0],valence); // Init version 1  ( int, string, string )
   else  // no valence space. we've got a single-reference.
-     Init(emax,valence,valence);
+     Init(emax,valence,valence); // Init version 1  ( int, string, string )
 }
 
 
 
-void ModelSpace::SetUpOrbits( )
-{
-   std::vector<int> IsospinList = {-1, 1};
-   if (single_species) IsospinList.pop_back(); // just use tz = -1 in this case
-
-   norbits = (Emax+1)*(Emax+2);
-   Orbits.resize(0);
-//   std::cout << "Starting loop in SetUpOrbits " << std::endl;
-   for (int N=0; N<=Emax; ++N)
-   {
-     for (int l=N; l>=0; l-=2)
-     {
-       if (l>Lmax) continue;
-       int n = (N-l)/2;
-       for (int j2=2*l+1; j2>=2*l-1 and j2>0; j2-=2)
-       {
-//         for (int tz : {-1, 1} )
-         for (int tz : IsospinList )
-         {
-            double occ = 0;
-            int cvq = 2;
-//            int indx = Index1(n,l,j2,tz);
-//            if (hole_list.find(indx) != hole_list.end()) occ = hole_list[indx];
-//            if ( find(core_list.begin(), core_list.end(), indx) != core_list.end() ) cvq=0; // core orbit
-//            if ( find(valence_list.begin(), valence_list.end(), indx) != valence_list.end() ) cvq=1; // valence orbit
-//            std::cout << "calling AddOrbit( " << n << " " << l << " " << tz << " " << occ << " " << cvq << " ) " << std::endl;
-            AddOrbit(n,l,j2,tz,occ,cvq);
-         }
-       }
-     }
-   }
-   norbits = all_orbits.size();
-//   Orbits.resize(norbits);
-//   std::cout << "done with SetUpOrbits" << std::endl;
-}
+//void ModelSpace::SetUpOrbits( )
+//{
+//  std::cout << __func__ << "  line " << __LINE__ << std::endl;
+//   std::vector<int> IsospinList = {-1, 1};
+//   if (single_species) IsospinList.pop_back(); // just use tz = -1 in this case
+//
+//   norbits = (Emax+1)*(Emax+2);
+//   Orbits.resize(0);
+////   std::cout << "Starting loop in SetUpOrbits " << std::endl;
+//   for (int N=0; N<=Emax; ++N)
+//   {
+//     for (int l=N; l>=0; l-=2)
+//     {
+//       if (l>Lmax) continue;
+//       int n = (N-l)/2;
+//       for (int j2=2*l+1; j2>=2*l-1 and j2>0; j2-=2)
+//       {
+////         for (int tz : {-1, 1} )
+//         for (int tz : IsospinList )
+//         {
+//            double occ = 0;
+//            int cvq = 2;
+//            AddOrbit(n,l,j2,tz,occ,cvq);
+//         }
+//       }
+//     }
+//   }
+//   norbits = all_orbits.size();
+////   Orbits.resize(norbits);
+////   std::cout << "done with SetUpOrbits" << std::endl;
+//}
 
 
 // Specify the reference and either the core or valence
 // This is the most convenient interface
+// Init version 1  (int, string, string)
 void ModelSpace::Init(int emax, std::string reference, std::string valence)
 {
+//  std::cout << __func__ << "  line " << __LINE__ << std::endl;
 //  int Aref,Zref;
   GetAZfromString(reference,Aref,Zref);
-  std::map<index_t,double> hole_list = GetOrbitsAZ(Aref,Zref);
-  Init(emax,hole_list,valence);
+//  std::map<index_t,double> hole_list = GetOrbitsAZ(Aref,Zref);
+  auto hole_list = GetOrbitsAZ(Aref,Zref);
+  Init(emax,hole_list,valence);  // calls  Init version 2 (int, map, string)
 }
 
-void ModelSpace::Init(int emax, std::map<index_t,double> hole_list, std::string valence)
+//void ModelSpace::Init(int emax, std::map<index_t,double> hole_list, std::string valence)
+// Init version 2  (int, map<array,double>, string)
+void ModelSpace::Init(int emax, std::map<std::array<int,4>,double> hole_list, std::string valence)
 {
+//  std::cout << __func__ << "  line " << __LINE__ << std::endl;
   int Ac,Zc;
 //  std::vector<index_t> valence_list, core_list;
-  std::set<index_t> valence_list, core_list;
+//  std::set<index_t> valence_list, core_list;
+  std::set<std::array<int,4>> valence_list, core_list;
 
   if (valence == "0hw-shell")
   {
@@ -238,8 +236,28 @@ void ModelSpace::Init(int emax, std::map<index_t,double> hole_list, std::string
   }
   else if ( valence.find("FCI")!=std::string::npos ) // FCI space, so no core, all orbits are valence.
   {
-    index_t num_orbits = (emax+1)*(emax+2);
-    for (index_t i=0;i<num_orbits;++i) valence_list.insert( i );
+
+      for (int N=0; N<=Emax; ++N)
+      {
+        for (int l=N; l>=0; l-=2)
+        {
+          if (l>Lmax) continue;
+          int n = (N-l)/2;
+          for (int j2=2*l+1; j2>=2*l-1 and j2>0; j2-=2)
+          {
+            int tz_max =  single_species ? -1  : +1;
+            for (int tz=-1; tz<=tz_max; tz+=2 )
+            {
+               // check if this is a non-hole-type orbit and if we're above the EmaxUnocc cut.
+               if ( ((2*n+l)>EmaxUnocc) and (hole_quantum_numbers.find({l,j2})==hole_quantum_numbers.end()) ) continue;
+               valence_list.insert( {n,l,j2,tz} );
+            }
+          }
+        }
+      }
+
+//    index_t num_orbits = (emax+1)*(emax+2);
+//    for (index_t i=0;i<num_orbits;++i) valence_list.insert( i );
 //    for (index_t i=0;i<num_orbits;++i) valence_list.push_back( i );
   }
   else // check if it's one of the pre-defined spaces
@@ -250,7 +268,10 @@ void ModelSpace::Init(int emax, std::map<index_t,double> hole_list, std::string
     if ( itval != ValenceSpaces.end() ) // we've got a valence space
     {
        core_str = itval->second[0];
-       std::vector<index_t> vvec = String2Index(std::vector<std::string>(itval->second.begin()+1,itval->second.end()));
+       std::vector<std::string> vstrings( itval->second.begin()+1,itval->second.end());
+//       std::vector<index_t> vvec = String2Index(vstrings);
+       std::vector<std::array<int,4>> vvec = String2Qnumbers(vstrings);
+//       std::vector<index_t> vvec = String2Index(std::vector<std::string>(itval->second.begin()+1,itval->second.end()));
        for (auto v : vvec ) valence_list.insert(v);
 //       valence_list = String2Index(std::vector<std::string>(itval->second.begin()+1,itval->second.end()));
     }
@@ -265,19 +286,22 @@ void ModelSpace::Init(int emax, std::map<index_t,double> hole_list, std::string
   }
 
   // This should be done in Init, but it doesn't hurt to do it here as well, I think.
-  SetTargetMass(Aref);
-  SetTargetZ(Zref);
+//  SetTargetMass(Aref);
+//  SetTargetZ(Zref);
 //  target_mass = Aref;
 //  target_Z = Zref;
-  Init(emax,hole_list,core_list,valence_list);
+//  Init(emax,hole_list,core_list,valence_list);
+  Init(hole_list,core_list,valence_list);  // call Init version 0  ( map, set, set )
   
 }
 
 
 // Specify the model space with std::strings of orbit lists.
 // Less convenient, but more flexible
+/// Init version 3 (int ,vector<string>, vector<string>, vector<string> )
 void ModelSpace::Init(int emax, std::vector<std::string> hole_list, std::vector<std::string> core_list, std::vector<std::string> valence_list)
 {
+  std::cout << __func__ << "  line " << __LINE__ << std::endl;
    std::cout << "Creating a model space with Emax = " << Emax << "  and hole orbits [";
    for (auto& h : hole_list)  std::cout << h << " ";
    std::cout << "]   and core orbits [";
@@ -285,17 +309,26 @@ void ModelSpace::Init(int emax, std::vector<std::string> hole_list, std::vector<
    std::cout << "]   and valence orbits [";
    for (auto& v : valence_list)   std::cout << v << " ";
    std::cout << "]" << std::endl;
-   std::map<index_t,double> hole_map;
-   for (auto& h : String2Index(hole_list)) hole_map[h] = 1.0;
-  Init(emax, hole_map, String2Index(core_list), String2Index(valence_list) );
+//   std::map<index_t,double> hole_map;
+//   for (auto& h : String2Index(hole_list)) hole_map[h] = 1.0;
+   std::map<std::array<int,4>,double> hole_map;
+   std::set<std::array<int,4>> core_set;
+   std::set<std::array<int,4>> valence_set;
+   for ( auto c : String2Qnumbers(core_list) )  core_set.insert(c);
+   for ( auto v : String2Qnumbers(valence_list) )  valence_set.insert(v);
+   for (auto& h : String2Qnumbers(hole_list)) hole_map[h] = 1.0;
+  Init( hole_map, core_set, valence_set ); // call Init version 0  (map, set, set )
+//  Init(emax, hole_map, String2Index(core_list), String2Index(valence_list) );
 }
 
 
 void ModelSpace::Init_occ_from_file(int emax, std::string valence, std::string occ_file)
 {
-  index_t orb;
+  std::cout << __func__ << "  line " << __LINE__ << std::endl;
+//  index_t orb;
   double occ;
-  std::map<index_t,double> hole_list;
+//  std::map<index_t,double> hole_list;
+  std::map<std::array<int,4>,double> hole_list;
 
   std::ifstream infile(occ_file);
   if (!infile.good())
@@ -304,33 +337,134 @@ void ModelSpace::Init_occ_from_file(int emax, std::string valence, std::string o
     std::cout << "Trouble reading file: " << occ_file << std::endl;
     std::cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << std::endl << std::endl;
   }
-
-  while( infile >> orb >> occ )
+  int n,l,j2,tz;
+//  while( infile >> orb >> occ )
+  while( infile >> n >> l >> j2 >> tz >> occ )
   {
-    if ( hole_list.find(orb) != hole_list.end() and  std::abs( hole_list[orb] -occ) > 1e-6) 
+//    if ( hole_list.find(orb) != hole_list.end() and  std::abs( hole_list[orb] -occ) > 1e-6) 
+    if ( hole_list.find({n,l,j2,tz}) != hole_list.end() and  std::abs( hole_list[{n,l,j2,tz}] -occ) > 1e-6) 
     {
         std::cout << "Warning: in file " << occ_file << ", redefinition of occupation of orbit "
-             << orb << "  " << hole_list[orb] << " => " << occ << std::endl;
+             << n << " " << l << " " << j2 << " " << tz << "  " << hole_list[{n,l,j2,tz}] << " => " << occ << std::endl;
+//             << orb << "  " << hole_list[orb] << " => " << occ << std::endl;
     }
 
     std::cout << "from occ file: " << std::endl;
-    hole_list[orb] = occ;
-    std::cout << orb << " " << occ << std::endl;
+//    hole_list[orb] = occ;
+    hole_list[{n,l,j2,tz}] = occ;
+    std::cout << n << " " << l << " " << j2 << " " << tz  << "    " << occ << std::endl;
+//    std::cout << orb << " " << occ << std::endl;
   }
 
-  Init(emax,hole_list,valence);
+  Init(emax,hole_list,valence); // call Init version  2 ( int, map, string )
+//  Init(emax,hole_list,valence);
 }
 
 // An attempt at backward compatibility
-void ModelSpace::Init(int emax, std::map<index_t,double> hole_list, std::vector<index_t> core_list, std::vector<index_t> valence_list)
-{
-  std::set<index_t> clist(core_list.begin(),core_list.end());
-  std::set<index_t> vlist(valence_list.begin(),valence_list.end());
-  Init(emax,hole_list,clist,vlist);
-}
+// Init version 4 (int, map<index_t,double>, vector<index_t>, vector<index_t> )
+//void ModelSpace::Init(int emax, std::map<index_t,double> hole_list, std::vector<index_t> core_list, std::vector<index_t> valence_list)
+//{
+//  std::cout << __func__ << "  line " << __LINE__ << std::endl;
+//  std::set<index_t> clist(core_list.begin(),core_list.end());
+//  std::set<index_t> vlist(valence_list.begin(),valence_list.end());
+//  Init(emax,hole_list,clist,vlist);  // call Init version -1  (int, map<index>, set<index>, set<index> )
+//}
 
 
 // This is the Init which should inevitably be called
+//void ModelSpace::Init(int emax, std::map<index_t,double> hole_list, std::set<index_t> core_list, std::set<index_t> valence_list)
+// Init version 0 ( map<array,double>, set<array>, set<array> )
+void ModelSpace::Init( std::map<std::array<int,4>,double> hole_list, std::set<std::array<int,4>> core_list, std::set<std::array<int,4>> valence_list)
+{
+
+//  std::cout << __func__ << "  line " << __LINE__ << std::endl;
+   ClearVectors();
+//   Emax = emax;
+//   std::cout << "core list: ";
+//   for (auto& c : core_list) std::cout << c << " ";
+//   std::cout << std::endl;
+//   std::cout << "valence list: ";
+//   for (auto& v : valence_list) std::cout << v << " ";
+//   std::cout << std::endl;
+//   std::cout << "hole list: ";
+//   for (auto& h : hole_list) std::cout << h.first << " ( " << h.second << " ) ";
+//   std::cout << std::endl;
+
+   // Make sure no orbits are both core and valence
+   for (auto& c : core_list)
+   {
+     if ( find(valence_list.begin(), valence_list.end(), c) != valence_list.end() )
+       std::cout << "!!!!!!!!!!!!! ModelSpace::Init : Conflicting definition. Orbit (" << c[0] << " " << c[1] << " " << c[2] << " " << c[3] << ") is in core and valence spaces." << std::endl;
+//       std::cout << "!!!!!!!!!!!!! ModelSpace::Init : Conflicting definition. Orbit " << c << " is in core and valence spaces." << std::endl;
+   }
+
+   std::vector<int> IsospinList = {-1, 1};
+   if (single_species) IsospinList.pop_back(); // just use tz = -1 in this case
+
+   Orbits.resize(0);
+   OrbitLookup.clear(); // if we've resized Orbits to zero, there's nothing to point to or look up...
+
+   for (int N=0; N<=Emax; ++N)
+   {
+     for (int l=N; l>=0; l-=2)
+     {
+       if (l>Lmax) continue;
+       int n = (N-l)/2;
+       for (int j2=2*l+1; j2>=2*l-1 and j2>0; j2-=2)
+       {
+         for (int tz : IsospinList )
+         {
+            // check if this is a non-hole-type orbit and if we're above the EmaxUnocc cut.
+
+            if ( ((2*n+l)>EmaxUnocc) and (hole_quantum_numbers.find({l,j2})==hole_quantum_numbers.end()) ) continue;
+
+//            double occ = 0;
+            double occ = ( hole_list.find({n,l,j2,tz}) != hole_list.end() )  ?  hole_list.at({n,l,j2,tz})  :  0;
+            int cvq = 2;
+            if ( core_list.find({n,l,j2,tz}) != core_list.end() )  cvq = 0;
+            else if ( valence_list.find({n,l,j2,tz}) != valence_list.end() )  cvq = 1;
+
+            AddOrbit(n,l,j2,tz,occ,cvq);  // First, add the orbit to make sure it's in the lookup tables
+//            int indx = Index1(n,l,j2,tz);
+//            if (hole_list.find(indx) != hole_list.end()) occ = hole_list[indx];
+//            if ( find(core_list.begin(), core_list.end(), indx) != core_list.end() ) cvq=0; // core orbit
+//            if ( find(valence_list.begin(), valence_list.end(), indx) != valence_list.end() ) cvq=1; // valence orbit
+//            AddOrbit(n,l,j2,tz,occ,cvq); // Add it again with the right occupation and classification. (There's probably a cleaner way to do this.)
+         }
+       }
+     }
+   }
+   norbits = all_orbits.size();
+   double atmp=0;
+   double ztmp=0;
+   for (auto& h : holes)
+   {
+     Orbit& oh = GetOrbit(h);
+     atmp += (oh.j2+1.)*oh.occ;
+     if (oh.tz2 < 0) ztmp += (oh.j2+1.)*oh.occ;
+   }
+   Aref = round(atmp);
+   Zref = round(ztmp);
+   if (std::abs(Aref-atmp)>1e-5 or std::abs(Zref-ztmp)>1e-5)
+   {
+     std::cout << std::endl << "!!!! WARNING  " << __func__ << " recomputed A,Z and got " << atmp << " " << ztmp << std::endl;
+   }
+//   Aref = round(atmp);
+//   Zref = round(ztmp);
+   FindEFermi();
+   SetTargetMass(Aref);
+   SetTargetZ(Zref);
+   SetupKets();
+   Setup3bKets();
+}
+
+//// DEPRECATED Init version -1  (int, map<index,double>, set<index>, set<index> )
+//void ModelSpace::Init(int emax, std::map<index_t,double> hole_list, std::set<index_t> core_list, std::set<index_t> valence_list)
+//{
+//  std::cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Depricated !!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << std::endl;
+//  std::cout << "line " << __LINE__ << "  " << __func__ << std::endl;
+//}
+/*
 void ModelSpace::Init(int emax, std::map<index_t,double> hole_list, std::set<index_t> core_list, std::set<index_t> valence_list)
 {
    ClearVectors();
@@ -406,6 +540,10 @@ void ModelSpace::Init(int emax, std::map<index_t,double> hole_list, std::set<ind
    SetupKets();
    Setup3bKets();
 }
+*/
+
+
+
 
 
 void ModelSpace::InitSingleSpecies(int emax, std::string reference, std::string valence)
@@ -413,7 +551,8 @@ void ModelSpace::InitSingleSpecies(int emax, std::string reference, std::string
   single_species = true;
   ClearVectors();
   GetAZfromString(reference,Aref,Zref);
-  std::map<index_t,double> hole_list = GetOrbitsAZ(Aref,Zref);
+//  std::map<index_t,double> hole_list = GetOrbitsAZ(Aref,Zref);
+  std::map<std::array<int,4>,double> hole_list = GetOrbitsAZ(Aref,Zref);
   Init(emax,hole_list,valence);
 
 
@@ -429,10 +568,13 @@ void ModelSpace::InitSingleSpecies(int emax, std::string reference, std::string
 void ModelSpace::SetLmax( int l)
 {
   Lmax = l;
-  int e = Emax;
-  std::map<index_t,double> the_hole_list;
-  std::set<index_t> the_core_list;
-  std::set<index_t> the_valence_list;
+//  int e = Emax;
+//  std::map<index_t,double> the_hole_list;
+//  std::set<index_t> the_core_list;
+//  std::set<index_t> the_valence_list;
+  std::map<std::array<int,4>,double> the_hole_list;
+  std::set<std::array<int,4>> the_core_list;
+  std::set<std::array<int,4>> the_valence_list;
   for ( auto h : holes )
   {
     Orbit& oh = GetOrbit(h);
@@ -442,7 +584,8 @@ void ModelSpace::SetLmax( int l)
                 << "  which is bigger than Lmax = " << Lmax << " ... dying now. " << std::endl;
       exit(0);
     }
-    the_hole_list[h] = oh.occ;
+//    the_hole_list[h] = oh.occ;
+    the_hole_list[{oh.n,oh.l,oh.j2,oh.tz2}] = oh.occ;
   }
   for (auto c : core )
   {
@@ -453,7 +596,8 @@ void ModelSpace::SetLmax( int l)
                 << "  which is bigger than Lmax = " << Lmax << " ... dying now. " << std::endl;
       exit(0);
     }
-    the_core_list.insert(c);
+//    the_core_list.insert(c);
+    the_core_list.insert({oc.n,oc.l,oc.j2,oc.tz2});
   }
   for (auto v : valence )
   {
@@ -465,17 +609,19 @@ void ModelSpace::SetLmax( int l)
 //                << "  which is bigger than Lmax = " << Lmax << " ... dying now. " << std::endl;
 //      exit(0);
     }
-    the_valence_list.insert(v);
+//    the_valence_list.insert(v);
+    the_valence_list.insert({ov.n,ov.l,ov.j2,ov.tz2});
   }
-  Init( e, the_hole_list, the_core_list, the_valence_list );
+//  Init( e, the_hole_list, the_core_list, the_valence_list );
+  Init( the_hole_list, the_core_list, the_valence_list );
 }
 
 
 // Get std::vector of orbit indices from std::vector of std::strings
 // e.g. "p0f7" gives the index of the proton 0f7/2 orbit.
-std::vector<index_t> ModelSpace::String2Index( std::vector<std::string> vs )
+std::vector<std::array<int,4>> ModelSpace::String2Qnumbers( std::vector<std::string> vs )
 {
-  std::vector<index_t> vi;
+  std::vector<std::array<int,4>> vi;
   std::vector<char> l_list = {'s','p','d','f','g','h','i','j','k','l','m','n','o'};
 
   for ( auto& s : vs )
@@ -485,11 +631,33 @@ std::vector<index_t> ModelSpace::String2Index( std::vector<std::string> vs )
     std::istringstream( s.substr(1,2) ) >> n;
     l = find(l_list.begin(),l_list.end(), s[2]) - l_list.begin();
     std::istringstream( s.substr(3,s.size()) ) >> j2;
-    vi.push_back( Index1(n,l,j2,tz2) );
+//    vi.push_back( Index1(n,l,j2,tz2) );
+    vi.push_back( {n,l,j2,tz2} );
   }
   return vi;
 }
 
+//std::vector<index_t> ModelSpace::String2Index( std::vector<std::string>& vs )
+std::vector<index_t> ModelSpace::String2Index( std::vector<std::string> vs )
+{
+  std::vector<std::array<int,4>> vquant = String2Qnumbers( vs );
+  std::vector<index_t> vi;
+  for ( auto qn : vquant ) vi.push_back( Index1( qn[0], qn[1], qn[2], qn[3] ) );
+  return vi;
+//  std::vector<char> l_list = {'s','p','d','f','g','h','i','j','k','l','m','n','o'};
+//
+//  for ( auto& s : vs )
+//  {
+//    int n,l,j2,tz2;
+//    tz2 = s[0]=='p' ? -1 : 1;
+//    std::istringstream( s.substr(1,2) ) >> n;
+//    l = find(l_list.begin(),l_list.end(), s[2]) - l_list.begin();
+//    std::istringstream( s.substr(3,s.size()) ) >> j2;
+//    vi.push_back( Index1(n,l,j2,tz2) );
+//  }
+//  return vi;
+}
+
 
 std::string ModelSpace::Index2String( index_t ind)
 {
@@ -530,13 +698,15 @@ void ModelSpace::GetAZfromString(std::string str,int& A, int& Z) // TODO: accept
 
 // Fill A orbits with Z protons and A-Z neutrons
 // assuming a standard shell-model level ordering
-std::map<index_t,double> ModelSpace::GetOrbitsAZ(int A, int Z)
+//std::map<index_t,double> ModelSpace::GetOrbitsAZ(int A, int Z)
+std::map<std::array<int,4>,double> ModelSpace::GetOrbitsAZ(int A, int Z)
 {
 //  std::cout << "In GetOrbitsAZ  " << A << " " <<Z << std::endl;
 //  std::cout << "Size of OrbitLookup = " << OrbitLookup.size() << std::endl;
   int zz = 0;
   int nn = 0; // unfortunate there are so many n's here...
-  std::map<index_t,double> holesAZ;
+//  std::map<index_t,double> holesAZ;
+  std::map<std::array<int,4>,double> holesAZ;
   for (int N=0; N<=Emax; ++N)
   {
     for (int g=2*N+1;g>=-2*N;g-=4)
@@ -548,13 +718,15 @@ std::map<index_t,double> ModelSpace::GetOrbitsAZ(int A, int Z)
       if (zz < Z)
       {
         int dz = std::min(Z-zz,j2+1);
-        holesAZ[Index1(n,l,j2,-1)] = dz/(j2+1.0);
+//        holesAZ[Index1(n,l,j2,-1)] = dz/(j2+1.0);
+        holesAZ[{n,l,j2,-1}] = dz/(j2+1.0);
         zz += dz;
       }
       if (nn < A-Z)
       {
         int dn = std::min(A-Z-nn,j2+1);
-        holesAZ[Index1(n,l,j2,1)] = dn/(j2+1.0);
+//        holesAZ[Index1(n,l,j2,1)] = dn/(j2+1.0);
+        holesAZ[{n,l,j2,1}] = dn/(j2+1.0);
         nn += dn;
       }
       if (zz==Z and nn==A-Z)
@@ -575,7 +747,8 @@ std::map<index_t,double> ModelSpace::GetOrbitsAZ(int A, int Z)
 /// For example, if we want to treat C20, with 6 protons and 14 neutrons, we take the 0p shell for protons
 /// and 1s0d shell for neutrons.
 //void ModelSpace::Get0hwSpace(int Aref, int Zref, std::vector<index_t>& core_list, std::vector<index_t>& valence_list)
-void ModelSpace::Get0hwSpace(int Aref, int Zref, std::set<index_t>& core_list, std::set<index_t>& valence_list)
+//void ModelSpace::Get0hwSpace(int Aref, int Zref, std::set<index_t>& core_list, std::set<index_t>& valence_list)
+void ModelSpace::Get0hwSpace(int Aref, int Zref, std::set<std::array<int,4>>& core_list, std::set<std::array<int,4>>& valence_list)
 {
   int Nref = Aref-Zref;
   int OSC_protons=0,OSC_neutrons=0;
@@ -595,7 +768,8 @@ void ModelSpace::Get0hwSpace(int Aref, int Zref, std::set<index_t>& core_list, s
       for (int j2=2*L+1;j2>std::max(2*L-2,0);j2-=2)
       {
 //        valence_list.push_back( GetOrbitIndex( (OSC_protons-L)/2, L, j2, -1) );
-        valence_list.insert( GetOrbitIndex( (OSC_protons-L)/2, L, j2, -1) );
+//        valence_list.insert( GetOrbitIndex( (OSC_protons-L)/2, L, j2, -1) );
+        valence_list.insert( { (OSC_protons-L)/2, L, j2, -1} );
       }
     }
   }
@@ -606,7 +780,8 @@ void ModelSpace::Get0hwSpace(int Aref, int Zref, std::set<index_t>& core_list, s
       for (int j2=2*L+1;j2>std::max(2*L-2,0);j2-=2)
       {
 //        valence_list.push_back( GetOrbitIndex( (OSC_neutrons-L)/2, L, j2, 1) );
-        valence_list.insert( GetOrbitIndex( (OSC_neutrons-L)/2, L, j2, 1) );
+//        valence_list.insert( GetOrbitIndex( (OSC_neutrons-L)/2, L, j2, 1) );
+        valence_list.insert( { (OSC_neutrons-L)/2, L, j2, 1} );
       }
     }
   }
@@ -618,7 +793,8 @@ void ModelSpace::Get0hwSpace(int Aref, int Zref, std::set<index_t>& core_list, s
 // eg, the usual sd shell would look like "O16,p0d5,n0d5,p0d3,n0d3,p1s1,n1s1".
 // The number of ways to specify a model space is getting a bit out of hand...
 //void ModelSpace::ParseCommaSeparatedValenceSpace(std::string valence, std::vector<index_t>& core_list, std::vector<index_t>& valence_list)
-void ModelSpace::ParseCommaSeparatedValenceSpace(std::string valence, std::set<index_t>& core_list, std::set<index_t>& valence_list)
+//void ModelSpace::ParseCommaSeparatedValenceSpace(std::string valence, std::set<index_t>& core_list, std::set<index_t>& valence_list)
+void ModelSpace::ParseCommaSeparatedValenceSpace(std::string valence, std::set<std::array<int,4>>& core_list, std::set<std::array<int,4>>& valence_list)
 {
   std::istringstream ss(valence);
   std::string orbit_str,core_str;
@@ -634,7 +810,8 @@ void ModelSpace::ParseCommaSeparatedValenceSpace(std::string valence, std::set<i
 
   while(getline(ss, orbit_str, ','))
   {
-    valence_list.insert( String2Index({orbit_str})[0]);
+//    valence_list.insert( String2Index({orbit_str})[0]);
+    valence_list.insert( String2Qnumbers({orbit_str})[0]);
 //    valence_list.push_back( String2Index({orbit_str})[0]);
   }
 }
@@ -642,50 +819,95 @@ void ModelSpace::ParseCommaSeparatedValenceSpace(std::string valence, std::set<i
 // For backwards compatibility
 void ModelSpace::SetReference(std::vector<index_t> new_reference)
 {
+  std::cout << __func__ << "  line " << __LINE__ << std::endl;
   std::set<index_t> ref( new_reference.begin(),new_reference.end());
   SetReference( ref );
 }
 
 void ModelSpace::SetReference(std::set<index_t> new_reference)
 {
+  std::cout << __func__ << "  line " << __LINE__ << std::endl;
 //  std::cout << "I'm in this SetReference" << std::endl;
 //  std::vector<index_t> c = core;
 //  std::vector<index_t> v = valence;
-  std::set<index_t> c = core;
-  std::set<index_t> v = valence;
-  std::map<index_t,double> h;
-  for (auto r : new_reference) h[r] = 1.0;
+  std::map<std::array<int,4>,double> hlist ;
+  std::set<std::array<int,4>> clist ;
+  std::set<std::array<int,4>> vlist ;
+  for ( auto h : new_reference )
+  {
+    Orbit& oh = GetOrbit(h);
+    hlist[ {oh.n, oh.l, oh.j2, oh.tz2}]  = 1.0;
+  }
+  for ( auto c : core )
+  {
+    Orbit& oc = GetOrbit(c);
+    clist.insert( {oc.n, oc.l, oc.j2, oc.tz2} );
+  }
+  for ( auto v : valence )
+  {
+    Orbit& ov = GetOrbit(v);
+    vlist.insert( {ov.n, ov.l, ov.j2, ov.tz2} );
+  }
+
+
+//  std::set<index_t> c = core;
+//  std::set<index_t> v = valence;
+//  std::map<index_t,double> h;
+//  for (auto r : new_reference) h[r] = 1.0;
   ClearVectors();
-  Init(Emax, h,c,v);
+//  Init(Emax, h,c,v);
+  Init( hlist,clist,vlist);
 }
 
 void ModelSpace::SetReference(std::map<index_t,double> new_reference)
 {
-//  std::vector<index_t> c = core;
-//  std::vector<index_t> v = valence;
-  std::set<index_t> c = core;
-  std::set<index_t> v = valence;
-  if (valence.size()<1) // If we have no valece space, assume it's a single ref and core should equal the reference.
+  std::cout << __func__ << "  line " << __LINE__ << std::endl;
+  std::map<std::array<int,4>,double> hlist ;
+  std::set<std::array<int,4>> clist ;
+  std::set<std::array<int,4>> vlist ;
+  for ( auto& iterh : new_reference )
+  {
+    Orbit& oh = GetOrbit(iterh.first);
+    hlist[ {oh.n, oh.l, oh.j2, oh.tz2}]  = iterh.second;
+  }
+  for ( auto c : core )
+  {
+    Orbit& oc = GetOrbit(c);
+    clist.insert( {oc.n, oc.l, oc.j2, oc.tz2} );
+  }
+  for ( auto v : valence )
   {
-    c.clear();
-    for ( auto iter : new_reference )  c.insert(iter.first);
-//    c.resize(0);
-//    for ( auto iter : new_reference )  c.push_back(iter.first);
+    Orbit& ov = GetOrbit(v);
+    vlist.insert( {ov.n, ov.l, ov.j2, ov.tz2} );
   }
   ClearVectors();
-  Init(Emax, new_reference,c,v);
+  Init( hlist,clist,vlist);
+//  Init(Emax, new_reference,c,v);
 }
 
 void ModelSpace::SetReference(std::string new_reference)
 {
+  std::cout << __func__ << "  line " << __LINE__ << std::endl;
 //  std::vector<index_t> c = core;
 //  std::vector<index_t> v = valence;
-  std::set<index_t> c = core;
-  std::set<index_t> v = valence;
+  std::set<std::array<int,4>> clist ;
+  std::set<std::array<int,4>> vlist ;
+  for ( auto c : core )
+  {
+    Orbit& oc = GetOrbit(c);
+    clist.insert( {oc.n, oc.l, oc.j2, oc.tz2} );
+  }
+  for ( auto v : valence )
+  {
+    Orbit& ov = GetOrbit(v);
+    vlist.insert( {ov.n, ov.l, ov.j2, ov.tz2} );
+  }
   ClearVectors();
   GetAZfromString(new_reference,Aref,Zref);
-  std::map<index_t,double> h = GetOrbitsAZ(Aref,Zref);
-  Init(Emax, h,c,v);
+//  std::map<index_t,double> h = GetOrbitsAZ(Aref,Zref);
+  std::map<std::array<int,4>,double> hlist = GetOrbitsAZ(Aref,Zref);
+//  Init(Emax, h,c,v);
+  Init( hlist,clist,vlist);
 }
 
 ModelSpace ModelSpace::operator=(const ModelSpace& ms)
@@ -815,26 +1037,9 @@ void ModelSpace::AddOrbit(int n, int l, int j2, int tz2, double occ, int cvq)
    else  // we already have that one, but we'll replace it with the new info.
    {
      ind = OrbitLookup[hash];
-//     std::cout << "WARNING!!!  Adding an orbit that we already had: " << ind << " :  " << n << " " << l << " " << j2 << " " << tz2 << "    this could cause trouble." << std::endl;
-//     std::cout << "size of Orbits = " << Orbits.size() << std::endl;
      Orbits[ind] = Orbit(n,l,j2,tz2,occ,cvq,ind);
-//     std::cout << "Orbits[" << ind << "]  now points to an orbit who's ind is " << Orbits[ind].index << std::endl;
-
-     // Since we probably sorted into lists last time we added it, we need to remove the index ind from
-     // the lists so we can sort it properly according to the new cvq info.
-//..     for ( auto& vec : {particles,holes,core,valence,qspace,proton_orbits,neutron_orbits,all_orbits}  )
-
-// now that we use a set for these, we don't need to worry about this.
-//     for ( auto vec : {&particles,&holes,&core,&valence,&qspace,&proton_orbits,&neutron_orbits,&all_orbits}  )
-//     {
-//       vec->erase( std::remove( vec->begin(), vec->end(), ind ), vec->end() );
-//     }
-
-
    }
 
-//   Orbit& o = Orbits[ind];
-//   std::cout << "Now Orbit " << hash << " -> " << ind << "   is " << o.n << " " << o.l << " " << o.j2 << " " << o.tz2 << "    " << o.occ << " " << o.cvq << std::endl;
 
    if (j2 > OneBodyJmax)
    {
@@ -856,16 +1061,6 @@ void ModelSpace::AddOrbit(int n, int l, int j2, int tz2, double occ, int cvq)
    if (tz2 > 0 ) neutron_orbits.insert(ind);
    all_orbits.insert(ind);
 
-
-//   if ( occ < OCC_CUT) particles.push_back(ind);
-//   else holes.push_back(ind);
-//   if (cvq == 0) core.push_back(ind);
-//   if (cvq == 1) valence.push_back(ind);
-//   if (cvq == 2) qspace.push_back(ind);
-//   if (tz2 < 0 ) proton_orbits.push_back(ind);
-//   if (tz2 > 0 ) neutron_orbits.push_back(ind);
-//   all_orbits.push_back(ind);
-
 //   OneBodyChannels[{l, j2, tz2}].push_back(ind); // (Evidently, we mean one-body channels for an operator with the same symmetries as the Hamiltonian).
    OneBodyChannels[{l, j2, tz2}].insert(ind); // (Evidently, we mean one-body channels for an operator with the same symmetries as the Hamiltonian).
 }
@@ -907,7 +1102,7 @@ void ModelSpace::FindEFermi()
   if ( occmax[-1] > 0.99)  e_fermi[-1] = 0.5 * ( e_fermi[-1] + particle_e_min[-1] );
   if ( occmax[+1] > 0.99)  e_fermi[+1] = 0.5 * ( e_fermi[+1] + particle_e_min[+1] );
 
-  std::cout << "Fermi energies:  " << e_fermi[-1] << "   " << e_fermi[+1] << std::endl;
+//  std::cout << "Fermi energies:  " << e_fermi[-1] << "   " << e_fermi[+1] << std::endl;
 
 }
 
@@ -1234,12 +1429,14 @@ void ModelSpace::SetEmaxUnocc(int e)
 //  std::set<std::array<int,3>> hole_quantum_numbers; // For checking if an orbit could mix with the hole orbits
 
   hole_quantum_numbers.clear();
-  std::map<index_t,double> holemap;
+//  std::map<index_t,double> holemap;
+  std::map<std::array<int,4>,double> holemap;
   int max_l = -1;
   for (auto h : holes )
   {
     Orbit& oh = GetOrbit(h);
-    holemap[h] = oh.occ;
+//    holemap[h] = oh.occ;
+    holemap[{oh.n,oh.l,oh.j2,oh.tz2}] = oh.occ;
 //    hole_quantum_numbers.insert( { oh.l, oh.j2, oh.tz2} );
 //    hole_quantum_numbers.insert( { oh.l, oh.j2} );
     max_l = std::max(max_l, oh.l);
@@ -1250,17 +1447,20 @@ void ModelSpace::SetEmaxUnocc(int e)
     hole_quantum_numbers.insert( {l,2*l+1});
     if (l>0) hole_quantum_numbers.insert( {l,2*l-1} );
   }
+  std::set<std::array<int,4>> corelist, valencelist;
+  for ( auto c : core )
+  {
+    Orbit& oc = GetOrbit(c);
+    corelist.insert({oc.n,oc.l,oc.j2,oc.tz2});
+  }
+  for ( auto v : valence )
+  {
+    Orbit& ov = GetOrbit(v);
+    valencelist.insert({ov.n,ov.l,ov.j2,ov.tz2});
+  }
 
-//  std::cout << "hole quantum numbers: " << std::endl;
-//  for (auto& hqn : hole_quantum_numbers )
-//  {
-//    std::cout << hqn[0] << " " << hqn[1] << " " << hqn[2] << std::endl;
-//    std::cout << hqn[0] << " " << hqn[1]  << std::endl;
-//  }
-
-//  for ( auto h : holes ) holemap[h] = GetOrbit(h).occ;
-//  Init(Emax, holemap,c,v);
-  Init(Emax, holemap,core,valence);
+//  Init(Emax, holemap,core,valence);
+  Init(holemap,corelist,valencelist);
 
 }
 
@@ -1382,7 +1582,8 @@ double ModelSpace::GetSixJ(double j1, double j2, double j3, double J1, double J2
    else
    {
     sixj = AngMom::SixJ(j1,j2,j3,J1,J2,J3);
-    if (omp_get_num_threads()<2)
+//    if (omp_get_num_threads()<2)
+    if (not sixj_has_been_precalculated)
     {
       #pragma omp critical
       {
diff --git a/src/ModelSpace.hh b/src/ModelSpace.hh
index 810625f..07cd5b9 100755
--- a/src/ModelSpace.hh
+++ b/src/ModelSpace.hh
@@ -41,6 +41,7 @@ typedef unsigned long long int index_t;
 
 class ModelSpace; //forward declaration so Ket can use ModelSpace
 
+/////////////////////////////////////////////
 struct Orbit
 {
    int n;
@@ -62,6 +63,7 @@ struct Orbit
 
 
 
+/////////////////////////////////////////////
 struct Ket  //  | pq >
 {
    // Fields
@@ -85,6 +87,7 @@ struct Ket  //  | pq >
 };
 
 
+/////////////////////////////////////////////
 struct Ket3 // | p q r >
 {
   // Fields
@@ -112,6 +115,7 @@ struct Ket3 // | p q r >
 
 
 
+/////////////////////////////////////////////
 // This is now given its own implementation file, TwoBodyChannel.cc
 // but the header info stays here, because of the inextricable dependencies
 // between TwoBodyChannel, ModelSpace, Orbit, and Ket. What a mess...
@@ -180,6 +184,7 @@ struct TwoBodyChannel
 
 
 
+/////////////////////////////////////////////
 class TwoBodyChannel_CC : public TwoBodyChannel
 {
   public:
@@ -195,7 +200,7 @@ class TwoBodyChannel_CC : public TwoBodyChannel
 
 
 
-
+/////////////////////////////////////////////
 struct ThreeBodyChannel
 {
 
@@ -221,15 +226,11 @@ struct ThreeBodyChannel
    Ket3& GetKet(size_t iket) ;
    size_t GetNumberKets();
 
-
-
 };
 
 
 
 
-
-
 class ModelSpace
 {
  public:
@@ -253,7 +254,6 @@ class ModelSpace
 
    double dE3max; //  cut on three-body configurations which are considered in the IMSRG(3) commutators, taken relative to the fermi energy.
    double occnat3cut; //  cut on three-body configurations which are considered in the IMSRG(3) commutators, taken relative to the fermi energy.
-//   double e_fermi;    // The fermi energy, probably in oscillator units
    std::map<int,double> e_fermi;    // The fermi energy, probably in oscillator units. It's different for protons and neutrons, so index by tz
 
    int norbits;       // number of single-particle orbits (not counting the degenerate m-projections)
@@ -269,7 +269,6 @@ class ModelSpace
    std::vector<Ket3> Kets3;   // vector of three-body Ket3 structs
 
    std::map<std::array<int,3>,std::set<index_t> > OneBodyChannels;  // map that takes l,j,tz and gives a list of indicies of orbits with those quantum numbers
-//   std::map<std::array<int,3>,std::vector<index_t> > OneBodyChannels;
 
    int nTwoBodyChannels;  // number of two body channels J,parity,Tz
    std::vector<TwoBodyChannel> TwoBodyChannels;   // vector of TwoBodyChannel structs
@@ -293,16 +292,6 @@ class ModelSpace
    std::set<index_t> neutron_orbits;  // all the orbits with tz>0
    std::set<index_t> all_orbits;      // all of the orbits, for convenient looping
 
-//   std::vector<index_t> holes;           // in the reference Slater determinant
-//   std::vector<index_t> particles;       // above the reference Slater determinant
-//   std::vector<index_t> core;            // core for decoupling
-//   std::vector<index_t> valence;         // valence space for decoupling
-//   std::vector<index_t> qspace;          // above the valence space for decoupling
-//   std::vector<index_t> proton_orbits;
-//   std::vector<index_t> neutron_orbits;
-//   std::vector<index_t> all_orbits;
-
-//   std::set<std::array<int,3>> hole_quantum_numbers; // For checking if an orbit could mix with the hole orbits
    std::set<std::array<int,2>> hole_quantum_numbers; // For checking if an orbit could mix with the hole orbits
 
    std::vector<index_t> KetIndex_pp; 
@@ -345,7 +334,6 @@ class ModelSpace
 
 
    // Constructors
-//   ~ModelSpace();
    ModelSpace();
    ModelSpace(const ModelSpace&); // copy constructor
    ModelSpace( ModelSpace&&); // move constructor
@@ -361,34 +349,37 @@ class ModelSpace
 
    // Methods
 
-   void SetUpOrbits( );
+//   void SetUpOrbits( );
 
    void Init(int emax, std::string reference, std::string valence);
-   void Init(int emax, std::map<index_t,double> hole_list, std::string valence);
-   void Init(int emax, std::map<index_t,double> hole_list, std::vector<index_t> core_list, std::vector<index_t> valence_list);// keep this for backward-compatibility
-   void Init(int emax, std::map<index_t,double> hole_list, std::set<index_t> core_list, std::set<index_t> valence_list);
-   void Init(int emax, std::vector<std::string> hole_list, std::vector<std::string> core_list, std::vector<std::string> valence_list);
+//   void Init(int emax, std::map<index_t,double> hole_list, std::string valence);
+   void Init(int emax, std::map<std::array<int,4>,double> hole_list, std::string valence);
+//   void Init(int emax, std::map<index_t,double> hole_list, std::vector<index_t> core_list, std::vector<index_t> valence_list);// keep this for backward-compatibility
+//   void Init(int emax, std::map<index_t,double> hole_list, std::set<index_t> core_list, std::set<index_t> valence_list);
+   void Init( std::map<std::array<int,4>,double> hole_list, std::set<std::array<int,4>> core_list, std::set<std::array<int,4>> valence_list);
+   void Init(int emax, std::vector<std::string> hole_list, std::vector<std::string> core_list, std::vector<std::string> valence_list);// backward-compatibility
    void Init_occ_from_file(int emax, std::string valence, std::string occ_file);
    void InitSingleSpecies( int emax, std::string reference, std::string valence); // Work with just one type of fermion
-//   void InitSingleSpecies(int emax, std::string reference, std::string valence); // Work with just one type of fermion
 
-//   std::vector<index_t> GetOrbitsAZ(int A, int Z);
-   std::map<index_t,double> GetOrbitsAZ(int A, int Z);
+
+//   std::map<index_t,double> GetOrbitsAZ(int A, int Z);
+   std::map<std::array<int,4>,double> GetOrbitsAZ(int A, int Z);
    void GetAZfromString(std::string str, int& A, int& Z);
+   std::vector<std::array<int,4>> String2Qnumbers( std::vector<std::string> vs );
    std::vector<index_t> String2Index( std::vector<std::string> vs );
    std::string Index2String(index_t ind);
-   void Get0hwSpace(int Aref, int Zref, std::set<index_t>& core_list, std::set<index_t>& valence_list);
-//   void Get0hwSpace(int Aref, int Zref, std::vector<index_t>& core_list, std::vector<index_t>& valence_list);
-   void ParseCommaSeparatedValenceSpace(std::string valence, std::set<index_t>& core_list, std::set<index_t>& valence_list);
-//   void ParseCommaSeparatedValenceSpace(std::string valence, std::vector<index_t>& core_list, std::vector<index_t>& valence_list);
+   void Get0hwSpace(int Aref, int Zref, std::set<std::array<int,4>>& core_list, std::set<std::array<int,4>>& valence_list);
+//   void Get0hwSpace(int Aref, int Zref, std::set<index_t>& core_list, std::set<index_t>& valence_list);
+   void ParseCommaSeparatedValenceSpace(std::string valence, std::set<std::array<int,4>>& core_list, std::set<std::array<int,4>>& valence_list);
+//   void ParseCommaSeparatedValenceSpace(std::string valence, std::set<index_t>& core_list, std::set<index_t>& valence_list);
 
    void SetupKets();
    void Setup3bKets();
    void AddOrbit(Orbit orb);
-   void AddOrbit(int n, int l, int j2, int tz2, double occ, int io);
+   void AddOrbit(int n, int l, int j2, int tz2, double occ, int cvq);  // cvq: 0=>core, 1=>valence, 2=>qspace
+//   void AddOrbit(int n, int l, int j2, int tz2, double occ, int io);
    void FindEFermi();
    // Setter/Getters
-//   Orbit& GetOrbit(int i) {return (Orbit&) Orbits[i];}; 
    Orbit& GetOrbit(int i); 
    Ket& GetKet(int i) const {return (Ket&) Kets[i];};
    Ket& GetKet(int p, int q) const {return (Ket&) Kets[Index2(p,q)];};
@@ -414,6 +405,7 @@ class ModelSpace
    int GetAref() const {return Aref;};
    int GetZref() const {return Zref;};
    size_t GetNumberTwoBodyChannels() const {return TwoBodyChannels.size();};
+   size_t GetNumberTwoBodyChannels_CC() const {return TwoBodyChannels_CC.size();};
    size_t GetNumberThreeBodyChannels() const {return ThreeBodyChannels.size();};
 
    TwoBodyChannel& GetTwoBodyChannel(int ch) const {return (TwoBodyChannel&) TwoBodyChannels[ch];};
@@ -436,9 +428,7 @@ class ModelSpace
    int GetLmax3(){return Lmax3;};
    void SetEmax(int e){Emax=e;};
    void SetE2max(int e){E2max=e;};
-//   void SetE3max(int e){E3max=e;};
    void SetE3max(int e);
-//   void SetLmax(int l){Lmax=l;};
    void SetLmax(int l);
    void SetLmax2(int l){Lmax2=l;};
    void SetLmax3(int l){Lmax3=l;};
@@ -460,30 +450,20 @@ class ModelSpace
    size_t GetTwoBodyChannelIndex(int j, int p, int t);
    void UnpackTwoBodyChannelIndex( size_t ch, int& j, int& p, int& tz);
    int phase(int x) {return (x%2)==0 ? 1 : -1;};
-//   int phase(double x) {return phase(int(x));};
 
    
    size_t GetThreeBodyChannelIndex( int twoJ, int parity, int twoTz );
    std::array<size_t,2> CountThreeBodyStatesInsideCut();
-//   size_t CountThreeBodyStatesInsideCut();
-
 
-//   size_t Index1(int n, int l, int j2, int tz2) const {return(2*n+l)*(2*n+l+3) + 1-j2 + (tz2+1)/2 ;};
    size_t Index1(int n, int l, int j2, int tz2) const ;
    size_t Index1_hash(int n, int l, int j2, int tz2) const ;
-//   size_t Index1(int n, int l, int j2, int tz2) const { size_t indx = (2*n+l)*(2*n+l+3) + 1-j2 + (tz2+1)/2; return (single_species ? indx/2 : indx) ;};
-//   inline int Index2(int p, int q) const {return q*(q+1)/2 + p;};
-//   size_t Index2(size_t p, size_t q) const {return p*(2*norbits-1-p)/2 + q;};
    size_t Index2(size_t p, size_t q) const ;
-//   size_t Index2(size_t p, size_t q) const {return p*(2*all_orbits.size()-1-p)/2 + q;};
 
    void PreCalculateMoshinsky();
    void PreCalculateSixJ();
    void ClearVectors();
    void ResetFirstPass();
    void CalculatePandyaLookup(int rank_J, int rank_T, int parity); // construct a lookup table for more efficient pandya transformation
-//   map<array<int,2>,vector<array<int,2>>>& GetPandyaLookup(int rank_J, int rank_T, int parity);
-//   std::map<std::array<int,2>,std::array<std::vector<int>,2>>& GetPandyaLookup(int rank_J, int rank_T, int parity);
    std::map<std::array<size_t,2>,std::array<std::vector<size_t>,2>>& GetPandyaLookup(int rank_J, int rank_T, int parity);
    uint64_t SixJHash(double j1, double j2, double j3, double J1, double J2, double J3);
    void SixJUnHash(uint64_t key, uint64_t& j1, uint64_t& j2, uint64_t& j3, uint64_t& J1, uint64_t& J2, uint64_t& J3);
@@ -491,8 +471,6 @@ class ModelSpace
    void MoshinskyUnHash(uint64_t key,uint64_t& N,uint64_t& Lam,uint64_t& n,uint64_t& lam,uint64_t& n1,uint64_t& l1,uint64_t& n2,uint64_t& l2,uint64_t& L);
 
 
-
-
 };
 
 
diff --git a/src/Operator.cc b/src/Operator.cc
index 3715b07..ef0d579 100755
--- a/src/Operator.cc
+++ b/src/Operator.cc
@@ -484,23 +484,38 @@ Operator Operator::DoNormalOrdering2(int sign) const
 //Operator Operator::DoNormalOrdering3()
 Operator Operator::DoNormalOrdering3(int sign) const
 {
-   Operator opNO3 = Operator(*modelspace);
+//   Operator opNO3 = Operator(*modelspace);
+   if (rank_J>0)
+   {
+     std::cout << " Uh oh. Trying to call " << __func__ << "  on an operator with rank_J = " << rank_J << "   you should probably implement that first..." << std::endl;
+     std::exit(EXIT_FAILURE);
+   }
+   Operator opNO3 = Operator(*modelspace, rank_J, rank_T, parity,2);
 //   #pragma omp parallel for
    for ( auto& itmat : opNO3.TwoBody.MatEl )
    {
-      int ch = itmat.first[0]; // assume ch_bra = ch_ket for 3body...
-      TwoBodyChannel& tbc = modelspace->GetTwoBodyChannel(ch);
+//      int ch = itmat.first[0]; // assume ch_bra = ch_ket for 3body...
+      int ch_bra = itmat.first[0]; // assume ch_bra = ch_ket for 3body...
+      int ch_ket = itmat.first[1]; // assume ch_bra = ch_ket for 3body...
+//      TwoBodyChannel& tbc = modelspace->GetTwoBodyChannel(ch);
+      TwoBodyChannel& tbc_bra = modelspace->GetTwoBodyChannel(ch_bra);
+      TwoBodyChannel& tbc_ket = modelspace->GetTwoBodyChannel(ch_ket);
       arma::mat& Gamma = (arma::mat&) itmat.second;
-      for (size_t ibra=0; ibra<tbc.GetNumberKets(); ++ibra)
+//      for (size_t ibra=0; ibra<tbc.GetNumberKets(); ++ibra)
+      for (size_t ibra=0; ibra<tbc_bra.GetNumberKets(); ++ibra)
       {
-         Ket & bra = tbc.GetKet(ibra);
+//         Ket & bra = tbc.GetKet(ibra);
+         Ket & bra = tbc_bra.GetKet(ibra);
          int i = bra.p;
          int j = bra.q;
          Orbit & oi = modelspace->GetOrbit(i);
          Orbit & oj = modelspace->GetOrbit(j);
-         for (size_t iket=ibra; iket<tbc.GetNumberKets(); ++iket)
+         size_t iket_min = ch_bra==ch_ket ? ibra  : 0;
+//         for (size_t iket=ibra; iket<tbc.GetNumberKets(); ++iket)
+         for (size_t iket=iket_min; iket<tbc_ket.GetNumberKets(); ++iket)
          {
-            Ket & ket = tbc.GetKet(iket);
+//            Ket & ket = tbc.GetKet(iket);
+            Ket & ket = tbc_ket.GetKet(iket);
             int k = ket.p;
             int l = ket.q;
             Orbit & ok = modelspace->GetOrbit(k);
@@ -510,14 +525,18 @@ Operator Operator::DoNormalOrdering3(int sign) const
                Orbit & oa = modelspace->GetOrbit(a);
                if ( (2*(oi.n+oj.n+oa.n)+oi.l+oj.l+oa.l)>E3max) continue;
                if ( (2*(ok.n+ol.n+oa.n)+ok.l+ol.l+oa.l)>E3max) continue;
-               int kmin2 = abs(2*tbc.J-oa.j2);
-               int kmax2 = 2*tbc.J+oa.j2;
+//               int kmin2 = abs(2*tbc.J-oa.j2);
+//               int kmax2 = 2*tbc.J+oa.j2;
+               int kmin2 = abs(2*tbc_bra.J-oa.j2);
+               int kmax2 = 2*tbc_bra.J+oa.j2;
                for (int K2=kmin2; K2<=kmax2; K2+=2)
                {
-                  Gamma(ibra,iket) += (K2+1) * sign*oa.occ * ThreeBody.GetME_pn(tbc.J,tbc.J,K2,i,j,a,k,l,a); // This is unnormalized, but it should be normalized!!!!
+//                  Gamma(ibra,iket) += (K2+1) * sign*oa.occ * ThreeBody.GetME_pn(tbc.J,tbc.J,K2,i,j,a,k,l,a); // This is unnormalized.
+                  Gamma(ibra,iket) += (K2+1) * sign*oa.occ * ThreeBody.GetME_pn(tbc_bra.J,tbc_ket.J,K2,i,j,a,k,l,a); // This is unnormalized.
                }
             }
-            Gamma(ibra,iket) /= (2*tbc.J+1)* sqrt((1+bra.delta_pq())*(1+ket.delta_pq()));
+//            Gamma(ibra,iket) /= (2*tbc.J+1)* sqrt((1+bra.delta_pq())*(1+ket.delta_pq()));
+            Gamma(ibra,iket) /= (2*tbc_bra.J+1)* sqrt((1+bra.delta_pq())*(1+ket.delta_pq()));
          }
       }
    }
@@ -1211,7 +1230,7 @@ double Operator::GetMP2_3BEnergy()
      {
        Ket3& bra = Tbc.GetKet(ibra);
        double occ_bra = (bra.op->occ) * (bra.oq->occ) * (bra.oR->occ);
-       if ( std::abs(occ_bra)<1e-3) continue;
+       if ( std::abs(occ_bra)<1e-9) continue;
        size_t i = bra.p;
        size_t j = bra.q;
        size_t k = bra.r;
@@ -1223,7 +1242,7 @@ double Operator::GetMP2_3BEnergy()
        {
          Ket3& ket = Tbc.GetKet(iket);
          double unocc_ket = (1-ket.op->occ) * (1-ket.oq->occ) * (1-ket.oR->occ);
-         if ( std::abs(unocc_ket)<1e-3) continue;
+         if ( std::abs(unocc_ket)<1e-9) continue;
          size_t a = ket.p;
          size_t b = ket.q;
          size_t c = ket.r;
diff --git a/src/Parameters.hh b/src/Parameters.hh
index 0cfa8fd..7e373a1 100755
--- a/src/Parameters.hh
+++ b/src/Parameters.hh
@@ -53,15 +53,17 @@ class Parameters
 };
 
 std::map<std::string,std::string> Parameters::string_par = {
-  {"2bme",			"none"},
-  {"3bme",			"none"},
-  {"3bme_type",			"full"},
+  {"2bme",			"none"},        // name of file containing 2-body matrix elements
+  {"3bme",			"none"},        // name of file containing 3-body matrix elements
+  {"3bme_type",			"full"},        // are the 3-body matrix elements in NO2B format, or do we get all of them (full)?
+  {"no2b_precision",		"single"},      // if we use the no2b file type, do we store with single precision, or half precision?
   {"core_generator",		"atan"},	// generator used for core part of 2-step decoupling
   {"valence_generator",		"shell-model-atan"},	// generator used for valence decoupling and 1-step (also single-ref)
   {"flowfile",			"default"},	// name of output flow file
   {"intfile",			"default"},	// name of output interaction fille
   {"fmt2",			"me2j"},	// can also be navratil or Navratil to read Petr's TBME format
   {"fmt3",			"me3j"},	// can also be navratil or Navratil to read Petr's TBME format
+  {"input_op_fmt",		"navratil"},	// navratil means read Petr Navratil's format for 2b currents. miyagi means Takayuki Miyagi's format.
   {"reference",			"default"},	// nucleus used for HF and normal ordering.
   {"valence_space",		""},		// either valence space or nucleus for single reference
   {"custom_valence_space",      ""},		// if the provided valence spaces just aren't good enough for you
@@ -78,15 +80,17 @@ std::map<std::string,std::string> Parameters::string_par = {
   {"nucleon_mass_correction",	"false"},	// include effect of proton-neutron mass splitting
   {"hunter_gatherer",	        "false"},	// use hunter-gatherer approach to splitting omega
   {"relativistic_correction",   "false"},       // include the p^4 relativistic correction to the kinetic energy
-  {"IMSRG3",                    "false"},       // include 3-body terms in commutators. this is under construction still...
+  {"IMSRG3",                    "false"},       // include 3-body terms in commutators.
+  {"imsrg3_n7",                 "false"},       // include only n^7 scaling 3-body terms in commutators. Only does something if IMSRG3=true.
   {"physical_system",           "nuclear"},     // treat nucleus or atom. For atom, switch units from MeV,fm to eV,nm.
   {"freeze_occupations",        "false"},       // Should we freeze the occupations, or fill according to HF energy
   {"use_NAT_occupations",       "false"},       // When using natural orbitals, should we use the corresponding occupations?
   {"store_3bme_pn",             "false"},       // should the 3-body matrix elements be stored in proton-neutron formalism? Default is isospin.
   {"discard_residual_input3N",  "false"},       // If we're doing IMSRG3, should we discard the residual input 3N (only keep induced)?
-  {"only_2b_eta",               "false"},       // If we're doing IMSRG3, keep eta as 2b 
-  {"only_2b_omega",             "false"},       // If we're doing IMSRG3, keep omega (the magnus operator) as 2b 
-  {"perturbative_triples",      "false"},       // Compute perturbative energy shift due to [2,2]->3 induced 3-body 
+  {"only_2b_eta",               "false"},       // If we're doing IMSRG3, keep eta as 2b
+  {"only_2b_omega",             "false"},       // If we're doing IMSRG3, keep omega (the magnus operator) as 2b
+  {"perturbative_triples",      "false"},       // Compute perturbative energy shift due to [2,2]->3 induced 3-body
+  {"operator_evolution", "true"}, // operator evolution "false", "basis", "true"
 };
 
 
diff --git a/src/ReadWrite.cc b/src/ReadWrite.cc
index 722b9ea..fa3601f 100755
--- a/src/ReadWrite.cc
+++ b/src/ReadWrite.cc
@@ -709,7 +709,7 @@ void ReadWrite::Read_Darmstadt_3body( std::string filename, Operator& Hbare, int
 
   double start_time = omp_get_wtime();
   std::string extension = filename.substr( filename.find_last_of("."));
-  File3N = filename;
+//  File3N = filename;
   Aref = Hbare.GetModelSpace()->GetAref();
   Zref = Hbare.GetModelSpace()->GetZref();
 
@@ -788,7 +788,7 @@ void ReadWrite::Read_Darmstadt_3body( std::string filename, Operator& Hbare, int
 
 
 
-/// Read TBME's from a file formatted by the Darmstadt group.
+/// Read TBMEs from a file formatted by the Darmstadt group.
 /// The file contains just the matrix elements, and the corresponding quantum numbers
 /// are inferred. This means that the model space of the file must also be specified.
 /// emax refers to the maximum single-particle oscillator shell. Emax refers to the
@@ -1168,7 +1168,8 @@ void ReadWrite::ReadBareTBME_Darmstadt_from_stream( T& infile, Operator& Hbare,
 /// Read me3j format three-body matrix elements. Pass in E1max, E2max, E3max for the file, so that it can be properly interpreted.
 /// The modelspace truncation doesn't need to coincide with the file truncation. For example, you could have an emax=10 modelspace
 /// and read from an emax=14 file, and the matrix elements with emax>10 would be ignored.
-size_t ReadWrite::Count_Darmstadt_3body_to_read( Operator& Hbare, int E1max, int E2max, int E3max, std::vector<int>& orbits_remap, std::vector<size_t>& nread_list)
+//size_t ReadWrite::Count_Darmstadt_3body_to_read( Operator& Hbare, int E1max, int E2max, int E3max, std::vector<int>& orbits_remap, std::vector<size_t>& nread_list)
+size_t ReadWrite::Count_Darmstadt_3body_to_read( Operator& Hbare, int E1max_in, int E2max_in, int E3max_in, std::vector<int>& orbits_remap, std::vector<size_t>& nread_list)
 {
   double t_start = omp_get_wtime();
 //  if ( !infile.good() )
@@ -1192,8 +1193,25 @@ size_t ReadWrite::Count_Darmstadt_3body_to_read( Operator& Hbare, int E1max, int
   int e2max = modelspace->GetE2max(); // not used yet
   int e3max = modelspace->GetE3max();
 //  int lmax3 = modelspace->GetLmax3();
+  int E1max = E1max_in;
+  int E2max = E2max_in;
+  int E3max = E3max_in;
+//  if (Hbare.GetTRank()>0)
+//  {
+//    E1max = 2;
+//    E2max = 4;
+//    E3max = 2;
+//  }
   std::cout << "Reading 3body file. emax limits for file: " << E1max << " " << E2max << " " << E3max << "  for modelspace: " << e1max << " " << e2max << " " << e3max << std::endl;
 
+//  int iso_dim = Hbare.ThreeBody.ISOSPIN_BLOCK_DIMENSION;
+  int iso_dim = Hbare.ThreeBody.isospin3BME.ISOSPIN_BLOCK_DIMENSION;
+//  int iso_dim = 5;
+//  if (Hbare.GetTRank()==1) iso_dim=9;
+//  else if (Hbare.GetTRank()==2) iso_dim==5;
+//  else if (Hbare.GetTRank()==3) iso_dim==1;
+//  std::cout << " Isospin block dimension = " << iso_dim << std::endl;
+
 //  std::vector<int> orbits_remap(0);
   orbits_remap.clear();
 //  nread_list.clear();
@@ -1318,7 +1336,7 @@ size_t ReadWrite::Count_Darmstadt_3body_to_read( Operator& Hbare, int E1max, int
 
                 // read all the ME for this range of J,T into block
                 if (twoJCMin>twoJCMax) continue;
-                size_t blocksize = ((twoJCMax-twoJCMin)/2+1)*5;
+                size_t blocksize = ((twoJCMax-twoJCMin)/2+1) * iso_dim;
                 nread += blocksize;
 
 
@@ -1338,10 +1356,14 @@ size_t ReadWrite::Count_Darmstadt_3body_to_read( Operator& Hbare, int E1max, int
 }
 
 template <class T>
-void ReadWrite::Read_Darmstadt_3body_from_stream( T& infile, Operator& Hbare, int E1max, int E2max, int E3max)
+void ReadWrite::Read_Darmstadt_3body_from_stream( T& infile, Operator& Hbare, int E1max_in, int E2max_in, int E3max_in)
 {
 
   double t_start = omp_get_wtime();
+  int E1max = E1max_in;
+  int E2max = E2max_in;
+  int E3max = E3max_in;
+
   if ( !infile.good() )
   {
      std::cerr << "************************************" << std::endl
@@ -1350,10 +1372,11 @@ void ReadWrite::Read_Darmstadt_3body_from_stream( T& infile, Operator& Hbare, in
      goodstate = false;
      return;
   }
+//  std::cout << "input operator has particle rank = " << Hbare.GetParticleRank() << std::endl;
   if (Hbare.particle_rank < 3)
   {
     std::cerr << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! << " << std::endl;
-    std::cerr << " Oops. Looks like we're trying to read 3body matrix elements to a " << Hbare.particle_rank << "-body operator. For shame..." << std::endl;
+    std::cerr << " Line " << __LINE__ <<  " Oops. Looks like we're trying to read 3body matrix elements to a " << Hbare.particle_rank << "-body operator. For shame..." << std::endl;
     std::cerr << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! << " << std::endl;
     goodstate = false;
     return;
@@ -1361,6 +1384,33 @@ void ReadWrite::Read_Darmstadt_3body_from_stream( T& infile, Operator& Hbare, in
   ModelSpace * modelspace = Hbare.GetModelSpace();
   std::vector<int> orbits_remap;
   std::vector<size_t> nread_list;
+
+  // If it's me3j, read the header, and if it's Takayuki's format, read the other header to get Emax info
+  if (format3N == "me3j")
+  {
+    char line[LINESIZE];
+    infile.getline(line,LINESIZE);  // read the header
+    if ( Hbare.GetTRank() > 0 ) // It's not a Hamiltonian at all! It's a beta decay operator (probably).
+    {
+
+       float opJ,opP,opT,efil,e2fil,e3fil,lmaxfil;
+//       int opJ,opP,opT,efil,e2fil,e3fil,lmaxfil;
+       infile >> opJ >> opP >> opT >> efil >> e2fil >> e3fil >> lmaxfil; // There's an extra header line with useful information.
+       E1max = int(efil);
+       E2max = int(e2fil);
+       E3max = int(e3fil);
+       if ( (int(opJ) != Hbare.GetJRank())  or  (int(opT) != Hbare.GetTRank())  or  ((1-int(opP))/2 != Hbare.GetParity()) )
+       {
+         std::cout << "!!!!!!  DANGER!! The header for this 3-body file says JpT = " << opJ << " " << opP << " " << opT << "  and that doesn't match the operator, which has " << Hbare.GetJRank() << " " << Hbare.GetParity() << " " << Hbare.GetTRank()  << std::endl;
+        std::exit(EXIT_FAILURE);
+       }
+
+    }
+  }
+
+
+
+
   size_t nread = Count_Darmstadt_3body_to_read( Hbare, E1max, E2max, E3max, orbits_remap, nread_list);
 
 
@@ -1371,15 +1421,7 @@ void ReadWrite::Read_Darmstadt_3body_from_stream( T& infile, Operator& Hbare, in
 //  #define BUFFSIZE3N 1024*1000
   if (format3N == "me3j")
   {
-    char line[LINESIZE];
-    infile.getline(line,LINESIZE);  // read the header
-//    char buff[BUFFSIZE3N];
-//    size_t read_so_far = 0;
-//    while (read_so_far < nread and infile.good())
-//    {
-//      infile.read(buff, BUFFSIZE3N);
-//   //.... other stuff...
-//    }
+
     for (size_t i=0;i<nread;++i) infile >> ThreeBME[i];
   }
   else if (format3N == "navratil" or format3N == "Navratil")
@@ -1418,25 +1460,17 @@ void ReadWrite::Store_Darmstadt_3body( const std::vector<float>& ThreeBME, const
   int e3max = modelspace->GetE3max();
   int lmax3 = modelspace->GetLmax3();
   int lmax = modelspace->GetLmax();
-//  std::cout << "Reading 3body file. emax limits for file: " << E1max << " " << E2max << " " << E3max << "  for modelspace: " << e1max << " " << e2max << " " << e3max << std::endl;
+  int iso_dim = Hbare.ThreeBody.isospin3BME.ISOSPIN_BLOCK_DIMENSION;
+  // if opT=0,  then we can have (tab Tabc, tde, Tdef) = (0,1,0,1), (0,1,1,1), (1,1,0,1), (1,1,1,1), (1,3,1,3) => 5
+  // if opT=1,  then we can have (tab Tabc, tde, Tdef) = (0,1,0,1), (0,1,1,1), (0,1,1,3), (1,1,0,1), (1,1,1,1), (1,1,1,3), (1,3,1,3), (1,3,1,1), (1,3,1,3) => 9
+  // if opT=2,  then we can have (tab Tabc, tde, Tdef) = (0,1,1,3),  (1,1,1,3), (1,3,1,3), (1,3,1,1), (1,3,1,3) => 5
+  // if opT=3,  then we can have (tab Tabc, tde, Tderf = (1,3,1,3) => 1
+//  if (Hbare.GetTRank()==1) iso_dim=9;
+//  else if (Hbare.GetTRank()==2) iso_dim=5;
+//  else if (Hbare.GetTRank()==3) iso_dim=1;
+
+  std::cout << __func__ << "  begin storing. file limits = " << E1max << " " << E2max << " " << E3max  << std::endl;
 
-//  std::vector<int> orbits_remap(0);
-//  int lmax = E1max; // haven't yet implemented the lmax truncation for 3body. Should be easy.
-//
-//  for (int e=0; e<=std::min(E1max,e1max); ++e)
-//  {
-//    int lmin = e%2;
-//    for (int l=lmin; l<=std::min(e,lmax); l+=2)
-//    {
-//      int n = (e-l)/2;
-//      int twojMin = std::abs(2*l-1);
-//      int twojMax = 2*l+1;
-//      for (int twoj=twojMin; twoj<=twojMax; twoj+=2)
-//      {
-//         orbits_remap.push_back( modelspace->GetOrbitIndex(n,l,twoj,-1) );
-//      }
-//    }
-//  }
   int nljmax = orbits_remap.size();
 
 
@@ -1444,23 +1478,13 @@ void ReadWrite::Store_Darmstadt_3body( const std::vector<float>& ThreeBME, const
   // begin giant nested loops
   size_t nkept = 0;
   modelspace->PreCalculateSixJ(); // Get all the sixJ so we don't have to worry about threading issues
-  // combine the first two loops into one to better utilize more threads
-//  #pragma omp parallel for schedule(dynamic,1) reduction(+ : nkept)
-//  for (int index12=0; index12< nljmax*(nljmax+1)/2; ++index12)
-//  {
   #pragma omp parallel for schedule(dynamic,1) reduction(+ : nkept)
   for(int nlj1=0; nlj1<nljmax; ++nlj1)
   {
-//    int nlj1 = int( (sqrt(8*index12+1)-1)/2);
-//    int nlj2 = index12 - nlj1*(nlj1+1)/2;
-//    size_t nread = nread_list[index12];
     size_t nread = nread_list[nlj1];
     int a =  orbits_remap[nlj1];
     Orbit & oa = modelspace->GetOrbit(a);
     int ea = 2*oa.n + oa.l;
-//    if (ea > E1max) break;
-//    if (ea > e1max) break;
-//    if (ea > e3max) break;
     if (ea > E1max) continue;
     if (ea > e1max) continue;
     if (ea > e3max) continue;
@@ -1484,13 +1508,14 @@ void ReadWrite::Store_Darmstadt_3body( const std::vector<float>& ThreeBME, const
         int JabMax  = (oa.j2 + ob.j2)/2;
         int JabMin  = std::abs(oa.j2 - ob.j2)/2;
 
-        int twoJCMindownbra;
-        if (std::abs(oa.j2 - ob.j2) >oc.j2)
-           twoJCMindownbra = std::abs(oa.j2 - ob.j2)-oc.j2;
-        else if (oc.j2 < (oa.j2+ob.j2) )
-           twoJCMindownbra = 1;
-        else
-           twoJCMindownbra = oc.j2 - oa.j2 - ob.j2;
+        int twoJCMindownbra = std::max( std::abs(oa.j2-ob.j2)-oc.j2,   std::max( oc.j2-oa.j2-ob.j2 , 1 ) );
+//        int twoJCMindownbra;
+//        if (std::abs(oa.j2 - ob.j2) >oc.j2)
+//           twoJCMindownbra = std::abs(oa.j2 - ob.j2)-oc.j2;
+//        else if (oc.j2 < (oa.j2+ob.j2) )
+//           twoJCMindownbra = 1;
+//        else
+//           twoJCMindownbra = oc.j2 - oa.j2 - ob.j2;
         int twoJCMaxupbra = oa.j2 + ob.j2 + oc.j2;
 
 
@@ -1521,13 +1546,15 @@ void ReadWrite::Store_Darmstadt_3body( const std::vector<float>& ThreeBME, const
               int JJabMax = (od.j2 + oe.j2)/2;
               int JJabMin = std::abs(od.j2 - oe.j2)/2;
 
-              int twoJCMindownket;
-              if ( std::abs(od.j2 - oe.j2) > of.j2 )
-                 twoJCMindownket = std::abs(od.j2 - oe.j2) - of.j2;
-              else if ( of.j2 < (od.j2+oe.j2) )
-                 twoJCMindownket = 1;
-              else
-                 twoJCMindownket = of.j2 - od.j2 - oe.j2;
+              int twoJCMindownket = std::max( std::abs(od.j2-oe.j2)-of.j2,   std::max( of.j2-od.j2-oe.j2 , 1 ) );
+//              int twoJCMindownket;
+//              if ( std::abs(od.j2 - oe.j2) > of.j2 )
+//                 twoJCMindownket = std::abs(od.j2 - oe.j2) - of.j2;
+//              else twoJCMindownket = std::max( of.j2-od.j2-oe.j2 ,  1);
+//              else if ( of.j2 < (od.j2+oe.j2) )
+//                 twoJCMindownket = 1;
+//              else
+//                 twoJCMindownket = of.j2 - od.j2 - oe.j2;
 
               int twoJCMaxupket = od.j2 + oe.j2 + of.j2;
 
@@ -1546,24 +1573,40 @@ void ReadWrite::Store_Darmstadt_3body( const std::vector<float>& ThreeBME, const
 
                 // read all the ME for this range of J,T into block
                 if (twoJCMin>twoJCMax) continue;
-                size_t blocksize = ((twoJCMax-twoJCMin)/2+1)*5;
+//                size_t blocksize = ((twoJCMax-twoJCMin)/2+1)*5;
+                size_t blocksize = ((twoJCMax-twoJCMin)/2+1) * iso_dim ;
 
 //                 std::array<double,5> isospin_5plet = {0,0,0,0,0};
-                for(int JTind = 0; JTind <= (twoJCMax-twoJCMin)+1; JTind++)
+                for ( int twoJC=twoJCMin; twoJC<=twoJCMax; twoJC+=2 )
+//                for(int JTind = 0; JTind <= (twoJCMax-twoJCMin)+1; JTind++)
                 {
-                 int twoJC = twoJCMin + (JTind/2)*2;
-                 int twoT = 1+(JTind%2)*2;
+//                 int twoJC = twoJCMin + (JTind/2)*2;
+//                 int twoT = 1+(JTind%2)*2;
+                 // now we loop through (tab,ttab,twoT) = (0,0,1), (0,1,1), (1,0,1), (1,1,1), (1,1,3)
 //                 if (twoT==1) isospin_5plet = {0,0,0,0,0};
+                 size_t Tcounter = 0;
                  for(int tab = 0; tab <= 1; tab++) // the total isospin loop can be replaced by i+=5
                  {
                   for(int ttab = 0; ttab <= 1; ttab++)
                   {
                    //summation bounds
-                   if ( twoT > std::min( 2*tab+1, 2*ttab+1) ) continue;
+//                   if ( twoT > std::min( 2*tab+1, 2*ttab+1) ) continue;
 //                   int twoTMin = 1; // twoTMin can just be used as 1
+//                   int twoTTMin = 1; // twoTMin can just be used as 1
 //                   int twoTMax = std::min( 2*tab +1, 2*ttab +1);
+//                   int twoTMax  = 2*tab +1;
+//                   int twoTTMax =  2*ttab +1;
+                   for (int twoT=1; twoT<=2*tab+1; twoT+=2)
+                   {
+                    for (int twoTT=1; twoTT<=2*ttab+1; twoTT+=2)
+                    {
+                      if ( ( std::abs(twoT-twoTT)>2*Hbare.GetTRank() ) or ( (twoT+twoTT) < 2*Hbare.GetTRank() ) ) continue;
+
+//                    size_t index_ab =  iso_dim*(twoJC-twoJCMin)/2+2*tab+ttab+(twoT-1)/2;
+                      size_t index_ab =  iso_dim*(twoJC-twoJCMin)/2 + Tcounter;
+                      Tcounter++;
+
 
-                    size_t index_ab = 5*(twoJC-twoJCMin)/2+2*tab+ttab+(twoT-1)/2;
                     if (nread+index_ab >=ThreeBME.size())
                     {
                       std::cout << "OH NO!!! trying to access element " << nread << "+" << index_ab << " = " << nread+index_ab << "  which is >= "<< ThreeBME.size() << std::endl;
@@ -1574,7 +1617,6 @@ void ReadWrite::Store_Darmstadt_3body( const std::vector<float>& ThreeBME, const
                     if (oa.l>lmax3 or ob.l>lmax3 or oc.l>lmax3 or od.l>lmax3 or oe.l>lmax3 or of.l>lmax3) V=0;
                     if (oa.l>lmax or ob.l>lmax or oc.l>lmax or od.l>lmax or oe.l>lmax or of.l>lmax) V=0;
 
-//                    if (a==99999 or b==99999 or c==99999 or d==99999 or e==99999 or f==99999) continue;
                     if (a==ModelSpace::NOT_AN_ORBIT or b==ModelSpace::NOT_AN_ORBIT or c==ModelSpace::NOT_AN_ORBIT
                      or d==ModelSpace::NOT_AN_ORBIT or e==ModelSpace::NOT_AN_ORBIT or f==ModelSpace::NOT_AN_ORBIT) continue;
 
@@ -1582,7 +1624,8 @@ void ReadWrite::Store_Darmstadt_3body( const std::vector<float>& ThreeBME, const
                     if ( ( a==b and (tab+Jab)%2==0 )
                       or ( d==e and (ttab+JJab)%2==0 )
                       or ( a==b and a==c and twoT==3 and oa.j2<3 )
-                      or ( d==e and d==f and twoT==3 and od.j2<3 )) autozero = true;
+                      or ( d==e and d==f and twoTT==3 and od.j2<3 )) autozero = true;
+
 
                     if(ea<=e1max and eb<=e1max and ec<=e1max and ed<=e1max and ee<=e1max and ef<=e1max
                           and (ea+eb+ec<=e3max) and (ed+ee+ef<=e3max) )
@@ -1592,39 +1635,27 @@ void ReadWrite::Store_Darmstadt_3body( const std::vector<float>& ThreeBME, const
                       {
                         if (not autozero )
                         {
-//                            std::cout << a << " " << b << " " << c << " " << d << " " << e << " " << f << " " << Jab << " " << JJab << " " << twoJC << " " << tab << " " << ttab << " " << twoT << " " << V << std::endl;
-//                            if (a==4 and b==0 and c==0 and d==4 and e==0 and f==0)
+//                            Hbare.ThreeBody.SetME(Jab,JJab,twoJC,tab,ttab,twoT,a,b,c,d,e,f, V);
+//                            if ( Hbare.GetTRank()>0)
 //                            {
-//                               std::cout << std::endl << __func__ << "  setting Jab,Jde,J " << Jab << " " <<JJab << " " << twoJC << "  tab tde T  " << tab << " " << ttab << " " << twoT << "    V = " << V << std::endl;
+//                            std::cout << "Setting  " << Jab << " " << JJab << " " << twoJC << " " << tab << " " << ttab << " " << twoT << " " << twoTT
+//                                      << "   " << a << " " << b << " " << c << " " << d << " " << e << " " << f << "    ->  " << std::scientific << V << std::endl;
 //                            }
-//                               if ( a==2 and b==4 and c==4 and d==2 and e==0 and f==0 and tab==1 and ttab==1 and twoT==3 and JJab==1 and twoJC==3)
-//                               {
-////                                 std::cout << "t t T = " << tab << " " << ttab << " " << twoT << "   V = " << V << std::endl;
-//                                 std::cout << "found one Jab = " << Jab << "   V = " << V << std::endl;
-//                               }
-                            Hbare.ThreeBody.SetME(Jab,JJab,twoJC,tab,ttab,twoT,a,b,c,d,e,f, V);
-                         //     isospin_5plet[ 2*tab+ttab+(twoT-1)/2 ] = V;
-//                              std::cout << "5plet index " << 2*tab +ttab + (twoT-1)/2 << "  with " << tab << " " << ttab << " " << twoT << std::endl;
+                            Hbare.ThreeBody.SetME(Jab,JJab,twoJC,tab,ttab,twoT,twoTT,a,b,c,d,e,f, V);
                         }
                         else if (autozero)
                         {
-                            printf(" <--------- AAAHHHH!!!!!! Reading 3body file. <%d %d %d  %d %d |V| %d %d %d  %d %d>_(%d %d) should be zero but its %f.  nread = %lu index_ab = %lu\n",a,b,c,Jab,tab,d,e,f,JJab,ttab,twoJC,twoT,V,nread,index_ab);
-//                              std::cout << " <-------- AAAAHHHH!!!!!!!! Reading 3body file and this should be zero, but it's " << V << std::endl;
-//                            std::cout << a << " " << b << " " << c << " " << d << " " << e << " " << f << " " << Jab << " " << JJab << " " << twoJC << " " << tab << " " << ttab << " " << twoT << " " << V << std::endl;
-//                            std::cout << "nread = " << nread << "  index_ab = " << index_ab << std::endl;
-                              goodstate = false;
+                            printf(" <--------- AAAHHHH!!!!!! Reading 3body file. <%d %d %d  %d %d  %d |V| %d %d %d  %d %d  %d>_(%d) should be zero but its %f.  nread = %lu index_ab = %lu\n",a,b,c,Jab,tab,twoT,d,e,f,JJab,ttab,twoTT,twoJC,V,nread,index_ab);
+//                            printf(" <--------- AAAHHHH!!!!!! Reading 3body file. <%d %d %d  %d %d |V| %d %d %d  %d %d>_(%d %d) should be zero but its %f.  nread = %lu index_ab = %lu\n",a,b,c,Jab,tab,d,e,f,JJab,ttab,twoJC,twoT,V,nread,index_ab);
+                            goodstate = false;
                         }
                       }
                     }
 
+                    }//twoTT
+                   }//twoT
                   }//ttab
                  }//tab
-//                 std::cout << "Calling SetME_isospin5" << std::endl;
-//                 if (twoT==3)
-//                 {
-//                   std::cout << "---------- ReadWrite  call SetME_isospin5, Jab Jde twoJ = " << Jab << " " << JJab << " " << twoJC << " -----------" << std::endl;
-//                   Hbare.ThreeBody.SetME_isospin5(Jab,JJab,twoJC,a,b,c,d,e,f,isospin_5plet);
-//                 }
                 }//twoJ
                 nread += blocksize;
                }//JJab
@@ -1882,7 +1913,7 @@ void ReadWrite::Read3bodyHDF5( std::string filename,Operator& op )
        }
 
        me *= 0.5; // According to Heiko, this shouldn't be here. But comparing matrix elements with Petr's interaction suggests otherwise.
-       me *= modelspace->phase(oa.n+ob.n+oc.n+od.n+oe.n+of.n); // shamelessly copying Heiko. I don't understand this.
+       me *= modelspace->phase(oa.n+ob.n+oc.n+od.n+oe.n+of.n); // shamelessly copying Heiko. Presumably a different HO convention is used.
 
        op.ThreeBody.SetME(J12,JJ12,twoJ,T12,TT12,twoT,a,b,c,d,e,f, me);
        if (a==d and b==e and c==f and ( J12!=JJ12 ) )
@@ -2166,7 +2197,7 @@ void ReadWrite::ReadDarmstadt_2bodyRel( std::string filename, Operator& Op )
   int emax = Op.modelspace->Emax;
   infile.ignore(1024,'\n'); // skip header
   int n1,l1,n2,l2,S,J,T,Tz;
-  double v; 
+  double v;
   // channels are labeled by S,J,T,Tz
   std::unordered_map<size_t,arma::mat> Vrel;
   // allocate that bad boy
@@ -2245,7 +2276,7 @@ void ReadWrite::ReadDarmstadt_2bodyRel( std::string filename, Operator& Op )
           for (int Sab=0; Sab<=1; ++Sab)
           {
             if ( std::abs(Lab-Sab)>J or Lab+Sab<J) continue;
-     
+
             double njab = AngMom::NormNineJ(la,sa,ja, lb,sb,jb, Lab,Sab,J);
             if (njab == 0) continue;
             int Scd = Sab;
@@ -2941,6 +2972,9 @@ void ReadWrite::WriteNuShellX_intfile(Operator& op, std::string filename, std::s
    // then neutrons
    for ( auto i : valence_neutrons ) orb2nushell[i] = counter++;
    for ( auto& it : orb2nushell) nushell2orb[it.second] = it.first;
+   std::cout << "  Valence protons are :";
+   for ( auto i : valence_protons ) std::cout << i << " ";
+   std::cout << std::endl;
 
    // Get A of the core
    int Acore=0;
@@ -4288,7 +4322,7 @@ void ReadWrite::WriteValence3body( ThreeBodyMEpn& threeBME, std::string filename
       intfile << "!  " << it.first << "   " << oi.n << " " << oi.l << " " << oi.j2 << "/2" << " " << oi.tz2 << "/2" << std::endl;
    }
    intfile << "!" << std::endl;
-   intfile << "!" << std::setw(wint-1) << "a" << " " << std::setw(wint) << "b" << " " << std::setw(wint) <<"c" 
+   intfile << "!" << std::setw(wint-1) << "a" << " " << std::setw(wint) << "b" << " " << std::setw(wint) <<"c"
            << " " << std::setw(wint) << "d" << " " << std::setw(wint) << "e" << " " << std::setw(wint)
            << "f" << "   " << std::setw(wint)  << "Jab" << " " << std::setw(wint) << "Jde"
            << " " << std::setw(wint) << "2J" << "      "
@@ -4960,8 +4994,8 @@ void ReadWrite::WriteTokyo(Operator& op, std::string filename, std::string mode)
   intfile.open(filename, std::ofstream::out);
   ModelSpace * modelspace = op.GetModelSpace();
   int wint = 4; // width for printing integers
-  int wdouble = 12; // width for printing doubles
-  int pdouble = 6; // precision for printing doubles
+  int wdouble = 18; // width for printing doubles
+  int pdouble = 8; // precision for printing doubles
   std::vector<int> valence_protons(modelspace->valence.size());
   std::vector<int> valence_neutrons(modelspace->valence.size());
   auto it = set_intersection(modelspace->valence.begin(), modelspace->valence.end(), modelspace->proton_orbits.begin(), modelspace->proton_orbits.end(),valence_protons.begin());
@@ -4992,7 +5026,7 @@ void ReadWrite::WriteTokyo(Operator& op, std::string filename, std::string mode)
    intfile << "! input 3N: " << File3N.substr( File3N.find_last_of("/\\")+1 ) << std::endl;
    intfile << "! e1max: " << modelspace->GetEmax() << "  e2max: " << modelspace->GetE2max() << "   e3max: " << modelspace->GetE3max() << "   hw: " << modelspace->GetHbarOmega();
    intfile << "   Aref: " << Acore << "  Zref: " << Zcore << "  A_for_kinetic_energy: " << modelspace->GetTargetMass() << std::endl;
-   intfile << "! Zero body term: " << op.ZeroBody << std::endl;
+   intfile << "! Zero body term: " << std::setw(wdouble) << std::setiosflags(std::ios::fixed) << std::setprecision(pdouble) << op.ZeroBody << std::endl;
    intfile << "! " << std::endl;
    intfile << "! model space" << std::endl;
    intfile << std::setw(wint) << valence_protons.size() << std::setw(wint) << valence_neutrons.size()
@@ -5191,8 +5225,8 @@ void ReadWrite::WriteTensorTokyo(std::string filename, Operator& op)
   outfile.open(filename, std::ofstream::out);
   ModelSpace * modelspace = op.GetModelSpace();
   int wint = 4; // width for printing integers
-  int wdouble = 12; // width for printing doubles
-  int pdouble = 6; // precision for printing doubles
+  int wdouble = 18; // width for printing doubles
+  int pdouble = 8; // precision for printing doubles
   std::vector<int> valence_protons(modelspace->valence.size());
   std::vector<int> valence_neutrons(modelspace->valence.size());
   auto it = set_intersection(modelspace->valence.begin(), modelspace->valence.end(), modelspace->proton_orbits.begin(), modelspace->proton_orbits.end(),valence_protons.begin());
@@ -5213,6 +5247,7 @@ void ReadWrite::WriteTensorTokyo(std::string filename, Operator& op)
    int Acore = modelspace->GetAref();
    int Zcore = modelspace->GetZref();
    int Ncore = Acore - Zcore;
+   outfile << std::fixed << std::setprecision(pdouble);
 #ifdef BUILDVERSION
    outfile << "! shell model effective operator generated by IMSRG version " << BUILDVERSION << std::endl;
 #else
@@ -5317,14 +5352,132 @@ void ReadWrite::skip_comments(std::ifstream& in)
   }
 }
 
+/// Method added by Takayuki Miyagi.
+///
+Operator ReadWrite::ReadOperator2b_Miyagi(std::string filename, ModelSpace& modelspace)
+{
+  std::ifstream infile( filename, std::ios_base::in | std::ios_base::binary );
+  if ( !infile.good() )
+  {
+    std::cerr << "************************************" << std::endl
+      << "**    Trouble reading file  !!!   **" << filename << std::endl
+      << "************************************" << std::endl;
+    goodstate = false;
+    exit(0);
+  }
+  boost::iostreams::filtering_istream zipstream;
+  zipstream.push(boost::iostreams::gzip_decompressor());
+  zipstream.push(infile);
 
+  std::string line;
+  //std::cout << filename << std::endl;
+  getline(zipstream, line);
+  getline(zipstream, line);
+  int J=0, P=0, Z=0, emax=6, e2max=12;
+  std::istringstream tmp( line.c_str() );
+  tmp >> J >> P >> Z >> emax >> e2max;
+  //std::cout << J << " " << Z << " " << (1-P)/2 << " " << emax << " " << e2max << std::endl;
+  Operator op = Operator(modelspace, J, Z, (1-P)/2, 2);
+  zipstream >> op.ZeroBody;
+  std::vector<int> orbits_remap;
 
+  std::vector<int> energy_vals;
+  std::vector<int> n_vals;
+  std::vector<int> l_vals;
+  std::vector<int> j_vals;
 
+  for (int e=0; e<=emax; ++e)
+  {
+    int lmin = e%2;
+    for (int l=lmin; l<=e; l+=2)
+    {
+      int n = (e-l)/2;
+      int twojMin = std::abs(2*l-1);
+      int twojMax = 2*l+1;
+      for (int twoj=twojMin; twoj<=twojMax; twoj+=2)
+      {
+         orbits_remap.push_back( modelspace.GetOrbitIndex(n,l,twoj,-1) );
+         energy_vals.push_back( 2*n+l);
+         n_vals.push_back(n);
+         l_vals.push_back(l);
+         j_vals.push_back(twoj);
+      }
+    }
+  }
+  int nljmax = orbits_remap.size()-1;
+  float obme_pp,obme_nn,obme_np,obme_pn;
+  for(int nlj1=0; nlj1<=nljmax; ++nlj1) {
+    int ip = modelspace.GetOrbitIndex( n_vals[nlj1], l_vals[nlj1], j_vals[nlj1], -1 );
+    int in = modelspace.GetOrbitIndex( n_vals[nlj1], l_vals[nlj1], j_vals[nlj1],  1 );
+    for(int nlj2=0; nlj2<=nljmax; ++nlj2) {
+      int jp = modelspace.GetOrbitIndex( n_vals[nlj2], l_vals[nlj2], j_vals[nlj2], -1 );
+      int jn = modelspace.GetOrbitIndex( n_vals[nlj2], l_vals[nlj2], j_vals[nlj2],  1 );
+      if( (l_vals[nlj1]+l_vals[nlj2]+op.parity)%2 == 1 ) continue;
+      if( not AngMom::Triangle( j_vals[nlj1], j_vals[nlj2], 2*op.rank_J ) ) continue;
+      zipstream >> obme_pp >> obme_nn >> obme_np >> obme_pn;
+      //std::cout << nlj1 << " " << nlj2 << " " << obme_pp << " " << obme_nn << " " << obme_np << " " << obme_pn  << std::endl;
+      if( energy_vals[nlj1] > modelspace.GetEmax() ) continue;
+      if( energy_vals[nlj2] > modelspace.GetEmax() ) continue;
+      op.OneBody(ip,jp) = obme_pp;
+      op.OneBody(in,jn) = obme_nn;
+      op.OneBody(in,jp) = obme_np;
+      op.OneBody(ip,jn) = obme_pn;
+    }
+  }
 
+  float me_pppp, me_pppn, me_ppnp, me_ppnn, me_pnpn;
+  float me_pnnp, me_pnnn, me_npnp, me_npnn, me_nnnn;
+  for(int nlj1=0; nlj1<=nljmax; ++nlj1) {
+    if( energy_vals[nlj1] > modelspace.GetEmax() ) break;
+    int ip = modelspace.GetOrbitIndex( n_vals[nlj1], l_vals[nlj1], j_vals[nlj1], -1 );
+    int in = modelspace.GetOrbitIndex( n_vals[nlj1], l_vals[nlj1], j_vals[nlj1],  1 );
+    for(int nlj2=0; nlj2<=nlj1; ++nlj2) {
+      int jp = modelspace.GetOrbitIndex( n_vals[nlj2], l_vals[nlj2], j_vals[nlj2], -1 );
+      int jn = modelspace.GetOrbitIndex( n_vals[nlj2], l_vals[nlj2], j_vals[nlj2],  1 );
+      if( energy_vals[nlj1] + energy_vals[nlj2] > e2max ) continue;
+
+      for(int nlj3=0; nlj3<=nljmax; ++nlj3) {
+        int kp = modelspace.GetOrbitIndex( n_vals[nlj3], l_vals[nlj3], j_vals[nlj3], -1 );
+        int kn = modelspace.GetOrbitIndex( n_vals[nlj3], l_vals[nlj3], j_vals[nlj3],  1 );
+        for(int nlj4=0; nlj4<=nlj3; ++nlj4) {
+          int lp = modelspace.GetOrbitIndex( n_vals[nlj4], l_vals[nlj4], j_vals[nlj4], -1 );
+          int ln = modelspace.GetOrbitIndex( n_vals[nlj4], l_vals[nlj4], j_vals[nlj4],  1 );
+          if( energy_vals[nlj3] + energy_vals[nlj4] > e2max ) continue;
+          if( ( l_vals[nlj1]+l_vals[nlj2]+l_vals[nlj3]+l_vals[nlj4]+op.parity )%2 == 1) continue;
+          for(int Jij=std::abs(j_vals[nlj1]-j_vals[nlj2])/2; Jij<=(j_vals[nlj1]+j_vals[nlj2])/2; ++Jij){
+            for(int Jkl=std::abs(j_vals[nlj3]-j_vals[nlj4])/2; Jkl<=(j_vals[nlj3]+j_vals[nlj4])/2; ++Jkl){
+
+              if( not AngMom::Triangle( Jij, Jkl, op.rank_J ) ) continue;
+              zipstream >> me_pppp >> me_pppn >> me_ppnp >> me_ppnn >> me_pnpn;
+              zipstream >> me_pnnp >> me_pnnn >> me_npnp >> me_npnn >> me_nnnn;
+              //std::cout << nlj1 << " " << nlj2 << " " << nlj3 << " " << nlj4 << " " << Jij << " " << Jkl << " " <<
+              //  me_pppp << " " << me_pppn << " " << me_ppnp << " " << me_ppnn << " " << me_pnpn << " " <<
+              //  me_pnnp << " " << me_pnnn << " " << me_npnp << " " << me_npnn << " " << me_nnnn << std::endl;
+              if( energy_vals[nlj1] > modelspace.GetEmax() ) continue;
+              if( energy_vals[nlj2] > modelspace.GetEmax() ) continue;
+              if( energy_vals[nlj3] > modelspace.GetEmax() ) continue;
+              if( energy_vals[nlj4] > modelspace.GetEmax() ) continue;
+              if( std::abs(me_pppp) > 1.e-10 ) op.TwoBody.SetTBME_J(Jij, Jkl, ip, jp, kp, lp, me_pppp);
+              if( std::abs(me_pppn) > 1.e-10 ) op.TwoBody.SetTBME_J(Jij, Jkl, ip, jp, kp, ln, me_pppn);
+              if( std::abs(me_ppnp) > 1.e-10 ) op.TwoBody.SetTBME_J(Jij, Jkl, ip, jp, kn, lp, me_ppnp);
+              if( std::abs(me_ppnn) > 1.e-10 ) op.TwoBody.SetTBME_J(Jij, Jkl, ip, jp, kn, ln, me_ppnn);
+              if( std::abs(me_pnpn) > 1.e-10 ) op.TwoBody.SetTBME_J(Jij, Jkl, ip, jn, kp, ln, me_pnpn);
+
+              if( std::abs(me_pnnp) > 1.e-10 ) op.TwoBody.SetTBME_J(Jij, Jkl, ip, jn, kn, lp, me_pnnp);
+              if( std::abs(me_pnnn) > 1.e-10 ) op.TwoBody.SetTBME_J(Jij, Jkl, ip, jn, kn, ln, me_pnnn);
+              if( std::abs(me_npnp) > 1.e-10 ) op.TwoBody.SetTBME_J(Jij, Jkl, in, jp, kn, lp, me_npnp);
+              if( std::abs(me_npnn) > 1.e-10 ) op.TwoBody.SetTBME_J(Jij, Jkl, in, jp, kn, ln, me_npnn);
+              if( std::abs(me_nnnn) > 1.e-10 ) op.TwoBody.SetTBME_J(Jij, Jkl, in, jn, kn, ln, me_nnnn);
 
+            }
+          }
 
+        }
+      }
 
-
-
+    }
+  }
+  return op;
+}
 
 
diff --git a/src/ReadWrite.hh b/src/ReadWrite.hh
index 78f6638..50f49b0 100755
--- a/src/ReadWrite.hh
+++ b/src/ReadWrite.hh
@@ -115,6 +115,7 @@ class ReadWrite
    void WriteTokyo(Operator&, std::string, std::string);
    void WriteTokyoFull(Operator&, std::string); // only for Hamiltonian
    void WriteTensorTokyo(std::string, Operator&);
+   Operator ReadOperator2b_Miyagi(std::string, ModelSpace&); // general operator me2j-like format
    void skip_comments(std::ifstream&);
 
    // Fields
diff --git a/src/ThreeBodyME.cc b/src/ThreeBodyME.cc
index 525b2e7..045b2a7 100755
--- a/src/ThreeBodyME.cc
+++ b/src/ThreeBodyME.cc
@@ -15,12 +15,29 @@ ThreeBodyME::ThreeBodyME(ModelSpace* ms)
 : modelspace(ms), E3max(ms->E3max), emax(ms->Emax), herm(1), total_dimension(0)
 {}
 
+ThreeBodyME::ThreeBodyME(ModelSpace* ms, int rJ, int rT, int p)
+: modelspace(ms), E3max(ms->E3max), emax(ms->Emax), herm(1), total_dimension(0), rank_J(rJ), rank_T(rT), parity(p)
+{
+  ISOSPIN_BLOCK_DIMENSION = 5;
+  if (rank_T==1) ISOSPIN_BLOCK_DIMENSION = 9; 
+  else if (rank_T==3) ISOSPIN_BLOCK_DIMENSION = 1;
+}
+
 ThreeBodyME::ThreeBodyME(ModelSpace* ms, int e3max)
 : modelspace(ms),E3max(e3max), emax(ms->Emax), herm(1), total_dimension(0)
 {}
 
-ThreeBodyME::ThreeBodyME(const ThreeBodyME& tbme)
-: modelspace(tbme.modelspace), MatEl( tbme.MatEl ), OrbitIndexHash( tbme.OrbitIndexHash ),  E3max(tbme.E3max), emax(tbme.emax), herm(tbme.herm)
+ThreeBodyME::ThreeBodyME(ModelSpace* ms, int e3max, int rJ, int rT, int p)
+: modelspace(ms),E3max(e3max), emax(ms->Emax), herm(1), total_dimension(0), rank_J(rJ), rank_T(rT), parity(p)
+{
+  ISOSPIN_BLOCK_DIMENSION = 5;
+  if (rank_T==1) ISOSPIN_BLOCK_DIMENSION = 9; 
+  else if (rank_T==3) ISOSPIN_BLOCK_DIMENSION = 1;
+}
+
+ThreeBodyME::ThreeBodyME(const ThreeBodyME& Tbme)
+: modelspace(Tbme.modelspace), MatEl( Tbme.MatEl ), OrbitIndexHash( Tbme.OrbitIndexHash ),  E3max(Tbme.E3max), emax(Tbme.emax), herm(Tbme.herm),
+   rank_J(Tbme.rank_J), rank_T(Tbme.rank_T), parity(Tbme.parity)
 {}
 
 //ThreeBodyME::ThreeBodyME(ThreeBodyME tbme)
@@ -113,7 +130,11 @@ void ThreeBodyME::Allocate()
   E3max = modelspace->GetE3max();
   int norbits = modelspace->GetNumberOrbits();
   std::cout << "Begin AllocateThreeBody() with E3max = " << E3max << " norbits = " << norbits << std::endl;
-  int lmax = 500*norbits; // maybe do something with this later...
+  int lmax = 50000; // maybe do something with this later...
+  ISOSPIN_BLOCK_DIMENSION = 5;
+  if (rank_T==1) ISOSPIN_BLOCK_DIMENSION = 9; 
+  else if (rank_T==3) ISOSPIN_BLOCK_DIMENSION = 1;
+
 
   for (int a=0; a<norbits; a+=2)
   {
@@ -152,10 +173,8 @@ void ThreeBodyME::Allocate()
              Orbit& of = modelspace->GetOrbit(f);
              int ef = 2*of.n+of.l;
              if ((ed+ee+ef)>E3max) break;
-             if ((oa.l+ob.l+oc.l+od.l+oe.l+of.l)%2>0 or of.l > lmax)
-             {
-               continue;
-             }
+             if (((oa.l+ob.l+oc.l+od.l+oe.l+of.l)%2 !=parity) or (of.l > lmax)) continue;
+
              OrbitIndexHash[ KeyHash(a,b,c,d,e,f) ] = total_dimension;
              int Jde_min = std::abs(od.j2-oe.j2)/2;
              int Jde_max = (od.j2+oe.j2)/2;
@@ -164,11 +183,14 @@ void ThreeBodyME::Allocate()
              {
               for (int Jde=Jde_min; Jde<=Jde_max; ++Jde)
               {
-                int J2_min = std::max( std::abs(2*Jab-oc.j2), std::abs(2*Jde-of.j2));
-                int J2_max = std::min( 2*Jab+oc.j2, 2*Jde+of.j2);
-                for (int J2=J2_min; J2<=J2_max; J2+=2)
+//                int J2_min = std::max( std::abs(2*Jab-oc.j2), std::abs(2*Jde-of.j2));
+//                int J2_max = std::min( 2*Jab+oc.j2, 2*Jde+of.j2);
+//                for (int J2=J2_min; J2<=J2_max; J2+=2)
+                int twoJ_min = std::max( std::abs(2*Jab-oc.j2), std::abs(2*Jde-of.j2));
+                int twoJ_max = std::min( 2*Jab+oc.j2, 2*Jde+of.j2);
+                for (int twoJ=twoJ_min; twoJ<=twoJ_max; twoJ+=2)
                 {
-                  total_dimension += 5; // 5 different isospin combinations
+                  total_dimension += ISOSPIN_BLOCK_DIMENSION; // how many different isospin combinations
                 } //J2
               } //Jde
              } //Jab
@@ -179,7 +201,7 @@ void ThreeBodyME::Allocate()
    } //b
   } //a
   MatEl.resize(total_dimension,0.0);
-  std::cout << "Allocated " << total_dimension << " three body matrix elements (" <<  total_dimension * sizeof(ThreeBME_type)/1024./1024./1024. << " GB), "
+  std::cout << "Allocated " << total_dimension << " three body matrix elements (" <<  total_dimension * sizeof(ThreeBodyME::ME_type)/1024./1024./1024. << " GB), "
        << std::endl << "  number of buckets in hash table: " << OrbitIndexHash.bucket_count() << "  and load factor = " << OrbitIndexHash.load_factor()
        << "  estimated storage ~ " << ((OrbitIndexHash.bucket_count()+OrbitIndexHash.size()) * (sizeof(size_t)+sizeof(void*))) / (1024.*1024.*1024.) << " GB"
        << std::endl;
@@ -197,11 +219,9 @@ void ThreeBodyME::Allocate()
 ///  <t_{ab} t_c | T> <t_{de} t_f| T> V_{abcdef}^{t_{ab} t_{de} T}
 /// \f]
 //*******************************************************************
-ThreeBME_type ThreeBodyME::GetME_pn(int Jab_in, int Jde_in, int J2, int a, int b, int c, int d, int e, int f) const
+ThreeBodyME::ME_type ThreeBodyME::GetME_pn(int Jab_in, int Jde_in, int twoJ, int a, int b, int c, int d, int e, int f) const
 {
 
-//   std::cout << "ENTER " << __func__ << "  " << Jab_in << " " << Jde_in << " " << J2 << " "
-//             << a  << " " << b << " " << c << " " << d << " " << e << " " << f << std::endl;
 //  IMSRGProfiler::counter[__func__] ++;
    if (a==b and a==c and modelspace->GetOrbit(a).j2<3) return 0;
    if (d==e and d==f and modelspace->GetOrbit(d).j2<3) return 0;
@@ -213,13 +233,13 @@ ThreeBME_type ThreeBodyME::GetME_pn(int Jab_in, int Jde_in, int J2, int a, int b
    double tzd = modelspace->GetOrbit(d).tz2*0.5;
    double tze = modelspace->GetOrbit(e).tz2*0.5;
    double tzf = modelspace->GetOrbit(f).tz2*0.5;
-   if ( (tza+tzb+tzc) != (tzd+tze+tzf) ) return 0;
+//   if ( (tza+tzb+tzc) != (tzd+tze+tzf) ) return 0;
+   double dTz =  (tza+tzb+tzc) - (tzd+tze+tzf);
+   if ( std::abs(dTz) > rank_T ) return 0;
 
-//   std::cout << "  Jab_in Jde_in J2 a b c d e f: " << Jab_in << " " << Jde_in << " " << J2 << " " << a << " " << b << " " << c << " " << d << " " << e << " " << f << std::endl;
-//   std::cout << "  tz vals: " << tza << " " << tzb << " " << tzc << " " << tzd << " " << tze << " " << tzf << std::endl;
 
    double Vpn=0;
-   int Tmin = std::max( std::abs(tza+tzb+tzc), std::abs(tzd+tze+tzf) )*2;
+   int twoTabc_min = std::abs(tza+tzb+tzc)*2;
    for (int tab=std::abs(tza+tzb); tab<=1; ++tab)
    {
       // CG calculates the Clebsch-Gordan coefficient  TODO: There are only a few CG cases, and we can probably use a specific formula rather than the general one.
@@ -228,15 +248,23 @@ ThreeBME_type ThreeBodyME::GetME_pn(int Jab_in, int Jde_in, int J2, int a, int b
       {
          double CG2 = AngMom::CG(0.5,tzd, 0.5,tze, tde, tzd+tze);
          if (CG1*CG2==0) continue;
-         for (int T=Tmin; T<=3; T+=2)
+         for (int twoTabc=twoTabc_min; twoTabc<=3; twoTabc+=2)
          {
-           double CG3 = AngMom::CG(tab,tza+tzb, 0.5,tzc, T/2., tza+tzb+tzc);
-           double CG4 = AngMom::CG(tde,tzd+tze, 0.5,tzf, T/2., tzd+tze+tzf);
-           if (CG3*CG4==0) continue;
-           Vpn += CG1*CG2*CG3*CG4*GetME(Jab_in,Jde_in,J2,tab,tde,T,a,b,c,d,e,f);
-//           std::cout << "   tab,tde,T: " << tab << " " << tde << " " << T << "  clebsch: " << CG1 << " " << CG2 << " " << CG3 << " " << CG4
-//                     << "  Vpn = " << Vpn << std::endl;
-
+           double CG3 = AngMom::CG(tab,tza+tzb, 0.5,tzc, twoTabc/2., tza+tzb+tzc);
+           int twoTdef_min = std::max( (int)std::abs(tzd+tze+tzf)*2, std::abs(twoTabc-2*rank_T));
+           int twoTdef_max = twoTabc + 2*rank_T;
+           for (int twoTdef=twoTdef_min; twoTdef<=twoTdef_max; twoTdef+=2)
+           {
+             double CG4 = AngMom::CG(tde,tzd+tze, 0.5,tzf, twoTdef/2., tzd+tze+tzf);
+             if (CG3*CG4==0) continue;
+//             Vpn += CG1*CG2*CG3*CG4*GetME(Jab_in,Jde_in,J2,tab,tde,T,a,b,c,d,e,f);
+             double Viso = GetME(Jab_in,Jde_in,twoJ,tab,tde,twoTabc,twoTdef,a,b,c,d,e,f);
+             if (rank_T > 0 ) // the matrix elements are reduced in T, so apply Wigner-Eckart
+             {
+               Viso *= AngMom::CG(0.5*twoTdef,tzd+tze+tzf,  rank_T,dTz,  0.5*twoTabc,tza+tzb+tzc  ) / sqrt( twoTabc+1);
+             }
+             Vpn += CG1*CG2*CG3*CG4* Viso;
+           }
          }
       }
    }
@@ -245,6 +273,12 @@ ThreeBME_type ThreeBodyME::GetME_pn(int Jab_in, int Jde_in, int J2, int a, int b
 
 
 
+/// Wrapper for the other version for backwards compatibility
+ThreeBodyME::ME_type ThreeBodyME::GetME(int Jab_in, int Jde_in, int twoJ, int tab_in, int tde_in, int twoT, int a_in, int b_in, int c_in, int d_in, int e_in, int f_in) const
+{
+  return GetME(Jab_in, Jde_in, twoJ, tab_in, tde_in, twoT, twoT, a_in, b_in, c_in, d_in, e_in, f_in);
+}
+
 //*******************************************************************
 /// Get three body matrix element in isospin formalism
 /// \f$ V_{abcdef}^{J_{ab}J_{de}Jt_{ab}t_{de}T} \f$
@@ -254,42 +288,54 @@ ThreeBME_type ThreeBodyME::GetME_pn(int Jab_in, int Jde_in, int J2, int a, int b
 /// and if \f$ b=e \f$ then \f$ c \geq f \f$.
 /// Other orderings are obtained by recoupling on the fly.
 //*******************************************************************
-ThreeBME_type ThreeBodyME::GetME(int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int T2, int a_in, int b_in, int c_in, int d_in, int e_in, int f_in) const
+ThreeBodyME::ME_type ThreeBodyME::GetME(int Jab_in, int Jde_in, int twoJ, int tab_in, int tde_in, int twoTabc, int twoTdef, int a_in, int b_in, int c_in, int d_in, int e_in, int f_in) const
 {
-//   std::cout << "     ENTER " << __func__ << std::endl;
-//   std::cout << "       Jab_in Jde_in J2 tab_in tde_in T2 a b c d e f: " << Jab_in << " " << Jde_in << " " << J2
-//             << "  " << tab_in << " " << tde_in << " " << T2
-//             << "  " << a_in << " " << b_in << " " << c_in << " " << d_in << " " << e_in << " " << f_in << std::endl;
    if ((a_in/2==b_in/2) and (Jab_in+tab_in)%2==0) return 0; // Make sure this is ok
    if ((d_in/2==e_in/2) and (Jde_in+tde_in)%2==0) return 0; // Make sure this is ok
-   auto elements =  AccessME(Jab_in,Jde_in,J2,tab_in,tde_in,T2,a_in,b_in,c_in,d_in,e_in,f_in);
+   auto elements =  AccessME(Jab_in,Jde_in,twoJ,tab_in,tde_in,twoTabc,twoTdef,a_in,b_in,c_in,d_in,e_in,f_in);
    double me = 0;
    for (auto elem : elements) me += MatEl.at(elem.first) * elem.second;
 //   for (auto elem : elements) std::cout << "       first: " << MatEl.at(elem.first) << "   second: " << elem.second << std::endl;
    return me;
 }
 
+
+
+/// Wrapper for the other version for backwards compatibility
+void ThreeBodyME::SetME(int Jab_in, int Jde_in, int twoJ, int tab_in, int tde_in, int twoT, int a_in, int b_in, int c_in, int d_in, int e_in, int f_in, ThreeBodyME::ME_type V)
+{
+  SetME(Jab_in, Jde_in, twoJ, tab_in, tde_in, twoT, twoT, a_in, b_in, c_in, d_in, e_in, f_in, V);
+}
+
 //*******************************************************************
 /// Set a three body matrix element. Since only a subset of orbit
 /// orderings are stored, we need to recouple if the input ordering
 /// is different.
 //*******************************************************************
-void ThreeBodyME::SetME(int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int T2, int a_in, int b_in, int c_in, int d_in, int e_in, int f_in, ThreeBME_type V)
+void ThreeBodyME::SetME(int Jab_in, int Jde_in, int twoJ, int tab_in, int tde_in, int twoTabc, int twoTdef, int a_in, int b_in, int c_in, int d_in, int e_in, int f_in, ThreeBodyME::ME_type V)
 {
-   auto elements = AccessME(Jab_in,Jde_in,J2,tab_in,tde_in,T2,a_in,b_in,c_in,d_in,e_in,f_in);
+//   auto elements = AccessME(Jab_in,Jde_in,J2,tab_in,tde_in,T2,a_in,b_in,c_in,d_in,e_in,f_in);
+   auto elements = AccessME(Jab_in,Jde_in,twoJ,tab_in,tde_in,twoTabc,twoTdef,a_in,b_in,c_in,d_in,e_in,f_in);
    double me = 0;
    for (auto elem : elements)  me += MatEl.at(elem.first) * elem.second;
    for (auto elem : elements)  MatEl.at(elem.first) += (V-me)*elem.second;
 }
 
 
-void ThreeBodyME::AddToME(int Jab, int Jde, int J2, int tab, int tde, int T2, int a, int b, int c, int d, int e, int f, ThreeBME_type V)
+void ThreeBodyME::AddToME(int Jab, int Jde, int twoJ, int tab, int tde, int twoT, int a, int b, int c, int d, int e, int f, ThreeBodyME::ME_type V)
+{
+  AddToME(Jab, Jde, twoJ, tab, tde, twoT, twoT, a, b, c, d, e, f, V);
+}
+
+void ThreeBodyME::AddToME(int Jab, int Jde, int twoJ, int tab, int tde, int twoTabc, int twoTdef, int a, int b, int c, int d, int e, int f, ThreeBodyME::ME_type V)
 {
-   auto elements = AccessME(Jab,Jde,J2,tab,tde,T2,a,b,c,d,e,f);
+   auto elements = AccessME(Jab,Jde,twoJ,tab,tde,twoTabc,twoTdef,a,b,c,d,e,f);
    for (auto elem : elements)  MatEl.at(elem.first) += V * elem.second;
 }
 
-void ThreeBodyME::AddToME_pn(int Jab, int Jde, int J2, int a, int b, int c, int d, int e, int f, ThreeBME_type Vpn)
+/// Remove this because we shouldn't be doing it anyway...
+/*
+void ThreeBodyME::AddToME_pn(int Jab, int Jde, int twoJ, int a, int b, int c, int d, int e, int f, ThreeBodyME::ME_type Vpn)
 {
 
    double tza = modelspace->GetOrbit(a).tz2*0.5;
@@ -313,11 +359,14 @@ void ThreeBodyME::AddToME_pn(int Jab, int Jde, int J2, int a, int b, int c, int
            double CG3 = AngMom::CG(tab,tza+tzb, 0.5,tzc, T/2., tza+tzb+tzc);
            double CG4 = AngMom::CG(tde,tzd+tze, 0.5,tzf, T/2., tzd+tze+tzf);
            if (CG3*CG4==0) continue;
-           AddToME(Jab,Jde,J2,tab,tde,T,a,b,c,d,e,f, CG1*CG2*CG3*CG4*Vpn );
+           AddToME(Jab,Jde,twoJ,tab,tde,T,a,b,c,d,e,f, CG1*CG2*CG3*CG4*Vpn );
          }
       }
    }
 }
+*/
+
+
 
 
 //*******************************************************************
@@ -325,7 +374,8 @@ void ThreeBodyME::AddToME_pn(int Jab, int Jde, int J2, int a, int b, int c, int
 /// identical, do all the work here to pull out a list of indices
 /// and coefficients which are needed for setting or getting.
 //*******************************************************************
-std::vector<std::pair<size_t,double>> ThreeBodyME::AccessME(int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int T2, int a_in, int b_in, int c_in, int d_in, int e_in, int f_in) const
+//std::vector<std::pair<size_t,double>> ThreeBodyME::AccessME(int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int T2, int a_in, int b_in, int c_in, int d_in, int e_in, int f_in) const
+std::vector<std::pair<size_t,double>> ThreeBodyME::AccessME(int Jab_in, int Jde_in, int twoJ, int tab_in, int tde_in, int twoTabc, int twoTdef, int a_in, int b_in, int c_in, int d_in, int e_in, int f_in) const
 {
 
    std::vector<std::pair<size_t,double>> elements;
@@ -342,6 +392,7 @@ std::vector<std::pair<size_t,double>> ThreeBodyME::AccessME(int Jab_in, int Jde_
       	std::swap(c,f);
       	std::swap(Jab_in,Jde_in);
       	std::swap(tab_in,tde_in);
+        std::swap(twoTabc,twoTdef);
       	std::swap(abc_recoupling_case, def_recoupling_case);
         herm_flip *= herm;
    }
@@ -370,9 +421,9 @@ std::vector<std::pair<size_t,double>> ThreeBodyME::AccessME(int Jab_in, int Jde_
    int Jab_max = (ja+jb);
    int Jde_max = (jd+je);
 
-   int tab_min = T2==3 ? 1 : 0;
+   int tab_min = twoTabc==3 ? 1 : 0;
    int tab_max = 1;
-   int tde_min = T2==3 ? 1 : 0;
+   int tde_min = twoTdef==3 ? 1 : 0;
    int tde_max = 1;
 
 
@@ -383,50 +434,39 @@ std::vector<std::pair<size_t,double>> ThreeBodyME::AccessME(int Jab_in, int Jde_
    for (int Jab=Jab_min; Jab<=Jab_max; ++Jab)
    {
 
-     double Cj_abc = RecouplingCoefficient(abc_recoupling_case,ja,jb,jc,Jab_in,Jab,J2);
+     double Cj_abc = RecouplingCoefficient(abc_recoupling_case,ja,jb,jc,Jab_in,Jab,twoJ);
      // Pick up a -1 for odd permutations
      if ( abc_recoupling_case/3 != def_recoupling_case/3 ) Cj_abc *= -1;
 
      for (int Jde=Jde_min; Jde<=Jde_max; ++Jde)
      {
-       double Cj_def = RecouplingCoefficient(def_recoupling_case,jd,je,jf,Jde_in,Jde,J2);
+       double Cj_def = RecouplingCoefficient(def_recoupling_case,jd,je,jf,Jde_in,Jde,twoJ);
 
-       int J2_min = std::max( std::abs(2*Jab-oc.j2), std::abs(2*Jde-of.j2));
-       int J2_max = std::min( 2*Jab+oc.j2, 2*Jde+of.j2);
-       if (J2_min>J2_max) continue;
-       J_index += (J2-J2_min)/2*5;
+       int twoJ_min = std::max( std::abs(2*Jab-oc.j2), std::abs(2*Jde-of.j2));
+       int twoJ_max = std::min( 2*Jab+oc.j2, 2*Jde+of.j2);
+       if (twoJ_min>twoJ_max) continue;
+       J_index += (twoJ-twoJ_min)/2 * ISOSPIN_BLOCK_DIMENSION;
+//       J_index += (twoJ-twoJ_min)/2*5;
 
-       if (J2>=J2_min and J2<=J2_max and std::abs(Cj_abc*Cj_def)>1e-8)
+       if (twoJ>=twoJ_min and twoJ<=twoJ_max and std::abs(Cj_abc*Cj_def)>1e-8)
        {
          for (int tab=tab_min; tab<=tab_max; ++tab)
          {
-//           if (a==b and (tab+Jab)%2==0 ) continue; // added recently. test.  this breaks things
-           double Ct_abc = RecouplingCoefficient(abc_recoupling_case,0.5,0.5,0.5,tab_in,tab,T2);
+           double Ct_abc = RecouplingCoefficient(abc_recoupling_case,0.5,0.5,0.5,tab_in,tab,twoTabc);
            for (int tde=tde_min; tde<=tde_max; ++tde)
            {
-//             if (d==e and (tde+Jde)%2==0 ) continue; // added recently. test.  this breaks things
-             double Ct_def = RecouplingCoefficient(def_recoupling_case,0.5,0.5,0.5,tde_in,tde,T2);
+             double Ct_def = RecouplingCoefficient(def_recoupling_case,0.5,0.5,0.5,tde_in,tde,twoTdef);
              if (std::abs(Ct_abc*Ct_def)<1e-8) continue;
              if (herm==-1 and a==d and b==e and c==f and Jab==Jde and tab==tde) continue; // TODO: check this is ok
 
-             int Tindex = 2*tab + tde + (T2-1)/2;
-
-//             if ( a==4 and b==4 and c==2 and d==2 and e==0 and f==0 and J2==3 and T2==3)
-////             if ( a_in==4 and b_in==4 and c_in==2 and d_in==2 and e_in==0 and f_in==0 and J2==3 and T2==3)
-//             {
-//             std::cout << "            " << __func__ << " adding Jab,Jde,J2 = " << Jab << " " << Jde << " " << J2
-//                       << "  tab,tde,T2 " << tab << " " << tde << " " << T2 << "  recoupling case " << abc_recoupling_case << " " << def_recoupling_case
-//                        << "  with coeffs "
-//                       << Cj_abc << " " << Cj_def << " " << Ct_abc << " " << Ct_def << " , herm " << herm_flip << std::endl;
-//              std::cout << "   the MatEl is " << MatEl.at( indx+ J_index + Tindex) << std::endl;
-////  std::cout << "      indx ,J_index, Tindex  " << indx << " " << J_index << " " << Tindex  << "-> " << indx + J_index + Tindex << std::endl;
-//             }
+             int Tindex = 2*tab + tde + (twoTabc)/2;    // (0,1) (1,1) (1,3) => 0,1,2   twoTabc/2 +2*tab or   tab + (twoTabc)/2
+             if ( rank_T>0 ) Tindex = ( 2*tab + twoTabc/2) + 3*( 2*tde + twoTdef/2);
 
              elements.emplace_back( std::make_pair(indx + J_index + Tindex, Cj_abc * Cj_def * Ct_abc * Ct_def * herm_flip )) ;
            }
          }
        }
-       J_index += (J2_max-J2+2)/2*5;
+       J_index += (twoJ_max-twoJ+2)/2 * ISOSPIN_BLOCK_DIMENSION;
      }
    }
    return elements;
@@ -439,18 +479,18 @@ std::vector<std::pair<size_t,double>> ThreeBodyME::AccessME(int Jab_in, int Jde_
 /// permutation of fermionic operators. That is handled in ThreeBodyME::AccessME.
 /// Here, we just only with the angular momentum / isospin recoupling factors
 //*******************************************************************
-double ThreeBodyME::RecouplingCoefficient(int recoupling_case, double ja, double jb, double jc, int Jab_in, int Jab, int J) const
+double ThreeBodyME::RecouplingCoefficient(int recoupling_case, double ja, double jb, double jc, int Jab_in, int Jab, int twoJ) const
 {
    if ( std::abs(int(ja-jb))>Jab  or int(ja+jb)<Jab) return 0;
-   if ( std::abs(int(jc-J/2.))>Jab  or int(jc+J/2.)<Jab) return 0;
+   if ( std::abs(int(jc-twoJ/2.))>Jab  or int(jc+twoJ/2.)<Jab) return 0;
    switch (recoupling_case)
    {
     case ABC: return Jab==Jab_in ? 1 : 0;
-    case BCA: return modelspace->phase( jb+jc+Jab_in+1) * sqrt((2*Jab_in+1)*(2*Jab+1)) * modelspace->GetSixJ(ja, jb, Jab, jc, J/2., Jab_in);
-    case CAB: return modelspace->phase( ja+jb-Jab+1) * sqrt((2*Jab_in+1)*(2*Jab+1)) * modelspace->GetSixJ(jb, ja, Jab, jc, J/2., Jab_in);
-    case ACB: return modelspace->phase( jb+jc+Jab_in-Jab) * sqrt((2*Jab_in+1)*(2*Jab+1)) * modelspace->GetSixJ(jb, ja, Jab, jc, J/2., Jab_in);
+    case BCA: return modelspace->phase( jb+jc+Jab_in+1) * sqrt((2*Jab_in+1)*(2*Jab+1)) * modelspace->GetSixJ(ja, jb, Jab, jc, twoJ/2., Jab_in);
+    case CAB: return modelspace->phase( ja+jb-Jab+1) * sqrt((2*Jab_in+1)*(2*Jab+1)) * modelspace->GetSixJ(jb, ja, Jab, jc, twoJ/2., Jab_in);
+    case ACB: return modelspace->phase( jb+jc+Jab_in-Jab) * sqrt((2*Jab_in+1)*(2*Jab+1)) * modelspace->GetSixJ(jb, ja, Jab, jc, twoJ/2., Jab_in);
     case BAC: return Jab==Jab_in ? modelspace->phase(ja+jb-Jab) : 0;
-    case CBA: return -sqrt((2*Jab_in+1)*(2*Jab+1)) * modelspace->GetSixJ(ja, jb, Jab, jc, J/2., Jab_in);
+    case CBA: return -sqrt((2*Jab_in+1)*(2*Jab+1)) * modelspace->GetSixJ(ja, jb, Jab, jc, twoJ/2., Jab_in);
     default: return 0;
     }
 }
@@ -504,7 +544,7 @@ void ThreeBodyME::Erase()
 /// Free up the memory used for the matrix elements
 void ThreeBodyME::Deallocate()
 {
-   std::vector<ThreeBME_type>().swap(MatEl);
+   std::vector<ThreeBodyME::ME_type>().swap(MatEl);
    OrbitIndexHash.clear();
 }
 
@@ -522,7 +562,7 @@ void ThreeBodyME::ReadBinary(std::ifstream& f)
   f.read((char*)&E3max,sizeof(E3max));
   f.read((char*)&total_dimension,sizeof(total_dimension));
   Allocate();
-  f.read((char*)&MatEl[0],total_dimension*sizeof(ThreeBME_type));
+  f.read((char*)&MatEl[0],total_dimension*sizeof(ThreeBodyME::ME_type));
 }
 
 
diff --git a/src/ThreeBodyME.hh b/src/ThreeBodyME.hh
index 7570a40..726520c 100755
--- a/src/ThreeBodyME.hh
+++ b/src/ThreeBodyME.hh
@@ -25,7 +25,7 @@
 #include <unordered_map>
 
 //typedef double ThreeBME_type;
-typedef float ThreeBME_type;
+//typedef float ThreeBME_type;
 
 /// The three-body piece of an operator, stored in nested vectors.
 /// The 3BMEs are stored in unnormalized JT coupled form
@@ -38,13 +38,20 @@ typedef float ThreeBME_type;
 class ThreeBodyME
 {
  public:
+  typedef float ME_type;
   ModelSpace * modelspace;
-  std::vector<ThreeBME_type> MatEl;
-  std::unordered_map<size_t, size_t> OrbitIndexHash; // TODO: reorganize so that we store the pn matrix elements, rather than isospin
+  std::vector<ME_type> MatEl;
+  std::unordered_map<size_t, size_t> OrbitIndexHash; 
   int E3max;
   int emax; // usually, this should be the emax of the modelspace, but we might want something smaller.
   int herm; // +1 for hermitian, -1 for anti-hermitian
   size_t total_dimension;
+
+  int rank_J=0;
+  int rank_T=0;
+  int parity=0;
+  int ISOSPIN_BLOCK_DIMENSION=5;
+
   bool is_allocated = false;
 
   const static int ABC;
@@ -57,9 +64,11 @@ class ThreeBodyME
   ~ThreeBodyME();
   ThreeBodyME();
   ThreeBodyME(ModelSpace*);
+  ThreeBodyME(ModelSpace*, int rank_J, int rank_T, int parity);
   ThreeBodyME(ModelSpace* ms, int e3max);
+  ThreeBodyME(ModelSpace* ms, int e3max, int rank_J, int rank_T, int parity);
 //  ThreeBodyME(ThreeBodyME tbme);
-  ThreeBodyME(const ThreeBodyME& tbme);
+  ThreeBodyME(const ThreeBodyME& Tbme);
 
 
   ThreeBodyME& operator*=(const double);
@@ -74,18 +83,24 @@ class ThreeBodyME
   ModelSpace* GetModelSpace(){return modelspace;};
 
 //// Three body setter getters
-  std::vector<std::pair<size_t,double>> AccessME(int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int T2, int i, int j, int k, int l, int m, int n) const;
-  void AddToME(int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int T2, int i, int j, int k, int l, int m, int n, ThreeBME_type V);
-  void   SetME(int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int T2, int i, int j, int k, int l, int m, int n, ThreeBME_type V);
-  ThreeBME_type GetME(int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int T2, int i, int j, int k, int l, int m, int n) const;
-  void AddToME_pn(int Jab_in, int Jde_in, int J2, int i, int j, int k, int l, int m, int n, ThreeBME_type V);
-  void   SetME_pn(int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int T2, int i, int j, int k, int l, int m, int n, ThreeBME_type V);
-  ThreeBME_type GetME_pn(int Jab_in, int Jde_in, int J2, int i, int j, int k, int l, int m, int n) const;
+//  std::vector<std::pair<size_t,double>> AccessME(int Jab_in, int Jde_in, int twoJ, int tab_in, int tde_in, int twoT, int i, int j, int k, int l, int m, int n) const;
+  void AddToME(int Jab_in, int Jde_in, int twoJ, int tab_in, int tde_in, int twoT, int i, int j, int k, int l, int m, int n, ME_type V);
+  void   SetME(int Jab_in, int Jde_in, int twoJ, int tab_in, int tde_in, int twoT, int i, int j, int k, int l, int m, int n, ME_type V);
+  ME_type GetME(int Jab_in, int Jde_in, int twoJ, int tab_in, int tde_in, int twoT, int i, int j, int k, int l, int m, int n) const;
+//  void AddToME_pn(int Jab_in, int Jde_in, int twoJ, int i, int j, int k, int l, int m, int n, ME_type V);
+  void   SetME_pn(int Jab_in, int Jde_in, int twoJ, int tab_in, int tde_in, int twoT, int i, int j, int k, int l, int m, int n, ME_type V);
+  ME_type GetME_pn(int Jab_in, int Jde_in, int twoJ, int i, int j, int k, int l, int m, int n) const;
+
+
+  std::vector<std::pair<size_t,double>> AccessME(int Jab_in, int Jde_in, int twoJ, int tab_in, int tde_in, int twoTabc, int twoTdef, int a, int b, int c, int d, int e, int f) const;
+  void AddToME(int Jab_in, int Jde_in, int twoJ, int tab_in, int tde_in, int twoTabc, int twoTdef, int a, int b, int c, int d, int e, int f, ME_type V);
+  void   SetME(int Jab_in, int Jde_in, int twoJ, int tab_in, int tde_in, int twoTabc, int twoTdef, int a, int b, int c, int d, int e, int f, ME_type V);
+  ME_type GetME(int Jab_in, int Jde_in, int twoJ, int tab_in, int tde_in, int twoTabc, int twoTdef, int a, int b, int c, int d, int e, int f) const;
 
 ///// Some other three body methods
 
   int SortOrbits(int a_in, int b_in, int c_in, int& a,int& b,int& c) const;
-  double RecouplingCoefficient(int recoupling_case, double ja, double jb, double jc, int Jab_in, int Jab, int J) const;
+  double RecouplingCoefficient(int recoupling_case, double ja, double jb, double jc, int Jab_in, int Jab, int twoJ) const;
   void SetE3max(int e){E3max = e;};
   int GetE3max(){return E3max;};
   int Getemax(){return emax;};
@@ -97,7 +112,7 @@ class ThreeBodyME
 
   void Erase(); // set all three-body terms to zero
   void Deallocate();
-  size_t size(){return total_dimension * sizeof(ThreeBME_type);};
+  size_t size(){return total_dimension * sizeof(ME_type);};
 
 
   void WriteBinary(std::ofstream&);
diff --git a/src/ThreeBodyMENO2B.cc b/src/ThreeBodyMENO2B.cc
index d1a3b24..7767dfd 100644
--- a/src/ThreeBodyMENO2B.cc
+++ b/src/ThreeBodyMENO2B.cc
@@ -11,6 +11,13 @@
 #include <omp.h>
 #include "IMSRGProfiler.hh"
 
+
+const int ThreeBodyMENO2B::HALF_PRECISION = 2;
+const int ThreeBodyMENO2B::SINGLE_PRECISION = 4;
+const int ThreeBodyMENO2B::DOUBLE_PRECISION = 8;
+
+
+
 OrbitIsospin::~OrbitIsospin()
 {}
 
@@ -29,7 +36,8 @@ ThreeBodyChannelNO2B::ThreeBodyChannelNO2B(int J2, int P2, int J1, int P1, int T
   : J2(J2), P2(P2), J1(J1), P1(P1), T3(T3), thr(thr)
 {
   Ndim = 0;
-  int emax = std::max(thr->Emax, thr->Emax_file);
+//  int emax = std::max(thr->Emax, thr->Emax_file);
+  int emax = thr->Emax;
   int e2max = std::max(thr->E2max, thr->E2max_file);
   int e3max = std::max(thr->E3max, thr->E3max_file);
   int Norbs = thr->iOrbits.size();
@@ -107,14 +115,7 @@ ThreeBodySpaceNO2B::ThreeBodySpaceNO2B(ThreeBodyMENO2B* thr)
           for (int T3 : {1,3}){
             ThreeBodyChannelNO2B channel(J2, P2, J1, P1, T3, thr);
             if(channel.Ndim < 1) continue;
-            //std::cout <<
-            //  "   J2 = " << std::setw(4) << J2 <<
-            //  ",  P2 = " << std::setw(4) << P2 <<
-            //  ",  J1 = " << std::setw(4) << J1 <<
-            //  ",  P1 = " << std::setw(4) << P1 <<
-            //  ",  T3 = " << std::setw(4) << T3 <<
-            //  ",  Ndim = " << std::setw(10) << channel.Ndim <<
-            //  std::endl;
+
             ThreeBodyChannels.push_back(channel);
             int key = Hash_Channel(J2,P2,J1,P1,T3);
             int j2, p2, j1, p1, t3;
@@ -148,13 +149,16 @@ ThreeBodyMENO2B::~ThreeBodyMENO2B()
 {}
 
 ThreeBodyMENO2B::ThreeBodyMENO2B()
-  : Emax(0), E2max(0), E3max(0), Lmax(0),
+  : precision_mode(SINGLE_PRECISION),
+  Emax(0), E2max(0), E3max(0), Lmax(0),
   Emax_file(0), E2max_file(0), E3max_file(0), Lmax_file(0)
 {}
 
 ThreeBodyMENO2B::ThreeBodyMENO2B(const ThreeBodyMENO2B& tbme)
-  : modelspace(tbme.modelspace), threebodyspace(tbme.threebodyspace),
-  MatEl( tbme.MatEl ), iOrbits( tbme.iOrbits ),  nlj2idx(tbme.nlj2idx),
+  : precision_mode(SINGLE_PRECISION),
+  modelspace(tbme.modelspace), threebodyspace(tbme.threebodyspace),
+  MatEl_single( tbme.MatEl_single ), MatEl_half( tbme.MatEl_half), iOrbits( tbme.iOrbits ),  nlj2idx(tbme.nlj2idx),
+//  MatEl( tbme.MatEl ), iOrbits( tbme.iOrbits ),  nlj2idx(tbme.nlj2idx),
   Emax(tbme.Emax), E2max(tbme.E2max),
   E3max(tbme.E3max), Lmax(tbme.Lmax),
   Emax_file(tbme.Emax_file), E2max_file(tbme.E2max_file),
@@ -164,7 +168,14 @@ ThreeBodyMENO2B::ThreeBodyMENO2B(const ThreeBodyMENO2B& tbme)
 
 ThreeBodyMENO2B& ThreeBodyMENO2B::operator*=(const double rhs)
 {
-  for ( auto& itmat : MatEl )
+  for ( auto& itmat : MatEl_single )
+  {
+    for ( auto& it : itmat.second )
+    {
+      it *= rhs;
+    }
+  }
+  for ( auto& itmat : MatEl_half )
   {
     for ( auto& it : itmat.second )
     {
@@ -176,12 +187,20 @@ ThreeBodyMENO2B& ThreeBodyMENO2B::operator*=(const double rhs)
 
 ThreeBodyMENO2B& ThreeBodyMENO2B::operator+=(const ThreeBodyMENO2B& rhs)
 {
-  for ( auto& itmat : rhs.MatEl )
+  for ( auto& itmat : rhs.MatEl_single )
   {
     auto ch = itmat.first;
     for ( size_t i=0; i<itmat.second.size(); i++)
     {
-      MatEl[ch][i] += itmat.second[i];
+      MatEl_single[ch][i] += itmat.second[i];
+    }
+  }
+  for ( auto& itmat : rhs.MatEl_half )
+  {
+    auto ch = itmat.first;
+    for ( size_t i=0; i<itmat.second.size(); i++)
+    {
+      MatEl_half[ch][i] += itmat.second[i];
     }
   }
   return *this;
@@ -189,20 +208,37 @@ ThreeBodyMENO2B& ThreeBodyMENO2B::operator+=(const ThreeBodyMENO2B& rhs)
 
 ThreeBodyMENO2B& ThreeBodyMENO2B::operator-=(const ThreeBodyMENO2B& rhs)
 {
-  for ( auto& itmat : rhs.MatEl )
+  for ( auto& itmat : rhs.MatEl_single )
+  {
+    auto ch = itmat.first;
+    for ( size_t i=0; i<itmat.second.size(); i++)
+    {
+      MatEl_single[ch][i] -= itmat.second[i];
+    }
+  }
+  for ( auto& itmat : rhs.MatEl_half )
   {
     auto ch = itmat.first;
     for ( size_t i=0; i<itmat.second.size(); i++)
     {
-      MatEl[ch][i] -= itmat.second[i];
+      MatEl_half[ch][i] -= itmat.second[i];
     }
   }
   return *this;
 }
 
-void ThreeBodyMENO2B::Allocate(ModelSpace & ms,
-    int emax_file, int e2max_file, int e3max_file, int lmax_file,
-    std::string filename)
+
+void ThreeBodyMENO2B::SetHalfPrecision()
+{
+  precision_mode = HALF_PRECISION;
+}
+void ThreeBodyMENO2B::SetSinglePrecision()
+{
+  precision_mode = SINGLE_PRECISION;
+}
+
+//void ThreeBodyMENO2B::Allocate(ModelSpace & ms, int emax_file, int e2max_file, int e3max_file, int lmax_file,  std::string filename)
+void ThreeBodyMENO2B::Allocate(ModelSpace & ms, int emax_file, int e2max_file, int e3max_file, int lmax_file)
 {
   modelspace = &ms;
   Emax = modelspace->GetEmax();
@@ -213,7 +249,7 @@ void ThreeBodyMENO2B::Allocate(ModelSpace & ms,
   E2max_file = e2max_file;
   E3max_file = e3max_file;
   Lmax_file = lmax_file;
-  FileName = filename;
+//  FileName = filename;
   initialized = true;
   int idx = 0;
   for (int e=0; e<=std::max(modelspace->GetEmax(),Emax_file); ++e) {
@@ -234,13 +270,22 @@ void ThreeBodyMENO2B::Allocate(ModelSpace & ms,
   for (int ch=0; ch<threebodyspace.NChannels; ch++){
     ThreeBodyChannelNO2B ch_no2b=threebodyspace.ThreeBodyChannels[ch];
     size_t n = ch_no2b.Ndim;
-    std::vector<ThreeBME_type> vch(n*(n+1)/2, 0.0);
-    MatEl[ch] = vch;
+    if (precision_mode == SINGLE_PRECISION)
+    {
+      MatEl_single[ch] = std::vector<ThreeBMENO2B_single_type>( n*(n+1)/2, ThreeBMENO2B_single_type(0.0));
+    }
+    if (precision_mode == HALF_PRECISION)
+    {
+      MatEl_half[ch] = std::vector<ThreeBMENO2B_half_type>( n*(n+1)/2, ThreeBMENO2B_half_type(0.0));
+    }
+
+//    std::vector<ThreeBMENO2B_Store_type> vch(n*(n+1)/2, (ThreeBMENO2B_Store_type)0.0);
+//    MatEl[ch] = vch;
   }
 }
 
 void ThreeBodyMENO2B::SetThBME(int a, int b, int c, int Tab,
-    int d, int e, int f, int Tde, int J2, int T3, ThreeBME_type V)
+    int d, int e, int f, int Tde, int J2, int T3, ThreeBMENO2B_IO_type V)
 {
   OrbitIsospin & oa = iOrbits[a];
   OrbitIsospin & ob = iOrbits[b];
@@ -267,11 +312,13 @@ void ThreeBodyMENO2B::SetThBME(int a, int b, int c, int Tab,
   int ph = ch_no2b.iphase[ibra] * ch_no2b.iphase[iket];
   int bra = ch_no2b.abct2n[ibra];
   int ket = ch_no2b.abct2n[iket];
-  auto& Vch = MatEl[ch];
-  Vch[idx1d(bra,ket)] = V * ph;
+  if ( precision_mode == SINGLE_PRECISION )  MatEl_single[ch][idx1d(bra,ket)] = ThreeBMENO2B_single_type(V*ph);
+  else if ( precision_mode == HALF_PRECISION )  MatEl_half[ch][idx1d(bra,ket)] = ThreeBMENO2B_half_type(V*ph);
+//  auto& Vch = MatEl[ch];
+//  Vch[idx1d(bra,ket)] = ThreeBMENO2B_Store_type( V * ph);
 }
 
-ThreeBME_type ThreeBodyMENO2B::GetThBME(int a, int b, int c, int Tab,
+ThreeBMENO2B_IO_type ThreeBodyMENO2B::GetThBME(int a, int b, int c, int Tab,
     int d, int e, int f, int Tde, int J2, int T3)
 {
   OrbitIsospin & oa = iOrbits[a];
@@ -282,28 +329,33 @@ ThreeBME_type ThreeBodyMENO2B::GetThBME(int a, int b, int c, int Tab,
   OrbitIsospin & of = iOrbits[f];
 
   int P1 = oc.l%2;
-  if(P1 != of.l%2) return 0.0;
+  if(P1 != of.l%2) return ThreeBMENO2B_IO_type(0.0);
 
   int J1 = oc.j;
-  if(J1 != of.j) return 0.0;
+  if(J1 != of.j) return ThreeBMENO2B_IO_type(0.0);
 
   int P2 = (oa.l + ob.l)%2;
-  if(P2 != (od.l + oe.l)%2) return 0.0;
+  if(P2 != (od.l + oe.l)%2) return ThreeBMENO2B_IO_type(0.0);
 
   int ch = threebodyspace.idcs2ch[threebodyspace.GetChannelIndex(J2,P2,J1,P1,T3)];
   ThreeBodyChannelNO2B & ch_no2b = threebodyspace.ThreeBodyChannels[ch];
   int ibra = ch_no2b.GetIndex(a,b,c,Tab);
   int iket = ch_no2b.GetIndex(d,e,f,Tde);
-  if(ch_no2b.iphase.find(ibra) == ch_no2b.iphase.end()) return 0.0;
-  if(ch_no2b.iphase.find(iket) == ch_no2b.iphase.end()) return 0.0;
+  if(ch_no2b.iphase.find(ibra) == ch_no2b.iphase.end()) return ThreeBMENO2B_IO_type(0.0);
+  if(ch_no2b.iphase.find(iket) == ch_no2b.iphase.end()) return ThreeBMENO2B_IO_type(0.0);
   int ph = ch_no2b.iphase[ibra] * ch_no2b.iphase[iket];
   int bra = ch_no2b.abct2n[ibra];
   int ket = ch_no2b.abct2n[iket];
-  auto& Vch = MatEl[ch];
-  return Vch[idx1d(bra,ket)] * ph;
+  ThreeBMENO2B_IO_type vout = 0;
+  if ( precision_mode == SINGLE_PRECISION )    vout = MatEl_single[ch][idx1d(bra,ket)] * ph;
+  else if ( precision_mode == HALF_PRECISION ) vout = MatEl_half[ch][idx1d(bra,ket)] * ph;
+  return vout;
+//  auto& Vch = MatEl[ch];
+//  return ThreeBMENO2B_IO_type( Vch[idx1d(bra,ket)] * ph);
+//  return Vch[idx1d(bra,ket)] * ph;
 }
 
-ThreeBME_type ThreeBodyMENO2B::GetThBME(int a, int b, int c, int d, int e, int f,  int J2)
+ThreeBMENO2B_IO_type ThreeBodyMENO2B::GetThBME(int a, int b, int c, int d, int e, int f,  int J2)
 {
   Orbit & oa = modelspace->GetOrbit(a);
   Orbit & ob = modelspace->GetOrbit(b);
@@ -313,16 +365,16 @@ ThreeBME_type ThreeBodyMENO2B::GetThBME(int a, int b, int c, int d, int e, int f
   Orbit & of = modelspace->GetOrbit(f);
 
   int P1 = oc.l%2;
-  if(P1 != of.l%2) return 0.0;
+  if(P1 != of.l%2) return ThreeBMENO2B_IO_type(0.0);
 
   int J1 = oc.j2;
-  if(J1 != of.j2) return 0.0;
+  if(J1 != of.j2) return ThreeBMENO2B_IO_type(0.0);
 
   int P2 = (oa.l + ob.l)%2;
-  if(P2 != (od.l + oe.l)%2) return 0.0;
+  if(P2 != (od.l + oe.l)%2) return ThreeBMENO2B_IO_type(0.0);
 
   int Z3 = oa.tz2 + ob.tz2 + oc.tz2;
-  if(Z3 != od.tz2 + oe.tz2 + of.tz2) return 0.0;
+  if(Z3 != od.tz2 + oe.tz2 + of.tz2) return ThreeBMENO2B_IO_type(0.0);
 
   int i1 = nlj2idx[{oa.n, oa.l, oa.j2}];
   int i2 = nlj2idx[{ob.n, ob.l, ob.j2}];
@@ -339,21 +391,25 @@ ThreeBME_type ThreeBodyMENO2B::GetThBME(int a, int b, int c, int d, int e, int f
       for (int T=std::max( std::abs(2*T12-1), std::abs(2*T45-1) );
           T<= std::min( 2*T12+1, 2*T45+1 ); T+=2){
         v += GetThBME(i1, i2, i3, T12, i4, i5, i6, T45, J2, T) *
-          AngMom::CG(0.5, oa.tz2*0.5, 0.5, ob.tz2*0.5, T12, (oa.tz2+ob.tz2)*0.5) *
-          AngMom::CG(0.5, od.tz2*0.5, 0.5, oe.tz2*0.5, T45, (od.tz2+oe.tz2)*0.5) *
-          AngMom::CG(T12, (oa.tz2+ob.tz2)*0.5, 0.5, oc.tz2*0.5, T*0.5, Z3*0.5) *
-          AngMom::CG(T45, (od.tz2+oe.tz2)*0.5, 0.5, of.tz2*0.5, T*0.5, Z3*0.5);
+             AngMom::CG(0.5, oa.tz2*0.5, 0.5, ob.tz2*0.5, T12, (oa.tz2+ob.tz2)*0.5) *
+             AngMom::CG(0.5, od.tz2*0.5, 0.5, oe.tz2*0.5, T45, (od.tz2+oe.tz2)*0.5) *
+             AngMom::CG(T12, (oa.tz2+ob.tz2)*0.5, 0.5, oc.tz2*0.5, T*0.5, Z3*0.5) *
+             AngMom::CG(T45, (od.tz2+oe.tz2)*0.5, 0.5, of.tz2*0.5, T*0.5, Z3*0.5);
       }
     }
   }
-  return v;
+  return ThreeBMENO2B_IO_type(v);
 }
 
-void ThreeBodyMENO2B::ReadFile()
+//void ThreeBodyMENO2B::ReadFile()
+void ThreeBodyMENO2B::ReadFile(std::string filename)
 {
   double t_start;
-//  long long unsigned int n_elms = CountME(); // this can be moved to after the stream.bin block
-  size_t n_elms = CountME(); 
+  size_t nwords = (precision_mode==HALF_PRECISION) ? sizeof(ThreeBMENO2B_half_type) : sizeof(ThreeBMENO2B_single_type);
+  std::cout << __func__ << "  reading/storing with " << 8*nwords << "  bit floats" << std::endl;
+
+  size_t n_elms = CountME();
+  FileName = filename;
   if(FileName.find("stream.bin") != std::string::npos){
     t_start = omp_get_wtime();
     std::ifstream infile(FileName, std::ios::binary);
@@ -361,22 +417,29 @@ void ThreeBodyMENO2B::ReadFile()
     size_t n_elem = infile.tellg();
     infile.seekg(0, infile.beg);
     n_elem -= infile.tellg();
-    n_elem /= sizeof(ThreeBME_type);
-    // maybe this is the problem?
+//    n_elem /= sizeof(ThreeBMENO2B_File_type);
+    n_elem /= nwords;
     n_elem = std::min(n_elem, n_elms);
     IMSRGProfiler::timer["ThreeBodyMENO2B_calc_n_elem"] += omp_get_wtime() - t_start;
-//    std::vector<float> v(n_elem);
-    std::vector<ThreeBME_type> v(n_elem);
-    t_start = omp_get_wtime();
-    infile.read((char*)&v[0], n_elem*sizeof(ThreeBME_type));
-    IMSRGProfiler::timer["ThreeBodyMENO2B_read_to_array"] += omp_get_wtime() - t_start;
-    //for (int i = 0; i<50; i++){ std::cout<<v[i]<<std::endl;}
-//    VectorStream vecstream(v);
-//    VectorStream<float> vecstream(v);
-    t_start = omp_get_wtime();
-//    ReadStream(vecstream, n_elem);
-    ReadBinaryStream(  v, n_elem);
-    IMSRGProfiler::timer["ThreeBodyMENO2B_read_from_vecstream"] += omp_get_wtime() - t_start;
+
+    if ( precision_mode == SINGLE_PRECISION)
+    {
+      std::vector<ThreeBMENO2B_single_type> v(n_elem);
+//      infile.read((char*)&v[0], n_elem*sizeof(ThreeBMENO2B_File_type));
+      t_start = omp_get_wtime();
+      infile.read((char*)&v[0], n_elem*nwords);
+      IMSRGProfiler::timer["ThreeBodyMENO2B_read_to_array"] += omp_get_wtime() - t_start;
+      ReadBinaryStream(  v, n_elem);
+    }
+    else if ( precision_mode == HALF_PRECISION)
+    {
+      std::vector<ThreeBMENO2B_half_type> v(n_elem);
+      t_start = omp_get_wtime();
+      infile.read((char*)&v[0], n_elem*nwords);
+      IMSRGProfiler::timer["ThreeBodyMENO2B_read_to_array"] += omp_get_wtime() - t_start;
+      ReadBinaryStream(  v, n_elem);
+    }
+//    IMSRGProfiler::timer["ThreeBodyMENO2B_read_from_vecstream"] += omp_get_wtime() - t_start;
     return;
   }
   if(FileName.find(".gz") != std::string::npos){
@@ -410,6 +473,7 @@ long long unsigned int ThreeBodyMENO2B::CountME()
     int j1 = o1.j;
     int l1 = o1.l;
     int e1 = o1.e;
+    if(e1 > Emax) continue;
     if(e1 > Emax_file) continue;
     for (int i2=0; i2 <= i1; i2++) {
       OrbitIsospin & o2 = iOrbits[i2];
@@ -428,7 +492,7 @@ long long unsigned int ThreeBodyMENO2B::CountME()
         if(e1 + e3 > E2max_file) continue;
         if(e1 + e2 + e3 > E3max_file) continue;
 
-        for (int i4=0; i4 < Norbs; i4++) {
+        for (int i4=0; i4 <= i1; i4++) {
           OrbitIsospin & o4 = iOrbits[i4];
           int j4 = o4.j;
           int l4 = o4.l;
@@ -462,17 +526,6 @@ long long unsigned int ThreeBodyMENO2B::CountME()
 
               counter += JT_block_size;
 
-//              for (int J = std::max( std::abs(j1-j2), std::abs(j4-j5) )/2;
-//                  J <= std::min( j1+j2, j4+j5 )/2; J++) {
-//                for (int T12: {0,1}){
-//                  for (int T45: {0,1}){
-//                    for (int T = std::max( std::abs(2*T12-1), std::abs(2*T45-1) );
-//                        T <= std::min( 2*T12+1, 2*T45+1 ); T+=2) {
-//                      counter += 1;
-//                    }
-//                  }
-//                }
-//              }
             }
           }
         }
@@ -484,32 +537,25 @@ long long unsigned int ThreeBodyMENO2B::CountME()
 }
 
 
-// SRS-- I think this can be parallelized
-//void ThreeBodyMENO2B::ReadStream(T & infile, long long unsigned int n_elms)
-void ThreeBodyMENO2B::ReadBinaryStream( std::vector<ThreeBME_type> & v, size_t n_elms)
+//void ThreeBodyMENO2B::ReadBinaryStream( std::vector<ThreeBMENO2B_File_type> & v, size_t n_elms)
+template <class Type>
+void ThreeBodyMENO2B::ReadBinaryStream( std::vector<Type> & v, size_t n_elms)
 {
-//  int buffer_size = 10000000;
-//  int counter = 0;
-//  size_t buffer_size = 10000000;
-//  long long unsigned int total_counter = 0;
+  double t_start = omp_get_wtime();
   int Emax = modelspace->GetEmax();
   int E2max = modelspace->GetE2max();
   int E3max = modelspace->GetE3max();
   int Norbs = iOrbits.size();
-//  std::vector<ThreeBME_type> v(buffer_size,0.0);
-//
-//  std::cout << "Size of v is " << v.size() << std::endl;
+
   std::cout << "Reading " << n_elms << " elements from binary file" << std::endl;
 
   #pragma omp parallel  // not a for block. all the threads go through each step of the for loops
   {
      int num_threads = omp_get_num_threads();
      int this_thread = omp_get_thread_num();
-//     std::cout << "=> " << this_thread << std::endl;
      size_t counter = 0;
      size_t total_counter = 0;
      size_t orbit_counter = 0;
-//     size_t mat_el_counter = 0;
 
   for (int i1=0; i1 < Norbs; i1++) {
     OrbitIsospin & o1 = iOrbits[i1];
@@ -517,9 +563,7 @@ void ThreeBodyMENO2B::ReadBinaryStream( std::vector<ThreeBME_type> & v, size_t n
     int l1 = o1.l;
     int e1 = o1.e;
     if(e1 > Emax) break;
-//    if(e1 > Emax) continue;
     if(e1 > Emax_file) break;
-//    if(e1 > Emax_file) continue;
     for (int i2=0; i2 <= i1; i2++) {
       OrbitIsospin & o2 = iOrbits[i2];
       int j2 = o2.j;
@@ -537,7 +581,7 @@ void ThreeBodyMENO2B::ReadBinaryStream( std::vector<ThreeBME_type> & v, size_t n
         if(e1 + e3 > E2max_file) continue;
         if(e1 + e2 + e3 > E3max_file) continue;
 
-        for (int i4=0; i4 < Norbs; i4++) {
+        for (int i4=0; i4 <= i1; i4++) {
           OrbitIsospin & o4 = iOrbits[i4];
           int j4 = o4.j;
           int l4 = o4.l;
@@ -570,36 +614,19 @@ void ThreeBodyMENO2B::ReadBinaryStream( std::vector<ThreeBME_type> & v, size_t n
               if (Jmin>Jmax) continue;
               int JT_block_size = (Jmax+1-Jmin) * 5; // 5 comes from the 5 possible isospin combinations 001 011 101 111 113
 
-//              std::cout << "   thread, orbit_counter:  " << this_thread << "  " << orbit_counter << std::endl;
-              
-//              if (orbit_counter % 2 != this_thread) 
-              if (orbit_counter % num_threads != this_thread) 
-             {
+              if (orbit_counter % num_threads != this_thread) // This is how we divide the jobs among the threads
+              {
                counter += JT_block_size;
                continue;
-             }
+              }
 
               for (int J = Jmin; J<= Jmax; J++) {
                 for (int T12: {0,1}){
                   for (int T45: {0,1}){
                     for (int T3 = std::max( std::abs(2*T12-1), std::abs(2*T45-1) );
                         T3 <= std::min( 2*T12+1, 2*T45+1 ); T3+=2) {
-//                      if(counter == buffer_size) counter = 0;
-//                      if(counter == 0){
-//                        size_t maxread = std::min(buffer_size, n_elms-total_counter);
-//                        for (size_t iread=0; iread<maxread  ; iread++) infile >> v[iread];
-////                        infile.read( (char*)&v[0], maxread * sizeof(ThreeBME_type) / sizeof(char)  ) ;
-////                        if( n_elms - total_counter >= buffer_size){
-////                          for (size_t iread=0; iread<buffer_size; iread++) infile >> v[iread];
-//////                          for (int iread=0; iread<buffer_size; iread++) infile >> v[iread];
-////                        }
-////                        else{
-////                          for (size_t iread=0; iread<n_elms-total_counter; iread++) infile >> v[iread];
-//////                          for (int iread=0; iread<n_elms-total_counter; iread++) infile >> v[iread];
-////                        }
-//                      }
+
                       counter += 1;
-//                      total_counter += 1;
 
                       if( e1 > Emax) continue;
                       if( e2 > Emax) continue;
@@ -619,7 +646,7 @@ void ThreeBodyMENO2B::ReadBinaryStream( std::vector<ThreeBME_type> & v, size_t n
                       if( e4+e5+e6 > E3max ) continue;
 
                       if( i1==i2 and (J+T12)%2 ==0 ) {
-                        if( abs(v[counter-1]) > 1.e-6 ){
+                        if( std::abs(v[counter-1]) > 1.e-6 ){
                           std::cout << "Warning: something wrong, this three-body matrix element has to be zero" << std::endl;
                           std::cout <<
                             std::setw(4) << i1 << std::setw(4) << i2 << std::setw(4) << i3 << std::setw(4) << T12 <<
@@ -630,7 +657,7 @@ void ThreeBodyMENO2B::ReadBinaryStream( std::vector<ThreeBME_type> & v, size_t n
                       }
 
                       if( i4==i5 and (J+T45)%2 ==0 ) {
-                        if( abs(v[counter-1]) > 1.e-6 ){
+                        if( std::abs(v[counter-1]) > 1.e-6 ){
                           std::cout << "Warning: something wrong, this three-body matrix element has to be zero" << std::endl;
                           std::cout <<
                             std::setw(4) << i1 << std::setw(4) << i2 << std::setw(4) << i3 << std::setw(4) << T12 <<
@@ -639,32 +666,27 @@ void ThreeBodyMENO2B::ReadBinaryStream( std::vector<ThreeBME_type> & v, size_t n
                             std::setw(12) << std::setprecision(6) << v[counter-1] << std::endl;
                         }
                       }
-                      //std::cout <<
-                      //  std::setw(4) << i1 << std::setw(4) << i2 << std::setw(4) << i3 << std::setw(4) << T12 <<
-                      //  std::setw(4) << i4 << std::setw(4) << i5 << std::setw(4) << i6 << std::setw(4) << T45 <<
-                      //  std::setw(4) << J << std::setw(4) << T3 << std::setw(16) << counter <<
-                      //  std::setw(12) << std::setprecision(6) << v[counter-1] << std::endl;
-
-//                      if (this_thread !=0) continue;
-                      SetThBME(i1, i2, i3, T12, i4, i5, i6, T45, J, T3, v[counter-1]);
-
-                    }
-                  }
-                }
-              }
-            }
-          }
-        }
-      }
-    }
-  }
+
+//                      SetThBME(i1, i2, i3, T12, i4, i5, i6, T45, J, T3, v[counter-1]);
+                      SetThBME(i1, i2, i3, T12, i4, i5, i6, T45, J, T3, ThreeBMENO2B_IO_type(v[counter-1]) );
+
+                    }// for T3
+                  }// for T45
+                }// for T12
+              }// for J
+            }// for i6
+          }// for i5
+        }// for i4
+      }// for i3
+    }// for i2
+  }// for i1
   }// end of parallel block
 
+  IMSRGProfiler::timer["ThreeBodyMENO2B_ReadBinaryStream"] += omp_get_wtime() - t_start;
 }
 
 
-   template<class T>
-//void ThreeBodyMENO2B::ReadStream(T & infile, long long unsigned int n_elms)
+ template<class T>
 void ThreeBodyMENO2B::ReadStream(T & infile, size_t n_elms)
 {
 //  int buffer_size = 10000000;
@@ -677,7 +699,14 @@ void ThreeBodyMENO2B::ReadStream(T & infile, size_t n_elms)
   int E2max = modelspace->GetE2max();
   int E3max = modelspace->GetE3max();
   int Norbs = iOrbits.size();
-  std::vector<ThreeBME_type> v(buffer_size,0.0);
+//  std::vector<ThreeBMENO2B_type> v(buffer_size,0.0);
+//  std::vector<ThreeBMENO2B_File_type> v(buffer_size, ThreeBMENO2B_File_type(0.0) );
+  // Make both kinds of vectors, but then we only allocate the one we'll use
+  std::vector<ThreeBMENO2B_single_type> v_single;
+  std::vector<ThreeBMENO2B_half_type> v_half;
+  if (precision_mode == SINGLE_PRECISION )  v_single.resize(buffer_size, ThreeBMENO2B_single_type(0.0));
+  else if (precision_mode == HALF_PRECISION )  v_half.resize(buffer_size, ThreeBMENO2B_half_type(0.0));
+//  std::vector<ThreeBMENO2B_File_type> v(buffer_size, ThreeBMENO2B_File_type(0.0) );
 
   for (int i1=0; i1 < Norbs; i1++) {
     OrbitIsospin & o1 = iOrbits[i1];
@@ -703,7 +732,7 @@ void ThreeBodyMENO2B::ReadStream(T & infile, size_t n_elms)
         if(e1 + e3 > E2max_file) continue;
         if(e1 + e2 + e3 > E3max_file) continue;
 
-        for (int i4=0; i4 < Norbs; i4++) {
+        for (int i4=0; i4 <= i1; i4++) {
           OrbitIsospin & o4 = iOrbits[i4];
           int j4 = o4.j;
           int l4 = o4.l;
@@ -737,16 +766,11 @@ void ThreeBodyMENO2B::ReadStream(T & infile, size_t n_elms)
                       if(counter == buffer_size) counter = 0;
                       if(counter == 0){
                         size_t maxread = std::min(buffer_size, n_elms-total_counter);
-                        for (size_t iread=0; iread<maxread  ; iread++) infile >> v[iread];
-//                        infile.read( (char*)&v[0], maxread * sizeof(ThreeBME_type) / sizeof(char)  ) ;
-//                        if( n_elms - total_counter >= buffer_size){
-//                          for (size_t iread=0; iread<buffer_size; iread++) infile >> v[iread];
-////                          for (int iread=0; iread<buffer_size; iread++) infile >> v[iread];
-//                        }
-//                        else{
-//                          for (size_t iread=0; iread<n_elms-total_counter; iread++) infile >> v[iread];
-////                          for (int iread=0; iread<n_elms-total_counter; iread++) infile >> v[iread];
-//                        }
+
+                        // read from file into the appropriate buffer
+                        if    ( precision_mode == SINGLE_PRECISION )  for (size_t iread=0; iread<maxread ; iread++) infile >> v_single[iread];
+                        else if ( precision_mode == HALF_PRECISION )  for (size_t iread=0; iread<maxread ; iread++) infile >> v_half[iread];
+//                        for (size_t iread=0; iread<maxread  ; iread++) infile >> v[iread]; // read from file into the buffer
                       }
                       counter += 1;
                       total_counter += 1;
@@ -768,44 +792,51 @@ void ThreeBodyMENO2B::ReadStream(T & infile, size_t n_elms)
                       if( e1+e2+e3 > E3max ) continue;
                       if( e4+e5+e6 > E3max ) continue;
 
-                      if( i1==i2 and (J+T12)%2 ==0 ) {
-                        if( abs(v[counter-1]) > 1.e-6 ){
-                          std::cout << "Warning: something wrong, this three-body matrix element has to be zero" << std::endl;
-                          std::cout <<
-                            std::setw(4) << i1 << std::setw(4) << i2 << std::setw(4) << i3 << std::setw(4) << T12 <<
-                            std::setw(4) << i4 << std::setw(4) << i5 << std::setw(4) << i6 << std::setw(4) << T45 <<
-                            std::setw(4) << J << std::setw(4) << T3 << std::setw(16) << counter <<
-                            std::setw(12) << std::setprecision(6) << v[counter-1] << std::endl;
-                        }
-                      }
 
-                      if( i4==i5 and (J+T45)%2 ==0 ) {
-                        if( abs(v[counter-1]) > 1.e-6 ){
+                      ThreeBMENO2B_IO_type vset = 0.0;
+                      if ( precision_mode == SINGLE_PRECISION ) vset = v_single[counter-1];
+                      else if ( precision_mode == HALF_PRECISION ) vset = v_half[counter-1];
+
+
+                      if( (i1==i2 and (J+T12)%2 ==0 ) or ( i4==i5 and (J+T45)%2 ==0 ) ) {
+//                        if( abs(v[counter-1]) > 1.e-6 ){
+                        if( abs(vset) > 1.e-6 ){
                           std::cout << "Warning: something wrong, this three-body matrix element has to be zero" << std::endl;
                           std::cout <<
                             std::setw(4) << i1 << std::setw(4) << i2 << std::setw(4) << i3 << std::setw(4) << T12 <<
                             std::setw(4) << i4 << std::setw(4) << i5 << std::setw(4) << i6 << std::setw(4) << T45 <<
                             std::setw(4) << J << std::setw(4) << T3 << std::setw(16) << counter <<
-                            std::setw(12) << std::setprecision(6) << v[counter-1] << std::endl;
+                            std::setw(12) << std::setprecision(6) << vset << std::endl;
+//                            std::setw(12) << std::setprecision(6) << v[counter-1] << std::endl;
                         }
                       }
-                      //std::cout <<
-                      //  std::setw(4) << i1 << std::setw(4) << i2 << std::setw(4) << i3 << std::setw(4) << T12 <<
-                      //  std::setw(4) << i4 << std::setw(4) << i5 << std::setw(4) << i6 << std::setw(4) << T45 <<
-                      //  std::setw(4) << J << std::setw(4) << T3 << std::setw(16) << counter <<
-                      //  std::setw(12) << std::setprecision(6) << v[counter-1] << std::endl;
-                      SetThBME(i1, i2, i3, T12, i4, i5, i6, T45, J, T3, v[counter-1]);
-
-                    }
-                  }
-                }
-              }
-            }
-          }
-        }
-      }
-    }
-  }
+
+//                      if( i4==i5 and (J+T45)%2 ==0 ) {
+////                        if( abs(v[counter-1]) > 1.e-6 ){
+//                        if( abs(vset) > 1.e-6 ){
+//                          std::cout << "Warning: something wrong, this three-body matrix element has to be zero" << std::endl;
+//                          std::cout <<
+//                            std::setw(4) << i1 << std::setw(4) << i2 << std::setw(4) << i3 << std::setw(4) << T12 <<
+//                            std::setw(4) << i4 << std::setw(4) << i5 << std::setw(4) << i6 << std::setw(4) << T45 <<
+//                            std::setw(4) << J << std::setw(4) << T3 << std::setw(16) << counter <<
+//                            std::setw(12) << std::setprecision(6) << vset << std::endl;
+////                            std::setw(12) << std::setprecision(6) << v[counter-1] << std::endl;
+//                        }
+//                      }
+//                      SetThBME(i1, i2, i3, T12, i4, i5, i6, T45, J, T3, v[counter-1]);
+//                      SetThBME(i1, i2, i3, T12, i4, i5, i6, T45, J, T3, ThreeBMENO2B_IO_type(v[counter-1]) );
+                      SetThBME(i1, i2, i3, T12, i4, i5, i6, T45, J, T3, vset );
+
+                    }// for T3
+                  }// for T45
+                }// for T12
+              }// for J
+            }// for i6
+          }// for i5
+        }// for i4
+      }// for i3
+    }// for i2
+  }// for i1
 
 }
 
diff --git a/src/ThreeBodyMENO2B.hh b/src/ThreeBodyMENO2B.hh
index 7e70a5d..0bde89e 100644
--- a/src/ThreeBodyMENO2B.hh
+++ b/src/ThreeBodyMENO2B.hh
@@ -8,8 +8,22 @@
 #include <unordered_map>
 #include "ModelSpace.hh"
 
-typedef float ThreeBME_type;
-class ThreeBodyMENO2B;
+//#ifdef WITHHALF
+/// Use half-precision floats. For documentation, see http://half.sourceforge.net
+ #include <x86intrin.h>
+ #include "half.hpp"
+ typedef half_float::half ThreeBMENO2B_half_type;
+ typedef float ThreeBMENO2B_single_type;
+// typedef half_float::half ThreeBMENO2B_Store_type;
+// typedef half_float::half ThreeBMENO2B_File_type;
+ typedef double ThreeBMENO2B_IO_type;
+//#else
+// typedef float ThreeBMENO2B_Store_type;
+// typedef float ThreeBMENO2B_File_type;
+// typedef double ThreeBMENO2B_IO_type;
+//#endif
+
+class ThreeBodyMENO2B; // forward declaration
 
 class OrbitIsospin
 {
@@ -19,6 +33,13 @@ class OrbitIsospin
     ~OrbitIsospin();
 };
 
+/// A Three body channel for use in the NO2B approximation.
+/// For a state |abc> we have ja,jb coupled to J2 with parity P2
+/// J1 = jc, and P1 = parity of orbit c.
+/// T3 is twice the total 3-body isospin.
+/// Orbit c is the one that will get summed over the reference
+/// to get the normal ordered 2-body contribution.
+///     --- SRS interpretation of Takayuki's code, so grain of salt.
 class ThreeBodyChannelNO2B
 {
   public:
@@ -33,7 +54,7 @@ class ThreeBodyChannelNO2B
     std::unordered_map<int, int> iphase;
 
     ThreeBodyChannelNO2B();
-    ThreeBodyChannelNO2B(int, int, int, int, int, ThreeBodyMENO2B*);
+    ThreeBodyChannelNO2B(int J2, int P2, int J1, int P1, int T3, ThreeBodyMENO2B*);
     ~ThreeBodyChannelNO2B();
     int GetIndex(int a, int b, int c, int Tab) {return Hash_abct(a, b, c, Tab);};
   private:
@@ -60,10 +81,17 @@ class ThreeBodySpaceNO2B
 
 class ThreeBodyMENO2B
 {
+//    std::map<int, std::vector<ThreeBMENO2B_Store_type>> MatEl;
+    std::map<int, std::vector<ThreeBMENO2B_single_type>> MatEl_single;
+    std::map<int, std::vector<ThreeBMENO2B_half_type>> MatEl_half;
   public:
+    int precision_mode;
+    const static int DOUBLE_PRECISION;
+    const static int SINGLE_PRECISION;
+    const static int HALF_PRECISION;
     ModelSpace * modelspace;
     ThreeBodySpaceNO2B threebodyspace;
-    std::map<int, std::vector<ThreeBME_type>> MatEl;
+//    std::map<int, std::vector<ThreeBMENO2B_type>> MatEl;
     std::vector<OrbitIsospin> iOrbits;
     std::map<std::array<int,3>, int> nlj2idx;
     int Emax;
@@ -86,15 +114,21 @@ class ThreeBodyMENO2B
     ThreeBodyMENO2B& operator+=(const ThreeBodyMENO2B&);
     ThreeBodyMENO2B& operator-=(const ThreeBodyMENO2B&);
 
-    void Allocate(ModelSpace & ms, int emax_file, int e2max_file, int e3max_file, int lmax_file, std::string filename);
+    void SetHalfPrecision();
+    void SetSinglePrecision();
+
+//    void Allocate(ModelSpace & ms, int emax_file, int e2max_file, int e3max_file, int lmax_file, std::string filename);
+    void Allocate(ModelSpace & ms, int emax_file, int e2max_file, int e3max_file, int lmax_file);
     size_t idx1d(size_t bra, size_t ket) { return std::max(bra+1,ket+1) * (std::max(bra+1,ket+1)-1)/2 + std::min(bra+1,ket+1)-1;};
-    void SetThBME(int a, int b, int c, int Tab, int d, int e, int f, int Tde, int J2, int T3, ThreeBME_type V);
-    ThreeBME_type GetThBME(int a, int b, int c, int Tab, int d, int e, int f, int Tde, int J2, int T3);
-    ThreeBME_type GetThBME(int a, int b, int c, int d, int e, int f, int J2);
-    void ReadFile();
+    void SetThBME(int a, int b, int c, int Tab, int d, int e, int f, int Tde, int J2, int T3, ThreeBMENO2B_IO_type V);
+    ThreeBMENO2B_IO_type GetThBME(int a, int b, int c, int Tab, int d, int e, int f, int Tde, int J2, int T3);
+    ThreeBMENO2B_IO_type GetThBME(int a, int b, int c, int d, int e, int f, int twoJ);
+//    void ReadFile();
+    void ReadFile( std::string filename );
     long long unsigned int CountME();
 //    template<class T> void ReadStream(T & infile, long long unsigned int n_elms);
     template<class T> void ReadStream(T & infile, size_t n_elms);
-    void ReadBinaryStream( std::vector<ThreeBME_type>& v, size_t nelms);
+//    void ReadBinaryStream( std::vector<ThreeBMENO2B_Store_type>& v, size_t nelms);
+    template <class Type> void ReadBinaryStream( std::vector<Type>& v, size_t nelms);
 };
 #endif
diff --git a/src/ThreeBodyMEpn.cc b/src/ThreeBodyMEpn.cc
index 0efb6c4..b6d862a 100644
--- a/src/ThreeBodyMEpn.cc
+++ b/src/ThreeBodyMEpn.cc
@@ -18,7 +18,7 @@ ThreeBodyMEpn::ThreeBodyMEpn(ModelSpace* ms)
 }
 
 ThreeBodyMEpn::ThreeBodyMEpn(ModelSpace* ms, int e3max)
-:  modelspace(ms), isospin3BME(ms,e3max), PN_mode(false), E3max(e3max), herm(1), rank_J(0), rank_T(0), parity(0) 
+:  modelspace(ms), isospin3BME(ms,e3max,0,0,0), PN_mode(false), E3max(e3max), herm(1), rank_J(0), rank_T(0), parity(0) 
 {
 }
 
@@ -32,7 +32,7 @@ ThreeBodyMEpn::ThreeBodyMEpn(const ThreeBodyMEpn& tbme)
 }
 
 ThreeBodyMEpn::ThreeBodyMEpn(ModelSpace* ms, int rankJ, int rankT, int p)
-:  modelspace(ms), isospin3BME(ms,ms->GetE3max()), PN_mode(false), E3max(ms->GetE3max()), herm(1), rank_J(rankJ), rank_T(rankT), parity(p)
+:  modelspace(ms), isospin3BME(ms,ms->GetE3max(),rankJ,rankT,p), PN_mode(false), E3max(ms->GetE3max()), herm(1), rank_J(rankJ), rank_T(rankT), parity(p)
 {
 }
 
@@ -151,16 +151,29 @@ ThreeBodyMEpn::ME_type ThreeBodyMEpn::GetME_pn(int Jab_in, int Jde_in, int J2, i
 
 ThreeBodyMEpn::ME_type ThreeBodyMEpn::GetME(  int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int twoT, int i, int j, int k, int l, int m, int n)
 {
-  if (PN_mode) return GetME_PN( Jab_in, Jde_in, J2, tab_in,tde_in,twoT,i,j,k,l,m,n);
-  else return isospin3BME.GetME(Jab_in, Jde_in, J2, tab_in,tde_in,twoT,i,j,k,l,m,n);
+  if (PN_mode) return GetME_PN( Jab_in, Jde_in, J2, tab_in,tde_in,twoT,twoT,i,j,k,l,m,n);
+  else return isospin3BME.GetME(Jab_in, Jde_in, J2, tab_in,tde_in,twoT,twoT,i,j,k,l,m,n);
 }
 
+ThreeBodyMEpn::ME_type ThreeBodyMEpn::GetME(  int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int twoTabc, int twoTdef, int i, int j, int k, int l, int m, int n)
+{
+  if (PN_mode) return GetME_PN( Jab_in, Jde_in, J2, tab_in,tde_in,twoTabc,twoTdef,i,j,k,l,m,n);
+  else return isospin3BME.GetME(Jab_in, Jde_in, J2, tab_in,tde_in,twoTabc,twoTdef,i,j,k,l,m,n);
+}
+
+
+
 void ThreeBodyMEpn::SetME(  int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int twoT, int i, int j, int k, int l, int m, int n, ThreeBodyMEpn::ME_type V)
+{
+    SetME( Jab_in, Jde_in, J2, tab_in, tde_in, twoT, twoT, i, j, k, l, m, n, V);
+}
+
+void ThreeBodyMEpn::SetME(  int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int twoTabc, int twoTdef, int i, int j, int k, int l, int m, int n, ThreeBodyMEpn::ME_type V)
 {
 //  if (PN_mode) SetME_PN( Jab_in, Jde_in, J2, tab_in,tde_in,twoT,i,j,k,l,m,n,V);
   if ( not PN_mode)
   {
-     isospin3BME.SetME(Jab_in, Jde_in, J2, tab_in,tde_in,twoT,i,j,k,l,m,n,V);
+     isospin3BME.SetME(Jab_in, Jde_in, J2, tab_in,tde_in,twoTabc,twoTdef,i,j,k,l,m,n,V);
   }
   else
   {
@@ -168,6 +181,7 @@ void ThreeBodyMEpn::SetME(  int Jab_in, int Jde_in, int J2, int tab_in, int tde_
   }
 }
 
+
 //void ThreeBodyMEpn::AddToME(  int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int twoT, int i, int j, int k, int l, int m, int n, ThreeBodyMEpn::ME_type V)
 //{
 //  if (PN_mode) AddToME_PN( Jab_in, Jde_in, J2, tab_in,tde_in,twoT,i,j,k,l,m,n,V);
@@ -529,11 +543,18 @@ ThreeBodyMEpn::ME_type ThreeBodyMEpn::GetME_pn_PN(int Jab, int Jde, int twoJ, in
 //}
 
 // isospin version
+// backwards compatible wrapper for convenience
 ThreeBodyMEpn::ME_type ThreeBodyMEpn::GetME_PN(  int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int twoT, int i, int j, int k, int l, int m, int n ) 
+{
+  return GetME_PN( Jab_in, Jde_in, J2, tab_in, tde_in, twoT, twoT, i, j, k, l, m, n ); 
+}
+
+ThreeBodyMEpn::ME_type ThreeBodyMEpn::GetME_PN(  int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int twoTabc, int twoTdef, int i, int j, int k, int l, int m, int n ) 
 {
 
   ThreeBodyMEpn::ME_type me_iso = 0;
-  int twoTz =  twoT; // it should be independent of Tz, so we just pick one
+//  int twoTz =  twoT; // it should be independent of Tz, so we just pick one
+  int twoTz =  1; // it should be independent of Tz, so we just pick one
   if (i==j and (Jab_in+tab_in)%2==0) return 0;
   if (l==m and (Jde_in+tde_in)%2==0) return 0;
   for (int tz2i : {-1,1} )
@@ -545,7 +566,8 @@ ThreeBodyMEpn::ME_type ThreeBodyMEpn::GetME_PN(  int Jab_in, int Jde_in, int J2,
       for (int tz2k : {-1,1} )
       {
         if ( (tz2i + tz2j + tz2k) != twoTz) continue;
-        double clebsch_ijk = AngMom::CG(tab_in, 0.5*(tz2i+tz2j), 0.5, 0.5*tz2k, 0.5*twoT, 0.5*twoTz );
+//        double clebsch_ijk = AngMom::CG(tab_in, 0.5*(tz2i+tz2j), 0.5, 0.5*tz2k, 0.5*twoT, 0.5*twoTz );
+        double clebsch_ijk = AngMom::CG(tab_in, 0.5*(tz2i+tz2j), 0.5, 0.5*tz2k, 0.5*twoTabc, 0.5*twoTz );
         if ( std::abs(clebsch_ijk)<1e-7) continue;
         for (int tz2l : {-1,1} )
         {
@@ -555,7 +577,8 @@ ThreeBodyMEpn::ME_type ThreeBodyMEpn::GetME_PN(  int Jab_in, int Jde_in, int J2,
             if (std::abs(tz2n)!=1) continue;
             double clebsch_lm = AngMom::CG(0.5,0.5*tz2l, 0.5,0.5*tz2m, tde_in, 0.5*(tz2l+tz2m) );
             if ( std::abs(clebsch_lm)<1e-7) continue;
-            double clebsch_lmn = AngMom::CG(tde_in, 0.5*(tz2l+tz2m), 0.5, 0.5*tz2n, 0.5*twoT, 0.5*twoTz );
+//            double clebsch_lmn = AngMom::CG(tde_in, 0.5*(tz2l+tz2m), 0.5, 0.5*tz2n, 0.5*twoT, 0.5*twoTz );
+            double clebsch_lmn = AngMom::CG(tde_in, 0.5*(tz2l+tz2m), 0.5, 0.5*tz2n, 0.5*twoTdef, 0.5*twoTz );
             if ( std::abs(clebsch_lmn)<1e-7) continue;
             size_t ipn = 2*(i/2) + (tz2i+1)/2;
             size_t jpn = 2*(j/2) + (tz2j+1)/2;
@@ -612,7 +635,7 @@ void ThreeBodyMEpn::TransformToPN()
         Ket3& ket = Tbc.GetKet(iket);
         double me_pn = isospin3BME.GetME_pn( bra.Jpq, ket.Jpq,twoJ,  bra.p, bra.q, bra.r, ket.p, ket.q, ket.r );
         SetME_pn_PN_ch( ch, ch, ibra, iket, me_pn);
-        // check that this worked as expected
+//        // check that this worked as expected
 //        double me_check = GetME_pn_PN(bra.Jpq, ket.Jpq,twoJ,  bra.p, bra.q, bra.r, ket.p, ket.q, ket.r );
 //        if (std::abs(me_pn-me_check)>1e-6)
 //        {
@@ -624,7 +647,8 @@ void ThreeBodyMEpn::TransformToPN()
     }
   }
   // hopefully free up memory?
-  std::vector<ThreeBME_type>().swap( isospin3BME.MatEl );
+//  std::vector<ThreeBME_type>().swap( isospin3BME.MatEl );
+  std::vector<ThreeBodyME::ME_type>().swap( isospin3BME.MatEl );
   std::unordered_map<size_t, size_t>().swap( isospin3BME.OrbitIndexHash );
   PN_mode = true;
 
@@ -645,7 +669,8 @@ void ThreeBodyMEpn::SwitchToPN_and_discard()
   Allocate_PN();
 
   // hopefully free up memory?
-  std::vector<ThreeBME_type>().swap( isospin3BME.MatEl );
+//  std::vector<ThreeBME_type>().swap( isospin3BME.MatEl );
+  std::vector<ThreeBodyME::ME_type>().swap( isospin3BME.MatEl );
   std::unordered_map<size_t, size_t>().swap( isospin3BME.OrbitIndexHash );
   PN_mode = true;
   IMSRGProfiler::timer[__func__] += omp_get_wtime() - t_start;
@@ -844,7 +869,8 @@ void ThreeBodyMEpn::Print(size_t ch_bra, size_t ch_ket)
   size_t nkets = Tbc_ket.GetNumberKets();
   for (size_t ibra=0; ibra<nbras; ibra++)
   {
-    for (size_t iket=0; iket<=ibra; iket++)
+    size_t max_ket =   (ch_bra==ch_ket) ? ibra : nkets-1;
+    for (size_t iket=0; iket<=max_ket; iket++)
     {
 //      size_t index = ch_start[ch_bra] + (2*ch_dim[ch_bra] - iket - 1)*iket/2 + ibra  ;
       size_t index;
diff --git a/src/ThreeBodyMEpn.hh b/src/ThreeBodyMEpn.hh
index e4bbc53..52293e8 100644
--- a/src/ThreeBodyMEpn.hh
+++ b/src/ThreeBodyMEpn.hh
@@ -13,10 +13,9 @@
 //
 class ThreeBodyMEpn
 {
+ public:
 //  typedef float ME_type;
   typedef double ME_type;
-
- public:
   ModelSpace * modelspace;
   std::vector<ME_type> matrix_data;
 //  std::vector<size_t> ch_start;
@@ -56,7 +55,9 @@ class ThreeBodyMEpn
 
 
   ME_type GetME(  int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int twoT, int i, int j, int k, int l, int m, int n) ;
+  ME_type GetME(  int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int twoTabc, int twoTdef, int i, int j, int k, int l, int m, int n) ;
   void SetME(  int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int twoT, int i, int j, int k, int l, int m, int n, ME_type) ;
+  void SetME(  int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int twoTabc, int twoTdef, int i, int j, int k, int l, int m, int n, ME_type) ;
 //  void AddToME(  int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int twoT, int i, int j, int k, int l, int m, int n, ME_type) ;
 
 
@@ -74,6 +75,7 @@ class ThreeBodyMEpn
 //  void AddToME_pn_PN(int Jab_in, int Jde_in, int J2, int i, int j, int k, int l, int m, int n, ME_type) ;
 
   ME_type GetME_PN(  int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int twoT, int i, int j, int k, int l, int m, int n) ;
+  ME_type GetME_PN(  int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int twoTabc, int twoTdef, int i, int j, int k, int l, int m, int n) ;
 //  void SetME_PN(  int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int twoT, int i, int j, int k, int l, int m, int n, ME_type) ;
 //  void AddToME_PN(  int Jab_in, int Jde_in, int J2, int tab_in, int tde_in, int twoT, int i, int j, int k, int l, int m, int n, ME_type) ;
 
diff --git a/src/TwoBodyME.cc b/src/TwoBodyME.cc
index 08e01ce..cd61774 100755
--- a/src/TwoBodyME.cc
+++ b/src/TwoBodyME.cc
@@ -119,7 +119,7 @@ double TwoBodyME::GetTBME(int ch_bra, int ch_ket, int a, int b, int c, int d) co
    return norm * GetTBME_norm(ch_bra,ch_ket,a,b,c,d);
 }
 
-/// This returns the normalized matrix element 
+/// This returns the normalized matrix element
 double TwoBodyME::GetTBME_norm(int ch_bra, int ch_ket, int a, int b, int c, int d) const
 {
    TwoBodyChannel& tbc_bra =  modelspace->GetTwoBodyChannel(ch_bra);
@@ -143,6 +143,7 @@ double TwoBodyME::GetTBME_norm(int ch_bra, int ch_ket, int a, int b, int c, int
 
 void TwoBodyME::SetTBME(int ch_bra, int ch_ket, int a, int b, int c, int d, double tbme)
 {
+   if( ch_bra > ch_ket ) return;
    TwoBodyChannel& tbc_bra =  modelspace->GetTwoBodyChannel(ch_bra);
    TwoBodyChannel& tbc_ket =  modelspace->GetTwoBodyChannel(ch_ket);
    int bra_ind = tbc_bra.GetLocalIndex(std::min(a,b),std::max(a,b));
@@ -512,7 +513,7 @@ double TwoBodyME::GetTBMEmonopole(int a, int b, int c, int d) const
 
    int jmin = std::abs(oa.j2 - ob.j2)/2;
    int jmax = (oa.j2 + ob.j2)/2;
-   
+
    for (int J=jmin;J<=jmax;++J)
    {
 
@@ -538,7 +539,7 @@ double TwoBodyME::GetTBMEmonopole_norm(int a, int b, int c, int d) const
 
    int jmin = std::abs(oa.j2 - ob.j2)/2;
    int jmax = (oa.j2 + ob.j2)/2;
-   
+
    for (int J=jmin;J<=jmax;++J)
    {
 
diff --git a/src/UnitTest.cc b/src/UnitTest.cc
index 7559922..e38dac1 100644
--- a/src/UnitTest.cc
+++ b/src/UnitTest.cc
@@ -482,8 +482,8 @@ void UnitTest::TestCommutators3(Operator& X, Operator& Y)
 //  all_good &= Test_comm332_ppph_hhhpss( X, Y ); 
 //  all_good &= Test_comm332_pphhss( X, Y );  
 
-//  all_good &= Test_comm233_pp_hhss( X, Y );   
-  all_good &= Test_comm233_ph_ss( X, Y );  
+  all_good &= Test_comm233_pp_hhss( X, Y );   
+//  all_good &= Test_comm233_ph_ss( X, Y );  
 //  all_good &= Test_comm333_ppp_hhh_ss( X, Y );  
 //  all_good &= Test_comm333_pph_hhp_ss( X, Y );  
 
@@ -4394,6 +4394,51 @@ bool UnitTest::Test_comm433sd_ph( const Operator& X, const Operator& Yin )
 
 
 
+bool UnitTest::SanityCheck()
+{
+ 
+  std::cout << "Test simple Clebsch-Gordan coeff..." << std::endl;
+  double cg1 = AngMom::CG(0.5,0.5,0.5,-0.5,0,0);
+  if ( std::abs( cg1 - sqrt(0.5)) > 1e-6 )
+  {
+    std::cout << __FILE__ << "  " << __func__ << " failed on line " << __LINE__ << std::endl;
+    return false;
+  }
+
+  std::cout << "Construct a model space..." << std::endl;
+  int emax = 2;
+  std::string ref = "He4";
+  auto ms = ModelSpace(2,ref,ref);
+  int A,Z;
+  ms.GetAZfromString("Pb208",A,Z);
+  if ( not (A==208 and Z==82) )
+  {
+    std::cout << __FILE__ << "  " << __func__ << " failed on line " << __LINE__ << std::endl;
+    return false;
+  }
+
+  std::cout << "Construct the kinetic energy operator..." << std::endl;
+  Operator trel = imsrg_util::Trel_Op(ms);
+  double normT = trel.Norm();
+  std::cout << "...it should have a non-zero norm...  norm = " << normT << std::endl;
+  if ( std::abs(normT) < 1e-8 )
+  {
+    std::cout << __FILE__ << "  " << __func__ << " failed on line " << __LINE__ << std::endl;
+    return false;
+  }
+  Operator comTT = Commutator::Commutator(trel,trel);
+  double normcomTT = comTT.Norm();
+  std::cout << "...and check that it commutes with itself...   || [T,T] || = " << normcomTT << std::endl;
+  if ( std::abs(normcomTT) > 1e-8 )
+  {
+    std::cout << __FILE__ << "  " << __func__ << " failed on line " << __LINE__ << std::endl;
+    return false;
+  }
+
+ std::cout << __func__ << " :  Things look ok! " << std::endl;
+ return true;
+
+}
 
 
 
diff --git a/src/UnitTest.hh b/src/UnitTest.hh
index d901d02..82536cc 100644
--- a/src/UnitTest.hh
+++ b/src/UnitTest.hh
@@ -84,6 +84,8 @@ class UnitTest
   bool Test_comm433sd_ph(     const Operator& X, const Operator& Y   );
 
 
+  bool SanityCheck();
+
 };
 
 
diff --git a/src/half/ChangeLog.txt b/src/half/ChangeLog.txt
new file mode 100644
index 0000000..6142654
--- /dev/null
+++ b/src/half/ChangeLog.txt
@@ -0,0 +1,205 @@
+Release Notes
+=============
+
+2.1.0 release (2019-08-05):
+---------------------------
+
+- Added detection of IEEE floating-point exceptions to operators and functions.
+- Added configuration options for automatic exception handling.
+- Added functions for explicitly managing floating-point exception flags.
+- Improved accuracy of `pow` and `atan2` functions.
+
+
+2.0.0 release (2019-07-23):
+---------------------------
+
+- Made internal implementation independent from built-in floating point 
+  facilities for increased reliability and IEEE-conformance.
+- Changed default rounding mode to rounding to nearest.
+- Always round ties to even when rounding to nearest.
+- Extended `constexpr` support to comparison and classification functions.
+- Added support for F16C compiler intrinsics for conversions.
+- Enabled C++11 feature detection for Intel compilers.
+
+
+1.12.0 release (2017-03-06):
+----------------------------
+
+- Changed behaviour of `half_cast` to perform conversions to/from `double` 
+  and `long double` directly according to specified rounding mode, without an 
+  intermediate `float` conversion.
+- Added `noexcept` specifiers to constructors.
+- Fixed minor portability problem with `logb` and `ilogb`.
+- Tested for *VC++ 2015*.
+
+
+1.11.0 release (2013-11-16):
+----------------------------
+
+- Made tie-breaking behaviour in round to nearest configurable by 
+  `HALF_ROUND_TIES_TO_EVEN` macro.
+- Completed support for all C++11 mathematical functions even if single-
+  precision versions from `<cmath>` are unsupported.
+- Fixed inability to disable support for C++11 mathematical functions on 
+  *VC++ 2013*.
+
+
+1.10.0 release (2013-11-09):
+----------------------------
+
+- Made default rounding mode configurable by `HALF_ROUND_STYLE` macro.
+- Added support for non-IEEE single-precision implementations.
+- Added `HALF_ENABLE_CPP11_TYPE_TRAITS` preprocessor flag for checking 
+  support for C++11 type traits and TMP features.
+- Restricted `half_cast` to support built-in arithmetic types only.
+- Changed behaviour of `half_cast` to respect rounding mode when casting 
+  to/from integer types.
+
+
+1.9.2 release (2013-11-01):
+---------------------------
+
+- Tested for *gcc 4.8*.
+- Tested and fixed for *VC++ 2013*.
+- Removed unnecessary warnings in *MSVC*.
+
+
+1.9.1 release (2013-08-08):
+---------------------------
+
+- Fixed problems with older gcc and MSVC versions.
+- Small fix to non-C++11 implementations of `remainder` and `remquo`.
+
+
+1.9.0 release (2013-08-07):
+---------------------------
+
+- Changed behaviour of `nearbyint`, `rint`, `lrint` and `llrint` to use 
+  rounding mode of half-precision implementation (which is 
+  truncating/indeterminate) instead of single-precision rounding mode.
+- Added support for more C++11 mathematical functions even if single-
+  precision versions from `<cmath>` are unsupported, in particular 
+  `remainder`, `remquo` and `cbrt`.
+- Minor implementation changes.
+
+
+1.8.1 release (2013-01-22):
+---------------------------
+
+- Fixed bug resulting in multiple definitions of the `nanh` function due to 
+  a missing `inline` specification.
+
+
+1.8.0 release (2013-01-19):
+---------------------------
+
+- Added support for more C++11 mathematical functions even if single-
+  precision versions from `<cmath>` are unsupported, in particular 
+  exponential and logarithm functions, hyperbolic area functions and the 
+  hypotenuse function.
+- Made `fma` function use default implementation if single-precision version
+  from `<cmath>` is not faster and thus `FP_FAST_FMAH` to be defined always.
+- Fixed overload resolution issues when invoking certain mathematical 
+  functions by unqualified calls.
+
+
+1.7.0 release (2012-10-26):
+---------------------------
+
+- Added support for C++11 `noexcept` specifiers.
+- Changed C++11 `long long` to be supported on *VC++ 2003* and up.
+
+
+1.6.1 release (2012-09-13):
+---------------------------
+
+- Made `fma` and `fdim` functions available even if corresponding 
+  single-precision functions are not.
+
+
+1.6.0 release (2012-09-12):
+---------------------------
+
+- Added `HALF_ENABLE_CPP11_LONG_LONG` to control support for `long long` 
+  integers and corresponding mathematical functions.
+- Fixed C++98 compatibility on non-VC compilers.
+
+
+1.5.1 release (2012-08-17):
+---------------------------
+
+- Recorrected `std::numeric_limits::round_style` to always return 
+  `std::round_indeterminate`, due to overflow-handling deviating from 
+  correct round-toward-zero behaviour.
+
+
+1.5.0 release (2012-08-16):
+---------------------------
+
+- Added `half_cast` for explicitly casting between half and any type 
+  convertible to/from `float` and allowing the explicit specification of 
+  the rounding mode to use.
+
+
+1.4.0 release (2012-08-12):
+---------------------------
+
+- Added support for C++11 generalized constant expressions (`constexpr`).
+
+
+1.3.1 release (2012-08-11):
+---------------------------
+
+- Fixed requirement for `std::signbit` and `std::isnan` (even if C++11 
+  `<cmath>` functions disabled) on non-VC compilers.
+
+
+1.3.0 release (2012-08-10):
+---------------------------
+
+- Made requirement for `<cstdint>` and `static_assert` optional and thus 
+  made the library C++98-compatible.
+- Made support for C++11 features user-overridable through explicit 
+  definition of corresponding preprocessor symbols to either 0 or 1.
+- Renamed `HALF_ENABLE_HASH` to `HALF_ENABLE_CPP11_HASH` in correspondence 
+  with other C++11 preprocessor symbols.
+
+
+1.2.0 release (2012-08-07):
+---------------------------
+
+- Added proper preprocessor definitions for `HUGE_VALH` and `FP_FAST_FMAH` 
+  in correspondence with their single-precision counterparts from `<cmath>`.
+- Fixed internal preprocessor macros to be properly undefined after use.
+
+
+1.1.2 release (2012-08-07):
+---------------------------
+
+- Revised `std::numeric_limits::round_style` to return 
+  `std::round_toward_zero` if the `float` version also does and 
+  `std::round_indeterminate` otherwise.
+- Fixed `std::numeric_limits::round_error` to reflect worst-case round 
+  toward zero behaviour.
+
+
+1.1.1 release (2012-08-06):
+---------------------------
+
+- Fixed `std::numeric_limits::min` to return smallest positive normal 
+  number, instead of subnormal number.
+- Fixed `std::numeric_limits::round_style` to return 
+  `std::round_indeterminate` due to mixture of separately rounded 
+  single-precision arithmetics with truncating single-to-half conversions.
+
+
+1.1.0 release (2012-08-06):
+---------------------------
+
+- Added half-precision literals.
+
+
+1.0.0 release (2012-08-05):
+---------------------------
+
+- First release.
diff --git a/src/half/LICENSE.txt b/src/half/LICENSE.txt
new file mode 100644
index 0000000..a3fcf0f
--- /dev/null
+++ b/src/half/LICENSE.txt
@@ -0,0 +1,21 @@
+The MIT License
+
+Copyright (c) 2012-2019 Christian Rau
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
diff --git a/src/half/README.txt b/src/half/README.txt
new file mode 100644
index 0000000..e73400e
--- /dev/null
+++ b/src/half/README.txt
@@ -0,0 +1,317 @@
+HALF-PRECISION FLOATING-POINT LIBRARY (Version 2.1.0)
+-----------------------------------------------------
+
+This is a C++ header-only library to provide an IEEE 754 conformant 16-bit 
+half-precision floating-point type along with corresponding arithmetic 
+operators, type conversions and common mathematical functions. It aims for both 
+efficiency and ease of use, trying to accurately mimic the behaviour of the 
+built-in floating-point types at the best performance possible.
+
+
+INSTALLATION AND REQUIREMENTS
+-----------------------------
+
+Conveniently, the library consists of just a single header file containing all 
+the functionality, which can be directly included by your projects, without the 
+neccessity to build anything or link to anything.
+
+Whereas this library is fully C++98-compatible, it can profit from certain 
+C++11 features. Support for those features is checked automatically at compile 
+(or rather preprocessing) time, but can be explicitly enabled or disabled by 
+predefining the corresponding preprocessor symbols to either 1 or 0 yourself 
+before including half.hpp. This is useful when the automatic detection fails 
+(for more exotic implementations) or when a feature should be explicitly 
+disabled:
+
+  - 'long long' integer type for mathematical functions returning 'long long' 
+    results (enabled for VC++ 2003 and icc 11.1 and newer, gcc and clang, 
+    overridable with 'HALF_ENABLE_CPP11_LONG_LONG').
+
+  - Static assertions for extended compile-time checks (enabled for VC++ 2010, 
+    gcc 4.3, clang 2.9, icc 11.1 and newer, overridable with 
+    'HALF_ENABLE_CPP11_STATIC_ASSERT').
+
+  - Generalized constant expressions (enabled for VC++ 2015, gcc 4.6, clang 3.1, 
+    icc 14.0 and newer, overridable with 'HALF_ENABLE_CPP11_CONSTEXPR').
+
+  - noexcept exception specifications (enabled for VC++ 2015, gcc 4.6, 
+    clang 3.0, icc 14.0 and newer, overridable with 'HALF_ENABLE_CPP11_NOEXCEPT').
+
+  - User-defined literals for half-precision literals to work (enabled for 
+    VC++ 2015, gcc 4.7, clang 3.1, icc 15.0 and newer, overridable with 
+    'HALF_ENABLE_CPP11_USER_LITERALS').
+
+  - Thread-local storage for per-thread floating-point exception flags (enabled 
+    for VC++ 2015, gcc 4.8, clang 3.3, icc 15.0 and newer, overridable with 
+    'HALF_ENABLE_CPP11_THREAD_LOCAL').
+
+  - Type traits and template meta-programming features from <type_traits> 
+    (enabled for VC++ 2010, libstdc++ 4.3, libc++ and newer, overridable with 
+    'HALF_ENABLE_CPP11_TYPE_TRAITS').
+
+  - Special integer types from <cstdint> (enabled for VC++ 2010, libstdc++ 4.3, 
+    libc++ and newer, overridable with 'HALF_ENABLE_CPP11_CSTDINT').
+
+  - Certain C++11 single-precision mathematical functions from <cmath> for 
+    floating-point classification during conversions from higher precision types 
+    (enabled for VC++ 2013, libstdc++ 4.3, libc++ and newer, overridable with 
+    'HALF_ENABLE_CPP11_CMATH').
+
+  - Floating-point environment control from <cfenv> for possible exception 
+    propagation to the built-in floating-point platform (enabled for VC++ 2013, 
+    libstdc++ 4.3, libc++ and newer, overridable with 'HALF_ENABLE_CPP11_CFENV').
+
+  - Hash functor 'std::hash' from <functional> (enabled for VC++ 2010, 
+    libstdc++ 4.3, libc++ and newer, overridable with 'HALF_ENABLE_CPP11_HASH').
+
+The library has been tested successfully with Visual C++ 2005-2015, gcc 4-8 
+and clang 3-8 on 32- and 64-bit x86 systems. Please contact me if you have any 
+problems, suggestions or even just success testing it on other platforms.
+
+
+DOCUMENTATION
+-------------
+
+What follows are some general words about the usage of the library and its 
+implementation. For a complete documentation of its interface consult the 
+corresponding website http://half.sourceforge.net. You may also generate the 
+complete developer documentation from the library's only include file's doxygen 
+comments, but this is more relevant to developers rather than mere users.
+
+BASIC USAGE
+
+To make use of the library just include its only header file half.hpp, which 
+defines all half-precision functionality inside the 'half_float' namespace. The 
+actual 16-bit half-precision data type is represented by the 'half' type, which 
+uses the standard IEEE representation with 1 sign bit, 5 exponent bits and 11 
+mantissa bits (including the hidden bit) and supports all types of special 
+values, like subnormal values, infinity and NaNs. This type behaves like the 
+built-in floating-point types as much as possible, supporting the usual 
+arithmetic, comparison and streaming operators, which makes its use pretty 
+straight-forward:
+
+    using half_float::half;
+    half a(3.4), b(5);
+    half c = a * b;
+    c += 3;
+    if(c > a)
+        std::cout << c << std::endl;
+
+Additionally the 'half_float' namespace also defines half-precision versions 
+for all mathematical functions of the C++ standard library, which can be used 
+directly through ADL:
+
+    half a(-3.14159);
+    half s = sin(abs(a));
+    long l = lround(s);
+
+You may also specify explicit half-precision literals, since the library 
+provides a user-defined literal inside the 'half_float::literal' namespace, 
+which you just need to import (assuming support for C++11 user-defined literals):
+
+    using namespace half_float::literal;
+    half x = 1.0_h;
+
+Furthermore the library provides proper specializations for 
+'std::numeric_limits', defining various implementation properties, and 
+'std::hash' for hashing half-precision numbers (assuming support for C++11 
+'std::hash'). Similar to the corresponding preprocessor symbols from <cmath> 
+the library also defines the 'HUGE_VALH' constant and maybe the 'FP_FAST_FMAH' 
+symbol.
+
+CONVERSIONS AND ROUNDING
+
+The half is explicitly constructible/convertible from a single-precision float 
+argument. Thus it is also explicitly constructible/convertible from any type 
+implicitly convertible to float, but constructing it from types like double or 
+int will involve the usual warnings arising when implicitly converting those to 
+float because of the lost precision. On the one hand those warnings are 
+intentional, because converting those types to half neccessarily also reduces 
+precision. But on the other hand they are raised for explicit conversions from 
+those types, when the user knows what he is doing. So if those warnings keep 
+bugging you, then you won't get around first explicitly converting to float 
+before converting to half, or use the 'half_cast' described below. In addition 
+you can also directly assign float values to halfs.
+
+In contrast to the float-to-half conversion, which reduces precision, the 
+conversion from half to float (and thus to any other type implicitly 
+convertible from float) is implicit, because all values represetable with 
+half-precision are also representable with single-precision. This way the 
+half-to-float conversion behaves similar to the builtin float-to-double 
+conversion and all arithmetic expressions involving both half-precision and 
+single-precision arguments will be of single-precision type. This way you can 
+also directly use the mathematical functions of the C++ standard library, 
+though in this case you will invoke the single-precision versions which will 
+also return single-precision values, which is (even if maybe performing the 
+exact same computation, see below) not as conceptually clean when working in a 
+half-precision environment.
+
+The default rounding mode for conversions between half and more precise types 
+as well as for rounding results of arithmetic operations and mathematical 
+functions rounds to the nearest representable value. But by predefining the 
+'HALF_ROUND_STYLE' preprocessor symbol this default can be overridden with one 
+of the other standard rounding modes using their respective constants or the 
+equivalent values of 'std::float_round_style' (it can even be synchronized with 
+the built-in single-precision implementation by defining it to 
+'std::numeric_limits<float>::round_style'):
+
+  - 'std::round_indeterminate' (-1) for the fastest rounding.
+
+  - 'std::round_toward_zero' (0) for rounding toward zero.
+
+  - 'std::round_to_nearest' (1) for rounding to the nearest value (default).
+
+  - 'std::round_toward_infinity' (2) for rounding toward positive infinity.
+
+  - 'std::round_toward_neg_infinity' (3) for rounding toward negative infinity.
+
+In addition to changing the overall default rounding mode one can also use the 
+'half_cast'. This converts between half and any built-in arithmetic type using 
+a configurable rounding mode (or the default rounding mode if none is 
+specified). In addition to a configurable rounding mode, 'half_cast' has 
+another big difference to a mere 'static_cast': Any conversions are performed 
+directly using the given rounding mode, without any intermediate conversion 
+to/from 'float'. This is especially relevant for conversions to integer types, 
+which don't necessarily truncate anymore. But also for conversions from 
+'double' or 'long double' this may produce more precise results than a 
+pre-conversion to 'float' using the single-precision implementation's current 
+rounding mode would.
+
+    half a = half_cast<half>(4.2);
+    half b = half_cast<half,std::numeric_limits<float>::round_style>(4.2f);
+    assert( half_cast<int, std::round_to_nearest>( 0.7_h )     == 1 );
+    assert( half_cast<half,std::round_toward_zero>( 4097 )     == 4096.0_h );
+    assert( half_cast<half,std::round_toward_infinity>( 4097 ) == 4100.0_h );
+    assert( half_cast<half,std::round_toward_infinity>( std::numeric_limits<double>::min() ) > 0.0_h );
+
+ACCURACY AND PERFORMANCE
+
+From version 2.0 onward the library is implemented without employing the 
+underlying floating-point implementation of the system (except for conversions, 
+of course), providing an entirely self-contained half-precision implementation 
+with results independent from the system's existing single- or double-precision 
+implementation and its rounding behaviour.
+
+As to accuracy, many of the operators and functions provided by this library 
+are exact to rounding for all rounding modes, i.e. the error to the exact 
+result is at most 0.5 ULP (unit in the last place) for rounding to nearest and 
+less than 1 ULP for all other rounding modes. This holds for all the operations 
+required by the IEEE 754 standard and many more. Specifically the following 
+functions might exhibit a deviation from the correctly rounded exact result by 
+1 ULP for a select few input values: 'expm1', 'log1p', 'pow', 'atan2', 'erf', 
+'erfc', 'lgamma', 'tgamma' (for more details see the documentation of the 
+individual functions). All other functions and operators are always exact to 
+rounding or independent of the rounding mode altogether.
+
+The increased IEEE-conformance and cleanliness of this implementation comes 
+with a certain performance cost compared to doing computations and mathematical 
+functions in hardware-accelerated single-precision. On average and depending on 
+the platform, the arithemtic operators are about 75% as fast and the 
+mathematical functions about 33-50% as fast as performing the corresponding 
+operations in single-precision and converting between the inputs and outputs. 
+However, directly computing with half-precision values is a rather rare 
+use-case and usually using actual 'float' values for all computations and 
+temproraries and using 'half's only for storage is the recommended way. But 
+nevertheless the goal of this library was to provide a complete and 
+conceptually clean IEEE-confromant half-precision implementation and in the few 
+cases when you do need to compute directly in half-precision you do so for a 
+reason and want accurate results.
+
+If necessary, this internal implementation can be overridden by predefining the 
+'HALF_ARITHMETIC_TYPE' preprocessor symbol to one of the built-in 
+floating-point types ('float', 'double' or 'long double'), which will cause the 
+library to use this type for computing arithmetic operations and mathematical 
+functions (if available). However, due to using the platform's floating-point 
+implementation (and its rounding behaviour) internally, this might cause 
+results to deviate from the specified half-precision rounding mode. It will of 
+course also inhibit the automatic exception detection described below.
+
+The conversion operations between half-precision and single-precision types can 
+also make use of the F16C extension for x86 processors by using the 
+corresponding compiler intrinsics from <immintrin.h>. Support for this is 
+checked at compile-time by looking for the '__F16C__' macro which at least gcc 
+and clang define based on the target platform. It can also be enabled manually 
+by predefining the 'HALF_ENABLE_F16C_INTRINSICS' preprocessor symbol to 1, or 0 
+for explicitly disabling it. However, this will directly use the corresponding 
+intrinsics for conversion without checking if they are available at runtime 
+(possibly crashing if they are not), so make sure they are supported on the 
+target platform before enabling this.
+
+EXCEPTION HANDLING
+
+The half-precision implementation supports all 5 required floating-point 
+exceptions from the IEEE standard to indicate erroneous inputs or inexact 
+results during operations. These are represented by exception flags which 
+actually use the same values as the corresponding 'FE_...' flags defined in 
+C++11's <cfenv> header if supported, specifically:
+
+  - 'FE_INVALID' for invalid inputs to an operation.
+  - 'FE_DIVBYZERO' for finite inputs producing infinite results.
+  - 'FE_OVERFLOW' if a result is too large to represent finitely.
+  - 'FE_UNDERFLOW' for a subnormal or zero result after rounding.
+  - 'FE_INEXACT' if a result needed rounding to be representable.
+  - 'FE_ALL_EXCEPT' as a convenient OR of all possible exception flags.
+
+The internal exception flag state will start with all flags cleared and is 
+maintained per thread if C++11 thread-local storage is supported, otherwise it 
+will be maintained globally and will theoretically NOT be thread-safe (while 
+practically being as thread-safe as a simple integer variable can be). These 
+flags can be managed explicitly using the library's error handling functions, 
+which again try to mimic the built-in functions for handling floating-point 
+exceptions from <cfenv>. You can clear them with 'feclearexcept' (which is the 
+only way a flag can be cleared), test them with 'fetestexcept', explicitly 
+raise errors with 'feraiseexcept' and save and restore their state using 
+'fegetexceptflag' and 'fesetexceptflag'. You can also throw corresponding C++ 
+exceptions based on the current flag state using 'fethrowexcept'.
+
+However, any automatic exception detection and handling during half-precision 
+operations and functions is DISABLED by default, since it comes with a minor 
+performance overhead due to runtime checks, and reacting to IEEE floating-point 
+exceptions is rarely ever needed in application code. But the library fully 
+supports IEEE-conformant detection of floating-point exceptions and various 
+ways for handling them, which can be enabled by pre-defining the corresponding 
+preprocessor symbols to 1. They can be enabled individually or all at once and 
+they will be processed in the order they are listed here:
+
+  - 'HALF_ERRHANDLING_FLAGS' sets the internal exception flags described above 
+    whenever the corresponding exception occurs.
+  - 'HALF_ERRHANDLING_ERRNO' sets the value of 'errno' from <cerrno> similar to 
+    the behaviour of the built-in floating-point types when 'MATH_ERRNO' is used.
+  - 'HALF_ERRHANDLING_FENV' will propagate exceptions to the built-in 
+    floating-point implementation using 'std::feraiseexcept' if support for 
+    C++11 floating-point control is enabled. However, this does not synchronize 
+    exceptions: neither will clearing  propagate nor will it work in reverse.
+  - 'HALF_ERRHANDLING_THROW_...' can be defined to a string literal which will 
+    be used as description message for a C++ exception that is thrown whenever 
+    a 'FE_...' exception occurs, similar to the behaviour of 'fethrowexcept'.
+
+If any of the above error handling is activated, non-quiet operations on 
+half-precision values will also raise a 'FE_INVALID' exception whenever 
+they encounter a signaling NaN value, in addition to transforming the value 
+into a quiet NaN. If error handling is disabled, signaling NaNs will be 
+treated like quiet NaNs (while still getting explicitly quieted if propagated 
+to the result). There can also be additional treatment of overflow and 
+underflow errors after they have been processed as above, which is ENABLED by 
+default (but of course only takes effect if any other exception handling is 
+activated) unless overridden by pre-defining the corresponding preprocessor 
+symbol to 0:
+
+  - 'HALF_ERRHANDLING_OVERFLOW_TO_INEXACT' will cause overflow errors to also 
+    raise a 'FE_INEXACT' exception.
+  - 'HALF_ERRHANDLING_UNDERFLOW_TO_INEXACT' will cause underflow errors to also 
+    raise a 'FE_INEXACT' exception. This will also slightly change the 
+    behaviour of the underflow exception, which will ONLY be raised if the 
+    result is actually inexact due to underflow. If this is disabled, underflow 
+    exceptions will be raised for ANY (possibly exact) subnormal result.
+
+
+CREDITS AND CONTACT
+-------------------
+
+This library is developed by CHRISTIAN RAU and released under the MIT License 
+(see LICENSE.txt). If you have any questions or problems with it, feel free to 
+contact me at rauy@users.sourceforge.net.
+
+Additional credit goes to JEROEN VAN DER ZIJP for his paper on "Fast Half Float 
+Conversions", whose algorithms have been used in the library for converting 
+between half-precision and single-precision values.
diff --git a/src/half/include/half.hpp b/src/half/include/half.hpp
new file mode 100644
index 0000000..69f2ffd
--- /dev/null
+++ b/src/half/include/half.hpp
@@ -0,0 +1,4575 @@
+// half - IEEE 754-based half-precision floating-point library.
+//
+// Copyright (c) 2012-2019 Christian Rau <rauy@users.sourceforge.net>
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation 
+// files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, 
+// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the 
+// Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
+// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR 
+// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
+// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+// Version 2.1.0
+
+/// \file
+/// Main header file for half-precision functionality.
+
+#ifndef HALF_HALF_HPP
+#define HALF_HALF_HPP
+
+#define HALF_GCC_VERSION (__GNUC__*100+__GNUC_MINOR__)
+
+#if defined(__INTEL_COMPILER)
+	#define HALF_ICC_VERSION __INTEL_COMPILER
+#elif defined(__ICC)
+	#define HALF_ICC_VERSION __ICC
+#elif defined(__ICL)
+	#define HALF_ICC_VERSION __ICL
+#else
+	#define HALF_ICC_VERSION 0
+#endif
+
+// check C++11 language features
+#if defined(__clang__)										// clang
+	#if __has_feature(cxx_static_assert) && !defined(HALF_ENABLE_CPP11_STATIC_ASSERT)
+		#define HALF_ENABLE_CPP11_STATIC_ASSERT 1
+	#endif
+	#if __has_feature(cxx_constexpr) && !defined(HALF_ENABLE_CPP11_CONSTEXPR)
+		#define HALF_ENABLE_CPP11_CONSTEXPR 1
+	#endif
+	#if __has_feature(cxx_noexcept) && !defined(HALF_ENABLE_CPP11_NOEXCEPT)
+		#define HALF_ENABLE_CPP11_NOEXCEPT 1
+	#endif
+	#if __has_feature(cxx_user_literals) && !defined(HALF_ENABLE_CPP11_USER_LITERALS)
+		#define HALF_ENABLE_CPP11_USER_LITERALS 1
+	#endif
+	#if __has_feature(cxx_thread_local) && !defined(HALF_ENABLE_CPP11_THREAD_LOCAL)
+		#define HALF_ENABLE_CPP11_THREAD_LOCAL 1
+	#endif
+	#if (defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus >= 201103L) && !defined(HALF_ENABLE_CPP11_LONG_LONG)
+		#define HALF_ENABLE_CPP11_LONG_LONG 1
+	#endif
+#elif HALF_ICC_VERSION && defined(__INTEL_CXX11_MODE__)		// Intel C++
+	#if HALF_ICC_VERSION >= 1500 && !defined(HALF_ENABLE_CPP11_THREAD_LOCAL)
+		#define HALF_ENABLE_CPP11_THREAD_LOCAL 1
+	#endif
+	#if HALF_ICC_VERSION >= 1500 && !defined(HALF_ENABLE_CPP11_USER_LITERALS)
+		#define HALF_ENABLE_CPP11_USER_LITERALS 1
+	#endif
+	#if HALF_ICC_VERSION >= 1400 && !defined(HALF_ENABLE_CPP11_CONSTEXPR)
+		#define HALF_ENABLE_CPP11_CONSTEXPR 1
+	#endif
+	#if HALF_ICC_VERSION >= 1400 && !defined(HALF_ENABLE_CPP11_NOEXCEPT)
+		#define HALF_ENABLE_CPP11_NOEXCEPT 1
+	#endif
+	#if HALF_ICC_VERSION >= 1110 && !defined(HALF_ENABLE_CPP11_STATIC_ASSERT)
+		#define HALF_ENABLE_CPP11_STATIC_ASSERT 1
+	#endif
+	#if HALF_ICC_VERSION >= 1110 && !defined(HALF_ENABLE_CPP11_LONG_LONG)
+		#define HALF_ENABLE_CPP11_LONG_LONG 1
+	#endif
+#elif defined(__GNUC__)										// gcc
+	#if defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus >= 201103L
+		#if HALF_GCC_VERSION >= 408 && !defined(HALF_ENABLE_CPP11_THREAD_LOCAL)
+			#define HALF_ENABLE_CPP11_THREAD_LOCAL 1
+		#endif
+		#if HALF_GCC_VERSION >= 407 && !defined(HALF_ENABLE_CPP11_USER_LITERALS)
+			#define HALF_ENABLE_CPP11_USER_LITERALS 1
+		#endif
+		#if HALF_GCC_VERSION >= 406 && !defined(HALF_ENABLE_CPP11_CONSTEXPR)
+			#define HALF_ENABLE_CPP11_CONSTEXPR 1
+		#endif
+		#if HALF_GCC_VERSION >= 406 && !defined(HALF_ENABLE_CPP11_NOEXCEPT)
+			#define HALF_ENABLE_CPP11_NOEXCEPT 1
+		#endif
+		#if HALF_GCC_VERSION >= 403 && !defined(HALF_ENABLE_CPP11_STATIC_ASSERT)
+			#define HALF_ENABLE_CPP11_STATIC_ASSERT 1
+		#endif
+		#if !defined(HALF_ENABLE_CPP11_LONG_LONG)
+			#define HALF_ENABLE_CPP11_LONG_LONG 1
+		#endif
+	#endif
+	#define HALF_TWOS_COMPLEMENT_INT 1
+#elif defined(_MSC_VER)										// Visual C++
+	#if _MSC_VER >= 1900 && !defined(HALF_ENABLE_CPP11_THREAD_LOCAL)
+		#define HALF_ENABLE_CPP11_THREAD_LOCAL 1
+	#endif
+	#if _MSC_VER >= 1900 && !defined(HALF_ENABLE_CPP11_USER_LITERALS)
+		#define HALF_ENABLE_CPP11_USER_LITERALS 1
+	#endif
+	#if _MSC_VER >= 1900 && !defined(HALF_ENABLE_CPP11_CONSTEXPR)
+		#define HALF_ENABLE_CPP11_CONSTEXPR 1
+	#endif
+	#if _MSC_VER >= 1900 && !defined(HALF_ENABLE_CPP11_NOEXCEPT)
+		#define HALF_ENABLE_CPP11_NOEXCEPT 1
+	#endif
+	#if _MSC_VER >= 1600 && !defined(HALF_ENABLE_CPP11_STATIC_ASSERT)
+		#define HALF_ENABLE_CPP11_STATIC_ASSERT 1
+	#endif
+	#if _MSC_VER >= 1310 && !defined(HALF_ENABLE_CPP11_LONG_LONG)
+		#define HALF_ENABLE_CPP11_LONG_LONG 1
+	#endif
+	#define HALF_TWOS_COMPLEMENT_INT 1
+	#define HALF_POP_WARNINGS 1
+	#pragma warning(push)
+	#pragma warning(disable : 4099 4127 4146)	//struct vs class, constant in if, negative unsigned
+#endif
+
+// check C++11 library features
+#include <utility>
+#if defined(_LIBCPP_VERSION)								// libc++
+	#if defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus >= 201103
+		#ifndef HALF_ENABLE_CPP11_TYPE_TRAITS
+			#define HALF_ENABLE_CPP11_TYPE_TRAITS 1
+		#endif
+		#ifndef HALF_ENABLE_CPP11_CSTDINT
+			#define HALF_ENABLE_CPP11_CSTDINT 1
+		#endif
+		#ifndef HALF_ENABLE_CPP11_CMATH
+			#define HALF_ENABLE_CPP11_CMATH 1
+		#endif
+		#ifndef HALF_ENABLE_CPP11_HASH
+			#define HALF_ENABLE_CPP11_HASH 1
+		#endif
+		#ifndef HALF_ENABLE_CPP11_CFENV
+			#define HALF_ENABLE_CPP11_CFENV 1
+		#endif
+	#endif
+#elif defined(__GLIBCXX__)									// libstdc++
+	#if defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus >= 201103
+		#ifdef __clang__
+			#if __GLIBCXX__ >= 20080606 && !defined(HALF_ENABLE_CPP11_TYPE_TRAITS)
+				#define HALF_ENABLE_CPP11_TYPE_TRAITS 1
+			#endif
+			#if __GLIBCXX__ >= 20080606 && !defined(HALF_ENABLE_CPP11_CSTDINT)
+				#define HALF_ENABLE_CPP11_CSTDINT 1
+			#endif
+			#if __GLIBCXX__ >= 20080606 && !defined(HALF_ENABLE_CPP11_CMATH)
+				#define HALF_ENABLE_CPP11_CMATH 1
+			#endif
+			#if __GLIBCXX__ >= 20080606 && !defined(HALF_ENABLE_CPP11_HASH)
+				#define HALF_ENABLE_CPP11_HASH 1
+			#endif
+			#if __GLIBCXX__ >= 20080606 && !defined(HALF_ENABLE_CPP11_CFENV)
+				#define HALF_ENABLE_CPP11_CFENV 1
+			#endif
+		#else
+			#if HALF_GCC_VERSION >= 403 && !defined(HALF_ENABLE_CPP11_TYPE_TRAITS)
+				#define HALF_ENABLE_CPP11_TYPE_TRAITS 1
+			#endif
+			#if HALF_GCC_VERSION >= 403 && !defined(HALF_ENABLE_CPP11_CSTDINT)
+				#define HALF_ENABLE_CPP11_CSTDINT 1
+			#endif
+			#if HALF_GCC_VERSION >= 403 && !defined(HALF_ENABLE_CPP11_CMATH)
+				#define HALF_ENABLE_CPP11_CMATH 1
+			#endif
+			#if HALF_GCC_VERSION >= 403 && !defined(HALF_ENABLE_CPP11_HASH)
+				#define HALF_ENABLE_CPP11_HASH 1
+			#endif
+			#if HALF_GCC_VERSION >= 403 && !defined(HALF_ENABLE_CPP11_CFENV)
+				#define HALF_ENABLE_CPP11_CFENV 1
+			#endif
+		#endif
+	#endif
+#elif defined(_CPPLIB_VER)									// Dinkumware/Visual C++
+	#if _CPPLIB_VER >= 520 && !defined(HALF_ENABLE_CPP11_TYPE_TRAITS)
+		#define HALF_ENABLE_CPP11_TYPE_TRAITS 1
+	#endif
+	#if _CPPLIB_VER >= 520 && !defined(HALF_ENABLE_CPP11_CSTDINT)
+			#define HALF_ENABLE_CPP11_CSTDINT 1
+	#endif
+	#if _CPPLIB_VER >= 520 && !defined(HALF_ENABLE_CPP11_HASH)
+		#define HALF_ENABLE_CPP11_HASH 1
+	#endif
+	#if _CPPLIB_VER >= 610 && !defined(HALF_ENABLE_CPP11_CMATH)
+		#define HALF_ENABLE_CPP11_CMATH 1
+	#endif
+	#if _CPPLIB_VER >= 610 && !defined(HALF_ENABLE_CPP11_CFENV)
+		#define HALF_ENABLE_CPP11_CFENV 1
+	#endif
+#endif
+#undef HALF_GCC_VERSION
+#undef HALF_ICC_VERSION
+
+// any error throwing C++ exceptions?
+#if defined(HALF_ERRHANDLING_THROW_INVALID) || defined(HALF_ERRHANDLING_THROW_DIVBYZERO) || defined(HALF_ERRHANDLING_THROW_OVERFLOW) || defined(HALF_ERRHANDLING_THROW_UNDERFLOW) || defined(HALF_ERRHANDLING_THROW_INEXACT)
+#define HALF_ERRHANDLING_THROWS 1
+#endif
+
+// any error handling enabled?
+#define HALF_ERRHANDLING	(HALF_ERRHANDLING_FLAGS||HALF_ERRHANDLING_ERRNO||HALF_ERRHANDLING_FENV||HALF_ERRHANDLING_THROWS)
+
+#if HALF_ERRHANDLING
+	#define HALF_UNUSED_NOERR(name) name
+#else
+	#define HALF_UNUSED_NOERR(name)
+#endif
+
+// support constexpr
+#if HALF_ENABLE_CPP11_CONSTEXPR
+	#define HALF_CONSTEXPR				constexpr
+	#define HALF_CONSTEXPR_CONST		constexpr
+	#if HALF_ERRHANDLING
+		#define HALF_CONSTEXPR_NOERR
+	#else
+		#define HALF_CONSTEXPR_NOERR	constexpr
+	#endif
+#else
+	#define HALF_CONSTEXPR
+	#define HALF_CONSTEXPR_CONST		const
+	#define HALF_CONSTEXPR_NOERR
+#endif
+
+// support noexcept
+#if HALF_ENABLE_CPP11_NOEXCEPT
+	#define HALF_NOEXCEPT	noexcept
+	#define HALF_NOTHROW	noexcept
+#else
+	#define HALF_NOEXCEPT
+	#define HALF_NOTHROW	throw()
+#endif
+
+// support thread storage
+#if HALF_ENABLE_CPP11_THREAD_LOCAL
+	#define HALF_THREAD_LOCAL	thread_local
+#else
+	#define HALF_THREAD_LOCAL	static
+#endif
+
+#include <utility>
+#include <algorithm>
+#include <istream>
+#include <ostream>
+#include <limits>
+#include <stdexcept>
+#include <climits>
+#include <cmath>
+#include <cstring>
+#include <cstdlib>
+#if HALF_ENABLE_CPP11_TYPE_TRAITS
+	#include <type_traits>
+#endif
+#if HALF_ENABLE_CPP11_CSTDINT
+	#include <cstdint>
+#endif
+#if HALF_ERRHANDLING_ERRNO
+	#include <cerrno>
+#endif
+#if HALF_ENABLE_CPP11_CFENV
+	#include <cfenv>
+#endif
+#if HALF_ENABLE_CPP11_HASH
+	#include <functional>
+#endif
+#if HALF_ENABLE_F16C_INTRINSICS
+	#include <immintrin.h>
+#endif
+
+
+#ifndef HALF_ENABLE_F16C_INTRINSICS
+	/// Enable F16C intruction set intrinsics.
+	/// Defining this to 1 enables the use of [F16C compiler intrinsics](https://en.wikipedia.org/wiki/F16C) for converting between 
+	/// half-precision and single-precision values which may result in improved performance. This will not perform additional checks 
+	/// for support of the F16C instruction set, so an appropriate target platform is required when enabling this feature.
+	///
+	/// Unless predefined it will be enabled automatically when the `__F16C__` symbol is defined, which some compilers do on supporting platforms.
+	#define HALF_ENABLE_F16C_INTRINSICS __F16C__
+#endif
+
+#ifdef HALF_DOXYGEN_ONLY
+/// Type for internal floating-point computations.
+/// This can be predefined to a built-in floating-point type (`float`, `double` or `long double`) to override the internal 
+/// half-precision implementation to use this type for computing arithmetic operations and mathematical function (if available). 
+/// This can result in improved performance for arithmetic operators and mathematical functions but might cause results to 
+/// deviate from the specified half-precision rounding mode and inhibits proper detection of half-precision exceptions.
+#define HALF_ARITHMETIC_TYPE (undefined)
+
+/// Enable internal exception flags.
+/// Defining this to 1 causes operations on half-precision values to raise internal floating-point exception flags according to 
+/// the IEEE 754 standard. These can then be cleared and checked with clearexcept(), testexcept().
+#define HALF_ERRHANDLING_FLAGS	0
+
+/// Enable exception propagation to `errno`.
+/// Defining this to 1 causes operations on half-precision values to propagate floating-point exceptions to 
+/// [errno](https://en.cppreference.com/w/cpp/error/errno) from `<cerrno>`. Specifically this will propagate domain errors as 
+/// [EDOM](https://en.cppreference.com/w/cpp/error/errno_macros) and pole, overflow and underflow errors as 
+/// [ERANGE](https://en.cppreference.com/w/cpp/error/errno_macros). Inexact errors won't be propagated.
+#define HALF_ERRHANDLING_ERRNO	0
+
+/// Enable exception propagation to built-in floating-point platform.
+/// Defining this to 1 causes operations on half-precision values to propagate floating-point exceptions to the built-in 
+/// single- and double-precision implementation's exception flags using the 
+/// [C++11 floating-point environment control](https://en.cppreference.com/w/cpp/numeric/fenv) from `<cfenv>`. However, this 
+/// does not work in reverse and single- or double-precision exceptions will not raise the corresponding half-precision 
+/// exception flags, nor will explicitly clearing flags clear the corresponding built-in flags.
+#define HALF_ERRHANDLING_FENV	0
+
+/// Throw C++ exception on domain errors.
+/// Defining this to a string literal causes operations on half-precision values to throw a 
+/// [std::domain_error](https://en.cppreference.com/w/cpp/error/domain_error) with the specified message on domain errors.
+#define HALF_ERRHANDLING_THROW_INVALID		(undefined)
+
+/// Throw C++ exception on pole errors.
+/// Defining this to a string literal causes operations on half-precision values to throw a 
+/// [std::domain_error](https://en.cppreference.com/w/cpp/error/domain_error) with the specified message on pole errors.
+#define HALF_ERRHANDLING_THROW_DIVBYZERO	(undefined)
+
+/// Throw C++ exception on overflow errors.
+/// Defining this to a string literal causes operations on half-precision values to throw a 
+/// [std::overflow_error](https://en.cppreference.com/w/cpp/error/overflow_error) with the specified message on overflows.
+#define HALF_ERRHANDLING_THROW_OVERFLOW		(undefined)
+
+/// Throw C++ exception on underflow errors.
+/// Defining this to a string literal causes operations on half-precision values to throw a 
+/// [std::underflow_error](https://en.cppreference.com/w/cpp/error/underflow_error) with the specified message on underflows.
+#define HALF_ERRHANDLING_THROW_UNDERFLOW	(undefined)
+
+/// Throw C++ exception on rounding errors.
+/// Defining this to 1 causes operations on half-precision values to throw a 
+/// [std::range_error](https://en.cppreference.com/w/cpp/error/range_error) with the specified message on general rounding errors.
+#define HALF_ERRHANDLING_THROW_INEXACT		(undefined)
+#endif
+
+#ifndef HALF_ERRHANDLING_OVERFLOW_TO_INEXACT
+/// Raise INEXACT exception on overflow.
+/// Defining this to 1 (default) causes overflow errors to automatically raise inexact exceptions in addition.
+/// These will be raised after any possible handling of the underflow exception.
+#define HALF_ERRHANDLING_OVERFLOW_TO_INEXACT	1
+#endif
+
+#ifndef HALF_ERRHANDLING_UNDERFLOW_TO_INEXACT
+/// Raise INEXACT exception on underflow.
+/// Defining this to 1 (default) causes underflow errors to automatically raise inexact exceptions in addition.
+/// These will be raised after any possible handling of the underflow exception.
+///
+/// **Note:** This will actually cause underflow (and the accompanying inexact) exceptions to be raised *only* when the result 
+/// is inexact, while if disabled bare underflow errors will be raised for *any* (possibly exact) subnormal result.
+#define HALF_ERRHANDLING_UNDERFLOW_TO_INEXACT	1
+#endif
+
+/// Default rounding mode.
+/// This specifies the rounding mode used for all conversions between [half](\ref half_float::half)s and more precise types 
+/// (unless using half_cast() and specifying the rounding mode directly) as well as in arithmetic operations and mathematical 
+/// functions. It can be redefined (before including half.hpp) to one of the standard rounding modes using their respective 
+/// constants or the equivalent values of 
+/// [std::float_round_style](https://en.cppreference.com/w/cpp/types/numeric_limits/float_round_style):
+///
+/// `std::float_round_style`         | value | rounding
+/// ---------------------------------|-------|-------------------------
+/// `std::round_indeterminate`       | -1    | fastest
+/// `std::round_toward_zero`         | 0     | toward zero
+/// `std::round_to_nearest`          | 1     | to nearest (default)
+/// `std::round_toward_infinity`     | 2     | toward positive infinity
+/// `std::round_toward_neg_infinity` | 3     | toward negative infinity
+///
+/// By default this is set to `1` (`std::round_to_nearest`), which rounds results to the nearest representable value. It can even 
+/// be set to [std::numeric_limits<float>::round_style](https://en.cppreference.com/w/cpp/types/numeric_limits/round_style) to synchronize 
+/// the rounding mode with that of the built-in single-precision implementation (which is likely `std::round_to_nearest`, though).
+#ifndef HALF_ROUND_STYLE
+	#define HALF_ROUND_STYLE	1		// = std::round_to_nearest
+#endif
+
+/// Value signaling overflow.
+/// In correspondence with `HUGE_VAL[F|L]` from `<cmath>` this symbol expands to a positive value signaling the overflow of an 
+/// operation, in particular it just evaluates to positive infinity.
+///
+/// **See also:** Documentation for [HUGE_VAL](https://en.cppreference.com/w/cpp/numeric/math/HUGE_VAL)
+#define HUGE_VALH	std::numeric_limits<half_float::half>::infinity()
+
+/// Fast half-precision fma function.
+/// This symbol is defined if the fma() function generally executes as fast as, or faster than, a separate 
+/// half-precision multiplication followed by an addition, which is always the case.
+///
+/// **See also:** Documentation for [FP_FAST_FMA](https://en.cppreference.com/w/cpp/numeric/math/fma)
+#define FP_FAST_FMAH	1
+
+///	Half rounding mode.
+/// In correspondence with `FLT_ROUNDS` from `<cfloat>` this symbol expands to the rounding mode used for 
+/// half-precision operations. It is an alias for [HALF_ROUND_STYLE](\ref HALF_ROUND_STYLE).
+///
+/// **See also:** Documentation for [FLT_ROUNDS](https://en.cppreference.com/w/cpp/types/climits/FLT_ROUNDS)
+#define HLF_ROUNDS	HALF_ROUND_STYLE
+
+#ifndef FP_ILOGB0
+	#define FP_ILOGB0		INT_MIN
+#endif
+#ifndef FP_ILOGBNAN
+	#define FP_ILOGBNAN		INT_MAX
+#endif
+#ifndef FP_SUBNORMAL
+	#define FP_SUBNORMAL	0
+#endif
+#ifndef FP_ZERO
+	#define FP_ZERO			1
+#endif
+#ifndef FP_NAN
+	#define FP_NAN			2
+#endif
+#ifndef FP_INFINITE
+	#define FP_INFINITE		3
+#endif
+#ifndef FP_NORMAL
+	#define FP_NORMAL		4
+#endif
+
+#if !HALF_ENABLE_CPP11_CFENV && !defined(FE_ALL_EXCEPT)
+	#define FE_INVALID		0x10
+	#define FE_DIVBYZERO	0x08
+	#define FE_OVERFLOW		0x04
+	#define FE_UNDERFLOW	0x02
+	#define FE_INEXACT		0x01
+	#define FE_ALL_EXCEPT	(FE_INVALID|FE_DIVBYZERO|FE_OVERFLOW|FE_UNDERFLOW|FE_INEXACT)
+#endif
+
+
+/// Main namespace for half-precision functionality.
+/// This namespace contains all the functionality provided by the library.
+namespace half_float
+{
+	class half;
+
+#if HALF_ENABLE_CPP11_USER_LITERALS
+	/// Library-defined half-precision literals.
+	/// Import this namespace to enable half-precision floating-point literals:
+	/// ~~~~{.cpp}
+	/// using namespace half_float::literal;
+	/// half_float::half = 4.2_h;
+	/// ~~~~
+	namespace literal
+	{
+		half operator "" _h(long double);
+	}
+#endif
+
+	/// \internal
+	/// \brief Implementation details.
+	namespace detail
+	{
+	#if HALF_ENABLE_CPP11_TYPE_TRAITS
+		/// Conditional type.
+		template<bool B,typename T,typename F> struct conditional : std::conditional<B,T,F> {};
+
+		/// Helper for tag dispatching.
+		template<bool B> struct bool_type : std::integral_constant<bool,B> {};
+		using std::true_type;
+		using std::false_type;
+
+		/// Type traits for floating-point types.
+		template<typename T> struct is_float : std::is_floating_point<T> {};
+	#else
+		/// Conditional type.
+		template<bool,typename T,typename> struct conditional { typedef T type; };
+		template<typename T,typename F> struct conditional<false,T,F> { typedef F type; };
+
+		/// Helper for tag dispatching.
+		template<bool> struct bool_type {};
+		typedef bool_type<true> true_type;
+		typedef bool_type<false> false_type;
+
+		/// Type traits for floating-point types.
+		template<typename> struct is_float : false_type {};
+		template<typename T> struct is_float<const T> : is_float<T> {};
+		template<typename T> struct is_float<volatile T> : is_float<T> {};
+		template<typename T> struct is_float<const volatile T> : is_float<T> {};
+		template<> struct is_float<float> : true_type {};
+		template<> struct is_float<double> : true_type {};
+		template<> struct is_float<long double> : true_type {};
+	#endif
+
+		/// Type traits for floating-point bits.
+		template<typename T> struct bits { typedef unsigned char type; };
+		template<typename T> struct bits<const T> : bits<T> {};
+		template<typename T> struct bits<volatile T> : bits<T> {};
+		template<typename T> struct bits<const volatile T> : bits<T> {};
+
+	#if HALF_ENABLE_CPP11_CSTDINT
+		/// Unsigned integer of (at least) 16 bits width.
+		typedef std::uint_least16_t uint16;
+
+		/// Fastest unsigned integer of (at least) 32 bits width.
+		typedef std::uint_fast32_t uint32;
+
+		/// Fastest signed integer of (at least) 32 bits width.
+		typedef std::int_fast32_t int32;
+
+		/// Unsigned integer of (at least) 32 bits width.
+		template<> struct bits<float> { typedef std::uint_least32_t type; };
+
+		/// Unsigned integer of (at least) 64 bits width.
+		template<> struct bits<double> { typedef std::uint_least64_t type; };
+	#else
+		/// Unsigned integer of (at least) 16 bits width.
+		typedef unsigned short uint16;
+
+		/// Fastest unsigned integer of (at least) 32 bits width.
+		typedef unsigned long uint32;
+
+		/// Fastest unsigned integer of (at least) 32 bits width.
+		typedef long int32;
+
+		/// Unsigned integer of (at least) 32 bits width.
+		template<> struct bits<float> : conditional<std::numeric_limits<unsigned int>::digits>=32,unsigned int,unsigned long> {};
+
+		#if HALF_ENABLE_CPP11_LONG_LONG
+			/// Unsigned integer of (at least) 64 bits width.
+			template<> struct bits<double> : conditional<std::numeric_limits<unsigned long>::digits>=64,unsigned long,unsigned long long> {};
+		#else
+			/// Unsigned integer of (at least) 64 bits width.
+			template<> struct bits<double> { typedef unsigned long type; };
+		#endif
+	#endif
+
+	#ifdef HALF_ARITHMETIC_TYPE
+		/// Type to use for arithmetic computations and mathematic functions internally.
+		typedef HALF_ARITHMETIC_TYPE internal_t;
+	#endif
+
+		/// Tag type for binary construction.
+		struct binary_t {};
+
+		/// Tag for binary construction.
+		HALF_CONSTEXPR_CONST binary_t binary = binary_t();
+
+		/// \name Implementation defined classification and arithmetic
+		/// \{
+
+		/// Check for infinity.
+		/// \tparam T argument type (builtin floating-point type)
+		/// \param arg value to query
+		/// \retval true if infinity
+		/// \retval false else
+		template<typename T> bool builtin_isinf(T arg)
+		{
+		#if HALF_ENABLE_CPP11_CMATH
+			return std::isinf(arg);
+		#elif defined(_MSC_VER)
+			return !::_finite(static_cast<double>(arg)) && !::_isnan(static_cast<double>(arg));
+		#else
+			return arg == std::numeric_limits<T>::infinity() || arg == -std::numeric_limits<T>::infinity();
+		#endif
+		}
+
+		/// Check for NaN.
+		/// \tparam T argument type (builtin floating-point type)
+		/// \param arg value to query
+		/// \retval true if not a number
+		/// \retval false else
+		template<typename T> bool builtin_isnan(T arg)
+		{
+		#if HALF_ENABLE_CPP11_CMATH
+			return std::isnan(arg);
+		#elif defined(_MSC_VER)
+			return ::_isnan(static_cast<double>(arg)) != 0;
+		#else
+			return arg != arg;
+		#endif
+		}
+
+		/// Check sign.
+		/// \tparam T argument type (builtin floating-point type)
+		/// \param arg value to query
+		/// \retval true if signbit set
+		/// \retval false else
+		template<typename T> bool builtin_signbit(T arg)
+		{
+		#if HALF_ENABLE_CPP11_CMATH
+			return std::signbit(arg);
+		#else
+			return arg < T() || (arg == T() && T(1)/arg < T());
+		#endif
+		}
+
+		/// Platform-independent sign mask.
+		/// \param arg integer value in two's complement
+		/// \retval -1 if \a arg negative
+		/// \retval 0 if \a arg positive
+		inline uint32 sign_mask(uint32 arg)
+		{
+			static const int N = std::numeric_limits<uint32>::digits - 1;
+		#if HALF_TWOS_COMPLEMENT_INT
+			return static_cast<int32>(arg) >> N;
+		#else
+			return -((arg>>N)&1);
+		#endif
+		}
+
+		/// Platform-independent arithmetic right shift.
+		/// \param arg integer value in two's complement
+		/// \param i shift amount (at most 31)
+		/// \return \a arg right shifted for \a i bits with possible sign extension
+		inline uint32 arithmetic_shift(uint32 arg, int i)
+		{
+		#if HALF_TWOS_COMPLEMENT_INT
+			return static_cast<int32>(arg) >> i;
+		#else
+			return static_cast<int32>(arg)/(static_cast<int32>(1)<<i) - ((arg>>(std::numeric_limits<uint32>::digits-1))&1);
+		#endif
+		}
+
+		/// \}
+		/// \name Error handling
+		/// \{
+
+		/// Internal exception flags.
+		/// \return reference to global exception flags
+		inline int& errflags() { HALF_THREAD_LOCAL int flags = 0; return flags; }
+
+		/// Raise floating-point exception.
+		/// \param flags exceptions to raise
+		/// \param cond condition to raise exceptions for
+		inline void raise(int HALF_UNUSED_NOERR(flags), bool HALF_UNUSED_NOERR(cond) = true)
+		{
+		#if HALF_ERRHANDLING
+			if(!cond)
+				return;
+		#if HALF_ERRHANDLING_FLAGS
+			errflags() |= flags;
+		#endif
+		#if HALF_ERRHANDLING_ERRNO
+			if(flags & FE_INVALID)
+				errno = EDOM;
+			else if(flags & (FE_DIVBYZERO|FE_OVERFLOW|FE_UNDERFLOW))
+				errno = ERANGE;
+		#endif
+		#if HALF_ERRHANDLING_FENV && HALF_ENABLE_CPP11_CFENV
+			std::feraiseexcept(flags);
+		#endif
+		#ifdef HALF_ERRHANDLING_THROW_INVALID
+			if(flags & FE_INVALID)
+				throw std::domain_error(HALF_ERRHANDLING_THROW_INVALID);
+		#endif
+		#ifdef HALF_ERRHANDLING_THROW_DIVBYZERO
+			if(flags & FE_DIVBYZERO)
+				throw std::domain_error(HALF_ERRHANDLING_THROW_DIVBYZERO);
+		#endif
+		#ifdef HALF_ERRHANDLING_THROW_OVERFLOW
+			if(flags & FE_OVERFLOW)
+				throw std::overflow_error(HALF_ERRHANDLING_THROW_OVERFLOW);
+		#endif
+		#ifdef HALF_ERRHANDLING_THROW_UNDERFLOW
+			if(flags & FE_UNDERFLOW)
+				throw std::underflow_error(HALF_ERRHANDLING_THROW_UNDERFLOW);
+		#endif
+		#ifdef HALF_ERRHANDLING_THROW_INEXACT
+			if(flags & FE_INEXACT)
+				throw std::range_error(HALF_ERRHANDLING_THROW_INEXACT);
+		#endif
+		#if HALF_ERRHANDLING_UNDERFLOW_TO_INEXACT
+			if((flags & FE_UNDERFLOW) && !(flags & FE_INEXACT))
+				raise(FE_INEXACT);
+		#endif
+		#if HALF_ERRHANDLING_OVERFLOW_TO_INEXACT
+			if((flags & FE_OVERFLOW) && !(flags & FE_INEXACT))
+				raise(FE_INEXACT);
+		#endif
+		#endif
+		}
+
+		/// Check and signal for any NaN.
+		/// \param x first half-precision value to check
+		/// \param y second half-precision value to check
+		/// \retval true if either \a x or \a y is NaN
+		/// \retval false else
+		/// \exception FE_INVALID if \a x or \a y is NaN
+		inline HALF_CONSTEXPR_NOERR bool compsignal(unsigned int x, unsigned int y)
+		{
+		#if HALF_ERRHANDLING
+			raise(FE_INVALID, (x&0x7FFF)>0x7C00 || (y&0x7FFF)>0x7C00);
+		#endif
+			return (x&0x7FFF) > 0x7C00 || (y&0x7FFF) > 0x7C00;
+		}
+
+		/// Signal and silence signaling NaN.
+		/// \param nan half-precision NaN value
+		/// \return quiet NaN
+		/// \exception FE_INVALID if \a nan is signaling NaN
+		inline HALF_CONSTEXPR_NOERR unsigned int signal(unsigned int nan)
+		{
+		#if HALF_ERRHANDLING
+			raise(FE_INVALID, !(nan&0x200));
+		#endif
+			return nan | 0x200;
+		}
+
+		/// Signal and silence signaling NaNs.
+		/// \param x first half-precision value to check
+		/// \param y second half-precision value to check
+		/// \return quiet NaN
+		/// \exception FE_INVALID if \a x or \a y is signaling NaN
+		inline HALF_CONSTEXPR_NOERR unsigned int signal(unsigned int x, unsigned int y)
+		{
+		#if HALF_ERRHANDLING
+			raise(FE_INVALID, ((x&0x7FFF)>0x7C00 && !(x&0x200)) || ((y&0x7FFF)>0x7C00 && !(y&0x200)));
+		#endif
+			return ((x&0x7FFF)>0x7C00) ? (x|0x200) : (y|0x200);
+		}
+
+		/// Signal and silence signaling NaNs.
+		/// \param x first half-precision value to check
+		/// \param y second half-precision value to check
+		/// \param z third half-precision value to check
+		/// \return quiet NaN
+		/// \exception FE_INVALID if \a x, \a y or \a z is signaling NaN
+		inline HALF_CONSTEXPR_NOERR unsigned int signal(unsigned int x, unsigned int y, unsigned int z)
+		{
+		#if HALF_ERRHANDLING
+			raise(FE_INVALID, ((x&0x7FFF)>0x7C00 && !(x&0x200)) || ((y&0x7FFF)>0x7C00 && !(y&0x200)) || ((z&0x7FFF)>0x7C00 && !(z&0x200)));
+		#endif
+			return ((x&0x7FFF)>0x7C00) ? (x|0x200) : ((y&0x7FFF)>0x7C00) ? (y|0x200) : (z|0x200);
+		}
+
+		/// Select value or signaling NaN.
+		/// \param x preferred half-precision value
+		/// \param y ignored half-precision value except for signaling NaN
+		/// \return \a y if signaling NaN, \a x otherwise
+		/// \exception FE_INVALID if \a y is signaling NaN
+		inline HALF_CONSTEXPR_NOERR unsigned int select(unsigned int x, unsigned int HALF_UNUSED_NOERR(y))
+		{
+		#if HALF_ERRHANDLING
+			return (((y&0x7FFF)>0x7C00) && !(y&0x200)) ? signal(y) : x;
+		#else
+			return x;
+		#endif
+		}
+
+		/// Raise domain error and return NaN.
+		/// return quiet NaN
+		/// \exception FE_INVALID
+		inline HALF_CONSTEXPR_NOERR unsigned int invalid()
+		{
+		#if HALF_ERRHANDLING
+			raise(FE_INVALID);
+		#endif
+			return 0x7FFF;
+		}
+
+		/// Raise pole error and return infinity.
+		/// \param sign half-precision value with sign bit only
+		/// \return half-precision infinity with sign of \a sign
+		/// \exception FE_DIVBYZERO
+		inline HALF_CONSTEXPR_NOERR unsigned int pole(unsigned int sign = 0)
+		{
+		#if HALF_ERRHANDLING
+			raise(FE_DIVBYZERO);
+		#endif
+			return sign | 0x7C00;
+		}
+
+		/// Check value for underflow.
+		/// \param arg non-zero half-precision value to check
+		/// \return \a arg
+		/// \exception FE_UNDERFLOW if arg is subnormal
+		inline HALF_CONSTEXPR_NOERR unsigned int check_underflow(unsigned int arg)
+		{
+		#if HALF_ERRHANDLING && !HALF_ERRHANDLING_UNDERFLOW_TO_INEXACT
+			raise(FE_UNDERFLOW, !(arg&0x7C00));
+		#endif
+			return arg;
+		}
+
+		/// \}
+		/// \name Conversion and rounding
+		/// \{
+
+		/// Half-precision overflow.
+		/// \tparam R rounding mode to use
+		/// \param sign half-precision value with sign bit only
+		/// \return rounded overflowing half-precision value
+		/// \exception FE_OVERFLOW
+		template<std::float_round_style R> HALF_CONSTEXPR_NOERR unsigned int overflow(unsigned int sign = 0)
+		{
+		#if HALF_ERRHANDLING
+			raise(FE_OVERFLOW);
+		#endif
+			return	(R==std::round_toward_infinity) ? (sign+0x7C00-(sign>>15)) :
+					(R==std::round_toward_neg_infinity) ? (sign+0x7BFF+(sign>>15)) :
+					(R==std::round_toward_zero) ? (sign|0x7BFF) :
+					(sign|0x7C00);
+		}
+
+		/// Half-precision underflow.
+		/// \tparam R rounding mode to use
+		/// \param sign half-precision value with sign bit only
+		/// \return rounded underflowing half-precision value
+		/// \exception FE_UNDERFLOW
+		template<std::float_round_style R> HALF_CONSTEXPR_NOERR unsigned int underflow(unsigned int sign = 0)
+		{
+		#if HALF_ERRHANDLING
+			raise(FE_UNDERFLOW);
+		#endif
+			return	(R==std::round_toward_infinity) ? (sign+1-(sign>>15)) :
+					(R==std::round_toward_neg_infinity) ? (sign+(sign>>15)) :
+					sign;
+		}
+
+		/// Round half-precision number.
+		/// \tparam R rounding mode to use
+		/// \tparam I `true` to always raise INEXACT exception, `false` to raise only for rounded results
+		/// \param value finite half-precision number to round
+		/// \param g guard bit (most significant discarded bit)
+		/// \param s sticky bit (or of all but the most significant discarded bits)
+		/// \return rounded half-precision value
+		/// \exception FE_OVERFLOW on overflows
+		/// \exception FE_UNDERFLOW on underflows
+		/// \exception FE_INEXACT if value had to be rounded or \a I is `true`
+		template<std::float_round_style R,bool I> HALF_CONSTEXPR_NOERR unsigned int rounded(unsigned int value, int g, int s)
+		{
+		#if HALF_ERRHANDLING
+			value +=	(R==std::round_to_nearest) ? (g&(s|value)) :
+						(R==std::round_toward_infinity) ? (~(value>>15)&(g|s)) :
+						(R==std::round_toward_neg_infinity) ? ((value>>15)&(g|s)) : 0;
+			if((value&0x7C00) == 0x7C00)
+				raise(FE_OVERFLOW);
+			else if(value & 0x7C00)
+				raise(FE_INEXACT, I || (g|s)!=0);
+			else
+				raise(FE_UNDERFLOW, !(HALF_ERRHANDLING_UNDERFLOW_TO_INEXACT) || I || (g|s)!=0);
+			return value;
+		#else
+			return	(R==std::round_to_nearest) ? (value+(g&(s|value))) :
+					(R==std::round_toward_infinity) ? (value+(~(value>>15)&(g|s))) :
+					(R==std::round_toward_neg_infinity) ? (value+((value>>15)&(g|s))) :
+					value;
+		#endif
+		}
+
+		/// Round half-precision number to nearest integer value.
+		/// \tparam R rounding mode to use
+		/// \tparam E `true` for round to even, `false` for round away from zero
+		/// \tparam I `true` to raise INEXACT exception (if inexact), `false` to never raise it
+		/// \param value half-precision value to round
+		/// \return half-precision bits for nearest integral value
+		/// \exception FE_INVALID for signaling NaN
+		/// \exception FE_INEXACT if value had to be rounded and \a I is `true`
+		template<std::float_round_style R,bool E,bool I> unsigned int integral(unsigned int value)
+		{
+			unsigned int abs = value & 0x7FFF;
+			if(abs < 0x3C00)
+			{
+				raise(FE_INEXACT, I);
+				return ((R==std::round_to_nearest) ? (0x3C00&-static_cast<unsigned>(abs>=(0x3800+E))) :
+						(R==std::round_toward_infinity) ? (0x3C00&-(~(value>>15)&(abs!=0))) :
+						(R==std::round_toward_neg_infinity) ? (0x3C00&-static_cast<unsigned>(value>0x8000)) :
+						0) | (value&0x8000);
+			}
+			if(abs >= 0x6400)
+				return (abs>0x7C00) ? signal(value) : value;
+			unsigned int exp = 25 - (abs>>10), mask = (1<<exp) - 1;
+			raise(FE_INEXACT, I && (value&mask));
+			return ((	(R==std::round_to_nearest) ? ((1<<(exp-1))-(~(value>>exp)&E)) :
+						(R==std::round_toward_infinity) ? (mask&((value>>15)-1)) :
+						(R==std::round_toward_neg_infinity) ? (mask&-(value>>15)) :
+						0) + value) & ~mask;
+		}
+
+		/// Convert fixed point to half-precision floating-point.
+		/// \tparam R rounding mode to use
+		/// \tparam F number of fractional bits (at least 11)
+		/// \tparam S `true` for signed, `false` for unsigned
+		/// \tparam N `true` for additional normalization step, `false` if already normalized to 1.F
+		/// \tparam I `true` to always raise INEXACT exception, `false` to raise only for rounded results
+		/// \param m mantissa in Q1.F fixed point format
+		/// \param exp exponent
+		/// \param sign half-precision value with sign bit only
+		/// \param s sticky bit (or of all but the most significant already discarded bits)
+		/// \return value converted to half-precision
+		/// \exception FE_OVERFLOW on overflows
+		/// \exception FE_UNDERFLOW on underflows
+		/// \exception FE_INEXACT if value had to be rounded or \a I is `true`
+		template<std::float_round_style R,unsigned int F,bool S,bool N,bool I> unsigned int fixed2half(uint32 m, int exp = 14, unsigned int sign = 0, int s = 0)
+		{
+			if(S)
+			{
+				uint32 msign = sign_mask(m);
+				m = (m^msign) - msign;
+				sign = msign & 0x8000;
+			}
+			if(N)
+				for(; m<(static_cast<uint32>(1)<<F) && exp; m<<=1,--exp) ;
+			else if(exp < 0)
+				return rounded<R,I>(sign+(m>>(F-10-exp)), (m>>(F-11-exp))&1, s|((m&((static_cast<uint32>(1)<<(F-11-exp))-1))!=0));
+			return rounded<R,I>(sign+(exp<<10)+(m>>(F-10)), (m>>(F-11))&1, s|((m&((static_cast<uint32>(1)<<(F-11))-1))!=0));
+		}
+
+		/// Convert IEEE single-precision to half-precision.
+		/// Credit for this goes to [Jeroen van der Zijp](ftp://ftp.fox-toolkit.org/pub/fasthalffloatconversion.pdf).
+		/// \tparam R rounding mode to use
+		/// \param value single-precision value to convert
+		/// \return rounded half-precision value
+		/// \exception FE_OVERFLOW on overflows
+		/// \exception FE_UNDERFLOW on underflows
+		/// \exception FE_INEXACT if value had to be rounded
+		template<std::float_round_style R> unsigned int float2half_impl(float value, true_type)
+		{
+		#if HALF_ENABLE_F16C_INTRINSICS
+			return _mm_cvtsi128_si32(_mm_cvtps_ph(_mm_set_ss(value),
+				(R==std::round_to_nearest) ? _MM_FROUND_TO_NEAREST_INT :
+				(R==std::round_toward_zero) ? _MM_FROUND_TO_ZERO :
+				(R==std::round_toward_infinity) ? _MM_FROUND_TO_POS_INF :
+				(R==std::round_toward_neg_infinity) ? _MM_FROUND_TO_NEG_INF :
+				_MM_FROUND_CUR_DIRECTION));
+		#else
+			bits<float>::type fbits;
+			std::memcpy(&fbits, &value, sizeof(float));
+		#if 1
+			unsigned int sign = (fbits>>16) & 0x8000;
+			fbits &= 0x7FFFFFFF;
+			if(fbits >= 0x7F800000)
+				return sign | 0x7C00 | ((fbits>0x7F800000) ? (0x200|((fbits>>13)&0x3FF)) : 0);
+			if(fbits >= 0x47800000)
+				return overflow<R>(sign);
+			if(fbits >= 0x38800000)
+				return rounded<R,false>(sign|(((fbits>>23)-112)<<10)|((fbits>>13)&0x3FF), (fbits>>12)&1, (fbits&0xFFF)!=0);
+			if(fbits >= 0x33000000)
+			{
+				int i = 125 - (fbits>>23);
+				fbits = (fbits&0x7FFFFF) | 0x800000;
+				return rounded<R,false>(sign|(fbits>>(i+1)), (fbits>>i)&1, (fbits&((static_cast<uint32>(1)<<i)-1))!=0);
+			}
+			if(fbits != 0)
+				return underflow<R>(sign);
+			return sign;
+		#else
+			static const uint16 base_table[512] = {
+				0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
+				0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
+				0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
+				0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
+				0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
+				0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
+				0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100, 
+				0x0200, 0x0400, 0x0800, 0x0C00, 0x1000, 0x1400, 0x1800, 0x1C00, 0x2000, 0x2400, 0x2800, 0x2C00, 0x3000, 0x3400, 0x3800, 0x3C00, 
+				0x4000, 0x4400, 0x4800, 0x4C00, 0x5000, 0x5400, 0x5800, 0x5C00, 0x6000, 0x6400, 0x6800, 0x6C00, 0x7000, 0x7400, 0x7800, 0x7BFF, 
+				0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 
+				0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 
+				0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 
+				0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 
+				0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 
+				0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 
+				0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7BFF, 0x7C00, 
+				0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 
+				0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 
+				0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 
+				0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 
+				0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 
+				0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 
+				0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8001, 0x8002, 0x8004, 0x8008, 0x8010, 0x8020, 0x8040, 0x8080, 0x8100, 
+				0x8200, 0x8400, 0x8800, 0x8C00, 0x9000, 0x9400, 0x9800, 0x9C00, 0xA000, 0xA400, 0xA800, 0xAC00, 0xB000, 0xB400, 0xB800, 0xBC00, 
+				0xC000, 0xC400, 0xC800, 0xCC00, 0xD000, 0xD400, 0xD800, 0xDC00, 0xE000, 0xE400, 0xE800, 0xEC00, 0xF000, 0xF400, 0xF800, 0xFBFF, 
+				0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 
+				0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 
+				0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 
+				0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 
+				0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 
+				0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 
+				0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFBFF, 0xFC00 };
+			static const unsigned char shift_table[256] = {
+				24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
+				25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
+				25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
+				25, 25, 25, 25, 25, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 
+				13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
+				24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
+				24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
+				24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13 };
+			int sexp = fbits >> 23, exp = sexp & 0xFF, i = shift_table[exp];
+			fbits &= 0x7FFFFF;
+			uint32 m = (fbits|((exp!=0)<<23)) & -static_cast<uint32>(exp!=0xFF);
+			return rounded<R,false>(base_table[sexp]+(fbits>>i), (m>>(i-1))&1, (((static_cast<uint32>(1)<<(i-1))-1)&m)!=0);
+		#endif
+		#endif
+		}
+
+		/// Convert IEEE double-precision to half-precision.
+		/// \tparam R rounding mode to use
+		/// \param value double-precision value to convert
+		/// \return rounded half-precision value
+		/// \exception FE_OVERFLOW on overflows
+		/// \exception FE_UNDERFLOW on underflows
+		/// \exception FE_INEXACT if value had to be rounded
+		template<std::float_round_style R> unsigned int float2half_impl(double value, true_type)
+		{
+		#if HALF_ENABLE_F16C_INTRINSICS
+			if(R == std::round_indeterminate)
+				return _mm_cvtsi128_si32(_mm_cvtps_ph(_mm_cvtpd_ps(_mm_set_sd(value)), _MM_FROUND_CUR_DIRECTION));
+		#endif
+			bits<double>::type dbits;
+			std::memcpy(&dbits, &value, sizeof(double));
+			uint32 hi = dbits >> 32, lo = dbits & 0xFFFFFFFF;
+			unsigned int sign = (hi>>16) & 0x8000;
+			hi &= 0x7FFFFFFF;
+			if(hi >= 0x7FF00000)
+				return sign | 0x7C00 | ((dbits&0xFFFFFFFFFFFFF) ? (0x200|((hi>>10)&0x3FF)) : 0);
+			if(hi >= 0x40F00000)
+				return overflow<R>(sign);
+			if(hi >= 0x3F100000)
+				return rounded<R,false>(sign|(((hi>>20)-1008)<<10)|((hi>>10)&0x3FF), (hi>>9)&1, ((hi&0x1FF)|lo)!=0);
+			if(hi >= 0x3E600000)
+			{
+				int i = 1018 - (hi>>20);
+				hi = (hi&0xFFFFF) | 0x100000;
+				return rounded<R,false>(sign|(hi>>(i+1)), (hi>>i)&1, ((hi&((static_cast<uint32>(1)<<i)-1))|lo)!=0);
+			}
+			if((hi|lo) != 0)
+				return underflow<R>(sign);
+			return sign;
+		}
+
+		/// Convert non-IEEE floating-point to half-precision.
+		/// \tparam R rounding mode to use
+		/// \tparam T source type (builtin floating-point type)
+		/// \param value floating-point value to convert
+		/// \return rounded half-precision value
+		/// \exception FE_OVERFLOW on overflows
+		/// \exception FE_UNDERFLOW on underflows
+		/// \exception FE_INEXACT if value had to be rounded
+		template<std::float_round_style R,typename T> unsigned int float2half_impl(T value, ...)
+		{
+			unsigned int hbits = static_cast<unsigned>(builtin_signbit(value)) << 15;
+			if(value == T())
+				return hbits;
+			if(builtin_isnan(value))
+				return hbits | 0x7FFF;
+			if(builtin_isinf(value))
+				return hbits | 0x7C00;
+			int exp;
+			std::frexp(value, &exp);
+			if(exp > 16)
+				return overflow<R>(hbits);
+			if(exp < -13)
+				value = std::ldexp(value, 25);
+			else
+			{
+				value = std::ldexp(value, 12-exp);
+				hbits |= ((exp+13)<<10);
+			}
+			T ival, frac = std::modf(value, &ival);
+			int m = std::abs(static_cast<int>(ival));
+			return rounded<R,false>(hbits+(m>>1), m&1, frac!=T());
+		}
+
+		/// Convert floating-point to half-precision.
+		/// \tparam R rounding mode to use
+		/// \tparam T source type (builtin floating-point type)
+		/// \param value floating-point value to convert
+		/// \return rounded half-precision value
+		/// \exception FE_OVERFLOW on overflows
+		/// \exception FE_UNDERFLOW on underflows
+		/// \exception FE_INEXACT if value had to be rounded
+		template<std::float_round_style R,typename T> unsigned int float2half(T value)
+		{
+			return float2half_impl<R>(value, bool_type<std::numeric_limits<T>::is_iec559&&sizeof(typename bits<T>::type)==sizeof(T)>());
+		}
+
+		/// Convert integer to half-precision floating-point.
+		/// \tparam R rounding mode to use
+		/// \tparam T type to convert (builtin integer type)
+		/// \param value integral value to convert
+		/// \return rounded half-precision value
+		/// \exception FE_OVERFLOW on overflows
+		/// \exception FE_INEXACT if value had to be rounded
+		template<std::float_round_style R,typename T> unsigned int int2half(T value)
+		{
+			unsigned int bits = static_cast<unsigned>(value<0) << 15;
+			if(!value)
+				return bits;
+			if(bits)
+				value = -value;
+			if(value > 0xFFFF)
+				return overflow<R>(bits);
+			unsigned int m = static_cast<unsigned int>(value), exp = 24;
+			for(; m<0x400; m<<=1,--exp) ;
+			for(; m>0x7FF; m>>=1,++exp) ;
+			bits |= (exp<<10) + m;
+			return (exp>24) ? rounded<R,false>(bits, (value>>(exp-25))&1, (((1<<(exp-25))-1)&value)!=0) : bits;
+		}
+
+		/// Convert half-precision to IEEE single-precision.
+		/// Credit for this goes to [Jeroen van der Zijp](ftp://ftp.fox-toolkit.org/pub/fasthalffloatconversion.pdf).
+		/// \param value half-precision value to convert
+		/// \return single-precision value
+		inline float half2float_impl(unsigned int value, float, true_type)
+		{
+		#if HALF_ENABLE_F16C_INTRINSICS
+			return _mm_cvtss_f32(_mm_cvtph_ps(_mm_cvtsi32_si128(value)));
+		#else
+		#if 0
+			bits<float>::type fbits = static_cast<bits<float>::type>(value&0x8000) << 16;
+			int abs = value & 0x7FFF;
+			if(abs)
+			{
+				fbits |= 0x38000000 << static_cast<unsigned>(abs>=0x7C00);
+				for(; abs<0x400; abs<<=1,fbits-=0x800000) ;
+				fbits += static_cast<bits<float>::type>(abs) << 13;
+			}
+		#else
+			static const bits<float>::type mantissa_table[2048] = {
+				0x00000000, 0x33800000, 0x34000000, 0x34400000, 0x34800000, 0x34A00000, 0x34C00000, 0x34E00000, 0x35000000, 0x35100000, 0x35200000, 0x35300000, 0x35400000, 0x35500000, 0x35600000, 0x35700000, 
+				0x35800000, 0x35880000, 0x35900000, 0x35980000, 0x35A00000, 0x35A80000, 0x35B00000, 0x35B80000, 0x35C00000, 0x35C80000, 0x35D00000, 0x35D80000, 0x35E00000, 0x35E80000, 0x35F00000, 0x35F80000, 
+				0x36000000, 0x36040000, 0x36080000, 0x360C0000, 0x36100000, 0x36140000, 0x36180000, 0x361C0000, 0x36200000, 0x36240000, 0x36280000, 0x362C0000, 0x36300000, 0x36340000, 0x36380000, 0x363C0000, 
+				0x36400000, 0x36440000, 0x36480000, 0x364C0000, 0x36500000, 0x36540000, 0x36580000, 0x365C0000, 0x36600000, 0x36640000, 0x36680000, 0x366C0000, 0x36700000, 0x36740000, 0x36780000, 0x367C0000, 
+				0x36800000, 0x36820000, 0x36840000, 0x36860000, 0x36880000, 0x368A0000, 0x368C0000, 0x368E0000, 0x36900000, 0x36920000, 0x36940000, 0x36960000, 0x36980000, 0x369A0000, 0x369C0000, 0x369E0000, 
+				0x36A00000, 0x36A20000, 0x36A40000, 0x36A60000, 0x36A80000, 0x36AA0000, 0x36AC0000, 0x36AE0000, 0x36B00000, 0x36B20000, 0x36B40000, 0x36B60000, 0x36B80000, 0x36BA0000, 0x36BC0000, 0x36BE0000, 
+				0x36C00000, 0x36C20000, 0x36C40000, 0x36C60000, 0x36C80000, 0x36CA0000, 0x36CC0000, 0x36CE0000, 0x36D00000, 0x36D20000, 0x36D40000, 0x36D60000, 0x36D80000, 0x36DA0000, 0x36DC0000, 0x36DE0000, 
+				0x36E00000, 0x36E20000, 0x36E40000, 0x36E60000, 0x36E80000, 0x36EA0000, 0x36EC0000, 0x36EE0000, 0x36F00000, 0x36F20000, 0x36F40000, 0x36F60000, 0x36F80000, 0x36FA0000, 0x36FC0000, 0x36FE0000, 
+				0x37000000, 0x37010000, 0x37020000, 0x37030000, 0x37040000, 0x37050000, 0x37060000, 0x37070000, 0x37080000, 0x37090000, 0x370A0000, 0x370B0000, 0x370C0000, 0x370D0000, 0x370E0000, 0x370F0000, 
+				0x37100000, 0x37110000, 0x37120000, 0x37130000, 0x37140000, 0x37150000, 0x37160000, 0x37170000, 0x37180000, 0x37190000, 0x371A0000, 0x371B0000, 0x371C0000, 0x371D0000, 0x371E0000, 0x371F0000, 
+				0x37200000, 0x37210000, 0x37220000, 0x37230000, 0x37240000, 0x37250000, 0x37260000, 0x37270000, 0x37280000, 0x37290000, 0x372A0000, 0x372B0000, 0x372C0000, 0x372D0000, 0x372E0000, 0x372F0000, 
+				0x37300000, 0x37310000, 0x37320000, 0x37330000, 0x37340000, 0x37350000, 0x37360000, 0x37370000, 0x37380000, 0x37390000, 0x373A0000, 0x373B0000, 0x373C0000, 0x373D0000, 0x373E0000, 0x373F0000, 
+				0x37400000, 0x37410000, 0x37420000, 0x37430000, 0x37440000, 0x37450000, 0x37460000, 0x37470000, 0x37480000, 0x37490000, 0x374A0000, 0x374B0000, 0x374C0000, 0x374D0000, 0x374E0000, 0x374F0000, 
+				0x37500000, 0x37510000, 0x37520000, 0x37530000, 0x37540000, 0x37550000, 0x37560000, 0x37570000, 0x37580000, 0x37590000, 0x375A0000, 0x375B0000, 0x375C0000, 0x375D0000, 0x375E0000, 0x375F0000, 
+				0x37600000, 0x37610000, 0x37620000, 0x37630000, 0x37640000, 0x37650000, 0x37660000, 0x37670000, 0x37680000, 0x37690000, 0x376A0000, 0x376B0000, 0x376C0000, 0x376D0000, 0x376E0000, 0x376F0000, 
+				0x37700000, 0x37710000, 0x37720000, 0x37730000, 0x37740000, 0x37750000, 0x37760000, 0x37770000, 0x37780000, 0x37790000, 0x377A0000, 0x377B0000, 0x377C0000, 0x377D0000, 0x377E0000, 0x377F0000, 
+				0x37800000, 0x37808000, 0x37810000, 0x37818000, 0x37820000, 0x37828000, 0x37830000, 0x37838000, 0x37840000, 0x37848000, 0x37850000, 0x37858000, 0x37860000, 0x37868000, 0x37870000, 0x37878000, 
+				0x37880000, 0x37888000, 0x37890000, 0x37898000, 0x378A0000, 0x378A8000, 0x378B0000, 0x378B8000, 0x378C0000, 0x378C8000, 0x378D0000, 0x378D8000, 0x378E0000, 0x378E8000, 0x378F0000, 0x378F8000, 
+				0x37900000, 0x37908000, 0x37910000, 0x37918000, 0x37920000, 0x37928000, 0x37930000, 0x37938000, 0x37940000, 0x37948000, 0x37950000, 0x37958000, 0x37960000, 0x37968000, 0x37970000, 0x37978000, 
+				0x37980000, 0x37988000, 0x37990000, 0x37998000, 0x379A0000, 0x379A8000, 0x379B0000, 0x379B8000, 0x379C0000, 0x379C8000, 0x379D0000, 0x379D8000, 0x379E0000, 0x379E8000, 0x379F0000, 0x379F8000, 
+				0x37A00000, 0x37A08000, 0x37A10000, 0x37A18000, 0x37A20000, 0x37A28000, 0x37A30000, 0x37A38000, 0x37A40000, 0x37A48000, 0x37A50000, 0x37A58000, 0x37A60000, 0x37A68000, 0x37A70000, 0x37A78000, 
+				0x37A80000, 0x37A88000, 0x37A90000, 0x37A98000, 0x37AA0000, 0x37AA8000, 0x37AB0000, 0x37AB8000, 0x37AC0000, 0x37AC8000, 0x37AD0000, 0x37AD8000, 0x37AE0000, 0x37AE8000, 0x37AF0000, 0x37AF8000, 
+				0x37B00000, 0x37B08000, 0x37B10000, 0x37B18000, 0x37B20000, 0x37B28000, 0x37B30000, 0x37B38000, 0x37B40000, 0x37B48000, 0x37B50000, 0x37B58000, 0x37B60000, 0x37B68000, 0x37B70000, 0x37B78000, 
+				0x37B80000, 0x37B88000, 0x37B90000, 0x37B98000, 0x37BA0000, 0x37BA8000, 0x37BB0000, 0x37BB8000, 0x37BC0000, 0x37BC8000, 0x37BD0000, 0x37BD8000, 0x37BE0000, 0x37BE8000, 0x37BF0000, 0x37BF8000, 
+				0x37C00000, 0x37C08000, 0x37C10000, 0x37C18000, 0x37C20000, 0x37C28000, 0x37C30000, 0x37C38000, 0x37C40000, 0x37C48000, 0x37C50000, 0x37C58000, 0x37C60000, 0x37C68000, 0x37C70000, 0x37C78000, 
+				0x37C80000, 0x37C88000, 0x37C90000, 0x37C98000, 0x37CA0000, 0x37CA8000, 0x37CB0000, 0x37CB8000, 0x37CC0000, 0x37CC8000, 0x37CD0000, 0x37CD8000, 0x37CE0000, 0x37CE8000, 0x37CF0000, 0x37CF8000, 
+				0x37D00000, 0x37D08000, 0x37D10000, 0x37D18000, 0x37D20000, 0x37D28000, 0x37D30000, 0x37D38000, 0x37D40000, 0x37D48000, 0x37D50000, 0x37D58000, 0x37D60000, 0x37D68000, 0x37D70000, 0x37D78000, 
+				0x37D80000, 0x37D88000, 0x37D90000, 0x37D98000, 0x37DA0000, 0x37DA8000, 0x37DB0000, 0x37DB8000, 0x37DC0000, 0x37DC8000, 0x37DD0000, 0x37DD8000, 0x37DE0000, 0x37DE8000, 0x37DF0000, 0x37DF8000, 
+				0x37E00000, 0x37E08000, 0x37E10000, 0x37E18000, 0x37E20000, 0x37E28000, 0x37E30000, 0x37E38000, 0x37E40000, 0x37E48000, 0x37E50000, 0x37E58000, 0x37E60000, 0x37E68000, 0x37E70000, 0x37E78000, 
+				0x37E80000, 0x37E88000, 0x37E90000, 0x37E98000, 0x37EA0000, 0x37EA8000, 0x37EB0000, 0x37EB8000, 0x37EC0000, 0x37EC8000, 0x37ED0000, 0x37ED8000, 0x37EE0000, 0x37EE8000, 0x37EF0000, 0x37EF8000, 
+				0x37F00000, 0x37F08000, 0x37F10000, 0x37F18000, 0x37F20000, 0x37F28000, 0x37F30000, 0x37F38000, 0x37F40000, 0x37F48000, 0x37F50000, 0x37F58000, 0x37F60000, 0x37F68000, 0x37F70000, 0x37F78000, 
+				0x37F80000, 0x37F88000, 0x37F90000, 0x37F98000, 0x37FA0000, 0x37FA8000, 0x37FB0000, 0x37FB8000, 0x37FC0000, 0x37FC8000, 0x37FD0000, 0x37FD8000, 0x37FE0000, 0x37FE8000, 0x37FF0000, 0x37FF8000, 
+				0x38000000, 0x38004000, 0x38008000, 0x3800C000, 0x38010000, 0x38014000, 0x38018000, 0x3801C000, 0x38020000, 0x38024000, 0x38028000, 0x3802C000, 0x38030000, 0x38034000, 0x38038000, 0x3803C000, 
+				0x38040000, 0x38044000, 0x38048000, 0x3804C000, 0x38050000, 0x38054000, 0x38058000, 0x3805C000, 0x38060000, 0x38064000, 0x38068000, 0x3806C000, 0x38070000, 0x38074000, 0x38078000, 0x3807C000, 
+				0x38080000, 0x38084000, 0x38088000, 0x3808C000, 0x38090000, 0x38094000, 0x38098000, 0x3809C000, 0x380A0000, 0x380A4000, 0x380A8000, 0x380AC000, 0x380B0000, 0x380B4000, 0x380B8000, 0x380BC000, 
+				0x380C0000, 0x380C4000, 0x380C8000, 0x380CC000, 0x380D0000, 0x380D4000, 0x380D8000, 0x380DC000, 0x380E0000, 0x380E4000, 0x380E8000, 0x380EC000, 0x380F0000, 0x380F4000, 0x380F8000, 0x380FC000, 
+				0x38100000, 0x38104000, 0x38108000, 0x3810C000, 0x38110000, 0x38114000, 0x38118000, 0x3811C000, 0x38120000, 0x38124000, 0x38128000, 0x3812C000, 0x38130000, 0x38134000, 0x38138000, 0x3813C000, 
+				0x38140000, 0x38144000, 0x38148000, 0x3814C000, 0x38150000, 0x38154000, 0x38158000, 0x3815C000, 0x38160000, 0x38164000, 0x38168000, 0x3816C000, 0x38170000, 0x38174000, 0x38178000, 0x3817C000, 
+				0x38180000, 0x38184000, 0x38188000, 0x3818C000, 0x38190000, 0x38194000, 0x38198000, 0x3819C000, 0x381A0000, 0x381A4000, 0x381A8000, 0x381AC000, 0x381B0000, 0x381B4000, 0x381B8000, 0x381BC000, 
+				0x381C0000, 0x381C4000, 0x381C8000, 0x381CC000, 0x381D0000, 0x381D4000, 0x381D8000, 0x381DC000, 0x381E0000, 0x381E4000, 0x381E8000, 0x381EC000, 0x381F0000, 0x381F4000, 0x381F8000, 0x381FC000, 
+				0x38200000, 0x38204000, 0x38208000, 0x3820C000, 0x38210000, 0x38214000, 0x38218000, 0x3821C000, 0x38220000, 0x38224000, 0x38228000, 0x3822C000, 0x38230000, 0x38234000, 0x38238000, 0x3823C000, 
+				0x38240000, 0x38244000, 0x38248000, 0x3824C000, 0x38250000, 0x38254000, 0x38258000, 0x3825C000, 0x38260000, 0x38264000, 0x38268000, 0x3826C000, 0x38270000, 0x38274000, 0x38278000, 0x3827C000, 
+				0x38280000, 0x38284000, 0x38288000, 0x3828C000, 0x38290000, 0x38294000, 0x38298000, 0x3829C000, 0x382A0000, 0x382A4000, 0x382A8000, 0x382AC000, 0x382B0000, 0x382B4000, 0x382B8000, 0x382BC000, 
+				0x382C0000, 0x382C4000, 0x382C8000, 0x382CC000, 0x382D0000, 0x382D4000, 0x382D8000, 0x382DC000, 0x382E0000, 0x382E4000, 0x382E8000, 0x382EC000, 0x382F0000, 0x382F4000, 0x382F8000, 0x382FC000, 
+				0x38300000, 0x38304000, 0x38308000, 0x3830C000, 0x38310000, 0x38314000, 0x38318000, 0x3831C000, 0x38320000, 0x38324000, 0x38328000, 0x3832C000, 0x38330000, 0x38334000, 0x38338000, 0x3833C000, 
+				0x38340000, 0x38344000, 0x38348000, 0x3834C000, 0x38350000, 0x38354000, 0x38358000, 0x3835C000, 0x38360000, 0x38364000, 0x38368000, 0x3836C000, 0x38370000, 0x38374000, 0x38378000, 0x3837C000, 
+				0x38380000, 0x38384000, 0x38388000, 0x3838C000, 0x38390000, 0x38394000, 0x38398000, 0x3839C000, 0x383A0000, 0x383A4000, 0x383A8000, 0x383AC000, 0x383B0000, 0x383B4000, 0x383B8000, 0x383BC000, 
+				0x383C0000, 0x383C4000, 0x383C8000, 0x383CC000, 0x383D0000, 0x383D4000, 0x383D8000, 0x383DC000, 0x383E0000, 0x383E4000, 0x383E8000, 0x383EC000, 0x383F0000, 0x383F4000, 0x383F8000, 0x383FC000, 
+				0x38400000, 0x38404000, 0x38408000, 0x3840C000, 0x38410000, 0x38414000, 0x38418000, 0x3841C000, 0x38420000, 0x38424000, 0x38428000, 0x3842C000, 0x38430000, 0x38434000, 0x38438000, 0x3843C000, 
+				0x38440000, 0x38444000, 0x38448000, 0x3844C000, 0x38450000, 0x38454000, 0x38458000, 0x3845C000, 0x38460000, 0x38464000, 0x38468000, 0x3846C000, 0x38470000, 0x38474000, 0x38478000, 0x3847C000, 
+				0x38480000, 0x38484000, 0x38488000, 0x3848C000, 0x38490000, 0x38494000, 0x38498000, 0x3849C000, 0x384A0000, 0x384A4000, 0x384A8000, 0x384AC000, 0x384B0000, 0x384B4000, 0x384B8000, 0x384BC000, 
+				0x384C0000, 0x384C4000, 0x384C8000, 0x384CC000, 0x384D0000, 0x384D4000, 0x384D8000, 0x384DC000, 0x384E0000, 0x384E4000, 0x384E8000, 0x384EC000, 0x384F0000, 0x384F4000, 0x384F8000, 0x384FC000, 
+				0x38500000, 0x38504000, 0x38508000, 0x3850C000, 0x38510000, 0x38514000, 0x38518000, 0x3851C000, 0x38520000, 0x38524000, 0x38528000, 0x3852C000, 0x38530000, 0x38534000, 0x38538000, 0x3853C000, 
+				0x38540000, 0x38544000, 0x38548000, 0x3854C000, 0x38550000, 0x38554000, 0x38558000, 0x3855C000, 0x38560000, 0x38564000, 0x38568000, 0x3856C000, 0x38570000, 0x38574000, 0x38578000, 0x3857C000, 
+				0x38580000, 0x38584000, 0x38588000, 0x3858C000, 0x38590000, 0x38594000, 0x38598000, 0x3859C000, 0x385A0000, 0x385A4000, 0x385A8000, 0x385AC000, 0x385B0000, 0x385B4000, 0x385B8000, 0x385BC000, 
+				0x385C0000, 0x385C4000, 0x385C8000, 0x385CC000, 0x385D0000, 0x385D4000, 0x385D8000, 0x385DC000, 0x385E0000, 0x385E4000, 0x385E8000, 0x385EC000, 0x385F0000, 0x385F4000, 0x385F8000, 0x385FC000, 
+				0x38600000, 0x38604000, 0x38608000, 0x3860C000, 0x38610000, 0x38614000, 0x38618000, 0x3861C000, 0x38620000, 0x38624000, 0x38628000, 0x3862C000, 0x38630000, 0x38634000, 0x38638000, 0x3863C000, 
+				0x38640000, 0x38644000, 0x38648000, 0x3864C000, 0x38650000, 0x38654000, 0x38658000, 0x3865C000, 0x38660000, 0x38664000, 0x38668000, 0x3866C000, 0x38670000, 0x38674000, 0x38678000, 0x3867C000, 
+				0x38680000, 0x38684000, 0x38688000, 0x3868C000, 0x38690000, 0x38694000, 0x38698000, 0x3869C000, 0x386A0000, 0x386A4000, 0x386A8000, 0x386AC000, 0x386B0000, 0x386B4000, 0x386B8000, 0x386BC000, 
+				0x386C0000, 0x386C4000, 0x386C8000, 0x386CC000, 0x386D0000, 0x386D4000, 0x386D8000, 0x386DC000, 0x386E0000, 0x386E4000, 0x386E8000, 0x386EC000, 0x386F0000, 0x386F4000, 0x386F8000, 0x386FC000, 
+				0x38700000, 0x38704000, 0x38708000, 0x3870C000, 0x38710000, 0x38714000, 0x38718000, 0x3871C000, 0x38720000, 0x38724000, 0x38728000, 0x3872C000, 0x38730000, 0x38734000, 0x38738000, 0x3873C000, 
+				0x38740000, 0x38744000, 0x38748000, 0x3874C000, 0x38750000, 0x38754000, 0x38758000, 0x3875C000, 0x38760000, 0x38764000, 0x38768000, 0x3876C000, 0x38770000, 0x38774000, 0x38778000, 0x3877C000, 
+				0x38780000, 0x38784000, 0x38788000, 0x3878C000, 0x38790000, 0x38794000, 0x38798000, 0x3879C000, 0x387A0000, 0x387A4000, 0x387A8000, 0x387AC000, 0x387B0000, 0x387B4000, 0x387B8000, 0x387BC000, 
+				0x387C0000, 0x387C4000, 0x387C8000, 0x387CC000, 0x387D0000, 0x387D4000, 0x387D8000, 0x387DC000, 0x387E0000, 0x387E4000, 0x387E8000, 0x387EC000, 0x387F0000, 0x387F4000, 0x387F8000, 0x387FC000, 
+				0x38000000, 0x38002000, 0x38004000, 0x38006000, 0x38008000, 0x3800A000, 0x3800C000, 0x3800E000, 0x38010000, 0x38012000, 0x38014000, 0x38016000, 0x38018000, 0x3801A000, 0x3801C000, 0x3801E000, 
+				0x38020000, 0x38022000, 0x38024000, 0x38026000, 0x38028000, 0x3802A000, 0x3802C000, 0x3802E000, 0x38030000, 0x38032000, 0x38034000, 0x38036000, 0x38038000, 0x3803A000, 0x3803C000, 0x3803E000, 
+				0x38040000, 0x38042000, 0x38044000, 0x38046000, 0x38048000, 0x3804A000, 0x3804C000, 0x3804E000, 0x38050000, 0x38052000, 0x38054000, 0x38056000, 0x38058000, 0x3805A000, 0x3805C000, 0x3805E000, 
+				0x38060000, 0x38062000, 0x38064000, 0x38066000, 0x38068000, 0x3806A000, 0x3806C000, 0x3806E000, 0x38070000, 0x38072000, 0x38074000, 0x38076000, 0x38078000, 0x3807A000, 0x3807C000, 0x3807E000, 
+				0x38080000, 0x38082000, 0x38084000, 0x38086000, 0x38088000, 0x3808A000, 0x3808C000, 0x3808E000, 0x38090000, 0x38092000, 0x38094000, 0x38096000, 0x38098000, 0x3809A000, 0x3809C000, 0x3809E000, 
+				0x380A0000, 0x380A2000, 0x380A4000, 0x380A6000, 0x380A8000, 0x380AA000, 0x380AC000, 0x380AE000, 0x380B0000, 0x380B2000, 0x380B4000, 0x380B6000, 0x380B8000, 0x380BA000, 0x380BC000, 0x380BE000, 
+				0x380C0000, 0x380C2000, 0x380C4000, 0x380C6000, 0x380C8000, 0x380CA000, 0x380CC000, 0x380CE000, 0x380D0000, 0x380D2000, 0x380D4000, 0x380D6000, 0x380D8000, 0x380DA000, 0x380DC000, 0x380DE000, 
+				0x380E0000, 0x380E2000, 0x380E4000, 0x380E6000, 0x380E8000, 0x380EA000, 0x380EC000, 0x380EE000, 0x380F0000, 0x380F2000, 0x380F4000, 0x380F6000, 0x380F8000, 0x380FA000, 0x380FC000, 0x380FE000, 
+				0x38100000, 0x38102000, 0x38104000, 0x38106000, 0x38108000, 0x3810A000, 0x3810C000, 0x3810E000, 0x38110000, 0x38112000, 0x38114000, 0x38116000, 0x38118000, 0x3811A000, 0x3811C000, 0x3811E000, 
+				0x38120000, 0x38122000, 0x38124000, 0x38126000, 0x38128000, 0x3812A000, 0x3812C000, 0x3812E000, 0x38130000, 0x38132000, 0x38134000, 0x38136000, 0x38138000, 0x3813A000, 0x3813C000, 0x3813E000, 
+				0x38140000, 0x38142000, 0x38144000, 0x38146000, 0x38148000, 0x3814A000, 0x3814C000, 0x3814E000, 0x38150000, 0x38152000, 0x38154000, 0x38156000, 0x38158000, 0x3815A000, 0x3815C000, 0x3815E000, 
+				0x38160000, 0x38162000, 0x38164000, 0x38166000, 0x38168000, 0x3816A000, 0x3816C000, 0x3816E000, 0x38170000, 0x38172000, 0x38174000, 0x38176000, 0x38178000, 0x3817A000, 0x3817C000, 0x3817E000, 
+				0x38180000, 0x38182000, 0x38184000, 0x38186000, 0x38188000, 0x3818A000, 0x3818C000, 0x3818E000, 0x38190000, 0x38192000, 0x38194000, 0x38196000, 0x38198000, 0x3819A000, 0x3819C000, 0x3819E000, 
+				0x381A0000, 0x381A2000, 0x381A4000, 0x381A6000, 0x381A8000, 0x381AA000, 0x381AC000, 0x381AE000, 0x381B0000, 0x381B2000, 0x381B4000, 0x381B6000, 0x381B8000, 0x381BA000, 0x381BC000, 0x381BE000, 
+				0x381C0000, 0x381C2000, 0x381C4000, 0x381C6000, 0x381C8000, 0x381CA000, 0x381CC000, 0x381CE000, 0x381D0000, 0x381D2000, 0x381D4000, 0x381D6000, 0x381D8000, 0x381DA000, 0x381DC000, 0x381DE000, 
+				0x381E0000, 0x381E2000, 0x381E4000, 0x381E6000, 0x381E8000, 0x381EA000, 0x381EC000, 0x381EE000, 0x381F0000, 0x381F2000, 0x381F4000, 0x381F6000, 0x381F8000, 0x381FA000, 0x381FC000, 0x381FE000, 
+				0x38200000, 0x38202000, 0x38204000, 0x38206000, 0x38208000, 0x3820A000, 0x3820C000, 0x3820E000, 0x38210000, 0x38212000, 0x38214000, 0x38216000, 0x38218000, 0x3821A000, 0x3821C000, 0x3821E000, 
+				0x38220000, 0x38222000, 0x38224000, 0x38226000, 0x38228000, 0x3822A000, 0x3822C000, 0x3822E000, 0x38230000, 0x38232000, 0x38234000, 0x38236000, 0x38238000, 0x3823A000, 0x3823C000, 0x3823E000, 
+				0x38240000, 0x38242000, 0x38244000, 0x38246000, 0x38248000, 0x3824A000, 0x3824C000, 0x3824E000, 0x38250000, 0x38252000, 0x38254000, 0x38256000, 0x38258000, 0x3825A000, 0x3825C000, 0x3825E000, 
+				0x38260000, 0x38262000, 0x38264000, 0x38266000, 0x38268000, 0x3826A000, 0x3826C000, 0x3826E000, 0x38270000, 0x38272000, 0x38274000, 0x38276000, 0x38278000, 0x3827A000, 0x3827C000, 0x3827E000, 
+				0x38280000, 0x38282000, 0x38284000, 0x38286000, 0x38288000, 0x3828A000, 0x3828C000, 0x3828E000, 0x38290000, 0x38292000, 0x38294000, 0x38296000, 0x38298000, 0x3829A000, 0x3829C000, 0x3829E000, 
+				0x382A0000, 0x382A2000, 0x382A4000, 0x382A6000, 0x382A8000, 0x382AA000, 0x382AC000, 0x382AE000, 0x382B0000, 0x382B2000, 0x382B4000, 0x382B6000, 0x382B8000, 0x382BA000, 0x382BC000, 0x382BE000, 
+				0x382C0000, 0x382C2000, 0x382C4000, 0x382C6000, 0x382C8000, 0x382CA000, 0x382CC000, 0x382CE000, 0x382D0000, 0x382D2000, 0x382D4000, 0x382D6000, 0x382D8000, 0x382DA000, 0x382DC000, 0x382DE000, 
+				0x382E0000, 0x382E2000, 0x382E4000, 0x382E6000, 0x382E8000, 0x382EA000, 0x382EC000, 0x382EE000, 0x382F0000, 0x382F2000, 0x382F4000, 0x382F6000, 0x382F8000, 0x382FA000, 0x382FC000, 0x382FE000, 
+				0x38300000, 0x38302000, 0x38304000, 0x38306000, 0x38308000, 0x3830A000, 0x3830C000, 0x3830E000, 0x38310000, 0x38312000, 0x38314000, 0x38316000, 0x38318000, 0x3831A000, 0x3831C000, 0x3831E000, 
+				0x38320000, 0x38322000, 0x38324000, 0x38326000, 0x38328000, 0x3832A000, 0x3832C000, 0x3832E000, 0x38330000, 0x38332000, 0x38334000, 0x38336000, 0x38338000, 0x3833A000, 0x3833C000, 0x3833E000, 
+				0x38340000, 0x38342000, 0x38344000, 0x38346000, 0x38348000, 0x3834A000, 0x3834C000, 0x3834E000, 0x38350000, 0x38352000, 0x38354000, 0x38356000, 0x38358000, 0x3835A000, 0x3835C000, 0x3835E000, 
+				0x38360000, 0x38362000, 0x38364000, 0x38366000, 0x38368000, 0x3836A000, 0x3836C000, 0x3836E000, 0x38370000, 0x38372000, 0x38374000, 0x38376000, 0x38378000, 0x3837A000, 0x3837C000, 0x3837E000, 
+				0x38380000, 0x38382000, 0x38384000, 0x38386000, 0x38388000, 0x3838A000, 0x3838C000, 0x3838E000, 0x38390000, 0x38392000, 0x38394000, 0x38396000, 0x38398000, 0x3839A000, 0x3839C000, 0x3839E000, 
+				0x383A0000, 0x383A2000, 0x383A4000, 0x383A6000, 0x383A8000, 0x383AA000, 0x383AC000, 0x383AE000, 0x383B0000, 0x383B2000, 0x383B4000, 0x383B6000, 0x383B8000, 0x383BA000, 0x383BC000, 0x383BE000, 
+				0x383C0000, 0x383C2000, 0x383C4000, 0x383C6000, 0x383C8000, 0x383CA000, 0x383CC000, 0x383CE000, 0x383D0000, 0x383D2000, 0x383D4000, 0x383D6000, 0x383D8000, 0x383DA000, 0x383DC000, 0x383DE000, 
+				0x383E0000, 0x383E2000, 0x383E4000, 0x383E6000, 0x383E8000, 0x383EA000, 0x383EC000, 0x383EE000, 0x383F0000, 0x383F2000, 0x383F4000, 0x383F6000, 0x383F8000, 0x383FA000, 0x383FC000, 0x383FE000, 
+				0x38400000, 0x38402000, 0x38404000, 0x38406000, 0x38408000, 0x3840A000, 0x3840C000, 0x3840E000, 0x38410000, 0x38412000, 0x38414000, 0x38416000, 0x38418000, 0x3841A000, 0x3841C000, 0x3841E000, 
+				0x38420000, 0x38422000, 0x38424000, 0x38426000, 0x38428000, 0x3842A000, 0x3842C000, 0x3842E000, 0x38430000, 0x38432000, 0x38434000, 0x38436000, 0x38438000, 0x3843A000, 0x3843C000, 0x3843E000, 
+				0x38440000, 0x38442000, 0x38444000, 0x38446000, 0x38448000, 0x3844A000, 0x3844C000, 0x3844E000, 0x38450000, 0x38452000, 0x38454000, 0x38456000, 0x38458000, 0x3845A000, 0x3845C000, 0x3845E000, 
+				0x38460000, 0x38462000, 0x38464000, 0x38466000, 0x38468000, 0x3846A000, 0x3846C000, 0x3846E000, 0x38470000, 0x38472000, 0x38474000, 0x38476000, 0x38478000, 0x3847A000, 0x3847C000, 0x3847E000, 
+				0x38480000, 0x38482000, 0x38484000, 0x38486000, 0x38488000, 0x3848A000, 0x3848C000, 0x3848E000, 0x38490000, 0x38492000, 0x38494000, 0x38496000, 0x38498000, 0x3849A000, 0x3849C000, 0x3849E000, 
+				0x384A0000, 0x384A2000, 0x384A4000, 0x384A6000, 0x384A8000, 0x384AA000, 0x384AC000, 0x384AE000, 0x384B0000, 0x384B2000, 0x384B4000, 0x384B6000, 0x384B8000, 0x384BA000, 0x384BC000, 0x384BE000, 
+				0x384C0000, 0x384C2000, 0x384C4000, 0x384C6000, 0x384C8000, 0x384CA000, 0x384CC000, 0x384CE000, 0x384D0000, 0x384D2000, 0x384D4000, 0x384D6000, 0x384D8000, 0x384DA000, 0x384DC000, 0x384DE000, 
+				0x384E0000, 0x384E2000, 0x384E4000, 0x384E6000, 0x384E8000, 0x384EA000, 0x384EC000, 0x384EE000, 0x384F0000, 0x384F2000, 0x384F4000, 0x384F6000, 0x384F8000, 0x384FA000, 0x384FC000, 0x384FE000, 
+				0x38500000, 0x38502000, 0x38504000, 0x38506000, 0x38508000, 0x3850A000, 0x3850C000, 0x3850E000, 0x38510000, 0x38512000, 0x38514000, 0x38516000, 0x38518000, 0x3851A000, 0x3851C000, 0x3851E000, 
+				0x38520000, 0x38522000, 0x38524000, 0x38526000, 0x38528000, 0x3852A000, 0x3852C000, 0x3852E000, 0x38530000, 0x38532000, 0x38534000, 0x38536000, 0x38538000, 0x3853A000, 0x3853C000, 0x3853E000, 
+				0x38540000, 0x38542000, 0x38544000, 0x38546000, 0x38548000, 0x3854A000, 0x3854C000, 0x3854E000, 0x38550000, 0x38552000, 0x38554000, 0x38556000, 0x38558000, 0x3855A000, 0x3855C000, 0x3855E000, 
+				0x38560000, 0x38562000, 0x38564000, 0x38566000, 0x38568000, 0x3856A000, 0x3856C000, 0x3856E000, 0x38570000, 0x38572000, 0x38574000, 0x38576000, 0x38578000, 0x3857A000, 0x3857C000, 0x3857E000, 
+				0x38580000, 0x38582000, 0x38584000, 0x38586000, 0x38588000, 0x3858A000, 0x3858C000, 0x3858E000, 0x38590000, 0x38592000, 0x38594000, 0x38596000, 0x38598000, 0x3859A000, 0x3859C000, 0x3859E000, 
+				0x385A0000, 0x385A2000, 0x385A4000, 0x385A6000, 0x385A8000, 0x385AA000, 0x385AC000, 0x385AE000, 0x385B0000, 0x385B2000, 0x385B4000, 0x385B6000, 0x385B8000, 0x385BA000, 0x385BC000, 0x385BE000, 
+				0x385C0000, 0x385C2000, 0x385C4000, 0x385C6000, 0x385C8000, 0x385CA000, 0x385CC000, 0x385CE000, 0x385D0000, 0x385D2000, 0x385D4000, 0x385D6000, 0x385D8000, 0x385DA000, 0x385DC000, 0x385DE000, 
+				0x385E0000, 0x385E2000, 0x385E4000, 0x385E6000, 0x385E8000, 0x385EA000, 0x385EC000, 0x385EE000, 0x385F0000, 0x385F2000, 0x385F4000, 0x385F6000, 0x385F8000, 0x385FA000, 0x385FC000, 0x385FE000, 
+				0x38600000, 0x38602000, 0x38604000, 0x38606000, 0x38608000, 0x3860A000, 0x3860C000, 0x3860E000, 0x38610000, 0x38612000, 0x38614000, 0x38616000, 0x38618000, 0x3861A000, 0x3861C000, 0x3861E000, 
+				0x38620000, 0x38622000, 0x38624000, 0x38626000, 0x38628000, 0x3862A000, 0x3862C000, 0x3862E000, 0x38630000, 0x38632000, 0x38634000, 0x38636000, 0x38638000, 0x3863A000, 0x3863C000, 0x3863E000, 
+				0x38640000, 0x38642000, 0x38644000, 0x38646000, 0x38648000, 0x3864A000, 0x3864C000, 0x3864E000, 0x38650000, 0x38652000, 0x38654000, 0x38656000, 0x38658000, 0x3865A000, 0x3865C000, 0x3865E000, 
+				0x38660000, 0x38662000, 0x38664000, 0x38666000, 0x38668000, 0x3866A000, 0x3866C000, 0x3866E000, 0x38670000, 0x38672000, 0x38674000, 0x38676000, 0x38678000, 0x3867A000, 0x3867C000, 0x3867E000, 
+				0x38680000, 0x38682000, 0x38684000, 0x38686000, 0x38688000, 0x3868A000, 0x3868C000, 0x3868E000, 0x38690000, 0x38692000, 0x38694000, 0x38696000, 0x38698000, 0x3869A000, 0x3869C000, 0x3869E000, 
+				0x386A0000, 0x386A2000, 0x386A4000, 0x386A6000, 0x386A8000, 0x386AA000, 0x386AC000, 0x386AE000, 0x386B0000, 0x386B2000, 0x386B4000, 0x386B6000, 0x386B8000, 0x386BA000, 0x386BC000, 0x386BE000, 
+				0x386C0000, 0x386C2000, 0x386C4000, 0x386C6000, 0x386C8000, 0x386CA000, 0x386CC000, 0x386CE000, 0x386D0000, 0x386D2000, 0x386D4000, 0x386D6000, 0x386D8000, 0x386DA000, 0x386DC000, 0x386DE000, 
+				0x386E0000, 0x386E2000, 0x386E4000, 0x386E6000, 0x386E8000, 0x386EA000, 0x386EC000, 0x386EE000, 0x386F0000, 0x386F2000, 0x386F4000, 0x386F6000, 0x386F8000, 0x386FA000, 0x386FC000, 0x386FE000, 
+				0x38700000, 0x38702000, 0x38704000, 0x38706000, 0x38708000, 0x3870A000, 0x3870C000, 0x3870E000, 0x38710000, 0x38712000, 0x38714000, 0x38716000, 0x38718000, 0x3871A000, 0x3871C000, 0x3871E000, 
+				0x38720000, 0x38722000, 0x38724000, 0x38726000, 0x38728000, 0x3872A000, 0x3872C000, 0x3872E000, 0x38730000, 0x38732000, 0x38734000, 0x38736000, 0x38738000, 0x3873A000, 0x3873C000, 0x3873E000, 
+				0x38740000, 0x38742000, 0x38744000, 0x38746000, 0x38748000, 0x3874A000, 0x3874C000, 0x3874E000, 0x38750000, 0x38752000, 0x38754000, 0x38756000, 0x38758000, 0x3875A000, 0x3875C000, 0x3875E000, 
+				0x38760000, 0x38762000, 0x38764000, 0x38766000, 0x38768000, 0x3876A000, 0x3876C000, 0x3876E000, 0x38770000, 0x38772000, 0x38774000, 0x38776000, 0x38778000, 0x3877A000, 0x3877C000, 0x3877E000, 
+				0x38780000, 0x38782000, 0x38784000, 0x38786000, 0x38788000, 0x3878A000, 0x3878C000, 0x3878E000, 0x38790000, 0x38792000, 0x38794000, 0x38796000, 0x38798000, 0x3879A000, 0x3879C000, 0x3879E000, 
+				0x387A0000, 0x387A2000, 0x387A4000, 0x387A6000, 0x387A8000, 0x387AA000, 0x387AC000, 0x387AE000, 0x387B0000, 0x387B2000, 0x387B4000, 0x387B6000, 0x387B8000, 0x387BA000, 0x387BC000, 0x387BE000, 
+				0x387C0000, 0x387C2000, 0x387C4000, 0x387C6000, 0x387C8000, 0x387CA000, 0x387CC000, 0x387CE000, 0x387D0000, 0x387D2000, 0x387D4000, 0x387D6000, 0x387D8000, 0x387DA000, 0x387DC000, 0x387DE000, 
+				0x387E0000, 0x387E2000, 0x387E4000, 0x387E6000, 0x387E8000, 0x387EA000, 0x387EC000, 0x387EE000, 0x387F0000, 0x387F2000, 0x387F4000, 0x387F6000, 0x387F8000, 0x387FA000, 0x387FC000, 0x387FE000 };
+			static const bits<float>::type exponent_table[64] = {
+				0x00000000, 0x00800000, 0x01000000, 0x01800000, 0x02000000, 0x02800000, 0x03000000, 0x03800000, 0x04000000, 0x04800000, 0x05000000, 0x05800000, 0x06000000, 0x06800000, 0x07000000, 0x07800000, 
+				0x08000000, 0x08800000, 0x09000000, 0x09800000, 0x0A000000, 0x0A800000, 0x0B000000, 0x0B800000, 0x0C000000, 0x0C800000, 0x0D000000, 0x0D800000, 0x0E000000, 0x0E800000, 0x0F000000, 0x47800000, 
+				0x80000000, 0x80800000, 0x81000000, 0x81800000, 0x82000000, 0x82800000, 0x83000000, 0x83800000, 0x84000000, 0x84800000, 0x85000000, 0x85800000, 0x86000000, 0x86800000, 0x87000000, 0x87800000, 
+				0x88000000, 0x88800000, 0x89000000, 0x89800000, 0x8A000000, 0x8A800000, 0x8B000000, 0x8B800000, 0x8C000000, 0x8C800000, 0x8D000000, 0x8D800000, 0x8E000000, 0x8E800000, 0x8F000000, 0xC7800000 };
+			static const unsigned short offset_table[64] = {
+				0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 
+				0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024 };
+			bits<float>::type fbits = mantissa_table[offset_table[value>>10]+(value&0x3FF)] + exponent_table[value>>10];
+		#endif
+			float out;
+			std::memcpy(&out, &fbits, sizeof(float));
+			return out;
+		#endif
+		}
+
+		/// Convert half-precision to IEEE double-precision.
+		/// \param value half-precision value to convert
+		/// \return double-precision value
+		inline double half2float_impl(unsigned int value, double, true_type)
+		{
+		#if HALF_ENABLE_F16C_INTRINSICS
+			return _mm_cvtsd_f64(_mm_cvtps_pd(_mm_cvtph_ps(_mm_cvtsi32_si128(value))));
+		#else
+			uint32 hi = static_cast<uint32>(value&0x8000) << 16;
+			unsigned int abs = value & 0x7FFF;
+			if(abs)
+			{
+				hi |= 0x3F000000 << static_cast<unsigned>(abs>=0x7C00);
+				for(; abs<0x400; abs<<=1,hi-=0x100000) ;
+				hi += static_cast<uint32>(abs) << 10;
+			}
+			bits<double>::type dbits = static_cast<bits<double>::type>(hi) << 32;
+			double out;
+			std::memcpy(&out, &dbits, sizeof(double));
+			return out;
+		#endif
+		}
+
+		/// Convert half-precision to non-IEEE floating-point.
+		/// \tparam T type to convert to (builtin integer type)
+		/// \param value half-precision value to convert
+		/// \return floating-point value
+		template<typename T> T half2float_impl(unsigned int value, T, ...)
+		{
+			T out;
+			unsigned int abs = value & 0x7FFF;
+			if(abs > 0x7C00)
+				out = (std::numeric_limits<T>::has_signaling_NaN && !(abs&0x200)) ? std::numeric_limits<T>::signaling_NaN() :
+					std::numeric_limits<T>::has_quiet_NaN ? std::numeric_limits<T>::quiet_NaN() : T();
+			else if(abs == 0x7C00)
+				out = std::numeric_limits<T>::has_infinity ? std::numeric_limits<T>::infinity() : std::numeric_limits<T>::max();
+			else if(abs > 0x3FF)
+				out = std::ldexp(static_cast<T>((abs&0x3FF)|0x400), (abs>>10)-25);
+			else
+				out = std::ldexp(static_cast<T>(abs), -24);
+			return (value&0x8000) ? -out : out;
+		}
+
+		/// Convert half-precision to floating-point.
+		/// \tparam T type to convert to (builtin integer type)
+		/// \param value half-precision value to convert
+		/// \return floating-point value
+		template<typename T> T half2float(unsigned int value)
+		{
+			return half2float_impl(value, T(), bool_type<std::numeric_limits<T>::is_iec559&&sizeof(typename bits<T>::type)==sizeof(T)>());
+		}
+
+		/// Convert half-precision floating-point to integer.
+		/// \tparam R rounding mode to use
+		/// \tparam E `true` for round to even, `false` for round away from zero
+		/// \tparam I `true` to raise INEXACT exception (if inexact), `false` to never raise it
+		/// \tparam T type to convert to (buitlin integer type with at least 16 bits precision, excluding any implicit sign bits)
+		/// \param value half-precision value to convert
+		/// \return rounded integer value
+		/// \exception FE_INVALID if value is not representable in type \a T
+		/// \exception FE_INEXACT if value had to be rounded and \a I is `true`
+		template<std::float_round_style R,bool E,bool I,typename T> T half2int(unsigned int value)
+		{
+			unsigned int abs = value & 0x7FFF;
+			if(abs >= 0x7C00)
+			{
+				raise(FE_INVALID);
+				return (value&0x8000) ? std::numeric_limits<T>::min() : std::numeric_limits<T>::max();
+			}
+			if(abs < 0x3800)
+			{
+				raise(FE_INEXACT, I);
+				return	(R==std::round_toward_infinity) ? T(~(value>>15)&(abs!=0)) :
+						(R==std::round_toward_neg_infinity) ? -T(value>0x8000) :
+						T();
+			}
+			int exp = 25 - (abs>>10);
+			unsigned int m = (value&0x3FF) | 0x400;
+			int32 i = static_cast<int32>((exp<=0) ? (m<<-exp) : ((m+(
+				(R==std::round_to_nearest) ? ((1<<(exp-1))-(~(m>>exp)&E)) :
+				(R==std::round_toward_infinity) ? (((1<<exp)-1)&((value>>15)-1)) :
+				(R==std::round_toward_neg_infinity) ? (((1<<exp)-1)&-(value>>15)) : 0))>>exp));
+			if((!std::numeric_limits<T>::is_signed && (value&0x8000)) || (std::numeric_limits<T>::digits<16 &&
+				((value&0x8000) ? (-i<std::numeric_limits<T>::min()) : (i>std::numeric_limits<T>::max()))))
+				raise(FE_INVALID);
+			else if(I && exp > 0 && (m&((1<<exp)-1)))
+				raise(FE_INEXACT);
+			return static_cast<T>((value&0x8000) ? -i : i);
+		}
+
+		/// \}
+		/// \name Mathematics
+		/// \{
+
+		/// upper part of 64-bit multiplication.
+		/// \tparam R rounding mode to use
+		/// \param x first factor
+		/// \param y second factor
+		/// \return upper 32 bit of \a x * \a y
+		template<std::float_round_style R> uint32 mulhi(uint32 x, uint32 y)
+		{
+			uint32 xy = (x>>16) * (y&0xFFFF), yx = (x&0xFFFF) * (y>>16), c = (xy&0xFFFF) + (yx&0xFFFF) + (((x&0xFFFF)*(y&0xFFFF))>>16);
+			return (x>>16)*(y>>16) + (xy>>16) + (yx>>16) + (c>>16) +
+				((R==std::round_to_nearest) ? ((c>>15)&1) : (R==std::round_toward_infinity) ? ((c&0xFFFF)!=0) : 0);
+		}
+
+		/// 64-bit multiplication.
+		/// \param x first factor
+		/// \param y second factor
+		/// \return upper 32 bit of \a x * \a y rounded to nearest
+		inline uint32 multiply64(uint32 x, uint32 y)
+		{
+		#if HALF_ENABLE_CPP11_LONG_LONG
+			return static_cast<uint32>((static_cast<unsigned long long>(x)*static_cast<unsigned long long>(y)+0x80000000)>>32);
+		#else
+			return mulhi<std::round_to_nearest>(x, y);
+		#endif
+		}
+
+		/// 64-bit division.
+		/// \param x upper 32 bit of dividend
+		/// \param y divisor
+		/// \param s variable to store sticky bit for rounding
+		/// \return (\a x << 32) / \a y
+		inline uint32 divide64(uint32 x, uint32 y, int &s)
+		{
+		#if HALF_ENABLE_CPP11_LONG_LONG
+			unsigned long long xx = static_cast<unsigned long long>(x) << 32;
+			return s = (xx%y!=0), static_cast<uint32>(xx/y);
+		#else
+			y >>= 1;
+			uint32 rem = x, div = 0;
+			for(unsigned int i=0; i<32; ++i)
+			{
+				div <<= 1;
+				if(rem >= y)
+				{
+					rem -= y;
+					div |= 1;
+				}
+				rem <<= 1;
+			}
+			return s = rem > 1, div;
+		#endif
+		}
+
+		/// Half precision positive modulus.
+		/// \tparam Q `true` to compute full quotient, `false` else
+		/// \tparam R `true` to compute signed remainder, `false` for positive remainder
+		/// \param x first operand as positive finite half-precision value
+		/// \param y second operand as positive finite half-precision value
+		/// \param quo adress to store quotient at, `nullptr` if \a Q `false`
+		/// \return modulus of \a x / \a y
+		template<bool Q,bool R> unsigned int mod(unsigned int x, unsigned int y, int *quo = NULL)
+		{
+			unsigned int q = 0;
+			if(x > y)
+			{
+				int absx = x, absy = y, expx = 0, expy = 0;
+				for(; absx<0x400; absx<<=1,--expx) ;
+				for(; absy<0x400; absy<<=1,--expy) ;
+				expx += absx >> 10;
+				expy += absy >> 10;
+				int mx = (absx&0x3FF) | 0x400, my = (absy&0x3FF) | 0x400;
+				for(int d=expx-expy; d; --d)
+				{
+					if(!Q && mx == my)
+						return 0;
+					if(mx >= my)
+					{
+						mx -= my;
+						q += Q;
+					}
+					mx <<= 1;
+					q <<= static_cast<int>(Q);
+				}
+				if(!Q && mx == my)
+					return 0;
+				if(mx >= my)
+				{
+					mx -= my;
+					++q;
+				}
+				if(Q)
+				{
+					q &= (1<<(std::numeric_limits<int>::digits-1)) - 1;
+					if(!mx)
+						return *quo = q, 0;
+				}
+				for(; mx<0x400; mx<<=1,--expy) ;
+				x = (expy>0) ? ((expy<<10)|(mx&0x3FF)) : (mx>>(1-expy));
+			}
+			if(R)
+			{
+				unsigned int a, b;
+				if(y < 0x800)
+				{
+					a = (x<0x400) ? (x<<1) : (x+0x400);
+					b = y;
+				}
+				else
+				{
+					a = x;
+					b = y - 0x400;
+				}
+				if(a > b || (a == b && (q&1)))
+				{
+					int exp = (y>>10) + (y<=0x3FF), d = exp - (x>>10) - (x<=0x3FF);
+					int m = (((y&0x3FF)|((y>0x3FF)<<10))<<1) - (((x&0x3FF)|((x>0x3FF)<<10))<<(1-d));
+					for(; m<0x800 && exp>1; m<<=1,--exp) ;
+					x = 0x8000 + ((exp-1)<<10) + (m>>1);
+					q += Q;
+				}
+			}
+			if(Q)
+				*quo = q;
+			return x;
+		}
+
+		/// Fixed point square root.
+		/// \tparam F number of fractional bits
+		/// \param r radicand in Q1.F fixed point format
+		/// \param exp exponent
+		/// \return square root as Q1.F/2
+		template<unsigned int F> uint32 sqrt(uint32 &r, int &exp)
+		{
+			int i = exp & 1;
+			r <<= i;
+			exp = (exp-i) / 2;
+			uint32 m = 0;
+			for(uint32 bit=static_cast<uint32>(1)<<F; bit; bit>>=2)
+			{
+				if(r < m+bit)
+					m >>= 1;
+				else
+				{
+					r -= m + bit;
+					m = (m>>1) + bit;
+				}
+			}
+			return m;
+		}
+
+		/// Fixed point binary exponential.
+		/// This uses the BKM algorithm in E-mode.
+		/// \param m exponent in [0,1) as Q0.31
+		/// \param n number of iterations (at most 32)
+		/// \return 2 ^ \a m as Q1.31
+		inline uint32 exp2(uint32 m, unsigned int n = 32)
+		{
+			static const uint32 logs[] = {
+				0x80000000, 0x4AE00D1D, 0x2934F098, 0x15C01A3A, 0x0B31FB7D, 0x05AEB4DD, 0x02DCF2D1, 0x016FE50B,
+				0x00B84E23, 0x005C3E10, 0x002E24CA, 0x001713D6, 0x000B8A47, 0x0005C53B, 0x0002E2A3, 0x00017153,
+				0x0000B8AA, 0x00005C55, 0x00002E2B, 0x00001715, 0x00000B8B, 0x000005C5, 0x000002E3, 0x00000171,
+				0x000000B9, 0x0000005C, 0x0000002E, 0x00000017, 0x0000000C, 0x00000006, 0x00000003, 0x00000001 };
+			if(!m)
+				return 0x80000000;
+			uint32 mx = 0x80000000, my = 0;
+			for(unsigned int i=1; i<n; ++i)
+			{
+				uint32 mz = my + logs[i];
+				if(mz <= m)
+				{
+					my = mz;
+					mx += mx >> i;
+				}
+			}
+			return mx;
+		}
+
+		/// Fixed point binary logarithm.
+		/// This uses the BKM algorithm in L-mode.
+		/// \param m mantissa in [1,2) as Q1.30
+		/// \param n number of iterations (at most 32)
+		/// \return log2(\a m) as Q0.31
+		inline uint32 log2(uint32 m, unsigned int n = 32)
+		{
+			static const uint32 logs[] = {
+				0x80000000, 0x4AE00D1D, 0x2934F098, 0x15C01A3A, 0x0B31FB7D, 0x05AEB4DD, 0x02DCF2D1, 0x016FE50B,
+				0x00B84E23, 0x005C3E10, 0x002E24CA, 0x001713D6, 0x000B8A47, 0x0005C53B, 0x0002E2A3, 0x00017153,
+				0x0000B8AA, 0x00005C55, 0x00002E2B, 0x00001715, 0x00000B8B, 0x000005C5, 0x000002E3, 0x00000171,
+				0x000000B9, 0x0000005C, 0x0000002E, 0x00000017, 0x0000000C, 0x00000006, 0x00000003, 0x00000001 };
+			if(m == 0x40000000)
+				return 0;
+			uint32 mx = 0x40000000, my = 0;
+			for(unsigned int i=1; i<n; ++i)
+			{
+				uint32 mz = mx + (mx>>i);
+				if(mz <= m)
+				{
+					mx = mz;
+					my += logs[i];
+				}
+			}
+			return my;
+		}
+
+		/// Fixed point sine and cosine.
+		/// This uses the CORDIC algorithm in rotation mode.
+		/// \param mz angle in [-pi/2,pi/2] as Q1.30
+		/// \param n number of iterations (at most 31)
+		/// \return sine and cosine of \a mz as Q1.30
+		inline std::pair<uint32,uint32> sincos(uint32 mz, unsigned int n = 31)
+		{
+			static const uint32 angles[] = {
+				0x3243F6A9, 0x1DAC6705, 0x0FADBAFD, 0x07F56EA7, 0x03FEAB77, 0x01FFD55C, 0x00FFFAAB, 0x007FFF55,
+				0x003FFFEB, 0x001FFFFD, 0x00100000, 0x00080000, 0x00040000, 0x00020000, 0x00010000, 0x00008000,
+				0x00004000, 0x00002000, 0x00001000, 0x00000800, 0x00000400, 0x00000200, 0x00000100, 0x00000080,
+				0x00000040, 0x00000020, 0x00000010, 0x00000008, 0x00000004, 0x00000002, 0x00000001 };
+			uint32 mx = 0x26DD3B6A, my = 0;
+			for(unsigned int i=0; i<n; ++i)
+			{
+				uint32 sign = sign_mask(mz);
+				uint32 tx = mx - (arithmetic_shift(my, i)^sign) + sign;
+				uint32 ty = my + (arithmetic_shift(mx, i)^sign) - sign;
+				mx = tx; my = ty; mz -= (angles[i]^sign) - sign;
+			}
+			return std::make_pair(my, mx);
+		}
+
+		/// Fixed point arc tangent.
+		/// This uses the CORDIC algorithm in vectoring mode.
+		/// \param my y coordinate as Q0.30
+		/// \param mx x coordinate as Q0.30
+		/// \param n number of iterations (at most 31)
+		/// \return arc tangent of \a my / \a mx as Q1.30
+		inline uint32 atan2(uint32 my, uint32 mx, unsigned int n = 31)
+		{
+			static const uint32 angles[] = {
+				0x3243F6A9, 0x1DAC6705, 0x0FADBAFD, 0x07F56EA7, 0x03FEAB77, 0x01FFD55C, 0x00FFFAAB, 0x007FFF55,
+				0x003FFFEB, 0x001FFFFD, 0x00100000, 0x00080000, 0x00040000, 0x00020000, 0x00010000, 0x00008000,
+				0x00004000, 0x00002000, 0x00001000, 0x00000800, 0x00000400, 0x00000200, 0x00000100, 0x00000080,
+				0x00000040, 0x00000020, 0x00000010, 0x00000008, 0x00000004, 0x00000002, 0x00000001 };
+			uint32 mz = 0;
+			for(unsigned int i=0; i<n; ++i)
+			{
+				uint32 sign = sign_mask(my);
+				uint32 tx = mx + (arithmetic_shift(my, i)^sign) - sign;
+				uint32 ty = my - (arithmetic_shift(mx, i)^sign) + sign;
+				mx = tx; my = ty; mz += (angles[i]^sign) - sign;
+			}
+			return mz;
+		}
+
+		/// Reduce argument for trigonometric functions.
+		/// \param abs half-precision floating-point value
+		/// \param k value to take quarter period
+		/// \return \a abs reduced to [-pi/4,pi/4] as Q0.30
+		inline uint32 angle_arg(unsigned int abs, int &k)
+		{
+			uint32 m = (abs&0x3FF) | ((abs>0x3FF)<<10);
+			int exp = (abs>>10) + (abs<=0x3FF) - 15;
+			if(abs < 0x3A48)
+				return k = 0, m << (exp+20);
+		#if HALF_ENABLE_CPP11_LONG_LONG
+			unsigned long long y = m * 0xA2F9836E4E442, mask = (1ULL<<(62-exp)) - 1, yi = (y+(mask>>1)) & ~mask, f = y - yi;
+			uint32 sign = -static_cast<uint32>(f>>63);
+			k = static_cast<int>(yi>>(62-exp));
+			return (multiply64(static_cast<uint32>((sign ? -f : f)>>(31-exp)), 0xC90FDAA2)^sign) - sign;
+		#else
+			uint32 yh = m*0xA2F98 + mulhi<std::round_toward_zero>(m, 0x36E4E442), yl = (m*0x36E4E442) & 0xFFFFFFFF;
+			uint32 mask = (static_cast<uint32>(1)<<(30-exp)) - 1, yi = (yh+(mask>>1)) & ~mask, sign = -static_cast<uint32>(yi>yh);
+			k = static_cast<int>(yi>>(30-exp));
+			uint32 fh = (yh^sign) + (yi^~sign) - ~sign, fl = (yl^sign) - sign;
+			return (multiply64((exp>-1) ? (((fh<<(1+exp))&0xFFFFFFFF)|((fl&0xFFFFFFFF)>>(31-exp))) : fh, 0xC90FDAA2)^sign) - sign;
+		#endif
+		}
+
+		/// Get arguments for atan2 function.
+		/// \param abs half-precision floating-point value
+		/// \return \a abs and sqrt(1 - \a abs^2) as Q0.30
+		inline std::pair<uint32,uint32> atan2_args(unsigned int abs)
+		{
+			int exp = -15;
+			for(; abs<0x400; abs<<=1,--exp) ;
+			exp += abs >> 10;
+			uint32 my = ((abs&0x3FF)|0x400) << 5, r = my * my;
+			int rexp = 2 * exp;
+			r = 0x40000000 - ((rexp>-31) ? ((r>>-rexp)|((r&((static_cast<uint32>(1)<<-rexp)-1))!=0)) : 1);
+			for(rexp=0; r<0x40000000; r<<=1,--rexp) ;
+			uint32 mx = sqrt<30>(r, rexp);
+			int d = exp - rexp;
+			if(d < 0)
+				return std::make_pair((d<-14) ? ((my>>(-d-14))+((my>>(-d-15))&1)) : (my<<(14+d)), (mx<<14)+(r<<13)/mx);
+			if(d > 0)
+				return std::make_pair(my<<14, (d>14) ? ((mx>>(d-14))+((mx>>(d-15))&1)) : ((d==14) ? mx : ((mx<<(14-d))+(r<<(13-d))/mx)));
+			return std::make_pair(my<<13, (mx<<13)+(r<<12)/mx);
+		}
+
+		/// Get exponentials for hyperbolic computation
+		/// \param abs half-precision floating-point value
+		/// \param exp variable to take unbiased exponent of larger result
+		/// \param n number of BKM iterations (at most 32)
+		/// \return exp(abs) and exp(-\a abs) as Q1.31 with same exponent
+		inline std::pair<uint32,uint32> hyperbolic_args(unsigned int abs, int &exp, unsigned int n = 32)
+		{
+			uint32 mx = detail::multiply64(static_cast<uint32>((abs&0x3FF)+((abs>0x3FF)<<10))<<21, 0xB8AA3B29), my;
+			int e = (abs>>10) + (abs<=0x3FF);
+			if(e < 14)
+			{
+				exp = 0;
+				mx >>= 14 - e;
+			}
+			else
+			{
+				exp = mx >> (45-e);
+				mx = (mx<<(e-14)) & 0x7FFFFFFF;
+			}
+			mx = exp2(mx, n);
+			int d = exp << 1, s;
+			if(mx > 0x80000000)
+			{
+				my = divide64(0x80000000, mx, s);
+				my |= s;
+				++d;
+			}
+			else
+				my = mx;
+			return std::make_pair(mx, (d<31) ? ((my>>d)|((my&((static_cast<uint32>(1)<<d)-1))!=0)) : 1);
+		}
+
+		/// Postprocessing for binary exponential.
+		/// \tparam R rounding mode to use
+		/// \tparam I `true` to always raise INEXACT exception, `false` to raise only for rounded results
+		/// \param m mantissa as Q1.31
+		/// \param exp absolute value of unbiased exponent
+		/// \param esign sign of actual exponent
+		/// \param sign sign bit of result
+		/// \return value converted to half-precision
+		/// \exception FE_OVERFLOW on overflows
+		/// \exception FE_UNDERFLOW on underflows
+		/// \exception FE_INEXACT if value had to be rounded or \a I is `true`
+		template<std::float_round_style R,bool I> unsigned int exp2_post(uint32 m, int exp, bool esign, unsigned int sign = 0)
+		{
+			int s = 0;
+			if(esign)
+			{
+				if(m > 0x80000000)
+				{
+					m = divide64(0x80000000, m, s);
+					++exp;
+				}
+				if(exp > 25)
+					return underflow<R>(sign);
+				else if(exp == 25)
+					return rounded<R,I>(sign, 1, (m&0x7FFFFFFF)!=0);
+				exp = -exp;
+			}
+			else if(exp > 15)
+				return overflow<R>(sign);
+			return fixed2half<R,31,false,false,I>(m, exp+14, sign, s);
+		}
+
+		/// Postprocessing for binary logarithm.
+		/// \tparam R rounding mode to use
+		/// \tparam L logarithm for base transformation as Q1.31
+		/// \param m fractional part of logarithm as Q0.31
+		/// \param ilog signed integer part of logarithm
+		/// \param exp biased exponent of result
+		/// \param sign sign bit of result
+		/// \return value base-transformed and converted to half-precision
+		/// \exception FE_OVERFLOW on overflows
+		/// \exception FE_UNDERFLOW on underflows
+		/// \exception FE_INEXACT if no other exception occurred
+		template<std::float_round_style R,uint32 L> unsigned int log2_post(uint32 m, int ilog, int exp, unsigned int sign = 0)
+		{
+			uint32 msign = sign_mask(ilog);
+			m = (((static_cast<uint32>(ilog)<<27)+(m>>4))^msign) - msign;
+			if(!m)
+				return 0;
+			for(; m<0x80000000; m<<=1,--exp) ;
+			int i = m >= L, s;
+			exp += i;
+			m >>= 1 + i;
+			sign ^= msign & 0x8000;
+			if(exp < -11)
+				return underflow<R>(sign);
+			m = divide64(m, L, s);
+			return fixed2half<R,30,false,false,true>(m, exp, sign, 1);
+		}
+
+		/// Hypotenuse square root and postprocessing.
+		/// \tparam R rounding mode to use
+		/// \param r mantissa as Q2.30
+		/// \param exp unbiased exponent
+		/// \return square root converted to half-precision
+		/// \exception FE_OVERFLOW on overflows
+		/// \exception FE_UNDERFLOW on underflows
+		/// \exception FE_INEXACT if value had to be rounded
+		template<std::float_round_style R> unsigned int hypot_post(uint32 r, int exp)
+		{
+			int i = r >> 31;
+			if((exp+=i) > 46)
+				return overflow<R>();
+			if(exp < -34)
+				return underflow<R>();
+			r = (r>>i) | (r&i);
+			uint32 m = sqrt<30>(r, exp+=15);
+			return fixed2half<R,15,false,false,false>(m, exp-1, 0, r!=0);
+		}
+
+		/// Division and postprocessing for tangents.
+		/// \tparam R rounding mode to use
+		/// \param my dividend as Q1.31
+		/// \param mx divisor as Q1.31
+		/// \param exp biased exponent of result
+		/// \param sign sign bit of result
+		/// \return quotient converted to half-precision
+		/// \exception FE_OVERFLOW on overflows
+		/// \exception FE_UNDERFLOW on underflows
+		/// \exception FE_INEXACT if no other exception occurred
+		template<std::float_round_style R> unsigned int tangent_post(uint32 my, uint32 mx, int exp, unsigned int sign = 0)
+		{
+			int i = my >= mx, s;
+			exp += i;
+			if(exp > 29)
+				return overflow<R>(sign);
+			if(exp < -11)
+				return underflow<R>(sign);
+			uint32 m = divide64(my>>(i+1), mx, s);
+			return fixed2half<R,30,false,false,true>(m, exp, sign, s);
+		}
+
+		/// Area function and postprocessing.
+		/// This computes the value directly in Q2.30 using the representation `asinh|acosh(x) = log(x+sqrt(x^2+|-1))`.
+		/// \tparam R rounding mode to use
+		/// \tparam S `true` for asinh, `false` for acosh
+		/// \param arg half-precision argument
+		/// \return asinh|acosh(\a arg) converted to half-precision
+		/// \exception FE_OVERFLOW on overflows
+		/// \exception FE_UNDERFLOW on underflows
+		/// \exception FE_INEXACT if no other exception occurred
+		template<std::float_round_style R,bool S> unsigned int area(unsigned int arg)
+		{
+			int abs = arg & 0x7FFF, expx = (abs>>10) + (abs<=0x3FF) - 15, expy = -15, ilog, i;
+			uint32 mx = static_cast<uint32>((abs&0x3FF)|((abs>0x3FF)<<10)) << 20, my, r;
+			for(; abs<0x400; abs<<=1,--expy) ;
+			expy += abs >> 10;
+			r = ((abs&0x3FF)|0x400) << 5;
+			r *= r;
+			i = r >> 31;
+			expy = 2*expy + i;
+			r >>= i;
+			if(S)
+			{
+				if(expy < 0)
+				{
+					r = 0x40000000 + ((expy>-30) ? ((r>>-expy)|((r&((static_cast<uint32>(1)<<-expy)-1))!=0)) : 1);
+					expy = 0;
+				}
+				else
+				{
+					r += 0x40000000 >> expy;
+					i = r >> 31;
+					r = (r>>i) | (r&i);
+					expy += i;
+				}
+			}
+			else
+			{
+				r -= 0x40000000 >> expy;
+				for(; r<0x40000000; r<<=1,--expy) ;
+			}
+			my = sqrt<30>(r, expy);
+			my = (my<<15) + (r<<14)/my;
+			if(S)
+			{
+				mx >>= expy - expx;
+				ilog = expy;
+			}
+			else
+			{
+				my >>= expx - expy;
+				ilog = expx;
+			}
+			my += mx;
+			i = my >> 31;
+			static const int G = S && (R==std::round_to_nearest);
+			return log2_post<R,0xB8AA3B2A>(log2(my>>i, 26+S+G)+(G<<3), ilog+i, 17, arg&(static_cast<unsigned>(S)<<15));
+		}
+
+		/// Class for 1.31 unsigned floating-point computation
+		struct f31
+		{
+			/// Constructor.
+			/// \param mant mantissa as 1.31
+			/// \param e exponent
+			HALF_CONSTEXPR f31(uint32 mant, int e) : m(mant), exp(e) {}
+
+			/// Constructor.
+			/// \param abs unsigned half-precision value
+			f31(unsigned int abs) : exp(-15)
+			{
+				for(; abs<0x400; abs<<=1,--exp) ;
+				m = static_cast<uint32>((abs&0x3FF)|0x400) << 21;
+				exp += (abs>>10);
+			}
+
+			/// Addition operator.
+			/// \param a first operand
+			/// \param b second operand
+			/// \return \a a + \a b
+			friend f31 operator+(f31 a, f31 b)
+			{
+				if(b.exp > a.exp)
+					std::swap(a, b);
+				int d = a.exp - b.exp;
+				uint32 m = a.m + ((d<32) ? (b.m>>d) : 0);
+				int i = (m&0xFFFFFFFF) < a.m;
+				return f31(((m+i)>>i)|0x80000000, a.exp+i);
+			}
+
+			/// Subtraction operator.
+			/// \param a first operand
+			/// \param b second operand
+			/// \return \a a - \a b
+			friend f31 operator-(f31 a, f31 b)
+			{
+				int d = a.exp - b.exp, exp = a.exp;
+				uint32 m = a.m - ((d<32) ? (b.m>>d) : 0);
+				if(!m)
+					return f31(0, -32);
+				for(; m<0x80000000; m<<=1,--exp) ;
+				return f31(m, exp);
+			}
+
+			/// Multiplication operator.
+			/// \param a first operand
+			/// \param b second operand
+			/// \return \a a * \a b
+			friend f31 operator*(f31 a, f31 b)
+			{
+				uint32 m = multiply64(a.m, b.m);
+				int i = m >> 31;
+				return f31(m<<(1-i), a.exp + b.exp + i);
+			}
+
+			/// Division operator.
+			/// \param a first operand
+			/// \param b second operand
+			/// \return \a a / \a b
+			friend f31 operator/(f31 a, f31 b)
+			{
+				int i = a.m >= b.m, s;
+				uint32 m = divide64((a.m+i)>>i, b.m, s);
+				return f31(m, a.exp - b.exp + i - 1);
+			}
+
+			uint32 m;			///< mantissa as 1.31.
+			int exp;			///< exponent.
+		};
+
+		/// Error function and postprocessing.
+		/// This computes the value directly in Q1.31 using the approximations given 
+		/// [here](https://en.wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions).
+		/// \tparam R rounding mode to use
+		/// \tparam C `true` for comlementary error function, `false` else
+		/// \param arg half-precision function argument
+		/// \return approximated value of error function in half-precision
+		/// \exception FE_OVERFLOW on overflows
+		/// \exception FE_UNDERFLOW on underflows
+		/// \exception FE_INEXACT if no other exception occurred
+		template<std::float_round_style R,bool C> unsigned int erf(unsigned int arg)
+		{
+			unsigned int abs = arg & 0x7FFF, sign = arg & 0x8000;
+			f31 x(abs), x2 = x * x * f31(0xB8AA3B29, 0), t = f31(0x80000000, 0) / (f31(0x80000000, 0)+f31(0xA7BA054A, -2)*x), t2 = t * t;
+			f31 e = ((f31(0x87DC2213, 0)*t2+f31(0xB5F0E2AE, 0))*t2+f31(0x82790637, -2)-(f31(0xBA00E2B8, 0)*t2+f31(0x91A98E62, -2))*t) * t /
+					((x2.exp<0) ? f31(exp2((x2.exp>-32) ? (x2.m>>-x2.exp) : 0, 30), 0) : f31(exp2((x2.m<<x2.exp)&0x7FFFFFFF, 22), x2.m>>(31-x2.exp)));
+			return (!C || sign) ? fixed2half<R,31,false,true,true>(0x80000000-(e.m>>(C-e.exp)), 14+C, sign&(C-1U)) :
+					(e.exp<-25) ? underflow<R>() : fixed2half<R,30,false,false,true>(e.m>>1, e.exp+14, 0, e.m&1);
+		}
+
+		/// Gamma function and postprocessing.
+		/// This approximates the value of either the gamma function or its logarithm directly in Q1.31.
+		/// \tparam R rounding mode to use
+		/// \tparam L `true` for lograithm of gamma function, `false` for gamma function
+		/// \param arg half-precision floating-point value
+		/// \return lgamma/tgamma(\a arg) in half-precision
+		/// \exception FE_OVERFLOW on overflows
+		/// \exception FE_UNDERFLOW on underflows
+		/// \exception FE_INEXACT if \a arg is not a positive integer
+		template<std::float_round_style R,bool L> unsigned int gamma(unsigned int arg)
+		{
+/*			static const double p[] ={ 2.50662827563479526904, 225.525584619175212544, -268.295973841304927459, 80.9030806934622512966, -5.00757863970517583837, 0.0114684895434781459556 };
+			double t = arg + 4.65, s = p[0];
+			for(unsigned int i=0; i<5; ++i)
+				s += p[i+1] / (arg+i);
+			return std::log(s) + (arg-0.5)*std::log(t) - t;
+*/			static const f31 pi(0xC90FDAA2, 1), lbe(0xB8AA3B29, 0);
+			unsigned int abs = arg & 0x7FFF, sign = arg & 0x8000;
+			bool bsign = sign != 0;
+			f31 z(abs), x = sign ? (z+f31(0x80000000, 0)) : z, t = x + f31(0x94CCCCCD, 2), s =
+				f31(0xA06C9901, 1) + f31(0xBBE654E2, -7)/(x+f31(0x80000000, 2)) + f31(0xA1CE6098, 6)/(x+f31(0x80000000, 1))
+				+ f31(0xE1868CB7, 7)/x - f31(0x8625E279, 8)/(x+f31(0x80000000, 0)) - f31(0xA03E158F, 2)/(x+f31(0xC0000000, 1));
+			int i = (s.exp>=2) + (s.exp>=4) + (s.exp>=8) + (s.exp>=16);
+			s = f31((static_cast<uint32>(s.exp)<<(31-i))+(log2(s.m>>1, 28)>>i), i) / lbe;
+			if(x.exp != -1 || x.m != 0x80000000)
+			{
+				i = (t.exp>=2) + (t.exp>=4) + (t.exp>=8);
+				f31 l = f31((static_cast<uint32>(t.exp)<<(31-i))+(log2(t.m>>1, 30)>>i), i) / lbe;
+				s = (x.exp<-1) ? (s-(f31(0x80000000, -1)-x)*l) : (s+(x-f31(0x80000000, -1))*l);
+			}
+			s = x.exp ? (s-t) : (t-s);
+			if(bsign)
+			{
+				if(z.exp >= 0)
+				{
+					sign &= (L|((z.m>>(31-z.exp))&1)) - 1;
+					for(z=f31((z.m<<(1+z.exp))&0xFFFFFFFF, -1); z.m<0x80000000; z.m<<=1,--z.exp) ;
+				}
+				if(z.exp == -1)
+					z = f31(0x80000000, 0) - z;
+				if(z.exp < -1)
+				{
+					z = z * pi;
+					z.m = sincos(z.m>>(1-z.exp), 30).first;
+					for(z.exp=1; z.m<0x80000000; z.m<<=1,--z.exp) ;
+				}
+				else
+					z = f31(0x80000000, 0);
+			}
+			if(L)
+			{
+				if(bsign)
+				{
+					f31 l(0x92868247, 0);
+					if(z.exp < 0)
+					{
+						uint32 m = log2((z.m+1)>>1, 27);
+						z = f31(-((static_cast<uint32>(z.exp)<<26)+(m>>5)), 5);
+						for(; z.m<0x80000000; z.m<<=1,--z.exp) ;
+						l = l + z / lbe;
+					}
+					sign = static_cast<unsigned>(x.exp&&(l.exp<s.exp||(l.exp==s.exp&&l.m<s.m))) << 15;
+					s = sign ? (s-l) : x.exp ? (l-s) : (l+s);
+				}
+				else
+				{
+					sign = static_cast<unsigned>(x.exp==0) << 15;
+					if(s.exp < -24)
+						return underflow<R>(sign);
+					if(s.exp > 15)
+						return overflow<R>(sign);
+				}
+			}
+			else
+			{
+				s = s * lbe;
+				uint32 m;
+				if(s.exp < 0)
+				{
+					m = s.m >> -s.exp;
+					s.exp = 0;
+				}
+				else
+				{
+					m = (s.m<<s.exp) & 0x7FFFFFFF;
+					s.exp = (s.m>>(31-s.exp));
+				}
+				s.m = exp2(m, 27);
+				if(!x.exp)
+					s = f31(0x80000000, 0) / s;
+				if(bsign)
+				{
+					if(z.exp < 0)
+						s = s * z;
+					s = pi / s;
+					if(s.exp < -24)
+						return underflow<R>(sign);
+				}
+				else if(z.exp > 0 && !(z.m&((1<<(31-z.exp))-1)))
+					return ((s.exp+14)<<10) + (s.m>>21);
+				if(s.exp > 15)
+					return overflow<R>(sign);
+			}
+			return fixed2half<R,31,false,false,true>(s.m, s.exp+14, sign);
+		}
+		/// \}
+
+		template<typename,typename,std::float_round_style> struct half_caster;
+	}
+
+	/// Half-precision floating-point type.
+	/// This class implements an IEEE-conformant half-precision floating-point type with the usual arithmetic 
+	/// operators and conversions. It is implicitly convertible to single-precision floating-point, which makes artihmetic 
+	/// expressions and functions with mixed-type operands to be of the most precise operand type.
+	///
+	/// According to the C++98/03 definition, the half type is not a POD type. But according to C++11's less strict and 
+	/// extended definitions it is both a standard layout type and a trivially copyable type (even if not a POD type), which 
+	/// means it can be standard-conformantly copied using raw binary copies. But in this context some more words about the 
+	/// actual size of the type. Although the half is representing an IEEE 16-bit type, it does not neccessarily have to be of 
+	/// exactly 16-bits size. But on any reasonable implementation the actual binary representation of this type will most 
+	/// probably not ivolve any additional "magic" or padding beyond the simple binary representation of the underlying 16-bit 
+	/// IEEE number, even if not strictly guaranteed by the standard. But even then it only has an actual size of 16 bits if 
+	/// your C++ implementation supports an unsigned integer type of exactly 16 bits width. But this should be the case on 
+	/// nearly any reasonable platform.
+	///
+	/// So if your C++ implementation is not totally exotic or imposes special alignment requirements, it is a reasonable 
+	/// assumption that the data of a half is just comprised of the 2 bytes of the underlying IEEE representation.
+	class half
+	{
+	public:
+		/// \name Construction and assignment
+		/// \{
+
+		/// Default constructor.
+		/// This initializes the half to 0. Although this does not match the builtin types' default-initialization semantics 
+		/// and may be less efficient than no initialization, it is needed to provide proper value-initialization semantics.
+		HALF_CONSTEXPR half() HALF_NOEXCEPT : data_() {}
+
+		/// Conversion constructor.
+		/// \param rhs float to convert
+		/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+		explicit half(float rhs) : data_(static_cast<detail::uint16>(detail::float2half<round_style>(rhs))) {}
+	
+		/// Conversion to single-precision.
+		/// \return single precision value representing expression value
+		operator float() const { return detail::half2float<float>(data_); }
+
+		/// Assignment operator.
+		/// \param rhs single-precision value to copy from
+		/// \return reference to this half
+		/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+		half& operator=(float rhs) { data_ = static_cast<detail::uint16>(detail::float2half<round_style>(rhs)); return *this; }
+
+		/// \}
+		/// \name Arithmetic updates
+		/// \{
+
+		/// Arithmetic assignment.
+		/// \tparam T type of concrete half expression
+		/// \param rhs half expression to add
+		/// \return reference to this half
+		/// \exception FE_... according to operator+(half,half)
+		half& operator+=(half rhs) { return *this = *this + rhs; }
+
+		/// Arithmetic assignment.
+		/// \tparam T type of concrete half expression
+		/// \param rhs half expression to subtract
+		/// \return reference to this half
+		/// \exception FE_... according to operator-(half,half)
+		half& operator-=(half rhs) { return *this = *this - rhs; }
+
+		/// Arithmetic assignment.
+		/// \tparam T type of concrete half expression
+		/// \param rhs half expression to multiply with
+		/// \return reference to this half
+		/// \exception FE_... according to operator*(half,half)
+		half& operator*=(half rhs) { return *this = *this * rhs; }
+
+		/// Arithmetic assignment.
+		/// \tparam T type of concrete half expression
+		/// \param rhs half expression to divide by
+		/// \return reference to this half
+		/// \exception FE_... according to operator/(half,half)
+		half& operator/=(half rhs) { return *this = *this / rhs; }
+
+		/// Arithmetic assignment.
+		/// \param rhs single-precision value to add
+		/// \return reference to this half
+		/// \exception FE_... according to operator=()
+		half& operator+=(float rhs) { return *this = *this + rhs; }
+
+		/// Arithmetic assignment.
+		/// \param rhs single-precision value to subtract
+		/// \return reference to this half
+		/// \exception FE_... according to operator=()
+		half& operator-=(float rhs) { return *this = *this - rhs; }
+
+		/// Arithmetic assignment.
+		/// \param rhs single-precision value to multiply with
+		/// \return reference to this half
+		/// \exception FE_... according to operator=()
+		half& operator*=(float rhs) { return *this = *this * rhs; }
+
+		/// Arithmetic assignment.
+		/// \param rhs single-precision value to divide by
+		/// \return reference to this half
+		/// \exception FE_... according to operator=()
+		half& operator/=(float rhs) { return *this = *this / rhs; }
+
+		/// \}
+		/// \name Increment and decrement
+		/// \{
+
+		/// Prefix increment.
+		/// \return incremented half value
+		/// \exception FE_... according to operator+(half,half)
+		half& operator++() { return *this = *this + half(detail::binary, 0x3C00); }
+
+		/// Prefix decrement.
+		/// \return decremented half value
+		/// \exception FE_... according to operator-(half,half)
+		half& operator--() { return *this = *this + half(detail::binary, 0xBC00); }
+
+		/// Postfix increment.
+		/// \return non-incremented half value
+		/// \exception FE_... according to operator+(half,half)
+		half operator++(int) { half out(*this); ++*this; return out; }
+
+		/// Postfix decrement.
+		/// \return non-decremented half value
+		/// \exception FE_... according to operator-(half,half)
+		half operator--(int) { half out(*this); --*this; return out; }
+		/// \}
+	
+	private:
+		/// Rounding mode to use
+		static const std::float_round_style round_style = (std::float_round_style)(HALF_ROUND_STYLE);
+
+		/// Constructor.
+		/// \param bits binary representation to set half to
+		HALF_CONSTEXPR half(detail::binary_t, unsigned int bits) HALF_NOEXCEPT : data_(static_cast<detail::uint16>(bits)) {}
+
+		/// Internal binary representation
+		detail::uint16 data_;
+
+	#ifndef HALF_DOXYGEN_ONLY
+		friend HALF_CONSTEXPR_NOERR bool operator==(half, half);
+		friend HALF_CONSTEXPR_NOERR bool operator!=(half, half);
+		friend HALF_CONSTEXPR_NOERR bool operator<(half, half);
+		friend HALF_CONSTEXPR_NOERR bool operator>(half, half);
+		friend HALF_CONSTEXPR_NOERR bool operator<=(half, half);
+		friend HALF_CONSTEXPR_NOERR bool operator>=(half, half);
+		friend HALF_CONSTEXPR half operator-(half);
+		friend half operator+(half, half);
+		friend half operator-(half, half);
+		friend half operator*(half, half);
+		friend half operator/(half, half);
+		template<typename charT,typename traits> friend std::basic_ostream<charT,traits>& operator<<(std::basic_ostream<charT,traits>&, half);
+		template<typename charT,typename traits> friend std::basic_istream<charT,traits>& operator>>(std::basic_istream<charT,traits>&, half&);
+		friend HALF_CONSTEXPR half fabs(half);
+		friend half fmod(half, half);
+		friend half remainder(half, half);
+		friend half remquo(half, half, int*);
+		friend half fma(half, half, half);
+		friend HALF_CONSTEXPR_NOERR half fmax(half, half);
+		friend HALF_CONSTEXPR_NOERR half fmin(half, half);
+		friend half fdim(half, half);
+		friend half nanh(const char*);
+		friend half exp(half);
+		friend half exp2(half);
+		friend half expm1(half);
+		friend half log(half);
+		friend half log10(half);
+		friend half log2(half);
+		friend half log1p(half);
+		friend half sqrt(half);
+		friend half cbrt(half);
+		friend half hypot(half, half);
+		friend half hypot(half, half, half);
+		friend half pow(half, half);
+		friend void sincos(half, half*, half*);
+		friend half sin(half);
+		friend half cos(half);
+		friend half tan(half);
+		friend half asin(half);
+		friend half acos(half);
+		friend half atan(half);
+		friend half atan2(half, half);
+		friend half sinh(half);
+		friend half cosh(half);
+		friend half tanh(half);
+		friend half asinh(half);
+		friend half acosh(half);
+		friend half atanh(half);
+		friend half erf(half);
+		friend half erfc(half);
+		friend half lgamma(half);
+		friend half tgamma(half);
+		friend half ceil(half);
+		friend half floor(half);
+		friend half trunc(half);
+		friend half round(half);
+		friend long lround(half);
+		friend half rint(half);
+		friend long lrint(half);
+		friend half nearbyint(half);
+	#ifdef HALF_ENABLE_CPP11_LONG_LONG
+		friend long long llround(half);
+		friend long long llrint(half);
+	#endif
+		friend half frexp(half, int*);
+		friend half scalbln(half, long);
+		friend half modf(half, half*);
+		friend int ilogb(half);
+		friend half logb(half);
+		friend half nextafter(half, half);
+		friend half nexttoward(half, long double);
+		friend HALF_CONSTEXPR half copysign(half, half);
+		friend HALF_CONSTEXPR int fpclassify(half);
+		friend HALF_CONSTEXPR bool isfinite(half);
+		friend HALF_CONSTEXPR bool isinf(half);
+		friend HALF_CONSTEXPR bool isnan(half);
+		friend HALF_CONSTEXPR bool isnormal(half);
+		friend HALF_CONSTEXPR bool signbit(half);
+		friend HALF_CONSTEXPR bool isgreater(half, half);
+		friend HALF_CONSTEXPR bool isgreaterequal(half, half);
+		friend HALF_CONSTEXPR bool isless(half, half);
+		friend HALF_CONSTEXPR bool islessequal(half, half);
+		friend HALF_CONSTEXPR bool islessgreater(half, half);
+		template<typename,typename,std::float_round_style> friend struct detail::half_caster;
+		friend class std::numeric_limits<half>;
+	#if HALF_ENABLE_CPP11_HASH
+		friend struct std::hash<half>;
+	#endif
+	#if HALF_ENABLE_CPP11_USER_LITERALS
+		friend half literal::operator "" _h(long double);
+	#endif
+	#endif
+	};
+
+#if HALF_ENABLE_CPP11_USER_LITERALS
+	namespace literal
+	{
+		/// Half literal.
+		/// While this returns a properly rounded half-precision value, half literals can unfortunately not be constant 
+		/// expressions due to rather involved conversions. So don't expect this to be a literal literal without involving 
+		/// conversion operations at runtime. It is a convenience feature, not a performance optimization.
+		/// \param value literal value
+		/// \return half with of given value (possibly rounded)
+		/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+		inline half operator "" _h(long double value) { return half(detail::binary, detail::float2half<half::round_style>(value)); }
+	}
+#endif
+
+	namespace detail
+	{
+		/// Helper class for half casts.
+		/// This class template has to be specialized for all valid cast arguments to define an appropriate static 
+		/// `cast` member function and a corresponding `type` member denoting its return type.
+		/// \tparam T destination type
+		/// \tparam U source type
+		/// \tparam R rounding mode to use
+		template<typename T,typename U,std::float_round_style R=(std::float_round_style)(HALF_ROUND_STYLE)> struct half_caster {};
+		template<typename U,std::float_round_style R> struct half_caster<half,U,R>
+		{
+		#if HALF_ENABLE_CPP11_STATIC_ASSERT && HALF_ENABLE_CPP11_TYPE_TRAITS
+			static_assert(std::is_arithmetic<U>::value, "half_cast from non-arithmetic type unsupported");
+		#endif
+
+			static half cast(U arg) { return cast_impl(arg, is_float<U>()); };
+
+		private:
+			static half cast_impl(U arg, true_type) { return half(binary, float2half<R>(arg)); }
+			static half cast_impl(U arg, false_type) { return half(binary, int2half<R>(arg)); }
+		};
+		template<typename T,std::float_round_style R> struct half_caster<T,half,R>
+		{
+		#if HALF_ENABLE_CPP11_STATIC_ASSERT && HALF_ENABLE_CPP11_TYPE_TRAITS
+			static_assert(std::is_arithmetic<T>::value, "half_cast to non-arithmetic type unsupported");
+		#endif
+
+			static T cast(half arg) { return cast_impl(arg, is_float<T>()); }
+
+		private:
+			static T cast_impl(half arg, true_type) { return half2float<T>(arg.data_); }
+			static T cast_impl(half arg, false_type) { return half2int<R,true,true,T>(arg.data_); }
+		};
+		template<std::float_round_style R> struct half_caster<half,half,R>
+		{
+			static half cast(half arg) { return arg; }
+		};
+	}
+}
+
+/// Extensions to the C++ standard library.
+namespace std
+{
+	/// Numeric limits for half-precision floats.
+	/// **See also:** Documentation for [std::numeric_limits](https://en.cppreference.com/w/cpp/types/numeric_limits)
+	template<> class numeric_limits<half_float::half>
+	{
+	public:
+		/// Is template specialization.
+		static HALF_CONSTEXPR_CONST bool is_specialized = true;
+
+		/// Supports signed values.
+		static HALF_CONSTEXPR_CONST bool is_signed = true;
+
+		/// Is not an integer type.
+		static HALF_CONSTEXPR_CONST bool is_integer = false;
+
+		/// Is not exact.
+		static HALF_CONSTEXPR_CONST bool is_exact = false;
+
+		/// Doesn't provide modulo arithmetic.
+		static HALF_CONSTEXPR_CONST bool is_modulo = false;
+
+		/// Has a finite set of values.
+		static HALF_CONSTEXPR_CONST bool is_bounded = true;
+
+		/// IEEE conformant.
+		static HALF_CONSTEXPR_CONST bool is_iec559 = true;
+
+		/// Supports infinity.
+		static HALF_CONSTEXPR_CONST bool has_infinity = true;
+
+		/// Supports quiet NaNs.
+		static HALF_CONSTEXPR_CONST bool has_quiet_NaN = true;
+
+		/// Supports signaling NaNs.
+		static HALF_CONSTEXPR_CONST bool has_signaling_NaN = true;
+
+		/// Supports subnormal values.
+		static HALF_CONSTEXPR_CONST float_denorm_style has_denorm = denorm_present;
+
+		/// Supports no denormalization detection.
+		static HALF_CONSTEXPR_CONST bool has_denorm_loss = false;
+
+	#if HALF_ERRHANDLING_THROWS
+		static HALF_CONSTEXPR_CONST bool traps = true;
+	#else
+		/// Traps only if [HALF_ERRHANDLING_THROW_...](\ref HALF_ERRHANDLING_THROW_INVALID) is acitvated.
+		static HALF_CONSTEXPR_CONST bool traps = false;
+	#endif
+
+		/// Does not support no pre-rounding underflow detection.
+		static HALF_CONSTEXPR_CONST bool tinyness_before = false;
+
+		/// Rounding mode.
+		static HALF_CONSTEXPR_CONST float_round_style round_style = half_float::half::round_style;
+
+		/// Significant digits.
+		static HALF_CONSTEXPR_CONST int digits = 11;
+
+		/// Significant decimal digits.
+		static HALF_CONSTEXPR_CONST int digits10 = 3;
+
+		/// Required decimal digits to represent all possible values.
+		static HALF_CONSTEXPR_CONST int max_digits10 = 5;
+
+		/// Number base.
+		static HALF_CONSTEXPR_CONST int radix = 2;
+
+		/// One more than smallest exponent.
+		static HALF_CONSTEXPR_CONST int min_exponent = -13;
+
+		/// Smallest normalized representable power of 10.
+		static HALF_CONSTEXPR_CONST int min_exponent10 = -4;
+
+		/// One more than largest exponent
+		static HALF_CONSTEXPR_CONST int max_exponent = 16;
+
+		/// Largest finitely representable power of 10.
+		static HALF_CONSTEXPR_CONST int max_exponent10 = 4;
+
+		/// Smallest positive normal value.
+		static HALF_CONSTEXPR half_float::half min() HALF_NOTHROW { return half_float::half(half_float::detail::binary, 0x0400); }
+
+		/// Smallest finite value.
+		static HALF_CONSTEXPR half_float::half lowest() HALF_NOTHROW { return half_float::half(half_float::detail::binary, 0xFBFF); }
+
+		/// Largest finite value.
+		static HALF_CONSTEXPR half_float::half max() HALF_NOTHROW { return half_float::half(half_float::detail::binary, 0x7BFF); }
+
+		/// Difference between 1 and next representable value.
+		static HALF_CONSTEXPR half_float::half epsilon() HALF_NOTHROW { return half_float::half(half_float::detail::binary, 0x1400); }
+
+		/// Maximum rounding error in ULP (units in the last place).
+		static HALF_CONSTEXPR half_float::half round_error() HALF_NOTHROW
+			{ return half_float::half(half_float::detail::binary, (round_style==std::round_to_nearest) ? 0x3800 : 0x3C00); }
+
+		/// Positive infinity.
+		static HALF_CONSTEXPR half_float::half infinity() HALF_NOTHROW { return half_float::half(half_float::detail::binary, 0x7C00); }
+
+		/// Quiet NaN.
+		static HALF_CONSTEXPR half_float::half quiet_NaN() HALF_NOTHROW { return half_float::half(half_float::detail::binary, 0x7FFF); }
+
+		/// Signaling NaN.
+		static HALF_CONSTEXPR half_float::half signaling_NaN() HALF_NOTHROW { return half_float::half(half_float::detail::binary, 0x7DFF); }
+
+		/// Smallest positive subnormal value.
+		static HALF_CONSTEXPR half_float::half denorm_min() HALF_NOTHROW { return half_float::half(half_float::detail::binary, 0x0001); }
+	};
+
+#if HALF_ENABLE_CPP11_HASH
+	/// Hash function for half-precision floats.
+	/// This is only defined if C++11 `std::hash` is supported and enabled.
+	///
+	/// **See also:** Documentation for [std::hash](https://en.cppreference.com/w/cpp/utility/hash)
+	template<> struct hash<half_float::half>
+	{
+		/// Type of function argument.
+		typedef half_float::half argument_type;
+
+		/// Function return type.
+		typedef size_t result_type;
+
+		/// Compute hash function.
+		/// \param arg half to hash
+		/// \return hash value
+		result_type operator()(argument_type arg) const { return hash<half_float::detail::uint16>()(arg.data_&-static_cast<unsigned>(arg.data_!=0x8000)); }
+	};
+#endif
+}
+
+namespace half_float
+{
+	/// \anchor compop
+	/// \name Comparison operators
+	/// \{
+
+	/// Comparison for equality.
+	/// \param x first operand
+	/// \param y second operand
+	/// \retval true if operands equal
+	/// \retval false else
+	/// \exception FE_INVALID if \a x or \a y is NaN
+	inline HALF_CONSTEXPR_NOERR bool operator==(half x, half y)
+	{
+		return !detail::compsignal(x.data_, y.data_) && (x.data_==y.data_ || !((x.data_|y.data_)&0x7FFF));
+	}
+
+	/// Comparison for inequality.
+	/// \param x first operand
+	/// \param y second operand
+	/// \retval true if operands not equal
+	/// \retval false else
+	/// \exception FE_INVALID if \a x or \a y is NaN
+	inline HALF_CONSTEXPR_NOERR bool operator!=(half x, half y)
+	{
+		return detail::compsignal(x.data_, y.data_) || (x.data_!=y.data_ && ((x.data_|y.data_)&0x7FFF));
+	}
+
+	/// Comparison for less than.
+	/// \param x first operand
+	/// \param y second operand
+	/// \retval true if \a x less than \a y
+	/// \retval false else
+	/// \exception FE_INVALID if \a x or \a y is NaN
+	inline HALF_CONSTEXPR_NOERR bool operator<(half x, half y)
+	{
+		return !detail::compsignal(x.data_, y.data_) &&
+			((x.data_^(0x8000|(0x8000-(x.data_>>15))))+(x.data_>>15)) < ((y.data_^(0x8000|(0x8000-(y.data_>>15))))+(y.data_>>15));
+	}
+
+	/// Comparison for greater than.
+	/// \param x first operand
+	/// \param y second operand
+	/// \retval true if \a x greater than \a y
+	/// \retval false else
+	/// \exception FE_INVALID if \a x or \a y is NaN
+	inline HALF_CONSTEXPR_NOERR bool operator>(half x, half y)
+	{
+		return !detail::compsignal(x.data_, y.data_) &&
+			((x.data_^(0x8000|(0x8000-(x.data_>>15))))+(x.data_>>15)) > ((y.data_^(0x8000|(0x8000-(y.data_>>15))))+(y.data_>>15));
+	}
+
+	/// Comparison for less equal.
+	/// \param x first operand
+	/// \param y second operand
+	/// \retval true if \a x less equal \a y
+	/// \retval false else
+	/// \exception FE_INVALID if \a x or \a y is NaN
+	inline HALF_CONSTEXPR_NOERR bool operator<=(half x, half y)
+	{
+		return !detail::compsignal(x.data_, y.data_) &&
+			((x.data_^(0x8000|(0x8000-(x.data_>>15))))+(x.data_>>15)) <= ((y.data_^(0x8000|(0x8000-(y.data_>>15))))+(y.data_>>15));
+	}
+
+	/// Comparison for greater equal.
+	/// \param x first operand
+	/// \param y second operand
+	/// \retval true if \a x greater equal \a y
+	/// \retval false else
+	/// \exception FE_INVALID if \a x or \a y is NaN
+	inline HALF_CONSTEXPR_NOERR bool operator>=(half x, half y)
+	{
+		return !detail::compsignal(x.data_, y.data_) &&
+			((x.data_^(0x8000|(0x8000-(x.data_>>15))))+(x.data_>>15)) >= ((y.data_^(0x8000|(0x8000-(y.data_>>15))))+(y.data_>>15));
+	}
+
+	/// \}
+	/// \anchor arithmetics
+	/// \name Arithmetic operators
+	/// \{
+
+	/// Identity.
+	/// \param arg operand
+	/// \return unchanged operand
+	inline HALF_CONSTEXPR half operator+(half arg) { return arg; }
+
+	/// Negation.
+	/// \param arg operand
+	/// \return negated operand
+	inline HALF_CONSTEXPR half operator-(half arg) { return half(detail::binary, arg.data_^0x8000); }
+
+	/// Addition.
+	/// This operation is exact to rounding for all rounding modes.
+	/// \param x left operand
+	/// \param y right operand
+	/// \return sum of half expressions
+	/// \exception FE_INVALID if \a x and \a y are infinities with different signs or signaling NaNs
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half operator+(half x, half y)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		return half(detail::binary, detail::float2half<half::round_style>(detail::half2float<detail::internal_t>(x.data_)+detail::half2float<detail::internal_t>(y.data_)));
+	#else
+		int absx = x.data_ & 0x7FFF, absy = y.data_ & 0x7FFF;
+		bool sub = ((x.data_^y.data_)&0x8000) != 0;
+		if(absx >= 0x7C00 || absy >= 0x7C00)
+			return half(detail::binary,	(absx>0x7C00 || absy>0x7C00) ? detail::signal(x.data_, y.data_) : (absy!=0x7C00) ? x.data_ :
+										(sub && absx==0x7C00) ? detail::invalid() : y.data_);
+		if(!absx)
+			return absy ? y : half(detail::binary, (half::round_style==std::round_toward_neg_infinity) ? (x.data_|y.data_) : (x.data_&y.data_));
+		if(!absy)
+			return x;
+		unsigned int sign = ((sub && absy>absx) ? y.data_ : x.data_) & 0x8000;
+		if(absy > absx)
+			std::swap(absx, absy);
+		int exp = (absx>>10) + (absx<=0x3FF), d = exp - (absy>>10) - (absy<=0x3FF), mx = ((absx&0x3FF)|((absx>0x3FF)<<10)) << 3, my;
+		if(d < 13)
+		{
+			my = ((absy&0x3FF)|((absy>0x3FF)<<10)) << 3;
+			my = (my>>d) | ((my&((1<<d)-1))!=0);
+		}
+		else
+			my = 1;
+		if(sub)
+		{
+			if(!(mx-=my))
+				return half(detail::binary, static_cast<unsigned>(half::round_style==std::round_toward_neg_infinity)<<15);
+			for(; mx<0x2000 && exp>1; mx<<=1,--exp) ;
+		}
+		else
+		{
+			mx += my;
+			int i = mx >> 14;
+			if((exp+=i) > 30)
+				return half(detail::binary, detail::overflow<half::round_style>(sign));
+			mx = (mx>>i) | (mx&i);
+		}
+		return half(detail::binary, detail::rounded<half::round_style,false>(sign+((exp-1)<<10)+(mx>>3), (mx>>2)&1, (mx&0x3)!=0));
+	#endif
+	}
+
+	/// Subtraction.
+	/// This operation is exact to rounding for all rounding modes.
+	/// \param x left operand
+	/// \param y right operand
+	/// \return difference of half expressions
+	/// \exception FE_INVALID if \a x and \a y are infinities with equal signs or signaling NaNs
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half operator-(half x, half y)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		return half(detail::binary, detail::float2half<half::round_style>(detail::half2float<detail::internal_t>(x.data_)-detail::half2float<detail::internal_t>(y.data_)));
+	#else
+		return x + -y;
+	#endif
+	}
+
+	/// Multiplication.
+	/// This operation is exact to rounding for all rounding modes.
+	/// \param x left operand
+	/// \param y right operand
+	/// \return product of half expressions
+	/// \exception FE_INVALID if multiplying 0 with infinity or if \a x or \a y is signaling NaN
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half operator*(half x, half y)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		return half(detail::binary, detail::float2half<half::round_style>(detail::half2float<detail::internal_t>(x.data_)*detail::half2float<detail::internal_t>(y.data_)));
+	#else
+		int absx = x.data_ & 0x7FFF, absy = y.data_ & 0x7FFF, exp = -16;
+		unsigned int sign = (x.data_^y.data_) & 0x8000;
+		if(absx >= 0x7C00 || absy >= 0x7C00)
+			return half(detail::binary,	(absx>0x7C00 || absy>0x7C00) ? detail::signal(x.data_, y.data_) :
+										((absx==0x7C00 && !absy)||(absy==0x7C00 && !absx)) ? detail::invalid() : (sign|0x7C00));
+		if(!absx || !absy)
+			return half(detail::binary, sign);
+		for(; absx<0x400; absx<<=1,--exp) ;
+		for(; absy<0x400; absy<<=1,--exp) ;
+		detail::uint32 m = static_cast<detail::uint32>((absx&0x3FF)|0x400) * static_cast<detail::uint32>((absy&0x3FF)|0x400);
+		int i = m >> 21, s = m & i;
+		exp += (absx>>10) + (absy>>10) + i;
+		if(exp > 29)
+			return half(detail::binary, detail::overflow<half::round_style>(sign));
+		else if(exp < -11)
+			return half(detail::binary, detail::underflow<half::round_style>(sign));
+		return half(detail::binary, detail::fixed2half<half::round_style,20,false,false,false>(m>>i, exp, sign, s));
+	#endif
+	}
+
+	/// Division.
+	/// This operation is exact to rounding for all rounding modes.
+	/// \param x left operand
+	/// \param y right operand
+	/// \return quotient of half expressions
+	/// \exception FE_INVALID if dividing 0s or infinities with each other or if \a x or \a y is signaling NaN
+	/// \exception FE_DIVBYZERO if dividing finite value by 0
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half operator/(half x, half y)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		return half(detail::binary, detail::float2half<half::round_style>(detail::half2float<detail::internal_t>(x.data_)/detail::half2float<detail::internal_t>(y.data_)));
+	#else
+		int absx = x.data_ & 0x7FFF, absy = y.data_ & 0x7FFF, exp = 14;
+		unsigned int sign = (x.data_^y.data_) & 0x8000;
+		if(absx >= 0x7C00 || absy >= 0x7C00)
+			return half(detail::binary,	(absx>0x7C00 || absy>0x7C00) ? detail::signal(x.data_, y.data_) :
+										(absx==absy) ? detail::invalid() : (sign|((absx==0x7C00) ? 0x7C00 : 0)));
+		if(!absx)
+			return half(detail::binary, absy ? sign : detail::invalid());
+		if(!absy)
+			return half(detail::binary, detail::pole(sign));
+		for(; absx<0x400; absx<<=1,--exp) ;
+		for(; absy<0x400; absy<<=1,++exp) ;
+		detail::uint32 mx = (absx&0x3FF) | 0x400, my = (absy&0x3FF) | 0x400;
+		int i = mx < my;
+		exp += (absx>>10) - (absy>>10) - i;
+		if(exp > 29)
+			return half(detail::binary, detail::overflow<half::round_style>(sign));
+		else if(exp < -11)
+			return half(detail::binary, detail::underflow<half::round_style>(sign));
+		mx <<= 12 + i;
+		my <<= 1;
+		return half(detail::binary, detail::fixed2half<half::round_style,11,false,false,false>(mx/my, exp, sign, mx%my!=0));
+	#endif
+	}
+
+	/// \}
+	/// \anchor streaming
+	/// \name Input and output
+	/// \{
+
+	/// Output operator.
+	///	This uses the built-in functionality for streaming out floating-point numbers.
+	/// \param out output stream to write into
+	/// \param arg half expression to write
+	/// \return reference to output stream
+	template<typename charT,typename traits> std::basic_ostream<charT,traits>& operator<<(std::basic_ostream<charT,traits> &out, half arg)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		return out << detail::half2float<detail::internal_t>(arg.data_);
+	#else
+		return out << detail::half2float<float>(arg.data_);
+	#endif
+	}
+
+	/// Input operator.
+	///	This uses the built-in functionality for streaming in floating-point numbers, specifically double precision floating 
+	/// point numbers (unless overridden with [HALF_ARITHMETIC_TYPE](\ref HALF_ARITHMETIC_TYPE)). So the input string is first 
+	/// rounded to double precision using the underlying platform's current floating-point rounding mode before being rounded 
+	/// to half-precision using the library's half-precision rounding mode.
+	/// \param in input stream to read from
+	/// \param arg half to read into
+	/// \return reference to input stream
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	template<typename charT,typename traits> std::basic_istream<charT,traits>& operator>>(std::basic_istream<charT,traits> &in, half &arg)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		detail::internal_t f;
+	#else
+		double f;
+	#endif
+		if(in >> f)
+			arg.data_ = detail::float2half<half::round_style>(f);
+		return in;
+	}
+
+	/// \}
+	/// \anchor basic
+	/// \name Basic mathematical operations
+	/// \{
+
+	/// Absolute value.
+	/// **See also:** Documentation for [std::fabs](https://en.cppreference.com/w/cpp/numeric/math/fabs).
+	/// \param arg operand
+	/// \return absolute value of \a arg
+	inline HALF_CONSTEXPR half fabs(half arg) { return half(detail::binary, arg.data_&0x7FFF); }
+
+	/// Absolute value.
+	/// **See also:** Documentation for [std::abs](https://en.cppreference.com/w/cpp/numeric/math/fabs).
+	/// \param arg operand
+	/// \return absolute value of \a arg
+	inline HALF_CONSTEXPR half abs(half arg) { return fabs(arg); }
+
+	/// Remainder of division.
+	/// **See also:** Documentation for [std::fmod](https://en.cppreference.com/w/cpp/numeric/math/fmod).
+	/// \param x first operand
+	/// \param y second operand
+	/// \return remainder of floating-point division.
+	/// \exception FE_INVALID if \a x is infinite or \a y is 0 or if \a x or \a y is signaling NaN
+	inline half fmod(half x, half y)
+	{
+		unsigned int absx = x.data_ & 0x7FFF, absy = y.data_ & 0x7FFF, sign = x.data_ & 0x8000;
+		if(absx >= 0x7C00 || absy >= 0x7C00)
+			return half(detail::binary,	(absx>0x7C00 || absy>0x7C00) ? detail::signal(x.data_, y.data_) :
+										(absx==0x7C00) ? detail::invalid() : x.data_);
+		if(!absy)
+			return half(detail::binary, detail::invalid());
+		if(!absx)
+			return x;
+		if(absx == absy)
+			return half(detail::binary, sign);
+		return half(detail::binary, sign|detail::mod<false,false>(absx, absy));
+	}
+
+	/// Remainder of division.
+	/// **See also:** Documentation for [std::remainder](https://en.cppreference.com/w/cpp/numeric/math/remainder).
+	/// \param x first operand
+	/// \param y second operand
+	/// \return remainder of floating-point division.
+	/// \exception FE_INVALID if \a x is infinite or \a y is 0 or if \a x or \a y is signaling NaN
+	inline half remainder(half x, half y)
+	{
+		unsigned int absx = x.data_ & 0x7FFF, absy = y.data_ & 0x7FFF, sign = x.data_ & 0x8000;
+		if(absx >= 0x7C00 || absy >= 0x7C00)
+			return half(detail::binary,	(absx>0x7C00 || absy>0x7C00) ? detail::signal(x.data_, y.data_) :
+										(absx==0x7C00) ? detail::invalid() : x.data_);
+		if(!absy)
+			return half(detail::binary, detail::invalid());
+		if(absx == absy)
+			return half(detail::binary, sign);
+		return half(detail::binary, sign^detail::mod<false,true>(absx, absy));
+	}
+
+	/// Remainder of division.
+	/// **See also:** Documentation for [std::remquo](https://en.cppreference.com/w/cpp/numeric/math/remquo).
+	/// \param x first operand
+	/// \param y second operand
+	/// \param quo address to store some bits of quotient at
+	/// \return remainder of floating-point division.
+	/// \exception FE_INVALID if \a x is infinite or \a y is 0 or if \a x or \a y is signaling NaN
+	inline half remquo(half x, half y, int *quo)
+	{
+		unsigned int absx = x.data_ & 0x7FFF, absy = y.data_ & 0x7FFF, value = x.data_ & 0x8000;
+		if(absx >= 0x7C00 || absy >= 0x7C00)
+			return half(detail::binary,	(absx>0x7C00 || absy>0x7C00) ? detail::signal(x.data_, y.data_) :
+										(absx==0x7C00) ? detail::invalid() : (*quo = 0, x.data_));
+		if(!absy)
+			return half(detail::binary, detail::invalid());
+		bool qsign = ((value^y.data_)&0x8000) != 0;
+		int q = 1;
+		if(absx != absy)
+			value ^= detail::mod<true, true>(absx, absy, &q);
+		return *quo = qsign ? -q : q, half(detail::binary, value);
+	}
+
+	/// Fused multiply add.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::fma](https://en.cppreference.com/w/cpp/numeric/math/fma).
+	/// \param x first operand
+	/// \param y second operand
+	/// \param z third operand
+	/// \return ( \a x * \a y ) + \a z rounded as one operation.
+	/// \exception FE_INVALID according to operator*() and operator+() unless any argument is a quiet NaN and no argument is a signaling NaN
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding the final addition
+	inline half fma(half x, half y, half z)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		detail::internal_t fx = detail::half2float<detail::internal_t>(x.data_), fy = detail::half2float<detail::internal_t>(y.data_), fz = detail::half2float<detail::internal_t>(z.data_);
+		#if HALF_ENABLE_CPP11_CMATH && FP_FAST_FMA
+			return half(detail::binary, detail::float2half<half::round_style>(std::fma(fx, fy, fz)));
+		#else
+			return half(detail::binary, detail::float2half<half::round_style>(fx*fy+fz));
+		#endif
+	#else
+		int absx = x.data_ & 0x7FFF, absy = y.data_ & 0x7FFF, absz = z.data_ & 0x7FFF, exp = -15;
+		unsigned int sign = (x.data_^y.data_) & 0x8000;
+		bool sub = ((sign^z.data_)&0x8000) != 0;
+		if(absx >= 0x7C00 || absy >= 0x7C00 || absz >= 0x7C00)
+			return	(absx>0x7C00 || absy>0x7C00 || absz>0x7C00) ? half(detail::binary, detail::signal(x.data_, y.data_, z.data_)) :
+					(absx==0x7C00) ? half(detail::binary, (!absy || (sub && absz==0x7C00)) ? detail::invalid() : (sign|0x7C00)) :
+					(absy==0x7C00) ? half(detail::binary, (!absx || (sub && absz==0x7C00)) ? detail::invalid() : (sign|0x7C00)) : z;
+		if(!absx || !absy)
+			return absz ? z : half(detail::binary, (half::round_style==std::round_toward_neg_infinity) ? (z.data_|sign) : (z.data_&sign));
+		for(; absx<0x400; absx<<=1,--exp) ;
+		for(; absy<0x400; absy<<=1,--exp) ;
+		detail::uint32 m = static_cast<detail::uint32>((absx&0x3FF)|0x400) * static_cast<detail::uint32>((absy&0x3FF)|0x400);
+		int i = m >> 21;
+		exp += (absx>>10) + (absy>>10) + i;
+		m <<= 3 - i;
+		if(absz)
+		{
+			int expz = 0;
+			for(; absz<0x400; absz<<=1,--expz) ;
+			expz += absz >> 10;
+			detail::uint32 mz = static_cast<detail::uint32>((absz&0x3FF)|0x400) << 13;
+			if(expz > exp || (expz == exp && mz > m))
+			{
+				std::swap(m, mz);
+				std::swap(exp, expz);
+				if(sub)
+					sign = z.data_ & 0x8000;
+			}
+			int d = exp - expz;
+			mz = (d<23) ? ((mz>>d)|((mz&((static_cast<detail::uint32>(1)<<d)-1))!=0)) : 1;
+			if(sub)
+			{
+				m = m - mz;
+				if(!m)
+					return half(detail::binary, static_cast<unsigned>(half::round_style==std::round_toward_neg_infinity)<<15);
+				for(; m<0x800000; m<<=1,--exp) ;
+			}
+			else
+			{
+				m += mz;
+				i = m >> 24;
+				m = (m>>i) | (m&i);
+				exp += i;
+			}
+		}
+		if(exp > 30)
+			return half(detail::binary, detail::overflow<half::round_style>(sign));
+		else if(exp < -10)
+			return half(detail::binary, detail::underflow<half::round_style>(sign));
+		return half(detail::binary, detail::fixed2half<half::round_style,23,false,false,false>(m, exp-1, sign));
+	#endif
+	}
+
+	/// Maximum of half expressions.
+	/// **See also:** Documentation for [std::fmax](https://en.cppreference.com/w/cpp/numeric/math/fmax).
+	/// \param x first operand
+	/// \param y second operand
+	/// \return maximum of operands, ignoring quiet NaNs
+	/// \exception FE_INVALID if \a x or \a y is signaling NaN
+	inline HALF_CONSTEXPR_NOERR half fmax(half x, half y)
+	{
+		return half(detail::binary, (!isnan(y) && (isnan(x) || (x.data_^(0x8000|(0x8000-(x.data_>>15)))) < 
+			(y.data_^(0x8000|(0x8000-(y.data_>>15)))))) ? detail::select(y.data_, x.data_) : detail::select(x.data_, y.data_));
+	}
+
+	/// Minimum of half expressions.
+	/// **See also:** Documentation for [std::fmin](https://en.cppreference.com/w/cpp/numeric/math/fmin).
+	/// \param x first operand
+	/// \param y second operand
+	/// \return minimum of operands, ignoring quiet NaNs
+	/// \exception FE_INVALID if \a x or \a y is signaling NaN
+	inline HALF_CONSTEXPR_NOERR half fmin(half x, half y)
+	{
+		return half(detail::binary, (!isnan(y) && (isnan(x) || (x.data_^(0x8000|(0x8000-(x.data_>>15)))) >
+			(y.data_^(0x8000|(0x8000-(y.data_>>15)))))) ? detail::select(y.data_, x.data_) : detail::select(x.data_, y.data_));
+	}
+
+	/// Positive difference.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::fdim](https://en.cppreference.com/w/cpp/numeric/math/fdim).
+	/// \param x first operand
+	/// \param y second operand
+	/// \return \a x - \a y or 0 if difference negative
+	/// \exception FE_... according to operator-(half,half)
+	inline half fdim(half x, half y)
+	{
+		if(isnan(x) || isnan(y))
+			return half(detail::binary, detail::signal(x.data_, y.data_));
+		return (x.data_^(0x8000|(0x8000-(x.data_>>15)))) <= (y.data_^(0x8000|(0x8000-(y.data_>>15)))) ? half(detail::binary, 0) : (x-y);
+	}
+
+	/// Get NaN value.
+	/// **See also:** Documentation for [std::nan](https://en.cppreference.com/w/cpp/numeric/math/nan).
+	/// \param arg string code
+	/// \return quiet NaN
+	inline half nanh(const char *arg)
+	{
+		unsigned int value = 0x7FFF;
+		while(*arg)
+			value ^= static_cast<unsigned>(*arg++) & 0xFF;
+		return half(detail::binary, value);
+	}
+
+	/// \}
+	/// \anchor exponential
+	/// \name Exponential functions
+	/// \{
+
+	/// Exponential function.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::exp](https://en.cppreference.com/w/cpp/numeric/math/exp).
+	/// \param arg function argument
+	/// \return e raised to \a arg
+	/// \exception FE_INVALID for signaling NaN
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half exp(half arg)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		return half(detail::binary, detail::float2half<half::round_style>(std::exp(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		int abs = arg.data_ & 0x7FFF;
+		if(!abs)
+			return half(detail::binary, 0x3C00);
+		if(abs >= 0x7C00)
+			return half(detail::binary, (abs==0x7C00) ? (0x7C00&((arg.data_>>15)-1U)) : detail::signal(arg.data_));
+		if(abs >= 0x4C80)
+			return half(detail::binary, (arg.data_&0x8000) ? detail::underflow<half::round_style>() : detail::overflow<half::round_style>());
+		detail::uint32 m = detail::multiply64(static_cast<detail::uint32>((abs&0x3FF)+((abs>0x3FF)<<10))<<21, 0xB8AA3B29);
+		int e = (abs>>10) + (abs<=0x3FF), exp;
+		if(e < 14)
+		{
+			exp = 0;
+			m >>= 14 - e;
+		}
+		else
+		{
+			exp = m >> (45-e);
+			m = (m<<(e-14)) & 0x7FFFFFFF;
+		}
+		return half(detail::binary, detail::exp2_post<half::round_style,true>(detail::exp2(m, 26), exp, (arg.data_&0x8000)!=0));
+	#endif
+	}
+
+	/// Binary exponential.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::exp2](https://en.cppreference.com/w/cpp/numeric/math/exp2).
+	/// \param arg function argument
+	/// \return 2 raised to \a arg
+	/// \exception FE_INVALID for signaling NaN
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half exp2(half arg)
+	{
+	#if defined(HALF_ARITHMETIC_TYPE) && HALF_ENABLE_CPP11_CMATH
+		return half(detail::binary, detail::float2half<half::round_style>(std::exp2(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		int abs = arg.data_ & 0x7FFF;
+		if(!abs)
+			return half(detail::binary, 0x3C00);
+		if(abs >= 0x7C00)
+			return half(detail::binary, (abs==0x7C00) ? (0x7C00&((arg.data_>>15)-1U)) : detail::signal(arg.data_));
+		if(abs >= 0x4E40)
+			return half(detail::binary, (arg.data_&0x8000) ? detail::underflow<half::round_style>() : detail::overflow<half::round_style>());
+		int e = (abs>>10) + (abs<=0x3FF), exp = (abs&0x3FF) + ((abs>0x3FF)<<10);
+		detail::uint32 m = detail::exp2((static_cast<detail::uint32>(exp)<<(6+e))&0x7FFFFFFF, 28);
+		exp >>= 25 - e;
+		if(m == 0x80000000)
+		{
+			if(arg.data_&0x8000)
+				exp = -exp;
+			else if(exp > 15)
+				return half(detail::binary, detail::overflow<half::round_style>());
+			return half(detail::binary, detail::fixed2half<half::round_style,31,false,false,false>(m, exp+14));
+		}
+		return half(detail::binary, detail::exp2_post<half::round_style,true>(m, exp, (arg.data_&0x8000)!=0));
+	#endif
+	}
+
+	/// Exponential minus one.
+	/// This function may be 1 ULP off the correctly rounded exact result in <0.05% of inputs for `std::round_to_nearest` 
+	/// and in <1% of inputs for any other rounding mode.
+	///
+	/// **See also:** Documentation for [std::expm1](https://en.cppreference.com/w/cpp/numeric/math/expm1).
+	/// \param arg function argument
+	/// \return e raised to \a arg and subtracted by 1
+	/// \exception FE_INVALID for signaling NaN
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half expm1(half arg)
+	{
+	#if defined(HALF_ARITHMETIC_TYPE) && HALF_ENABLE_CPP11_CMATH
+		return half(detail::binary, detail::float2half<half::round_style>(std::expm1(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		unsigned int abs = arg.data_ & 0x7FFF, sign = arg.data_ & 0x8000;
+		if(!abs)
+			return arg;
+		if(abs >= 0x7C00)
+			return half(detail::binary, (abs==0x7C00) ? (0x7C00+(sign>>1)) : detail::signal(arg.data_));
+		if(abs >= 0x4A00)
+			return half(detail::binary, (arg.data_&0x8000) ? detail::rounded<half::round_style,true>(0xBBFF, 1, 1) : detail::overflow<half::round_style>());
+		detail::uint32 m = detail::multiply64(static_cast<detail::uint32>((abs&0x3FF)+((abs>0x3FF)<<10))<<21, 0xB8AA3B29);
+		int e = (abs>>10) + (abs<=0x3FF), exp;
+		if(e < 14)
+		{
+			exp = 0;
+			m >>= 14 - e;
+		}
+		else
+		{
+			exp = m >> (45-e);
+			m = (m<<(e-14)) & 0x7FFFFFFF;
+		}
+		m = detail::exp2(m);
+		if(sign)
+		{
+			int s = 0;
+			if(m > 0x80000000)
+			{
+				++exp;
+				m = detail::divide64(0x80000000, m, s);
+			}
+			m = 0x80000000 - ((m>>exp)|((m&((static_cast<detail::uint32>(1)<<exp)-1))!=0)|s);
+			exp = 0;
+		}
+		else
+			m -= (exp<31) ? (0x80000000>>exp) : 1;
+		for(exp+=14; m<0x80000000 && exp; m<<=1,--exp) ;
+		if(exp > 29)
+			return half(detail::binary, detail::overflow<half::round_style>());
+		return half(detail::binary, detail::rounded<half::round_style,true>(sign+(exp<<10)+(m>>21), (m>>20)&1, (m&0xFFFFF)!=0));
+	#endif
+	}
+
+	/// Natural logarithm.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::log](https://en.cppreference.com/w/cpp/numeric/math/log).
+	/// \param arg function argument
+	/// \return logarithm of \a arg to base e
+	/// \exception FE_INVALID for signaling NaN or negative argument
+	/// \exception FE_DIVBYZERO for 0
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half log(half arg)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		return half(detail::binary, detail::float2half<half::round_style>(std::log(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		int abs = arg.data_ & 0x7FFF, exp = -15;
+		if(!abs)
+			return half(detail::binary, detail::pole(0x8000));
+		if(arg.data_ & 0x8000)
+			return half(detail::binary, (arg.data_<=0xFC00) ? detail::invalid() : detail::signal(arg.data_));
+		if(abs >= 0x7C00)
+			return (abs==0x7C00) ? arg : half(detail::binary, detail::signal(arg.data_));
+		for(; abs<0x400; abs<<=1,--exp) ;
+		exp += abs >> 10;
+		return half(detail::binary, detail::log2_post<half::round_style,0xB8AA3B2A>(
+			detail::log2(static_cast<detail::uint32>((abs&0x3FF)|0x400)<<20, 27)+8, exp, 17));
+	#endif
+	}
+
+	/// Common logarithm.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::log10](https://en.cppreference.com/w/cpp/numeric/math/log10).
+	/// \param arg function argument
+	/// \return logarithm of \a arg to base 10
+	/// \exception FE_INVALID for signaling NaN or negative argument
+	/// \exception FE_DIVBYZERO for 0
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half log10(half arg)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		return half(detail::binary, detail::float2half<half::round_style>(std::log10(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		int abs = arg.data_ & 0x7FFF, exp = -15;
+		if(!abs)
+			return half(detail::binary, detail::pole(0x8000));
+		if(arg.data_ & 0x8000)
+			return half(detail::binary, (arg.data_<=0xFC00) ? detail::invalid() : detail::signal(arg.data_));
+		if(abs >= 0x7C00)
+			return (abs==0x7C00) ? arg : half(detail::binary, detail::signal(arg.data_));
+		switch(abs)
+		{
+			case 0x4900: return half(detail::binary, 0x3C00);
+			case 0x5640: return half(detail::binary, 0x4000);
+			case 0x63D0: return half(detail::binary, 0x4200);
+			case 0x70E2: return half(detail::binary, 0x4400);
+		}
+		for(; abs<0x400; abs<<=1,--exp) ;
+		exp += abs >> 10;
+		return half(detail::binary, detail::log2_post<half::round_style,0xD49A784C>(
+			detail::log2(static_cast<detail::uint32>((abs&0x3FF)|0x400)<<20, 27)+8, exp, 16));
+	#endif
+	}
+
+	/// Binary logarithm.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::log2](https://en.cppreference.com/w/cpp/numeric/math/log2).
+	/// \param arg function argument
+	/// \return logarithm of \a arg to base 2
+	/// \exception FE_INVALID for signaling NaN or negative argument
+	/// \exception FE_DIVBYZERO for 0
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half log2(half arg)
+	{
+	#if defined(HALF_ARITHMETIC_TYPE) && HALF_ENABLE_CPP11_CMATH
+		return half(detail::binary, detail::float2half<half::round_style>(std::log2(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		int abs = arg.data_ & 0x7FFF, exp = -15, s = 0;
+		if(!abs)
+			return half(detail::binary, detail::pole(0x8000));
+		if(arg.data_ & 0x8000)
+			return half(detail::binary, (arg.data_<=0xFC00) ? detail::invalid() : detail::signal(arg.data_));
+		if(abs >= 0x7C00)
+			return (abs==0x7C00) ? arg : half(detail::binary, detail::signal(arg.data_));
+		if(abs == 0x3C00)
+			return half(detail::binary, 0);
+		for(; abs<0x400; abs<<=1,--exp) ;
+		exp += (abs>>10);
+		if(!(abs&0x3FF))
+		{
+			unsigned int value = static_cast<unsigned>(exp<0) << 15, m = std::abs(exp) << 6;
+			for(exp=18; m<0x400; m<<=1,--exp) ;
+			return half(detail::binary, value+(exp<<10)+m);
+		}
+		detail::uint32 ilog = exp, sign = detail::sign_mask(ilog), m = 
+			(((ilog<<27)+(detail::log2(static_cast<detail::uint32>((abs&0x3FF)|0x400)<<20, 28)>>4))^sign) - sign;
+		if(!m)
+			return half(detail::binary, 0);
+		for(exp=14; m<0x8000000 && exp; m<<=1,--exp) ;
+		for(; m>0xFFFFFFF; m>>=1,++exp)
+			s |= m & 1;
+		return half(detail::binary, detail::fixed2half<half::round_style,27,false,false,true>(m, exp, sign&0x8000, s));
+	#endif
+	}
+
+	/// Natural logarithm plus one.
+	/// This function may be 1 ULP off the correctly rounded exact result in <0.05% of inputs for `std::round_to_nearest` 
+	/// and in ~1% of inputs for any other rounding mode.
+	///
+	/// **See also:** Documentation for [std::log1p](https://en.cppreference.com/w/cpp/numeric/math/log1p).
+	/// \param arg function argument
+	/// \return logarithm of \a arg plus 1 to base e
+	/// \exception FE_INVALID for signaling NaN or argument <-1
+	/// \exception FE_DIVBYZERO for -1
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half log1p(half arg)
+	{
+	#if defined(HALF_ARITHMETIC_TYPE) && HALF_ENABLE_CPP11_CMATH
+		return half(detail::binary, detail::float2half<half::round_style>(std::log1p(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		if(arg.data_ >= 0xBC00)
+			return half(detail::binary, (arg.data_==0xBC00) ? detail::pole(0x8000) : (arg.data_<=0xFC00) ? detail::invalid() : detail::signal(arg.data_));
+		int abs = arg.data_ & 0x7FFF, exp = -15;
+		if(!abs || abs >= 0x7C00)
+			return (abs>0x7C00) ? half(detail::binary, detail::signal(arg.data_)) : arg;
+		for(; abs<0x400; abs<<=1,--exp) ;
+		exp += abs >> 10;
+		detail::uint32 m = static_cast<detail::uint32>((abs&0x3FF)|0x400) << 20;
+		if(arg.data_ & 0x8000)
+		{
+			m = 0x40000000 - (m>>-exp);
+			for(exp=0; m<0x40000000; m<<=1,--exp) ;
+		}
+		else
+		{
+			if(exp < 0)
+			{
+				m = 0x40000000 + (m>>-exp);
+				exp = 0;
+			}
+			else
+			{
+				m += 0x40000000 >> exp;
+				int i = m >> 31;
+				m >>= i;
+				exp += i;
+			}
+		}
+		return half(detail::binary, detail::log2_post<half::round_style,0xB8AA3B2A>(detail::log2(m), exp, 17));
+	#endif
+	}
+
+	/// \}
+	/// \anchor power
+	/// \name Power functions
+	/// \{
+
+	/// Square root.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::sqrt](https://en.cppreference.com/w/cpp/numeric/math/sqrt).
+	/// \param arg function argument
+	/// \return square root of \a arg
+	/// \exception FE_INVALID for signaling NaN and negative arguments
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half sqrt(half arg)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		return half(detail::binary, detail::float2half<half::round_style>(std::sqrt(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		int abs = arg.data_ & 0x7FFF, exp = 15;
+		if(!abs || arg.data_ >= 0x7C00)
+			return half(detail::binary, (abs>0x7C00) ? detail::signal(arg.data_) : (arg.data_>0x8000) ? detail::invalid() : arg.data_);
+		for(; abs<0x400; abs<<=1,--exp) ;
+		detail::uint32 r = static_cast<detail::uint32>((abs&0x3FF)|0x400) << 10, m = detail::sqrt<20>(r, exp+=abs>>10);
+		return half(detail::binary, detail::rounded<half::round_style,false>((exp<<10)+(m&0x3FF), r>m, r!=0));
+	#endif
+	}
+
+	/// Cubic root.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::cbrt](https://en.cppreference.com/w/cpp/numeric/math/cbrt).
+	/// \param arg function argument
+	/// \return cubic root of \a arg
+	/// \exception FE_INVALID for signaling NaN
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half cbrt(half arg)
+	{
+	#if defined(HALF_ARITHMETIC_TYPE) && HALF_ENABLE_CPP11_CMATH
+		return half(detail::binary, detail::float2half<half::round_style>(std::cbrt(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		int abs = arg.data_ & 0x7FFF, exp = -15;
+		if(!abs || abs == 0x3C00 || abs >= 0x7C00)
+			return (abs>0x7C00) ? half(detail::binary, detail::signal(arg.data_)) : arg;
+		for(; abs<0x400; abs<<=1, --exp);
+		detail::uint32 ilog = exp + (abs>>10), sign = detail::sign_mask(ilog), f, m = 
+			(((ilog<<27)+(detail::log2(static_cast<detail::uint32>((abs&0x3FF)|0x400)<<20, 24)>>4))^sign) - sign;
+		for(exp=2; m<0x80000000; m<<=1,--exp) ;
+		m = detail::multiply64(m, 0xAAAAAAAB);
+		int i = m >> 31, s;
+		exp += i;
+		m <<= 1 - i;
+		if(exp < 0)
+		{
+			f = m >> -exp;
+			exp = 0;
+		}
+		else
+		{
+			f = (m<<exp) & 0x7FFFFFFF;
+			exp = m >> (31-exp);
+		}
+		m = detail::exp2(f, (half::round_style==std::round_to_nearest) ? 29 : 26);
+		if(sign)
+		{
+			if(m > 0x80000000)
+			{
+				m = detail::divide64(0x80000000, m, s);
+				++exp;
+			}
+			exp = -exp;
+		}
+		return half(detail::binary, (half::round_style==std::round_to_nearest) ?
+			detail::fixed2half<half::round_style,31,false,false,false>(m, exp+14, arg.data_&0x8000) :
+			detail::fixed2half<half::round_style,23,false,false,false>((m+0x80)>>8, exp+14, arg.data_&0x8000));
+	#endif
+	}
+
+	/// Hypotenuse function.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::hypot](https://en.cppreference.com/w/cpp/numeric/math/hypot).
+	/// \param x first argument
+	/// \param y second argument
+	/// \return square root of sum of squares without internal over- or underflows
+	/// \exception FE_INVALID if \a x or \a y is signaling NaN
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding of the final square root
+	inline half hypot(half x, half y)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		detail::internal_t fx = detail::half2float<detail::internal_t>(x.data_), fy = detail::half2float<detail::internal_t>(y.data_);
+		#if HALF_ENABLE_CPP11_CMATH
+			return half(detail::binary, detail::float2half<half::round_style>(std::hypot(fx, fy)));
+		#else
+			return half(detail::binary, detail::float2half<half::round_style>(std::sqrt(fx*fx+fy*fy)));
+		#endif
+	#else
+		int absx = x.data_ & 0x7FFF, absy = y.data_ & 0x7FFF, expx = 0, expy = 0;
+		if(absx >= 0x7C00 || absy >= 0x7C00)
+			return half(detail::binary,	(absx==0x7C00) ? detail::select(0x7C00, y.data_) :
+				(absy==0x7C00) ? detail::select(0x7C00, x.data_) : detail::signal(x.data_, y.data_));
+		if(!absx)
+			return half(detail::binary, absy ? detail::check_underflow(absy) : 0);
+		if(!absy)
+			return half(detail::binary, detail::check_underflow(absx));
+		if(absy > absx)
+			std::swap(absx, absy);
+		for(; absx<0x400; absx<<=1,--expx) ;
+		for(; absy<0x400; absy<<=1,--expy) ;
+		detail::uint32 mx = (absx&0x3FF) | 0x400, my = (absy&0x3FF) | 0x400;
+		mx *= mx;
+		my *= my;
+		int ix = mx >> 21, iy = my >> 21;
+		expx = 2*(expx+(absx>>10)) - 15 + ix;
+		expy = 2*(expy+(absy>>10)) - 15 + iy;
+		mx <<= 10 - ix;
+		my <<= 10 - iy;
+		int d = expx - expy;
+		my = (d<30) ? ((my>>d)|((my&((static_cast<detail::uint32>(1)<<d)-1))!=0)) : 1;
+		return half(detail::binary, detail::hypot_post<half::round_style>(mx+my, expx));
+	#endif
+	}
+
+	/// Hypotenuse function.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::hypot](https://en.cppreference.com/w/cpp/numeric/math/hypot).
+	/// \param x first argument
+	/// \param y second argument
+	/// \param z third argument
+	/// \return square root of sum of squares without internal over- or underflows
+	/// \exception FE_INVALID if \a x, \a y or \a z is signaling NaN
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding of the final square root
+	inline half hypot(half x, half y, half z)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		detail::internal_t fx = detail::half2float<detail::internal_t>(x.data_), fy = detail::half2float<detail::internal_t>(y.data_), fz = detail::half2float<detail::internal_t>(z.data_);
+		return half(detail::binary, detail::float2half<half::round_style>(std::sqrt(fx*fx+fy*fy+fz*fz)));
+	#else
+		int absx = x.data_ & 0x7FFF, absy = y.data_ & 0x7FFF, absz = z.data_ & 0x7FFF, expx = 0, expy = 0, expz = 0;
+		if(!absx)
+			return hypot(y, z);
+		if(!absy)
+			return hypot(x, z);
+		if(!absz)
+			return hypot(x, y);
+		if(absx >= 0x7C00 || absy >= 0x7C00 || absz >= 0x7C00)
+			return half(detail::binary,	(absx==0x7C00) ? detail::select(0x7C00, detail::select(y.data_, z.data_)) :
+										(absy==0x7C00) ? detail::select(0x7C00, detail::select(x.data_, z.data_)) :
+										(absz==0x7C00) ? detail::select(0x7C00, detail::select(x.data_, y.data_)) :
+										detail::signal(x.data_, y.data_, z.data_));
+		if(absz > absy)
+			std::swap(absy, absz);
+		if(absy > absx)
+			std::swap(absx, absy);
+		if(absz > absy)
+			std::swap(absy, absz);
+		for(; absx<0x400; absx<<=1,--expx) ;
+		for(; absy<0x400; absy<<=1,--expy) ;
+		for(; absz<0x400; absz<<=1,--expz) ;
+		detail::uint32 mx = (absx&0x3FF) | 0x400, my = (absy&0x3FF) | 0x400, mz = (absz&0x3FF) | 0x400;
+		mx *= mx;
+		my *= my;
+		mz *= mz;
+		int ix = mx >> 21, iy = my >> 21, iz = mz >> 21;
+		expx = 2*(expx+(absx>>10)) - 15 + ix;
+		expy = 2*(expy+(absy>>10)) - 15 + iy;
+		expz = 2*(expz+(absz>>10)) - 15 + iz;
+		mx <<= 10 - ix;
+		my <<= 10 - iy;
+		mz <<= 10 - iz;
+		int d = expy - expz;
+		mz = (d<30) ? ((mz>>d)|((mz&((static_cast<detail::uint32>(1)<<d)-1))!=0)) : 1;
+		my += mz;
+		if(my & 0x80000000)
+		{
+			my = (my>>1) | (my&1);
+			if(++expy > expx)
+			{
+				std::swap(mx, my);
+				std::swap(expx, expy);
+			}
+		}
+		d = expx - expy;
+		my = (d<30) ? ((my>>d)|((my&((static_cast<detail::uint32>(1)<<d)-1))!=0)) : 1;
+		return half(detail::binary, detail::hypot_post<half::round_style>(mx+my, expx));
+	#endif
+	}
+
+	/// Power function.
+	/// This function may be 1 ULP off the correctly rounded exact result for any rounding mode in ~0.00025% of inputs.
+	///
+	/// **See also:** Documentation for [std::pow](https://en.cppreference.com/w/cpp/numeric/math/pow).
+	/// \param x base
+	/// \param y exponent
+	/// \return \a x raised to \a y
+	/// \exception FE_INVALID if \a x or \a y is signaling NaN or if \a x is finite an negative and \a y is finite and not integral
+	/// \exception FE_DIVBYZERO if \a x is 0 and \a y is negative
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half pow(half x, half y)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		return half(detail::binary, detail::float2half<half::round_style>(std::pow(detail::half2float<detail::internal_t>(x.data_), detail::half2float<detail::internal_t>(y.data_))));
+	#else
+		int absx = x.data_ & 0x7FFF, absy = y.data_ & 0x7FFF, exp = -15;
+		if(!absy || x.data_ == 0x3C00)
+			return half(detail::binary, detail::select(0x3C00, (x.data_==0x3C00) ? y.data_ : x.data_));
+		bool is_int = absy >= 0x6400 || (absy>=0x3C00 && !(absy&((1<<(25-(absy>>10)))-1)));
+		unsigned int sign = x.data_ & (static_cast<unsigned>((absy<0x6800)&&is_int&&((absy>>(25-(absy>>10)))&1))<<15);
+		if(absx >= 0x7C00 || absy >= 0x7C00)
+			return half(detail::binary,	(absx>0x7C00 || absy>0x7C00) ? detail::signal(x.data_, y.data_) :
+										(absy==0x7C00) ? ((absx==0x3C00) ? 0x3C00 : (!absx && y.data_==0xFC00) ? detail::pole() :
+										(0x7C00&-((y.data_>>15)^(absx>0x3C00)))) : (sign|(0x7C00&((y.data_>>15)-1U))));
+		if(!absx)
+			return half(detail::binary, (y.data_&0x8000) ? detail::pole(sign) : sign);
+		if((x.data_&0x8000) && !is_int)
+			return half(detail::binary, detail::invalid());
+		if(x.data_ == 0xBC00)
+			return half(detail::binary, sign|0x3C00);
+		if(y.data_ == 0x3800)
+			return sqrt(x);
+		if(y.data_ == 0x3C00)
+			return half(detail::binary, detail::check_underflow(x.data_));
+		if(y.data_ == 0x4000)
+			return x * x;
+		for(; absx<0x400; absx<<=1,--exp) ;
+		detail::uint32 ilog = exp + (absx>>10), msign = detail::sign_mask(ilog), f, m = 
+			(((ilog<<27)+((detail::log2(static_cast<detail::uint32>((absx&0x3FF)|0x400)<<20)+8)>>4))^msign) - msign;
+		for(exp=-11; m<0x80000000; m<<=1,--exp) ;
+		for(; absy<0x400; absy<<=1,--exp) ;
+		m = detail::multiply64(m, static_cast<detail::uint32>((absy&0x3FF)|0x400)<<21);
+		int i = m >> 31;
+		exp += (absy>>10) + i;
+		m <<= 1 - i;
+		if(exp < 0)
+		{
+			f = m >> -exp;
+			exp = 0;
+		}
+		else
+		{
+			f = (m<<exp) & 0x7FFFFFFF;
+			exp = m >> (31-exp);
+		}
+		return half(detail::binary, detail::exp2_post<half::round_style,false>(detail::exp2(f), exp, ((msign&1)^(y.data_>>15))!=0, sign));
+	#endif
+	}
+
+	/// \}
+	/// \anchor trigonometric
+	/// \name Trigonometric functions
+	/// \{
+
+	/// Compute sine and cosine simultaneously.
+	///	This returns the same results as sin() and cos() but is faster than calling each function individually.
+	///
+	/// This function is exact to rounding for all rounding modes.
+	/// \param arg function argument
+	/// \param sin variable to take sine of \a arg
+	/// \param cos variable to take cosine of \a arg
+	/// \exception FE_INVALID for signaling NaN or infinity
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline void sincos(half arg, half *sin, half *cos)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		detail::internal_t f = detail::half2float<detail::internal_t>(arg.data_);
+		*sin = half(detail::binary, detail::float2half<half::round_style>(std::sin(f)));
+		*cos = half(detail::binary, detail::float2half<half::round_style>(std::cos(f)));
+	#else
+		int abs = arg.data_ & 0x7FFF, sign = arg.data_ >> 15, k;
+		if(abs >= 0x7C00)
+			*sin = *cos = half(detail::binary, (abs==0x7C00) ? detail::invalid() : detail::signal(arg.data_));
+		else if(!abs)
+		{
+			*sin = arg;
+			*cos = half(detail::binary, 0x3C00);
+		}
+		else if(abs < 0x2500)
+		{
+			*sin = half(detail::binary, detail::rounded<half::round_style,true>(arg.data_-1, 1, 1));
+			*cos = half(detail::binary, detail::rounded<half::round_style,true>(0x3BFF, 1, 1));
+		}
+		else
+		{
+			if(half::round_style != std::round_to_nearest)
+			{
+				switch(abs)
+				{
+				case 0x48B7:
+					*sin = half(detail::binary, detail::rounded<half::round_style,true>((~arg.data_&0x8000)|0x1D07, 1, 1));
+					*cos = half(detail::binary, detail::rounded<half::round_style,true>(0xBBFF, 1, 1));
+					return;
+				case 0x598C:
+					*sin = half(detail::binary, detail::rounded<half::round_style,true>((arg.data_&0x8000)|0x3BFF, 1, 1));
+					*cos = half(detail::binary, detail::rounded<half::round_style,true>(0x80FC, 1, 1));
+					return;
+				case 0x6A64:
+					*sin = half(detail::binary, detail::rounded<half::round_style,true>((~arg.data_&0x8000)|0x3BFE, 1, 1));
+					*cos = half(detail::binary, detail::rounded<half::round_style,true>(0x27FF, 1, 1));
+					return;
+				case 0x6D8C:
+					*sin = half(detail::binary, detail::rounded<half::round_style,true>((arg.data_&0x8000)|0x0FE6, 1, 1));
+					*cos = half(detail::binary, detail::rounded<half::round_style,true>(0x3BFF, 1, 1));
+					return;
+				}
+			}
+			std::pair<detail::uint32,detail::uint32> sc = detail::sincos(detail::angle_arg(abs, k), 28);
+			switch(k & 3)
+			{
+				case 1: sc = std::make_pair(sc.second, -sc.first); break;
+				case 2: sc = std::make_pair(-sc.first, -sc.second); break;
+				case 3: sc = std::make_pair(-sc.second, sc.first); break;
+			}
+			*sin = half(detail::binary, detail::fixed2half<half::round_style,30,true,true,true>((sc.first^-static_cast<detail::uint32>(sign))+sign));
+			*cos = half(detail::binary, detail::fixed2half<half::round_style,30,true,true,true>(sc.second));
+		}
+	#endif
+	}
+
+	/// Sine function.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::sin](https://en.cppreference.com/w/cpp/numeric/math/sin).
+	/// \param arg function argument
+	/// \return sine value of \a arg
+	/// \exception FE_INVALID for signaling NaN or infinity
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half sin(half arg)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		return half(detail::binary, detail::float2half<half::round_style>(std::sin(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		int abs = arg.data_ & 0x7FFF, k;
+		if(!abs)
+			return arg;
+		if(abs >= 0x7C00)
+			return half(detail::binary, (abs==0x7C00) ? detail::invalid() : detail::signal(arg.data_));
+		if(abs < 0x2900)
+			return half(detail::binary, detail::rounded<half::round_style,true>(arg.data_-1, 1, 1));
+		if(half::round_style != std::round_to_nearest)
+			switch(abs)
+			{
+				case 0x48B7: return half(detail::binary, detail::rounded<half::round_style,true>((~arg.data_&0x8000)|0x1D07, 1, 1));
+				case 0x6A64: return half(detail::binary, detail::rounded<half::round_style,true>((~arg.data_&0x8000)|0x3BFE, 1, 1));
+				case 0x6D8C: return half(detail::binary, detail::rounded<half::round_style,true>((arg.data_&0x8000)|0x0FE6, 1, 1));
+			}
+		std::pair<detail::uint32,detail::uint32> sc = detail::sincos(detail::angle_arg(abs, k), 28);
+		detail::uint32 sign = -static_cast<detail::uint32>(((k>>1)&1)^(arg.data_>>15));
+		return half(detail::binary, detail::fixed2half<half::round_style,30,true,true,true>((((k&1) ? sc.second : sc.first)^sign) - sign));
+	#endif
+	}
+
+	/// Cosine function.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::cos](https://en.cppreference.com/w/cpp/numeric/math/cos).
+	/// \param arg function argument
+	/// \return cosine value of \a arg
+	/// \exception FE_INVALID for signaling NaN or infinity
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half cos(half arg)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		return half(detail::binary, detail::float2half<half::round_style>(std::cos(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		int abs = arg.data_ & 0x7FFF, k;
+		if(!abs)
+			return half(detail::binary, 0x3C00);
+		if(abs >= 0x7C00)
+			return half(detail::binary, (abs==0x7C00) ? detail::invalid() : detail::signal(arg.data_));
+		if(abs < 0x2500)
+			return half(detail::binary, detail::rounded<half::round_style,true>(0x3BFF, 1, 1));
+		if(half::round_style != std::round_to_nearest && abs == 0x598C)
+			return half(detail::binary, detail::rounded<half::round_style,true>(0x80FC, 1, 1));
+		std::pair<detail::uint32,detail::uint32> sc = detail::sincos(detail::angle_arg(abs, k), 28);
+		detail::uint32 sign = -static_cast<detail::uint32>(((k>>1)^k)&1);
+		return half(detail::binary, detail::fixed2half<half::round_style,30,true,true,true>((((k&1) ? sc.first : sc.second)^sign) - sign));
+	#endif
+	}
+
+	/// Tangent function.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::tan](https://en.cppreference.com/w/cpp/numeric/math/tan).
+	/// \param arg function argument
+	/// \return tangent value of \a arg
+	/// \exception FE_INVALID for signaling NaN or infinity
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half tan(half arg)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		return half(detail::binary, detail::float2half<half::round_style>(std::tan(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		int abs = arg.data_ & 0x7FFF, exp = 13, k;
+		if(!abs)
+			return arg;
+		if(abs >= 0x7C00)
+			return half(detail::binary, (abs==0x7C00) ? detail::invalid() : detail::signal(arg.data_));
+		if(abs < 0x2700)
+			return half(detail::binary, detail::rounded<half::round_style,true>(arg.data_, 0, 1));
+		if(half::round_style != std::round_to_nearest)
+			switch(abs)
+			{
+				case 0x658C: return half(detail::binary, detail::rounded<half::round_style,true>((arg.data_&0x8000)|0x07E6, 1, 1));
+				case 0x7330: return half(detail::binary, detail::rounded<half::round_style,true>((~arg.data_&0x8000)|0x4B62, 1, 1));
+			}
+		std::pair<detail::uint32,detail::uint32> sc = detail::sincos(detail::angle_arg(abs, k), 30);
+		if(k & 1)
+			sc = std::make_pair(-sc.second, sc.first);
+		detail::uint32 signy = detail::sign_mask(sc.first), signx = detail::sign_mask(sc.second);
+		detail::uint32 my = (sc.first^signy) - signy, mx = (sc.second^signx) - signx;
+		for(; my<0x80000000; my<<=1,--exp) ;
+		for(; mx<0x80000000; mx<<=1,++exp) ;
+		return half(detail::binary, detail::tangent_post<half::round_style>(my, mx, exp, (signy^signx^arg.data_)&0x8000));
+	#endif
+	}
+
+	/// Arc sine.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::asin](https://en.cppreference.com/w/cpp/numeric/math/asin).
+	/// \param arg function argument
+	/// \return arc sine value of \a arg
+	/// \exception FE_INVALID for signaling NaN or if abs(\a arg) > 1
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half asin(half arg)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		return half(detail::binary, detail::float2half<half::round_style>(std::asin(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		unsigned int abs = arg.data_ & 0x7FFF, sign = arg.data_ & 0x8000;
+		if(!abs)
+			return arg;
+		if(abs >= 0x3C00)
+			return half(detail::binary, (abs>0x7C00) ? detail::signal(arg.data_) : (abs>0x3C00) ? detail::invalid() :
+										detail::rounded<half::round_style,true>(sign|0x3E48, 0, 1));
+		if(abs < 0x2900)
+			return half(detail::binary, detail::rounded<half::round_style,true>(arg.data_, 0, 1));
+		if(half::round_style != std::round_to_nearest && (abs == 0x2B44 || abs == 0x2DC3))
+			return half(detail::binary, detail::rounded<half::round_style,true>(arg.data_+1, 1, 1));
+		std::pair<detail::uint32,detail::uint32> sc = detail::atan2_args(abs);
+		detail::uint32 m = detail::atan2(sc.first, sc.second, (half::round_style==std::round_to_nearest) ? 27 : 26);
+		return half(detail::binary, detail::fixed2half<half::round_style,30,false,true,true>(m, 14, sign));
+	#endif
+	}
+
+	/// Arc cosine function.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::acos](https://en.cppreference.com/w/cpp/numeric/math/acos).
+	/// \param arg function argument
+	/// \return arc cosine value of \a arg
+	/// \exception FE_INVALID for signaling NaN or if abs(\a arg) > 1
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half acos(half arg)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		return half(detail::binary, detail::float2half<half::round_style>(std::acos(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		unsigned int abs = arg.data_ & 0x7FFF, sign = arg.data_ >> 15;
+		if(!abs)
+			return half(detail::binary, detail::rounded<half::round_style,true>(0x3E48, 0, 1));
+		if(abs >= 0x3C00)
+			return half(detail::binary,	(abs>0x7C00) ? detail::signal(arg.data_) : (abs>0x3C00) ? detail::invalid() :
+										sign ? detail::rounded<half::round_style,true>(0x4248, 0, 1) : 0);
+		std::pair<detail::uint32,detail::uint32> cs = detail::atan2_args(abs);
+		detail::uint32 m = detail::atan2(cs.second, cs.first, 28);
+		return half(detail::binary, detail::fixed2half<half::round_style,31,false,true,true>(sign ? (0xC90FDAA2-m) : m, 15, 0, sign));
+	#endif
+	}
+
+	/// Arc tangent function.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::atan](https://en.cppreference.com/w/cpp/numeric/math/atan).
+	/// \param arg function argument
+	/// \return arc tangent value of \a arg
+	/// \exception FE_INVALID for signaling NaN
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half atan(half arg)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		return half(detail::binary, detail::float2half<half::round_style>(std::atan(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		unsigned int abs = arg.data_ & 0x7FFF, sign = arg.data_ & 0x8000;
+		if(!abs)
+			return arg;
+		if(abs >= 0x7C00)
+			return half(detail::binary, (abs==0x7C00) ? detail::rounded<half::round_style,true>(sign|0x3E48, 0, 1) : detail::signal(arg.data_));
+		if(abs <= 0x2700)
+			return half(detail::binary, detail::rounded<half::round_style,true>(arg.data_-1, 1, 1));
+		int exp = (abs>>10) + (abs<=0x3FF);
+		detail::uint32 my = (abs&0x3FF) | ((abs>0x3FF)<<10);
+		detail::uint32 m = (exp>15) ?	detail::atan2(my<<19, 0x20000000>>(exp-15), (half::round_style==std::round_to_nearest) ? 26 : 24) :
+										detail::atan2(my<<(exp+4), 0x20000000, (half::round_style==std::round_to_nearest) ? 30 : 28);
+		return half(detail::binary, detail::fixed2half<half::round_style,30,false,true,true>(m, 14, sign));
+	#endif
+	}
+
+	/// Arc tangent function.
+	/// This function may be 1 ULP off the correctly rounded exact result in ~0.005% of inputs for `std::round_to_nearest`, 
+	/// in ~0.1% of inputs for `std::round_toward_zero` and in ~0.02% of inputs for any other rounding mode.
+	///
+	/// **See also:** Documentation for [std::atan2](https://en.cppreference.com/w/cpp/numeric/math/atan2).
+	/// \param y numerator
+	/// \param x denominator
+	/// \return arc tangent value
+	/// \exception FE_INVALID if \a x or \a y is signaling NaN
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half atan2(half y, half x)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		return half(detail::binary, detail::float2half<half::round_style>(std::atan2(detail::half2float<detail::internal_t>(y.data_), detail::half2float<detail::internal_t>(x.data_))));
+	#else
+		unsigned int absx = x.data_ & 0x7FFF, absy = y.data_ & 0x7FFF, signx = x.data_ >> 15, signy = y.data_ & 0x8000;
+		if(absx >= 0x7C00 || absy >= 0x7C00)
+		{
+			if(absx > 0x7C00 || absy > 0x7C00)
+				return half(detail::binary, detail::signal(x.data_, y.data_));
+			if(absy == 0x7C00)
+				return half(detail::binary, (absx<0x7C00) ?	detail::rounded<half::round_style,true>(signy|0x3E48, 0, 1) :
+													signx ?	detail::rounded<half::round_style,true>(signy|0x40B6, 0, 1) :
+															detail::rounded<half::round_style,true>(signy|0x3A48, 0, 1));
+			return (x.data_==0x7C00) ? half(detail::binary, signy) : half(detail::binary, detail::rounded<half::round_style,true>(signy|0x4248, 0, 1));
+		}
+		if(!absy)
+			return signx ? half(detail::binary, detail::rounded<half::round_style,true>(signy|0x4248, 0, 1)) : y;
+		if(!absx)
+			return half(detail::binary, detail::rounded<half::round_style,true>(signy|0x3E48, 0, 1));
+		int d = (absy>>10) + (absy<=0x3FF) - (absx>>10) - (absx<=0x3FF);
+		if(d > (signx ? 18 : 12))
+			return half(detail::binary, detail::rounded<half::round_style,true>(signy|0x3E48, 0, 1));
+		if(signx && d < -11)
+			return half(detail::binary, detail::rounded<half::round_style,true>(signy|0x4248, 0, 1));
+		if(!signx && d < ((half::round_style==std::round_toward_zero) ? -15 : -9))
+		{
+			for(; absy<0x400; absy<<=1,--d) ;
+			detail::uint32 mx = ((absx<<1)&0x7FF) | 0x800, my = ((absy<<1)&0x7FF) | 0x800;
+			int i = my < mx;
+			d -= i;
+			if(d < -25)
+				return half(detail::binary, detail::underflow<half::round_style>(signy));
+			my <<= 11 + i;
+			return half(detail::binary, detail::fixed2half<half::round_style,11,false,false,true>(my/mx, d+14, signy, my%mx!=0));
+		}
+		detail::uint32 m = detail::atan2(	((absy&0x3FF)|((absy>0x3FF)<<10))<<(19+((d<0) ? d : (d>0) ? 0 : -1)),
+											((absx&0x3FF)|((absx>0x3FF)<<10))<<(19-((d>0) ? d : (d<0) ? 0 : 1)));
+		return half(detail::binary, detail::fixed2half<half::round_style,31,false,true,true>(signx ? (0xC90FDAA2-m) : m, 15, signy, signx));
+	#endif
+	}
+
+	/// \}
+	/// \anchor hyperbolic
+	/// \name Hyperbolic functions
+	/// \{
+
+	/// Hyperbolic sine.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::sinh](https://en.cppreference.com/w/cpp/numeric/math/sinh).
+	/// \param arg function argument
+	/// \return hyperbolic sine value of \a arg
+	/// \exception FE_INVALID for signaling NaN
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half sinh(half arg)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		return half(detail::binary, detail::float2half<half::round_style>(std::sinh(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		int abs = arg.data_ & 0x7FFF, exp;
+		if(!abs || abs >= 0x7C00)
+			return (abs>0x7C00) ? half(detail::binary, detail::signal(arg.data_)) : arg;
+		if(abs <= 0x2900)
+			return half(detail::binary, detail::rounded<half::round_style,true>(arg.data_, 0, 1));
+		std::pair<detail::uint32,detail::uint32> mm = detail::hyperbolic_args(abs, exp, (half::round_style==std::round_to_nearest) ? 29 : 27);
+		detail::uint32 m = mm.first - mm.second;
+		for(exp+=13; m<0x80000000 && exp; m<<=1,--exp) ;
+		unsigned int sign = arg.data_ & 0x8000;
+		if(exp > 29)
+			return half(detail::binary, detail::overflow<half::round_style>(sign));
+		return half(detail::binary, detail::fixed2half<half::round_style,31,false,false,true>(m, exp, sign));
+	#endif
+	}
+
+	/// Hyperbolic cosine.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::cosh](https://en.cppreference.com/w/cpp/numeric/math/cosh).
+	/// \param arg function argument
+	/// \return hyperbolic cosine value of \a arg
+	/// \exception FE_INVALID for signaling NaN
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half cosh(half arg)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		return half(detail::binary, detail::float2half<half::round_style>(std::cosh(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		int abs = arg.data_ & 0x7FFF, exp;
+		if(!abs)
+			return half(detail::binary, 0x3C00);
+		if(abs >= 0x7C00)
+			return half(detail::binary, (abs>0x7C00) ? detail::signal(arg.data_) : 0x7C00);
+		std::pair<detail::uint32,detail::uint32> mm = detail::hyperbolic_args(abs, exp, (half::round_style==std::round_to_nearest) ? 23 : 26);
+		detail::uint32 m = mm.first + mm.second, i = (~m&0xFFFFFFFF) >> 31;
+		m = (m>>i) | (m&i) | 0x80000000;
+		if((exp+=13+i) > 29)
+			return half(detail::binary, detail::overflow<half::round_style>());
+		return half(detail::binary, detail::fixed2half<half::round_style,31,false,false,true>(m, exp));
+	#endif
+	}
+
+	/// Hyperbolic tangent.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::tanh](https://en.cppreference.com/w/cpp/numeric/math/tanh).
+	/// \param arg function argument
+	/// \return hyperbolic tangent value of \a arg
+	/// \exception FE_INVALID for signaling NaN
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half tanh(half arg)
+	{
+	#ifdef HALF_ARITHMETIC_TYPE
+		return half(detail::binary, detail::float2half<half::round_style>(std::tanh(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		int abs = arg.data_ & 0x7FFF, exp;
+		if(!abs)
+			return arg;
+		if(abs >= 0x7C00)
+			return half(detail::binary, (abs>0x7C00) ? detail::signal(arg.data_) : (arg.data_-0x4000));
+		if(abs >= 0x4500)
+			return half(detail::binary, detail::rounded<half::round_style,true>((arg.data_&0x8000)|0x3BFF, 1, 1));
+		if(abs < 0x2700)
+			return half(detail::binary, detail::rounded<half::round_style,true>(arg.data_-1, 1, 1));
+		if(half::round_style != std::round_to_nearest && abs == 0x2D3F)
+			return half(detail::binary, detail::rounded<half::round_style,true>(arg.data_-3, 0, 1));
+		std::pair<detail::uint32,detail::uint32> mm = detail::hyperbolic_args(abs, exp, 27);
+		detail::uint32 my = mm.first - mm.second - (half::round_style!=std::round_to_nearest), mx = mm.first + mm.second, i = (~mx&0xFFFFFFFF) >> 31;
+		for(exp=13; my<0x80000000; my<<=1,--exp) ;
+		mx = (mx>>i) | 0x80000000;
+		return half(detail::binary, detail::tangent_post<half::round_style>(my, mx, exp-i, arg.data_&0x8000));
+	#endif
+	}
+
+	/// Hyperbolic area sine.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::asinh](https://en.cppreference.com/w/cpp/numeric/math/asinh).
+	/// \param arg function argument
+	/// \return area sine value of \a arg
+	/// \exception FE_INVALID for signaling NaN
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half asinh(half arg)
+	{
+	#if defined(HALF_ARITHMETIC_TYPE) && HALF_ENABLE_CPP11_CMATH
+		return half(detail::binary, detail::float2half<half::round_style>(std::asinh(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		int abs = arg.data_ & 0x7FFF;
+		if(!abs || abs >= 0x7C00)
+			return (abs>0x7C00) ? half(detail::binary, detail::signal(arg.data_)) : arg;
+		if(abs <= 0x2900)
+			return half(detail::binary, detail::rounded<half::round_style,true>(arg.data_-1, 1, 1));
+		if(half::round_style != std::round_to_nearest)
+			switch(abs)
+			{
+				case 0x32D4: return half(detail::binary, detail::rounded<half::round_style,true>(arg.data_-13, 1, 1));
+				case 0x3B5B: return half(detail::binary, detail::rounded<half::round_style,true>(arg.data_-197, 1, 1));
+			}
+		return half(detail::binary, detail::area<half::round_style,true>(arg.data_));
+	#endif
+	}
+
+	/// Hyperbolic area cosine.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::acosh](https://en.cppreference.com/w/cpp/numeric/math/acosh).
+	/// \param arg function argument
+	/// \return area cosine value of \a arg
+	/// \exception FE_INVALID for signaling NaN or arguments <1
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half acosh(half arg)
+	{
+	#if defined(HALF_ARITHMETIC_TYPE) && HALF_ENABLE_CPP11_CMATH
+		return half(detail::binary, detail::float2half<half::round_style>(std::acosh(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		int abs = arg.data_ & 0x7FFF;
+		if((arg.data_&0x8000) || abs < 0x3C00)
+			return half(detail::binary, (abs<=0x7C00) ? detail::invalid() : detail::signal(arg.data_));
+		if(abs == 0x3C00)
+			return half(detail::binary, 0);
+		if(arg.data_ >= 0x7C00)
+			return (abs>0x7C00) ? half(detail::binary, detail::signal(arg.data_)) : arg;
+		return half(detail::binary, detail::area<half::round_style,false>(arg.data_));
+	#endif
+	}
+
+	/// Hyperbolic area tangent.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::atanh](https://en.cppreference.com/w/cpp/numeric/math/atanh).
+	/// \param arg function argument
+	/// \return area tangent value of \a arg
+	/// \exception FE_INVALID for signaling NaN or if abs(\a arg) > 1
+	/// \exception FE_DIVBYZERO for +/-1
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half atanh(half arg)
+	{
+	#if defined(HALF_ARITHMETIC_TYPE) && HALF_ENABLE_CPP11_CMATH
+		return half(detail::binary, detail::float2half<half::round_style>(std::atanh(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		int abs = arg.data_ & 0x7FFF, exp = 0;
+		if(!abs)
+			return arg;
+		if(abs >= 0x3C00)
+			return half(detail::binary, (abs==0x3C00) ? detail::pole(arg.data_&0x8000) : (abs<=0x7C00) ? detail::invalid() : detail::signal(arg.data_));
+		if(abs < 0x2700)
+			return half(detail::binary, detail::rounded<half::round_style,true>(arg.data_, 0, 1));
+		detail::uint32 m = static_cast<detail::uint32>((abs&0x3FF)|((abs>0x3FF)<<10)) << ((abs>>10)+(abs<=0x3FF)+6), my = 0x80000000 + m, mx = 0x80000000 - m;
+		for(; mx<0x80000000; mx<<=1,++exp) ;
+		int i = my >= mx, s;
+		return half(detail::binary, detail::log2_post<half::round_style,0xB8AA3B2A>(detail::log2(
+			(detail::divide64(my>>i, mx, s)+1)>>1, 27)+0x10, exp+i-1, 16, arg.data_&0x8000));
+	#endif
+	}
+
+	/// \}
+	/// \anchor special
+	/// \name Error and gamma functions
+	/// \{
+
+	/// Error function.
+	/// This function may be 1 ULP off the correctly rounded exact result for any rounding mode in <0.5% of inputs.
+	///
+	/// **See also:** Documentation for [std::erf](https://en.cppreference.com/w/cpp/numeric/math/erf).
+	/// \param arg function argument
+	/// \return error function value of \a arg
+	/// \exception FE_INVALID for signaling NaN
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half erf(half arg)
+	{
+	#if defined(HALF_ARITHMETIC_TYPE) && HALF_ENABLE_CPP11_CMATH
+		return half(detail::binary, detail::float2half<half::round_style>(std::erf(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		unsigned int abs = arg.data_ & 0x7FFF;
+		if(!abs || abs >= 0x7C00)
+			return (abs>=0x7C00) ? half(detail::binary, (abs==0x7C00) ? (arg.data_-0x4000) : detail::signal(arg.data_)) : arg;
+		if(abs >= 0x4200)
+			return half(detail::binary, detail::rounded<half::round_style,true>((arg.data_&0x8000)|0x3BFF, 1, 1));
+		return half(detail::binary, detail::erf<half::round_style,false>(arg.data_));
+	#endif
+	}
+
+	/// Complementary error function.
+	/// This function may be 1 ULP off the correctly rounded exact result for any rounding mode in <0.5% of inputs.
+	///
+	/// **See also:** Documentation for [std::erfc](https://en.cppreference.com/w/cpp/numeric/math/erfc).
+	/// \param arg function argument
+	/// \return 1 minus error function value of \a arg
+	/// \exception FE_INVALID for signaling NaN
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half erfc(half arg)
+	{
+	#if defined(HALF_ARITHMETIC_TYPE) && HALF_ENABLE_CPP11_CMATH
+		return half(detail::binary, detail::float2half<half::round_style>(std::erfc(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		unsigned int abs = arg.data_ & 0x7FFF, sign = arg.data_ & 0x8000;
+		if(abs >= 0x7C00)
+			return (abs>=0x7C00) ? half(detail::binary, (abs==0x7C00) ? (sign>>1) : detail::signal(arg.data_)) : arg;
+		if(!abs)
+			return half(detail::binary, 0x3C00);
+		if(abs >= 0x4400)
+			return half(detail::binary, detail::rounded<half::round_style,true>((sign>>1)-(sign>>15), sign>>15, 1));
+		return half(detail::binary, detail::erf<half::round_style,true>(arg.data_));
+	#endif
+	}
+
+	/// Natural logarithm of gamma function.
+	/// This function may be 1 ULP off the correctly rounded exact result for any rounding mode in ~0.025% of inputs.
+	///
+	/// **See also:** Documentation for [std::lgamma](https://en.cppreference.com/w/cpp/numeric/math/lgamma).
+	/// \param arg function argument
+	/// \return natural logarith of gamma function for \a arg
+	/// \exception FE_INVALID for signaling NaN
+	/// \exception FE_DIVBYZERO for 0 or negative integer arguments
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half lgamma(half arg)
+	{
+	#if defined(HALF_ARITHMETIC_TYPE) && HALF_ENABLE_CPP11_CMATH
+		return half(detail::binary, detail::float2half<half::round_style>(std::lgamma(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		int abs = arg.data_ & 0x7FFF;
+		if(abs >= 0x7C00)
+			return half(detail::binary, (abs==0x7C00) ? 0x7C00 : detail::signal(arg.data_));
+		if(!abs || arg.data_ >= 0xE400 || (arg.data_ >= 0xBC00 && !(abs&((1<<(25-(abs>>10)))-1))))
+			return half(detail::binary, detail::pole());
+		if(arg.data_ == 0x3C00 || arg.data_ == 0x4000)
+			return half(detail::binary, 0);
+		return half(detail::binary, detail::gamma<half::round_style,true>(arg.data_));
+	#endif
+	}
+
+	/// Gamma function.
+	/// This function may be 1 ULP off the correctly rounded exact result for any rounding mode in <0.25% of inputs.
+	///
+	/// **See also:** Documentation for [std::tgamma](https://en.cppreference.com/w/cpp/numeric/math/tgamma).
+	/// \param arg function argument
+	/// \return gamma function value of \a arg
+	/// \exception FE_INVALID for signaling NaN, negative infinity or negative integer arguments
+	/// \exception FE_DIVBYZERO for 0
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half tgamma(half arg)
+	{
+	#if defined(HALF_ARITHMETIC_TYPE) && HALF_ENABLE_CPP11_CMATH
+		return half(detail::binary, detail::float2half<half::round_style>(std::tgamma(detail::half2float<detail::internal_t>(arg.data_))));
+	#else
+		unsigned int abs = arg.data_ & 0x7FFF;
+		if(!abs)
+			return half(detail::binary, detail::pole(arg.data_));
+		if(abs >= 0x7C00)
+			return (arg.data_==0x7C00) ? arg : half(detail::binary, detail::signal(arg.data_));
+		if(arg.data_ >= 0xE400 || (arg.data_ >= 0xBC00 && !(abs&((1<<(25-(abs>>10)))-1))))
+			return half(detail::binary, detail::invalid());
+		if(arg.data_ >= 0xCA80)
+			return half(detail::binary, detail::underflow<half::round_style>((1-((abs>>(25-(abs>>10)))&1))<<15));
+		if(arg.data_ <= 0x100 || (arg.data_ >= 0x4900 && arg.data_ < 0x8000))
+			return half(detail::binary, detail::overflow<half::round_style>());
+		if(arg.data_ == 0x3C00)
+			return arg;
+		return half(detail::binary, detail::gamma<half::round_style,false>(arg.data_));
+	#endif
+	}
+
+	/// \}
+	/// \anchor rounding
+	/// \name Rounding
+	/// \{
+
+	/// Nearest integer not less than half value.
+	/// **See also:** Documentation for [std::ceil](https://en.cppreference.com/w/cpp/numeric/math/ceil).
+	/// \param arg half to round
+	/// \return nearest integer not less than \a arg
+	/// \exception FE_INVALID for signaling NaN
+	/// \exception FE_INEXACT if value had to be rounded
+	inline half ceil(half arg) { return half(detail::binary, detail::integral<std::round_toward_infinity,true,true>(arg.data_)); }
+
+	/// Nearest integer not greater than half value.
+	/// **See also:** Documentation for [std::floor](https://en.cppreference.com/w/cpp/numeric/math/floor).
+	/// \param arg half to round
+	/// \return nearest integer not greater than \a arg
+	/// \exception FE_INVALID for signaling NaN
+	/// \exception FE_INEXACT if value had to be rounded
+	inline half floor(half arg) { return half(detail::binary, detail::integral<std::round_toward_neg_infinity,true,true>(arg.data_)); }
+
+	/// Nearest integer not greater in magnitude than half value.
+	/// **See also:** Documentation for [std::trunc](https://en.cppreference.com/w/cpp/numeric/math/trunc).
+	/// \param arg half to round
+	/// \return nearest integer not greater in magnitude than \a arg
+	/// \exception FE_INVALID for signaling NaN
+	/// \exception FE_INEXACT if value had to be rounded
+	inline half trunc(half arg) { return half(detail::binary, detail::integral<std::round_toward_zero,true,true>(arg.data_)); }
+
+	/// Nearest integer.
+	/// **See also:** Documentation for [std::round](https://en.cppreference.com/w/cpp/numeric/math/round).
+	/// \param arg half to round
+	/// \return nearest integer, rounded away from zero in half-way cases
+	/// \exception FE_INVALID for signaling NaN
+	/// \exception FE_INEXACT if value had to be rounded
+	inline half round(half arg) { return half(detail::binary, detail::integral<std::round_to_nearest,false,true>(arg.data_)); }
+
+	/// Nearest integer.
+	/// **See also:** Documentation for [std::lround](https://en.cppreference.com/w/cpp/numeric/math/round).
+	/// \param arg half to round
+	/// \return nearest integer, rounded away from zero in half-way cases
+	/// \exception FE_INVALID if value is not representable as `long`
+	inline long lround(half arg) { return detail::half2int<std::round_to_nearest,false,false,long>(arg.data_); }
+
+	/// Nearest integer using half's internal rounding mode.
+	/// **See also:** Documentation for [std::rint](https://en.cppreference.com/w/cpp/numeric/math/rint).
+	/// \param arg half expression to round
+	/// \return nearest integer using default rounding mode
+	/// \exception FE_INVALID for signaling NaN
+	/// \exception FE_INEXACT if value had to be rounded
+	inline half rint(half arg) { return half(detail::binary, detail::integral<half::round_style,true,true>(arg.data_)); }
+
+	/// Nearest integer using half's internal rounding mode.
+	/// **See also:** Documentation for [std::lrint](https://en.cppreference.com/w/cpp/numeric/math/rint).
+	/// \param arg half expression to round
+	/// \return nearest integer using default rounding mode
+	/// \exception FE_INVALID if value is not representable as `long`
+	/// \exception FE_INEXACT if value had to be rounded
+	inline long lrint(half arg) { return detail::half2int<half::round_style,true,true,long>(arg.data_); }
+
+	/// Nearest integer using half's internal rounding mode.
+	/// **See also:** Documentation for [std::nearbyint](https://en.cppreference.com/w/cpp/numeric/math/nearbyint).
+	/// \param arg half expression to round
+	/// \return nearest integer using default rounding mode
+	/// \exception FE_INVALID for signaling NaN
+	inline half nearbyint(half arg) { return half(detail::binary, detail::integral<half::round_style,true,false>(arg.data_)); }
+#if HALF_ENABLE_CPP11_LONG_LONG
+	/// Nearest integer.
+	/// **See also:** Documentation for [std::llround](https://en.cppreference.com/w/cpp/numeric/math/round).
+	/// \param arg half to round
+	/// \return nearest integer, rounded away from zero in half-way cases
+	/// \exception FE_INVALID if value is not representable as `long long`
+	inline long long llround(half arg) { return detail::half2int<std::round_to_nearest,false,false,long long>(arg.data_); }
+
+	/// Nearest integer using half's internal rounding mode.
+	/// **See also:** Documentation for [std::llrint](https://en.cppreference.com/w/cpp/numeric/math/rint).
+	/// \param arg half expression to round
+	/// \return nearest integer using default rounding mode
+	/// \exception FE_INVALID if value is not representable as `long long`
+	/// \exception FE_INEXACT if value had to be rounded
+	inline long long llrint(half arg) { return detail::half2int<half::round_style,true,true,long long>(arg.data_); }
+#endif
+
+	/// \}
+	/// \anchor float
+	/// \name Floating point manipulation
+	/// \{
+
+	/// Decompress floating-point number.
+	/// **See also:** Documentation for [std::frexp](https://en.cppreference.com/w/cpp/numeric/math/frexp).
+	/// \param arg number to decompress
+	/// \param exp address to store exponent at
+	/// \return significant in range [0.5, 1)
+	/// \exception FE_INVALID for signaling NaN
+	inline half frexp(half arg, int *exp)
+	{
+		*exp = 0;
+		unsigned int abs = arg.data_ & 0x7FFF;
+		if(abs >= 0x7C00 || !abs)
+			return (abs>0x7C00) ? half(detail::binary, detail::signal(arg.data_)) : arg;
+		for(; abs<0x400; abs<<=1,--*exp) ;
+		*exp += (abs>>10) - 14;
+		return half(detail::binary, (arg.data_&0x8000)|0x3800|(abs&0x3FF));
+	}
+
+	/// Multiply by power of two.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::scalbln](https://en.cppreference.com/w/cpp/numeric/math/scalbn).
+	/// \param arg number to modify
+	/// \param exp power of two to multiply with
+	/// \return \a arg multplied by 2 raised to \a exp
+	/// \exception FE_INVALID for signaling NaN
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half scalbln(half arg, long exp)
+	{
+		unsigned int abs = arg.data_ & 0x7FFF, sign = arg.data_ & 0x8000;
+		if(abs >= 0x7C00 || !abs)
+			return (abs>0x7C00) ? half(detail::binary, detail::signal(arg.data_)) : arg;
+		for(; abs<0x400; abs<<=1,--exp) ;
+		exp += abs >> 10;
+		if(exp > 30)
+			return half(detail::binary, detail::overflow<half::round_style>(sign));
+		else if(exp < -10)
+			return half(detail::binary, detail::underflow<half::round_style>(sign));
+		else if(exp > 0)
+			return half(detail::binary, sign|(exp<<10)|(abs&0x3FF));
+		unsigned int m = (abs&0x3FF) | 0x400;
+		return half(detail::binary, detail::rounded<half::round_style,false>(sign|(m>>(1-exp)), (m>>-exp)&1, (m&((1<<-exp)-1))!=0));
+	}
+
+	/// Multiply by power of two.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::scalbn](https://en.cppreference.com/w/cpp/numeric/math/scalbn).
+	/// \param arg number to modify
+	/// \param exp power of two to multiply with
+	/// \return \a arg multplied by 2 raised to \a exp
+	/// \exception FE_INVALID for signaling NaN
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half scalbn(half arg, int exp) { return scalbln(arg, exp); }
+
+	/// Multiply by power of two.
+	/// This function is exact to rounding for all rounding modes.
+	///
+	/// **See also:** Documentation for [std::ldexp](https://en.cppreference.com/w/cpp/numeric/math/ldexp).
+	/// \param arg number to modify
+	/// \param exp power of two to multiply with
+	/// \return \a arg multplied by 2 raised to \a exp
+	/// \exception FE_INVALID for signaling NaN
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	inline half ldexp(half arg, int exp) { return scalbln(arg, exp); }
+
+	/// Extract integer and fractional parts.
+	/// **See also:** Documentation for [std::modf](https://en.cppreference.com/w/cpp/numeric/math/modf).
+	/// \param arg number to decompress
+	/// \param iptr address to store integer part at
+	/// \return fractional part
+	/// \exception FE_INVALID for signaling NaN
+	inline half modf(half arg, half *iptr)
+	{
+		unsigned int abs = arg.data_ & 0x7FFF;
+		if(abs > 0x7C00)
+		{
+			arg = half(detail::binary, detail::signal(arg.data_));
+			return *iptr = arg, arg;
+		}
+		if(abs >= 0x6400)
+			return *iptr = arg, half(detail::binary, arg.data_&0x8000);
+		if(abs < 0x3C00)
+			return iptr->data_ = arg.data_ & 0x8000, arg;
+		unsigned int exp = abs >> 10, mask = (1<<(25-exp)) - 1, m = arg.data_ & mask;
+		iptr->data_ = arg.data_ & ~mask;
+		if(!m)
+			return half(detail::binary, arg.data_&0x8000);
+		for(; m<0x400; m<<=1,--exp) ;
+		return half(detail::binary, (arg.data_&0x8000)|(exp<<10)|(m&0x3FF));
+	}
+
+	/// Extract exponent.
+	/// **See also:** Documentation for [std::ilogb](https://en.cppreference.com/w/cpp/numeric/math/ilogb).
+	/// \param arg number to query
+	/// \return floating-point exponent
+	/// \retval FP_ILOGB0 for zero
+	/// \retval FP_ILOGBNAN for NaN
+	/// \retval INT_MAX for infinity
+	/// \exception FE_INVALID for 0 or infinite values
+	inline int ilogb(half arg)
+	{
+		int abs = arg.data_ & 0x7FFF, exp;
+		if(!abs || abs >= 0x7C00)
+		{
+			detail::raise(FE_INVALID);
+			return !abs ? FP_ILOGB0 : (abs==0x7C00) ? INT_MAX : FP_ILOGBNAN;
+		}
+		for(exp=(abs>>10)-15; abs<0x200; abs<<=1,--exp) ;
+		return exp;
+	}
+
+	/// Extract exponent.
+	/// **See also:** Documentation for [std::logb](https://en.cppreference.com/w/cpp/numeric/math/logb).
+	/// \param arg number to query
+	/// \return floating-point exponent
+	/// \exception FE_INVALID for signaling NaN
+	/// \exception FE_DIVBYZERO for 0
+	inline half logb(half arg)
+	{
+		int abs = arg.data_ & 0x7FFF, exp;
+		if(!abs)
+			return half(detail::binary, detail::pole(0x8000));
+		if(abs >= 0x7C00)
+			return half(detail::binary, (abs==0x7C00) ? 0x7C00 : detail::signal(arg.data_));
+		for(exp=(abs>>10)-15; abs<0x200; abs<<=1,--exp) ;
+		unsigned int value = static_cast<unsigned>(exp<0) << 15;
+		if(exp)
+		{
+			unsigned int m = std::abs(exp) << 6;
+			for(exp=18; m<0x400; m<<=1,--exp) ;
+			value |= (exp<<10) + m;
+		}
+		return half(detail::binary, value);
+	}
+
+	/// Next representable value.
+	/// **See also:** Documentation for [std::nextafter](https://en.cppreference.com/w/cpp/numeric/math/nextafter).
+	/// \param from value to compute next representable value for
+	/// \param to direction towards which to compute next value
+	/// \return next representable value after \a from in direction towards \a to
+	/// \exception FE_INVALID for signaling NaN
+	/// \exception FE_OVERFLOW for infinite result from finite argument
+	/// \exception FE_UNDERFLOW for subnormal result
+	inline half nextafter(half from, half to)
+	{
+		int fabs = from.data_ & 0x7FFF, tabs = to.data_ & 0x7FFF;
+		if(fabs > 0x7C00 || tabs > 0x7C00)
+			return half(detail::binary, detail::signal(from.data_, to.data_));
+		if(from.data_ == to.data_ || !(fabs|tabs))
+			return to;
+		if(!fabs)
+		{
+			detail::raise(FE_UNDERFLOW, !HALF_ERRHANDLING_UNDERFLOW_TO_INEXACT);
+			return half(detail::binary, (to.data_&0x8000)+1);
+		}
+		unsigned int out = from.data_ + (((from.data_>>15)^static_cast<unsigned>(
+			(from.data_^(0x8000|(0x8000-(from.data_>>15))))<(to.data_^(0x8000|(0x8000-(to.data_>>15))))))<<1) - 1;
+		detail::raise(FE_OVERFLOW, fabs<0x7C00 && (out&0x7C00)==0x7C00);
+		detail::raise(FE_UNDERFLOW, !HALF_ERRHANDLING_UNDERFLOW_TO_INEXACT && (out&0x7C00)<0x400);
+		return half(detail::binary, out);
+	}
+
+	/// Next representable value.
+	/// **See also:** Documentation for [std::nexttoward](https://en.cppreference.com/w/cpp/numeric/math/nexttoward).
+	/// \param from value to compute next representable value for
+	/// \param to direction towards which to compute next value
+	/// \return next representable value after \a from in direction towards \a to
+	/// \exception FE_INVALID for signaling NaN
+	/// \exception FE_OVERFLOW for infinite result from finite argument
+	/// \exception FE_UNDERFLOW for subnormal result
+	inline half nexttoward(half from, long double to)
+	{
+		int fabs = from.data_ & 0x7FFF;
+		if(fabs > 0x7C00)
+			return half(detail::binary, detail::signal(from.data_));
+		long double lfrom = static_cast<long double>(from);
+		if(detail::builtin_isnan(to) || lfrom == to)
+			return half(static_cast<float>(to));
+		if(!fabs)
+		{
+			detail::raise(FE_UNDERFLOW, !HALF_ERRHANDLING_UNDERFLOW_TO_INEXACT);
+			return half(detail::binary, (static_cast<unsigned>(detail::builtin_signbit(to))<<15)+1);
+		}
+		unsigned int out = from.data_ + (((from.data_>>15)^static_cast<unsigned>(lfrom<to))<<1) - 1;
+		detail::raise(FE_OVERFLOW, (out&0x7FFF)==0x7C00);
+		detail::raise(FE_UNDERFLOW, !HALF_ERRHANDLING_UNDERFLOW_TO_INEXACT && (out&0x7FFF)<0x400);
+		return half(detail::binary, out);
+	}
+
+	/// Take sign.
+	/// **See also:** Documentation for [std::copysign](https://en.cppreference.com/w/cpp/numeric/math/copysign).
+	/// \param x value to change sign for
+	/// \param y value to take sign from
+	/// \return value equal to \a x in magnitude and to \a y in sign
+	inline HALF_CONSTEXPR half copysign(half x, half y) { return half(detail::binary, x.data_^((x.data_^y.data_)&0x8000)); }
+
+	/// \}
+	/// \anchor classification
+	/// \name Floating point classification
+	/// \{
+
+	/// Classify floating-point value.
+	/// **See also:** Documentation for [std::fpclassify](https://en.cppreference.com/w/cpp/numeric/math/fpclassify).
+	/// \param arg number to classify
+	/// \retval FP_ZERO for positive and negative zero
+	/// \retval FP_SUBNORMAL for subnormal numbers
+	/// \retval FP_INFINITY for positive and negative infinity
+	/// \retval FP_NAN for NaNs
+	/// \retval FP_NORMAL for all other (normal) values
+	inline HALF_CONSTEXPR int fpclassify(half arg)
+	{
+		return	!(arg.data_&0x7FFF) ? FP_ZERO :
+				((arg.data_&0x7FFF)<0x400) ? FP_SUBNORMAL :
+				((arg.data_&0x7FFF)<0x7C00) ? FP_NORMAL :
+				((arg.data_&0x7FFF)==0x7C00) ? FP_INFINITE :
+				FP_NAN;
+	}
+
+	/// Check if finite number.
+	/// **See also:** Documentation for [std::isfinite](https://en.cppreference.com/w/cpp/numeric/math/isfinite).
+	/// \param arg number to check
+	/// \retval true if neither infinity nor NaN
+	/// \retval false else
+	inline HALF_CONSTEXPR bool isfinite(half arg) { return (arg.data_&0x7C00) != 0x7C00; }
+
+	/// Check for infinity.
+	/// **See also:** Documentation for [std::isinf](https://en.cppreference.com/w/cpp/numeric/math/isinf).
+	/// \param arg number to check
+	/// \retval true for positive or negative infinity
+	/// \retval false else
+	inline HALF_CONSTEXPR bool isinf(half arg) { return (arg.data_&0x7FFF) == 0x7C00; }
+
+	/// Check for NaN.
+	/// **See also:** Documentation for [std::isnan](https://en.cppreference.com/w/cpp/numeric/math/isnan).
+	/// \param arg number to check
+	/// \retval true for NaNs
+	/// \retval false else
+	inline HALF_CONSTEXPR bool isnan(half arg) { return (arg.data_&0x7FFF) > 0x7C00; }
+
+	/// Check if normal number.
+	/// **See also:** Documentation for [std::isnormal](https://en.cppreference.com/w/cpp/numeric/math/isnormal).
+	/// \param arg number to check
+	/// \retval true if normal number
+	/// \retval false if either subnormal, zero, infinity or NaN
+	inline HALF_CONSTEXPR bool isnormal(half arg) { return ((arg.data_&0x7C00)!=0) & ((arg.data_&0x7C00)!=0x7C00); }
+
+	/// Check sign.
+	/// **See also:** Documentation for [std::signbit](https://en.cppreference.com/w/cpp/numeric/math/signbit).
+	/// \param arg number to check
+	/// \retval true for negative number
+	/// \retval false for positive number
+	inline HALF_CONSTEXPR bool signbit(half arg) { return (arg.data_&0x8000) != 0; }
+
+	/// \}
+	/// \anchor compfunc
+	/// \name Comparison
+	/// \{
+
+	/// Quiet comparison for greater than.
+	/// **See also:** Documentation for [std::isgreater](https://en.cppreference.com/w/cpp/numeric/math/isgreater).
+	/// \param x first operand
+	/// \param y second operand
+	/// \retval true if \a x greater than \a y
+	/// \retval false else
+	inline HALF_CONSTEXPR bool isgreater(half x, half y)
+	{
+		return ((x.data_^(0x8000|(0x8000-(x.data_>>15))))+(x.data_>>15)) > ((y.data_^(0x8000|(0x8000-(y.data_>>15))))+(y.data_>>15)) && !isnan(x) && !isnan(y);
+	}
+
+	/// Quiet comparison for greater equal.
+	/// **See also:** Documentation for [std::isgreaterequal](https://en.cppreference.com/w/cpp/numeric/math/isgreaterequal).
+	/// \param x first operand
+	/// \param y second operand
+	/// \retval true if \a x greater equal \a y
+	/// \retval false else
+	inline HALF_CONSTEXPR bool isgreaterequal(half x, half y)
+	{
+		return ((x.data_^(0x8000|(0x8000-(x.data_>>15))))+(x.data_>>15)) >= ((y.data_^(0x8000|(0x8000-(y.data_>>15))))+(y.data_>>15)) && !isnan(x) && !isnan(y);
+	}
+
+	/// Quiet comparison for less than.
+	/// **See also:** Documentation for [std::isless](https://en.cppreference.com/w/cpp/numeric/math/isless).
+	/// \param x first operand
+	/// \param y second operand
+	/// \retval true if \a x less than \a y
+	/// \retval false else
+	inline HALF_CONSTEXPR bool isless(half x, half y)
+	{
+		return ((x.data_^(0x8000|(0x8000-(x.data_>>15))))+(x.data_>>15)) < ((y.data_^(0x8000|(0x8000-(y.data_>>15))))+(y.data_>>15)) && !isnan(x) && !isnan(y);
+	}
+
+	/// Quiet comparison for less equal.
+	/// **See also:** Documentation for [std::islessequal](https://en.cppreference.com/w/cpp/numeric/math/islessequal).
+	/// \param x first operand
+	/// \param y second operand
+	/// \retval true if \a x less equal \a y
+	/// \retval false else
+	inline HALF_CONSTEXPR bool islessequal(half x, half y)
+	{
+		return ((x.data_^(0x8000|(0x8000-(x.data_>>15))))+(x.data_>>15)) <= ((y.data_^(0x8000|(0x8000-(y.data_>>15))))+(y.data_>>15)) && !isnan(x) && !isnan(y);
+	}
+
+	/// Quiet comarison for less or greater.
+	/// **See also:** Documentation for [std::islessgreater](https://en.cppreference.com/w/cpp/numeric/math/islessgreater).
+	/// \param x first operand
+	/// \param y second operand
+	/// \retval true if either less or greater
+	/// \retval false else
+	inline HALF_CONSTEXPR bool islessgreater(half x, half y)
+	{
+		return x.data_!=y.data_ && ((x.data_|y.data_)&0x7FFF) && !isnan(x) && !isnan(y);
+	}
+
+	/// Quiet check if unordered.
+	/// **See also:** Documentation for [std::isunordered](https://en.cppreference.com/w/cpp/numeric/math/isunordered).
+	/// \param x first operand
+	/// \param y second operand
+	/// \retval true if unordered (one or two NaN operands)
+	/// \retval false else
+	inline HALF_CONSTEXPR bool isunordered(half x, half y) { return isnan(x) || isnan(y); }
+
+	/// \}
+	/// \anchor casting
+	/// \name Casting
+	/// \{
+
+	/// Cast to or from half-precision floating-point number.
+	/// This casts between [half](\ref half_float::half) and any built-in arithmetic type. The values are converted 
+	/// directly using the default rounding mode, without any roundtrip over `float` that a `static_cast` would otherwise do.
+	///
+	/// Using this cast with neither of the two types being a [half](\ref half_float::half) or with any of the two types 
+	/// not being a built-in arithmetic type (apart from [half](\ref half_float::half), of course) results in a compiler 
+	/// error and casting between [half](\ref half_float::half)s returns the argument unmodified.
+	/// \tparam T destination type (half or built-in arithmetic type)
+	/// \tparam U source type (half or built-in arithmetic type)
+	/// \param arg value to cast
+	/// \return \a arg converted to destination type
+	/// \exception FE_INVALID if \a T is integer type and result is not representable as \a T
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	template<typename T,typename U> T half_cast(U arg) { return detail::half_caster<T,U>::cast(arg); }
+
+	/// Cast to or from half-precision floating-point number.
+	/// This casts between [half](\ref half_float::half) and any built-in arithmetic type. The values are converted 
+	/// directly using the specified rounding mode, without any roundtrip over `float` that a `static_cast` would otherwise do.
+	///
+	/// Using this cast with neither of the two types being a [half](\ref half_float::half) or with any of the two types 
+	/// not being a built-in arithmetic type (apart from [half](\ref half_float::half), of course) results in a compiler 
+	/// error and casting between [half](\ref half_float::half)s returns the argument unmodified.
+	/// \tparam T destination type (half or built-in arithmetic type)
+	/// \tparam R rounding mode to use.
+	/// \tparam U source type (half or built-in arithmetic type)
+	/// \param arg value to cast
+	/// \return \a arg converted to destination type
+	/// \exception FE_INVALID if \a T is integer type and result is not representable as \a T
+	/// \exception FE_OVERFLOW, ...UNDERFLOW, ...INEXACT according to rounding
+	template<typename T,std::float_round_style R,typename U> T half_cast(U arg) { return detail::half_caster<T,U,R>::cast(arg); }
+	/// \}
+
+	/// \}
+	/// \anchor errors
+	/// \name Error handling
+	/// \{
+
+	/// Clear exception flags.
+	/// This function works even if [automatic exception flag handling](\ref HALF_ERRHANDLING_FLAGS) is disabled, 
+	/// but in that case manual flag management is the only way to raise flags.
+	///
+	/// **See also:** Documentation for [std::feclearexcept](https://en.cppreference.com/w/cpp/numeric/fenv/feclearexcept).
+	/// \param excepts OR of exceptions to clear
+	/// \retval 0 all selected flags cleared successfully
+	inline int feclearexcept(int excepts) { detail::errflags() &= ~excepts; return 0; }
+
+	/// Test exception flags.
+	/// This function works even if [automatic exception flag handling](\ref HALF_ERRHANDLING_FLAGS) is disabled, 
+	/// but in that case manual flag management is the only way to raise flags.
+	///
+	/// **See also:** Documentation for [std::fetestexcept](https://en.cppreference.com/w/cpp/numeric/fenv/fetestexcept).
+	/// \param excepts OR of exceptions to test
+	/// \return OR of selected exceptions if raised
+	inline int fetestexcept(int excepts) { return detail::errflags() & excepts; }
+
+	/// Raise exception flags.
+	/// This raises the specified floating point exceptions and also invokes any additional automatic exception handling as 
+	/// configured with the [HALF_ERRHANDLIG_...](\ref HALF_ERRHANDLING_ERRNO) preprocessor symbols.
+	/// This function works even if [automatic exception flag handling](\ref HALF_ERRHANDLING_FLAGS) is disabled, 
+	/// but in that case manual flag management is the only way to raise flags.
+	///
+	/// **See also:** Documentation for [std::feraiseexcept](https://en.cppreference.com/w/cpp/numeric/fenv/feraiseexcept).
+	/// \param excepts OR of exceptions to raise
+	/// \retval 0 all selected exceptions raised successfully
+	inline int feraiseexcept(int excepts) { detail::errflags() |= excepts; detail::raise(excepts); return 0; }
+
+	/// Save exception flags.
+	/// This function works even if [automatic exception flag handling](\ref HALF_ERRHANDLING_FLAGS) is disabled, 
+	/// but in that case manual flag management is the only way to raise flags.
+	///
+	/// **See also:** Documentation for [std::fegetexceptflag](https://en.cppreference.com/w/cpp/numeric/fenv/feexceptflag).
+	/// \param flagp adress to store flag state at
+	/// \param excepts OR of flags to save
+	/// \retval 0 for success
+	inline int fegetexceptflag(int *flagp, int excepts) { *flagp = detail::errflags() & excepts; return 0; }
+
+	/// Restore exception flags.
+	/// This only copies the specified exception state (including unset flags) without incurring any additional exception handling.
+	/// This function works even if [automatic exception flag handling](\ref HALF_ERRHANDLING_FLAGS) is disabled, 
+	/// but in that case manual flag management is the only way to raise flags.
+	///
+	/// **See also:** Documentation for [std::fesetexceptflag](https://en.cppreference.com/w/cpp/numeric/fenv/feexceptflag).
+	/// \param flagp adress to take flag state from
+	/// \param excepts OR of flags to restore
+	/// \retval 0 for success
+	inline int fesetexceptflag(const int *flagp, int excepts) { detail::errflags() = (detail::errflags()|(*flagp&excepts)) & (*flagp|~excepts); return 0; }
+
+	/// Throw C++ exceptions based on set exception flags.
+	/// This function manually throws a corresponding C++ exception if one of the specified flags is set, 
+	/// no matter if automatic throwing (via [HALF_ERRHANDLING_THROW_...](\ref HALF_ERRHANDLING_THROW_INVALID)) is enabled or not.
+	/// This function works even if [automatic exception flag handling](\ref HALF_ERRHANDLING_FLAGS) is disabled, 
+	/// but in that case manual flag management is the only way to raise flags.
+	/// \param excepts OR of exceptions to test
+	/// \param msg error message to use for exception description
+	/// \throw std::domain_error if `FE_INVALID` or `FE_DIVBYZERO` is selected and set
+	/// \throw std::overflow_error if `FE_OVERFLOW` is selected and set
+	/// \throw std::underflow_error if `FE_UNDERFLOW` is selected and set
+	/// \throw std::range_error if `FE_INEXACT` is selected and set
+	inline void fethrowexcept(int excepts, const char *msg = "")
+	{
+		excepts &= detail::errflags();
+		if(excepts & (FE_INVALID|FE_DIVBYZERO))
+			throw std::domain_error(msg);
+		if(excepts & FE_OVERFLOW)
+			throw std::overflow_error(msg);
+		if(excepts & FE_UNDERFLOW)
+			throw std::underflow_error(msg);
+		if(excepts & FE_INEXACT)
+			throw std::range_error(msg);
+	}
+	/// \}
+}
+
+
+#undef HALF_UNUSED_NOERR
+#undef HALF_CONSTEXPR
+#undef HALF_CONSTEXPR_CONST
+#undef HALF_CONSTEXPR_NOERR
+#undef HALF_NOEXCEPT
+#undef HALF_NOTHROW
+#undef HALF_THREAD_LOCAL
+#undef HALF_TWOS_COMPLEMENT_INT
+#ifdef HALF_POP_WARNINGS
+	#pragma warning(pop)
+	#undef HALF_POP_WARNINGS
+#endif
+
+#endif
diff --git a/src/imsrg++ b/src/imsrg++
new file mode 100755
index 0000000..80dd5e7
Binary files /dev/null and b/src/imsrg++ differ
diff --git a/src/imsrg++.cc b/src/imsrg++.cc
index 10f9334..d2c54b4 100755
--- a/src/imsrg++.cc
+++ b/src/imsrg++.cc
@@ -71,6 +71,7 @@ int main(int argc, char** argv)
   std::string inputtbme = parameters.s("2bme");
   std::string input3bme = parameters.s("3bme");
   std::string input3bme_type = parameters.s("3bme_type");
+  std::string no2b_precision = parameters.s("no2b_precision");
   std::string reference = parameters.s("reference");
   std::string valence_space = parameters.s("valence_space");
   std::string custom_valence_space = parameters.s("custom_valence_space");
@@ -82,16 +83,19 @@ int main(int argc, char** argv)
   std::string valence_generator = parameters.s("valence_generator");
   std::string fmt2 = parameters.s("fmt2");
   std::string fmt3 = parameters.s("fmt3");
+  std::string input_op_fmt = parameters.s("input_op_fmt");
   std::string denominator_delta_orbit = parameters.s("denominator_delta_orbit");
   std::string LECs = parameters.s("LECs");
   std::string scratch = parameters.s("scratch");
   std::string valence_file_format = parameters.s("valence_file_format");
   std::string occ_file = parameters.s("occ_file");
   std::string physical_system = parameters.s("physical_system");
+  std::string operator_evolution = parameters.s("operator_evolution");
   bool use_brueckner_bch = parameters.s("use_brueckner_bch") == "true";
   bool nucleon_mass_correction = parameters.s("nucleon_mass_correction") == "true";
   bool relativistic_correction = parameters.s("relativistic_correction") == "true";
   bool IMSRG3 = parameters.s("IMSRG3") == "true";
+  bool imsrg3_n7 = parameters.s("imsrg3_n7") == "true";
   bool write_omega = parameters.s("write_omega") == "true";
   bool freeze_occupations = parameters.s("freeze_occupations")=="true";
   bool hunter_gatherer = parameters.s("hunter_gatherer") == "true";
@@ -225,12 +229,14 @@ int main(int argc, char** argv)
 
   ModelSpace modelspace = ( reference=="default" ? ModelSpace(eMax,valence_space) : ModelSpace(eMax,reference,valence_space) );
 
+  std::cout << __LINE__ << "  constructed modelspace " << std::endl;
   modelspace.SetE3max(E3max);
   modelspace.SetLmax(lmax);
+  std::cout << __LINE__ << "  done setting E3max and lmax " << std::endl;
 //  if (lmax!= 99999)
 //  {
 //    modelspace.ClearVectors();
-//    modelspace.Init(eMax, reference,valence_space);  
+//    modelspace.Init(eMax, reference,valence_space);
 //  }
 
   if (emax_unocc>0)
@@ -396,10 +402,13 @@ int main(int argc, char** argv)
     }
     if(input3bme_type == "no2b"){
       double t_start = omp_get_wtime();
-      Hbare.ThreeBodyNO2B.Allocate(modelspace, file3e1max, file3e2max, file3e3max, file3e1max, input3bme);
+//      Hbare.ThreeBodyNO2B.Allocate(modelspace, file3e1max, file3e2max, file3e3max, file3e1max, input3bme);
+      if ( no2b_precision == "half")  Hbare.ThreeBodyNO2B.SetHalfPrecision();
+      Hbare.ThreeBodyNO2B.Allocate(modelspace, file3e1max, file3e2max, file3e3max, file3e1max);
       Hbare.profiler.timer["ThreeBodyNO2B::Allocate"] += omp_get_wtime() - t_start;
       t_start = omp_get_wtime();
-      Hbare.ThreeBodyNO2B.ReadFile();
+//      Hbare.ThreeBodyNO2B.ReadFile();
+      Hbare.ThreeBodyNO2B.ReadFile( input3bme );
       Hbare.profiler.timer["ThreeBodyNO2B::ReadFile"] += omp_get_wtime() - t_start;
       std::cout << "done reading 3N" << std::endl;
     }
@@ -421,13 +430,6 @@ int main(int argc, char** argv)
   }
 
 
-  // If we're doing FCI, we want things normal ordered wrt the vacuum
-  // and we want things diagonal when normal ordered wrt the vacuum.
-//  if ( method == "FCI" )
-//  {
-//    modelspace.SetReference("vacuum");
-//  }
-
 
   std::cout << "Creating HF" << std::endl;
 //  HartreeFock hf(Hbare);
@@ -511,8 +513,8 @@ int main(int argc, char** argv)
 //      if ( Hbare.ThreeBodyNorm() <1e-6 )
 //      {
 //        HNO.ThreeBody.TransformToPN();
-        HNO.ThreeBody.SwitchToPN_and_discard();
 //      }
+      HNO.ThreeBody.SwitchToPN_and_discard();
     }
   }
 
@@ -570,16 +572,27 @@ int main(int argc, char** argv)
   }
 
 
-  // the format should look like OpName^j_t_p_r^/path/to/file
+  // the format should look like OpName^j_t_p_r^/path/to/2bfile
+  // the format should look like OpName^j_t_p_r^/path/to/2bfile^/path/to/3bfile  if particle rank of Op is 2-body, then 3bfile is not needed.
   for (auto& tag : opsfromfile)
   {
+    if( tag.find("op.me2j.gz") != std::string::npos )
+    {
+      std::string tmp = tag.substr( tag.rfind("/", tag.length())+1, tag.length() );
+      std::string opname = tmp.substr( 0, tmp.find_first_of("."));
+      Operator op = rw.ReadOperator2b_Miyagi( tag, modelspace );
+      ops.push_back( op );
+      opnames.push_back( opname );
+      continue;
+    }
     std::istringstream ss(tag);
-    std::string opname,qnumbers,fname;
+    std::string opname,qnumbers,f2name,f3name="";
     std::vector<int> qn(4);
 
     getline(ss,opname,'^');
     getline(ss,qnumbers,'^');
-    getline(ss,fname,'^');
+    getline(ss,f2name,'^');
+    if ( not ss.eof() )  getline(ss,f3name,'^');
     ss.str(qnumbers);
     ss.clear();
     for (int i=0;i<4;i++)
@@ -594,32 +607,49 @@ int main(int argc, char** argv)
     t = qn[1];
     p = qn[2];
     r = qn[3];
-//    std::cout << "Parsed tag. opname = " << opname << "  qnumbers = " << qnumbers << "  " << j << " " << t << " " << p << " " << r << "   file = " << fname << std::endl;
+//    std::cout << "Parsed tag. opname = " << opname << "  qnumbers = " << qnumbers << "  " << j << " " << t << " " << p << " " << r << "   file2 = " << f2name
+//              << "    file3 = " << f3name << std::endl;
     Operator op(modelspace,j,t,p,r);
-    rw.Read2bCurrent_Navratil( fname, op );
+//    std::cout << "Reading operator " << opname << "  in " << input_op_fmt << "  format from files " << f2name << "  ,  " << f3name << std::endl;
+//    std::cout << "Operator has particle rank " << op.GetParticleRank() << std::endl;
+    if ( input_op_fmt == "navratil" )
+    {
+      rw.Read2bCurrent_Navratil( f2name, op );
+    }
+    else if ( input_op_fmt == "miyagi" )
+    {
+      if (f2name != "")
+      {
+          Operator optmp = rw.ReadOperator2b_Miyagi( f2name, modelspace );
+          op.OneBody = optmp.OneBody;
+          op.TwoBody = optmp.TwoBody;
+      }
+      if ( r>2 and f3name != "")  rw.Read_Darmstadt_3body( f3name, op,  file3e1max,file3e2max,file3e3max);
+    }
     ops.push_back( op );
     opnames.push_back( opname );
   }
 
 
-
-//  for (auto& op : ops)
-  for (size_t i=0;i<ops.size();++i)
-  {
-     // We don't transform a DaggerHF, because we want the a^dagger to already refer to the HF basis.
-    if ((basis == "HF") and (opnames[i].find("DaggerHF") == std::string::npos)  )
-    {
-      ops[i] = hf.TransformToHFBasis(ops[i]);
-    }
-    else if ((basis == "NAT") and (opnames[i].find("DaggerHF") == std::string::npos)  )
-    {
-      ops[i] = hf.TransformHOToNATBasis(ops[i]);
-    }
-    ops[i] = ops[i].DoNormalOrdering();
-    if (method == "MP3")
+  if( operator_evolution == "basis" or operator_evolution == "true"){
+    //  for (auto& op : ops)
+    for (size_t i=0;i<ops.size();++i)
     {
-      double dop = ops[i].MP1_Eval( HNO );
-      std::cout << "Operator 1st order correction  " << dop << "  ->  " << ops[i].ZeroBody + dop << std::endl;
+      // We don't transform a DaggerHF, because we want the a^dagger to already refer to the HF basis.
+      if ((basis == "HF") and (opnames[i].find("DaggerHF") == std::string::npos)  )
+      {
+        ops[i] = hf.TransformToHFBasis(ops[i]);
+      }
+      else if ((basis == "NAT") and (opnames[i].find("DaggerHF") == std::string::npos)  )
+      {
+        ops[i] = hf.TransformHOToNATBasis(ops[i]);
+      }
+      ops[i] = ops[i].DoNormalOrdering();
+      if (method == "MP3")
+      {
+        double dop = ops[i].MP1_Eval( HNO );
+        std::cout << "Operator 1st order correction  " << dop << "  ->  " << ops[i].ZeroBody + dop << std::endl;
+      }
     }
   }
 
@@ -655,6 +685,7 @@ int main(int argc, char** argv)
 
   if (method == "FCI")
   {
+  std::cout << __func__ << "  line " << __LINE__ << std::endl;
    // we want the 1b piece to be diagonal in the vacuum NO representation
     HNO = HNO.UndoNormalOrdering();
     double previous_zero_body = HNO.ZeroBody;
@@ -733,6 +764,11 @@ int main(int argc, char** argv)
     Commutator::SetUseIMSRG3(true);
     std::cout << "Using IMSRG(3) commutators. This will probably be slow..." << std::endl;
   }
+  if (imsrg3_n7)
+  {
+    Commutator::SetUseIMSRG3N7(true);
+    std::cout << "  only including IMSRG3 commutator terms that scale up to n7" << std::endl;
+  }
 
   imsrgsolver.SetMethod(method);
 //  imsrgsolver.SetHin(Hbare);
@@ -750,7 +786,8 @@ int main(int argc, char** argv)
 
   if (method == "flow" or method == "flow_RK4" )
   {
-    for (auto& op : ops )  imsrgsolver.AddOperator( op );
+    if( operator_evolution == "true" ){
+    for (auto& op : ops )  imsrgsolver.AddOperator( op );}
   }
 
   imsrgsolver.SetGenerator(core_generator);
@@ -820,24 +857,28 @@ int main(int argc, char** argv)
   // Transform all the operators
   if (method == "magnus")
   {
-    if (ops.size()>0) std::cout << "transforming operators" << std::endl;
-    for (size_t i=0;i<ops.size();++i)
-    {
-      std::cout << opnames[i] << " " << std::endl;
-      ops[i] = imsrgsolver.Transform(ops[i]);
-      std::cout << " (" << ops[i].ZeroBody << " ) " << std::endl;
-//      rw.WriteOperatorHuman(ops[i],intfile+opnames[i]+"_step2.op");
+    if (operator_evolution == "true"){
+      if (ops.size()>0) std::cout << "transforming operators" << std::endl;
+      for (size_t i=0;i<ops.size();++i)
+      {
+        std::cout << opnames[i] << " " << std::endl;
+        ops[i] = imsrgsolver.Transform(ops[i]);
+        std::cout << " (" << ops[i].ZeroBody << " ) " << std::endl;
+        //      rw.WriteOperatorHuman(ops[i],intfile+opnames[i]+"_step2.op");
+      }
+      std::cout << std::endl;
+      // increase smax in case we need to do additional steps
+      smax *= 1.5;
+      imsrgsolver.SetSmax(smax);
     }
-    std::cout << std::endl;
-    // increase smax in case we need to do additional steps
-    smax *= 1.5;
-    imsrgsolver.SetSmax(smax);
   }
   if (method == "flow" or method == "flow_RK4" )
   {
-    for (size_t i=0;i<ops.size();++i)
-    {
-      ops[i] = imsrgsolver.GetOperator(i+1);  // the zero-th operator is the Hamiltonian
+    if (operator_evolution == "true"){
+      for (size_t i=0;i<ops.size();++i)
+      {
+        ops[i] = imsrgsolver.GetOperator(i+1);  // the zero-th operator is the Hamiltonian
+      }
     }
   }
 
@@ -892,16 +933,18 @@ int main(int argc, char** argv)
 //    imsrgsolver.SetEtaCriterion(1e-4);
 //    imsrgsolver.Solve();
     // Change operators to the new basis, then apply the rest of the transformation
-    std::cout << "Final transformation on the operators..." << std::endl;
-    int iop = 0;
-    for (auto& op : ops)
-    {
-      std::cout << opnames[iop++] << std::endl;
-      op = op.UndoNormalOrdering();
-      op.SetModelSpace(ms2);
-      op = op.DoNormalOrdering();
-      // transform using the remaining omegas
-      op = imsrgsolver.Transform_Partial(op,nOmega);
+    if (operator_evolution == "true"){
+      std::cout << "Final transformation on the operators..." << std::endl;
+      int iop = 0;
+      for (auto& op : ops)
+      {
+        std::cout << opnames[iop++] << std::endl;
+        op = op.UndoNormalOrdering();
+        op.SetModelSpace(ms2);
+        op = op.DoNormalOrdering();
+        // transform using the remaining omegas
+        op = imsrgsolver.Transform_Partial(op,nOmega);
+      }
     }
   }
 
@@ -930,17 +973,20 @@ int main(int argc, char** argv)
 
     if (method == "magnus" or method=="flow_RK4")
     {
+       std::string evol = "";
+       if( operator_evolution == "false" ) evol = "_unevolved";
+       if( operator_evolution == "basis" ) evol = "_" + basis;
        for (index_t i=0;i<ops.size();++i)
        {
           if ( ((ops[i].GetJRank()+ops[i].GetTRank()+ops[i].GetParity())<1) and (ops[i].GetNumberLegs()%2==0) )
           {
             if (valence_file_format == "tokyo")
             {
-              rw.WriteTokyo(ops[i],intfile+opnames[i]+".snt", "op");
+              rw.WriteTokyo(ops[i],intfile+opnames[i]+evol+".snt", "op");
             }
             else
             {
-              rw.WriteNuShellX_op(ops[i],intfile+opnames[i]+".int");
+              rw.WriteNuShellX_op(ops[i],intfile+opnames[i]+evol+".int");
             }
           }
           else if ( ops[i].GetNumberLegs()%2==1) // odd number of legs -> this is a dagger operator
@@ -952,12 +998,12 @@ int main(int argc, char** argv)
           {
             if (valence_file_format == "tokyo")
             {
-              rw.WriteTensorTokyo(intfile+opnames[i]+"_2b.snt",ops[i]);
+              rw.WriteTensorTokyo(intfile+"_"+opnames[i]+evol+".snt",ops[i]);
             }
             else
             {
-              rw.WriteTensorOneBody(intfile+opnames[i]+"_1b.op",ops[i],opnames[i]);
-              rw.WriteTensorTwoBody(intfile+opnames[i]+"_2b.op",ops[i],opnames[i]);
+              rw.WriteTensorOneBody(intfile+opnames[i]+evol+"_1b.op",ops[i],opnames[i]);
+              rw.WriteTensorTwoBody(intfile+opnames[i]+evol+"_2b.op",ops[i],opnames[i]);
             }
           }
        }
diff --git a/src/imsrg_util.cc b/src/imsrg_util.cc
index 164633f..138f358 100755
--- a/src/imsrg_util.cc
+++ b/src/imsrg_util.cc
@@ -4,6 +4,7 @@
 #include "Commutator.hh"
 #include "GaussLaguerre.hh"
 #include "DarkMatterNREFT.hh"
+#include "M0nu.hh"
 #include "omp.h"
 #include <gsl/gsl_integration.h>
 #include <gsl/gsl_sf_bessel.h> // to use bessel functions
@@ -99,7 +100,7 @@ namespace imsrg_util
       else if (opname == "VCoul")         return VCoulomb_Op(modelspace); // Untested...
       else if (opname == "hfsNMS")         return atomic_hfs::NormalMassShift(modelspace, 1);
       else if (opname == "hfsSMS")         return atomic_hfs::SpecificMassShift(modelspace, 1);
-      else if (opname == "VCentralCoul")         return VCentralCoulomb_Op(modelspace); 
+      else if (opname == "VCentralCoul")         return VCentralCoulomb_Op(modelspace);
       else if (opname == "AxialCharge")         return AxialCharge_Op(modelspace); // Untested...
       else if (opnamesplit[0] =="HCM")
       {
@@ -114,7 +115,7 @@ namespace imsrg_util
          double hw_VCM; // frequency of trapping potential
          std::istringstream(opnamesplit[1]) >> hw_VCM;
          int A = modelspace.GetTargetMass();
-         return 0.5*A*M_NUCLEON*hw_VCM*hw_VCM/HBARC/HBARC*R2CM_Op(modelspace); 
+         return 0.5*A*M_NUCLEON*hw_VCM*hw_VCM/HBARC/HBARC*R2CM_Op(modelspace);
       }
       else if (opnamesplit[0] == "Rp2Z") // Get point proton radius for specified Z, e.g. Rp2Z_10 for neon
       {
@@ -185,15 +186,7 @@ namespace imsrg_util
         std::istringstream( opnamesplit[1]) >> R0;
         return M0nu_contact_Op(modelspace, R0);
       }
-      else if (opnamesplit[0] == "M0nu" and opnamesplit[1] == "TBME") // 0\nu\beta\beta decay TBME, M0nu_TBME_${Nq}_${SRC} (CP)
-      {
-         int Nquad; // number of quadrature points
-         std::string src; // chosen SRC parameters (none, Argonne, CD-Bonn, Miller/Spencer)
-         std::istringstream(opnamesplit[2]) >> Nquad;
-         std::istringstream(opnamesplit[3]) >> src;
-         return M0nu_TBME_Op(modelspace,Nquad,src);
-      }
-      else if (opnamesplit[0] == "DMNREFT") // Dark matter non-relativistic EFT operators 
+      else if (opnamesplit[0] == "DMNREFT") // Dark matter non-relativistic EFT operators
       {
         double q;
         int J;
@@ -228,12 +221,28 @@ namespace imsrg_util
         index_t Q = modelspace.String2Index({opnamesplit[1]})[0];
         return DaggerAlln_Op( modelspace, Q);
       }
+      else if (opnamesplit[0] == "M0nu") // Neutrinoless Double Beta Decay Operators   format e.g.  M0nu_GT_7.72_none or M0nu_F_12.6_AV18
+      {
+        double Eclosure;
+        std::string M0nuopname = opnamesplit[1];
+        std::istringstream(opnamesplit[2]) >> Eclosure;
+        std::string src = opnamesplit[3];
+        std::map<std::string, Operator (*)(ModelSpace&, double, std::string) > M0nuop = {
+              {"GT", &M0nu::GamowTeller},
+              {"F",  &M0nu::Fermi},
+              {"T",  &M0nu::Tensor},
+             };
+        if ( M0nuop.find(M0nuopname) != M0nuop.end() )
+        {
+        return M0nuop[M0nuopname](modelspace,Eclosure,src);
+        }
+      }
       else //need to remove from the list
       {
          std::cout << "Unknown operator: " << opname << std::endl;
       }
       return Operator();
- 
+
  }
 
 
@@ -439,7 +448,7 @@ Operator KineticEnergy_Op(ModelSpace& modelspace)
    for ( auto a : modelspace.all_orbits )
    {
       Orbit & oa = modelspace.GetOrbit(a);
-      T.OneBody(a,a) = 0.5 * hw * (2*oa.n + oa.l +3./2); 
+      T.OneBody(a,a) = 0.5 * hw * (2*oa.n + oa.l +3./2);
       for ( auto b : T.OneBodyChannels.at({oa.l,oa.j2,oa.tz2}) )
       {
          if (b<=a) continue;
@@ -508,7 +517,7 @@ Operator KineticEnergy_RelativisticCorr(ModelSpace& modelspace)
 //      double N0m = na<1 ? 0 : (2*na+la-0.5) * sqrt( na*(na+la+0.5)) ;
 //      double Nmm = na<2 ? 0 : sqrt( (na-1)*(na+la-0.5) ) * sqrt( na*(na+la+0.5) );
 
-      Trc.OneBody(a,a) =  N00 + Npm + Nmp ; 
+      Trc.OneBody(a,a) =  N00 + Npm + Nmp ;
       // off-diagonal terms
       for ( int b : Trc.OneBodyChannels.at({oa.l,oa.j2,oa.tz2}) )
       {
@@ -521,7 +530,7 @@ Operator KineticEnergy_RelativisticCorr(ModelSpace& modelspace)
          // Make it hermitian:
          Trc.OneBody(a,b) = Trc.OneBody(b,a);
       }
-   }  // 
+   }  //
    return -Trc*coeff /(2*M_NUCLEON);  // the minus sign is put in here
 }
 
@@ -536,7 +545,7 @@ Operator KineticEnergy_RelativisticCorr(ModelSpace& modelspace)
 /// t_{ij} = \frac{1}{\hbar\omega} \left\langle i | T_{12} | j \right\rangle = \frac{1}{2}(2n_i+\ell_i+3/2) \delta_{ij} + \frac{1}{2}\sqrt{n_j(n_j+\ell_j+\frac{1}{2})} \delta_{n_i,n_j-1}\delta_{k_i k_j}
 /// \f]
 /// where \f$k\f$ labels all quantum numbers other than \f$n\f$ and a two-body piece
-/// \f[  
+/// \f[
 /// t_{ijkl} = \frac{1}{\hbar\omega} \left\langle ij | (T^{CM}_{12} - T^{rel}_{12}) | kl \right\rangle
 /// \f]
  Operator TCM_Op(ModelSpace& modelspace)
@@ -580,7 +589,7 @@ Operator KineticEnergy_RelativisticCorr(ModelSpace& modelspace)
          if ( 2*(oi.n+oj.n)+oi.l+oj.l > E2max) continue;
          for (int iket=ibra;iket<nkets;++iket)
          {
-            
+
             Ket & ket = tbc.GetKet(iket);
             Orbit & ok = modelspace.GetOrbit(ket.p);
             Orbit & ol = modelspace.GetOrbit(ket.q);
@@ -599,7 +608,7 @@ Operator KineticEnergy_RelativisticCorr(ModelSpace& modelspace)
  }
 
 
- // evaluate <bra| p1*p2/2 | ket> 
+ // evaluate <bra| p1*p2/2 | ket>
 /// This returns the antisymmetrized J-coupled two body matrix element of \f$ \vec{p}_1 \cdot \vec{p}_2 / (m) \f$.
 /// The formula is
 /// \f{eqnarray*}{
@@ -652,7 +661,7 @@ Operator KineticEnergy_RelativisticCorr(ModelSpace& modelspace)
    int fab = 2*na + 2*nb + la + lb;
    int fcd = 2*nc + 2*nd + lc + ld;
    // p1*p2 only connects kets with delta N = 0,1 ==> delta E = 0,2
-   if (std::abs(fab-fcd)>2 or std::abs(fab-fcd)%2 >0 ) return 0; 
+   if (std::abs(fab-fcd)>2 or std::abs(fab-fcd)%2 >0 ) return 0;
 
    double sa,sb,sc,sd;
    sa=sb=sc=sd=0.5;
@@ -762,7 +771,7 @@ Operator KineticEnergy_RelativisticCorr(ModelSpace& modelspace)
       Orbit & oa = modelspace.GetOrbit(a);
       double m_a = (oa.tz2 == -1) ? M_PROTON : M_NEUTRON ;
       double correction = (m_avg-m_a)/m_a;
-      dTrel.OneBody(a,a) = correction * 0.5 * hw * (2*oa.n + oa.l +3./2); 
+      dTrel.OneBody(a,a) = correction * 0.5 * hw * (2*oa.n + oa.l +3./2);
       for ( int b : dTrel.OneBodyChannels.at({oa.l,oa.j2,oa.tz2}) )
       {
          if (b<=a) continue;
@@ -860,7 +869,7 @@ Operator KineticEnergy_RelativisticCorr(ModelSpace& modelspace)
           if (std::abs(mosh)<1e-6) continue;
           Trans(iJac,iJJ) = ninej * mosh;
           n_nonzero += 1;
-           
+
         }
       }
       for (int i=0; i<nkets_Jacobi; ++i)
@@ -914,7 +923,7 @@ Operator KineticEnergy_RelativisticCorr(ModelSpace& modelspace)
 
 // Center of mass R^2, in units of fm^2
 /// Returns
-/// \f[ 
+/// \f[
 /// R^{2}_{CM} = \left( \frac{1}{A}\sum_{i}\vec{r}_{i}\right)^2 =
 /// \frac{1}{A^2} \left( \sum_{i}r_{i}^{2} + 2\sum_{i<j}\vec{r}_i\cdot\vec{r}_j  \right)
 /// \f]
@@ -947,7 +956,7 @@ Operator KineticEnergy_RelativisticCorr(ModelSpace& modelspace)
 
    int nchan = modelspace.GetNumberTwoBodyChannels();
    modelspace.PreCalculateMoshinsky();
-   #pragma omp parallel for schedule(dynamic,1) 
+   #pragma omp parallel for schedule(dynamic,1)
    for (int ch=0; ch<nchan; ++ch)
    {
       TwoBodyChannel& tbc = modelspace.GetTwoBodyChannel(ch);
@@ -959,8 +968,8 @@ Operator KineticEnergy_RelativisticCorr(ModelSpace& modelspace)
          {
             Ket & ket = tbc.GetKet(iket);
             // factor of 2 comes from limiting sum to i<j. Otherwise it would be r1*r2 + r2*r1.
-            double mat_el = 2*Calculate_r1r2(modelspace,bra,ket,tbc.J); 
-             
+            double mat_el = 2*Calculate_r1r2(modelspace,bra,ket,tbc.J);
+
             R2cmOp.TwoBody.SetTBME(ch,ibra,iket,mat_el);
             R2cmOp.TwoBody.SetTBME(ch,iket,ibra,mat_el);
          }
@@ -976,9 +985,9 @@ Operator KineticEnergy_RelativisticCorr(ModelSpace& modelspace)
 
 // Intrinsic point proton radius squared
 /// Returns
-/// \f[ 
+/// \f[
 /// R_p^{2} = \frac{1}{Z} \sum_{p}\left(\vec{r}_{p}-\vec{R}_{CM}\right)^2 =
-/// R^2_{CM} + \frac{A-2}{AZ} \sum_{p}r_{p}^{2} - \frac{4}{AZ}\sum_{i<j}\vec{r}_i\cdot\vec{r}_j  
+/// R^2_{CM} + \frac{A-2}{AZ} \sum_{p}r_{p}^{2} - \frac{4}{AZ}\sum_{i<j}\vec{r}_i\cdot\vec{r}_j
 /// \f]
 /// evaluated in the oscillator basis.
  Operator Rp2_corrected_Op(ModelSpace& modelspace, int A, int Z)
@@ -1151,7 +1160,7 @@ Operator RSquaredOp(ModelSpace& modelspace)
    for (unsigned int a=0;a<norbits;++a)
    {
       Orbit & oa = modelspace.GetOrbit(a);
-      r2.OneBody(a,a) = (2*oa.n + oa.l +1.5); 
+      r2.OneBody(a,a) = (2*oa.n + oa.l +1.5);
       for ( unsigned int b : r2.OneBodyChannels.at({oa.l, oa.j2, oa.tz2}) )
       {
         if ( b < a ) continue;
@@ -1178,7 +1187,7 @@ Operator RSquaredOp(ModelSpace& modelspace)
 
 /// One-body part of the proton charge radius operator.
 /// Returns
-/// \f[ 
+/// \f[
 /// \hat{R}^{2}_{p1} = \sum_{i} e_{i}{r}_i^2
 /// \f]
  Operator R2_1body_Op(ModelSpace& modelspace,std::string option)
@@ -1194,11 +1203,11 @@ Operator RSquaredOp(ModelSpace& modelspace)
 //   if (option == "neutron") orbitlist = modelspace.neutron_orbits;
 //   else if (option == "matter")  orbitlist.insert(orbitlist.end(),modelspace.neutron_orbits.begin(),modelspace.neutron_orbits.end());
 //   else if (option != "proton") std::cout << "!!! WARNING. BAD OPTION "  << option << " FOR imsrg_util::R2_p1_Op !!!" << std::endl;
- 
+
    for (unsigned int a : orbitlist )
    {
       Orbit & oa = modelspace.GetOrbit(a);
-      r2.OneBody(a,a) = (2*oa.n + oa.l +1.5); 
+      r2.OneBody(a,a) = (2*oa.n + oa.l +1.5);
       for ( unsigned int b : r2.OneBodyChannels.at({oa.l, oa.j2, oa.tz2}) )
       {
         if ( b < a ) continue;
@@ -1223,8 +1232,8 @@ Operator RSquaredOp(ModelSpace& modelspace)
 
 /// Two-body part of the proton charge radius operator.
 /// Returns
-/// \f[ 
-/// \hat{R}^{2}_{p2} = \sum_{i\neq j} e_{i}\vec{r}_i\cdot\vec{r}_j 
+/// \f[
+/// \hat{R}^{2}_{p2} = \sum_{i\neq j} e_{i}\vec{r}_i\cdot\vec{r}_j
 /// \f]
 /// evaluated in the oscillator basis.
  Operator R2_2body_Op(ModelSpace& modelspace,std::string option)
@@ -1236,7 +1245,7 @@ Operator RSquaredOp(ModelSpace& modelspace)
    int nchan = modelspace.GetNumberTwoBodyChannels();
    if (option!="matter" and option!="proton" and option!="neutron") std::cout << "!!! WARNING. " << __func__ << "  BAD OPTION "  << option << std::endl;
    modelspace.PreCalculateMoshinsky();
-   #pragma omp parallel for schedule(dynamic,1) 
+   #pragma omp parallel for schedule(dynamic,1)
    for (int ch=0; ch<nchan; ++ch)
    {
       TwoBodyChannel& tbc = modelspace.GetTwoBodyChannel(ch);
@@ -1259,8 +1268,8 @@ Operator RSquaredOp(ModelSpace& modelspace)
          {
             Ket & ket = tbc.GetKet(iket);
 //            std::cout << "    ~~ " << bra.p << " " << bra.q << "  " << ket.p << " " << ket.q << "  " << tbc.J << std::endl;
-//            double mat_el = Calculate_r1r2(modelspace,bra,ket,tbc.J) * oscillator_b ; 
-            double mat_el = Calculate_r1r2(modelspace,bra,ket,tbc.J) * prefactor; 
+//            double mat_el = Calculate_r1r2(modelspace,bra,ket,tbc.J) * oscillator_b ;
+            double mat_el = Calculate_r1r2(modelspace,bra,ket,tbc.J) * prefactor;
             Rp2Op.TwoBody.SetTBME(ch,ibra,iket,mat_el);
             Rp2Op.TwoBody.SetTBME(ch,iket,ibra,mat_el);
          }
@@ -1323,7 +1332,7 @@ Operator E0Op(ModelSpace& modelspace)
    for (unsigned int a : modelspace.proton_orbits)
    {
       Orbit & oa = modelspace.GetOrbit(a);
-      e0.OneBody(a,a) = (2*oa.n + oa.l +1.5); 
+      e0.OneBody(a,a) = (2*oa.n + oa.l +1.5);
       for (unsigned int b : e0.OneBodyChannels.at({oa.l,oa.j2,oa.tz2}) )
       {
         if (b<=a) continue;
@@ -1368,7 +1377,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
 
   double hw = modelspace.GetHbarOmega();
 
-  for ( auto p : index_list )  
+  for ( auto p : index_list )
   {
     Orbit& op = modelspace.GetOrbit(p);
     for (size_t i=0; i<npoints; i++)
@@ -1681,7 +1690,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
         int rho_cd = 2*nc+2*nd+lc+ld;
 
         double labME = 0;
-        
+
         for (int Lab=std::max(std::abs(la-lb),std::abs(Jab-1)); Lab<=std::min(la+lb,Jab+1); Lab+=1)
         {
          for (int Lcd=std::max(std::abs(lc-ld),std::abs(Jcd-1))+(Lab+L)%2; Lcd<=std::min(lc+ld,Jcd+1); Lcd+=2)
@@ -1720,7 +1729,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
        }
       }
     }
-    
+
     std::cout << "done with intrinsic EL. one body = " <<  std::endl;
     return EL;
   }
@@ -1743,7 +1752,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
     int tau_b = std::max((la-lb+L)/2,0);
     int sigma_min = std::max(std::max(na-tau_a,nb-tau_b),0);
     int sigma_max = std::min(na,nb);
-  
+
     double term1 = AngMom::phase(na+nb) * gsl_sf_fact(tau_a)*gsl_sf_fact(tau_b) * sqrt(gsl_sf_fact(na)*gsl_sf_fact(nb)
                    / (tgamma(na+la+1.5)*tgamma(nb+lb+1.5) ) );
 //    double term1 = AngMom::phase(na+nb) * gsl_sf_fact(tau_a)*gsl_sf_fact(tau_b) * sqrt(gsl_sf_fact(na)*gsl_sf_fact(nb)
@@ -1755,7 +1764,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
       term2 += tgamma(0.5*(la+lb+L)+sigma+1.5) / (gsl_sf_fact(sigma)*gsl_sf_fact(na-sigma)*gsl_sf_fact(nb-sigma)*gsl_sf_fact(sigma+tau_a-na)*gsl_sf_fact(sigma+tau_b-nb) );
     }
     return term1*term2;
-  
+
   }
 
 
@@ -1841,7 +1850,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
  long double TalmiB(int na, int la, int nb, int lb, int p)
  {
    if ( (la+lb)%2>0 ) return 0;
-   
+
    int q = (la+lb)/2;
 
    if ( std::max(na+la+p, nb+lb+p) < 10 )
@@ -1849,29 +1858,29 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
      return AngMom::TalmiB( na, la, nb, lb, p);
    }
 //   double B1 = AngMom::phase(p-q) * exp(lgamma(2*p+2)-lgamma(p+1)) / pow(2,(na+nb))
-//               *  exp(0.5*(lgamma(na+1)+lgamma(nb+1)-lgamma(na+la+1)-lgamma(nb+lb+1) 
+//               *  exp(0.5*(lgamma(na+1)+lgamma(nb+1)-lgamma(na+la+1)-lgamma(nb+lb+1)
 //   double B1 = AngMom::phase(p-q) * exp(lgamma(2*p+2)-lgamma(p+1) +0.5*(  lgamma(na+1)+lgamma(nb+1)-lgamma(na+la+1)-lgamma(nb+lb+1) + lgamma(2*na+2*la+2) + lgamma(2*nb+2*lb+2)) - (na+nb)*log(2)   ) ;
    long double logB1 = (lgamma(2*p+2)-lgamma(p+1) +0.5*(  lgamma(na+1)+lgamma(nb+1)-lgamma(na+la+1)-lgamma(nb+lb+1) + lgamma(2*na+2*la+2) + lgamma(2*nb+2*lb+2)) - (na+nb)*LOG2   ) ;
-//               *  exp(0.5*(lgamma(na+1)+lgamma(nb+1)-lgamma(na+la+1)-lgamma(nb+lb+1) 
+//               *  exp(0.5*(lgamma(na+1)+lgamma(nb+1)-lgamma(na+la+1)-lgamma(nb+lb+1)
 //                     + lgamma(2*na+2*la+2) + lgamma(2*nb+2*lb+2)) );
 //               * sqrt(  exp(lgamma(na+1)) * exp(lgamma(nb+1)) / exp(lgamma(na+la+1))/ exp(lgamma(nb+lb+1))
 //                     * exp(lgamma(2*na+2*la+2)) * exp(lgamma(2*nb+2*lb+2)) );
-//              * sqrt( gsl_sf_fact(na)*gsl_sf_fact(nb)/gsl_sf_fact(na+la)/gsl_sf_fact(nb+lb) 
+//              * sqrt( gsl_sf_fact(na)*gsl_sf_fact(nb)/gsl_sf_fact(na+la)/gsl_sf_fact(nb+lb)
 //                   * gsl_sf_fact(2*na+2*la+1) * gsl_sf_fact(2*nb+2*lb+1) );
-   
+
    long double B2 = 0;
    int kmin = std::max(0, p-q-nb);
    int kmax = std::min(na, p-q);
    for (int k=kmin;k<=kmax;++k)
    {
 //      B2  += exp(lgamma(la+k+1)-lgamma(k+1) +lgamma(p-(la-lb)/2-k+1) -lgamma(2*p-la+lb-2*k+2) )
-//             / (  gsl_sf_fact(2*la+2*k+1) * gsl_sf_fact(na-k)  
+//             / (  gsl_sf_fact(2*la+2*k+1) * gsl_sf_fact(na-k)
 //                * gsl_sf_fact(nb - p + q + k) * gsl_sf_fact(p-q-k) );
-      B2  += exp(logB1+lgamma(la+k+1)-lgamma(k+1) +lgamma(p-(la-lb)/2-k+1) -lgamma(2*p-la+lb-2*k+2) 
-                - lgamma(2*la+2*k+2) -lgamma(na-k+1)  
+      B2  += exp(logB1+lgamma(la+k+1)-lgamma(k+1) +lgamma(p-(la-lb)/2-k+1) -lgamma(2*p-la+lb-2*k+2)
+                - lgamma(2*la+2*k+2) -lgamma(na-k+1)
                 - lgamma(nb - p + q + k+1) - lgamma(p-q-k+1) );
    }
-   
+
    return AngMom::phase(p-q) *  B2;
 //   return  B1 * B2;
  }
@@ -1881,7 +1890,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
  {
 
    if ( (la+lb)%2>0 ) return 0;
-   
+
    int q = (la+lb)/2;
    long double logB1 = (lgamma(2*p+2)-lgamma(p+1) +0.5*(  lgamma(na+1)+lgamma(nb+1)-lgamma(na+la+1)-lgamma(nb+lb+1) + lgamma(2*na+2*la+2) + lgamma(2*nb+2*lb+2)) - (na+nb)*LOG2   ) ;
 //   long double B2 = 0;
@@ -1891,10 +1900,10 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
 //   for (int k=kmin;k<=kmax;++k)
 //   {
 //      B2  += exp(lgamma(la+k+1)-lgamma(k+1) +lgamma(p-(la-lb)/2-k+1) -lgamma(2*p-la+lb-2*k+2) )
-//             / (  gsl_sf_fact(2*la+2*k+1) * gsl_sf_fact(na-k)  
+//             / (  gsl_sf_fact(2*la+2*k+1) * gsl_sf_fact(na-k)
 //                * gsl_sf_fact(nb - p + q + k) * gsl_sf_fact(p-q-k) );
-   long double B2  = exp(logB1+lgamma(la+k+1)-lgamma(k+1) +lgamma(p-(la-lb)/2-k+1) -lgamma(2*p-la+lb-2*k+2) 
-                - lgamma(2*la+2*k+2) -lgamma(na-k+1)  
+   long double B2  = exp(logB1+lgamma(la+k+1)-lgamma(k+1) +lgamma(p-(la-lb)/2-k+1) -lgamma(2*p-la+lb-2*k+2)
+                - lgamma(2*la+2*k+2) -lgamma(na-k+1)
                 - lgamma(nb - p + q + k+1) - lgamma(p-q-k+1) );
 //   }
 
@@ -1914,7 +1923,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
  {
 
    if ( (la+lb)%2>0 ) return 0;
-   
+
    int q = (la+lb)/2;
    int k = K;
 //   long double logB1 = (lgamma(2*p+2)-lgamma(p+1) +0.5*(  lgamma(na+1)+lgamma(nb+1)-lgamma(na+la+1)-lgamma(nb+lb+1) + lgamma(2*na+2*la+2) + lgamma(2*nb+2*lb+2)) - (na+nb)*LOG2   ) ;
@@ -1930,10 +1939,10 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
 //   for (int k=kmin;k<=kmax;++k)
 //   {
 //      B2  += exp(lgamma(la+k+1)-lgamma(k+1) +lgamma(p-(la-lb)/2-k+1) -lgamma(2*p-la+lb-2*k+2) )
-//             / (  gsl_sf_fact(2*la+2*k+1) * gsl_sf_fact(na-k)  
+//             / (  gsl_sf_fact(2*la+2*k+1) * gsl_sf_fact(na-k)
 //                * gsl_sf_fact(nb - p + q + k) * gsl_sf_fact(p-q-k) );
-//   long double B2  = exp(logB1+lgamma(la+k+1)-lgamma(k+1) +lgamma(p-(la-lb)/2-k+1) -lgamma(2*p-la+lb-2*k+2) 
-//                - lgamma(2*la+2*k+2) -lgamma(na-k+1)  
+//   long double B2  = exp(logB1+lgamma(la+k+1)-lgamma(k+1) +lgamma(p-(la-lb)/2-k+1) -lgamma(2*p-la+lb-2*k+2)
+//                - lgamma(2*la+2*k+2) -lgamma(na-k+1)
 //                - lgamma(nb - p + q + k+1) - lgamma(p-q-k+1) );
 //   }
 
@@ -2014,7 +2023,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
         double M_sig = 2 * modelspace.phase(oi.l+oi.j2/2.0+1.5) * sqrt((oi.j2+1)*(oj.j2+1)) * sqrt(1.5) * sixj;
         Sig.OneBody(i,j) = M_sig;
       }
-   } 
+   }
    return Sig;
  }
 
@@ -2119,7 +2128,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
        {
          Orbit& oj = modelspace.GetOrbit(j);
          OVL.OneBody(i,j) = RadialIntegral(oi.n, oi.l, oj.n, oj.l, 0 ); // This is not quite right. Only works for li+lj=even.
-       } 
+       }
      }
      return OVL;
   }
@@ -2173,12 +2182,12 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
  // < ij J || Q*Q || kl J > = <i||Q||l> <j||Q||k> (2J+1)/sqrt(5) (-1)^(jk-jj) { i j J }
  //                                                                           { k l 2 }
  //
- //  Try again...  <ij J | Q*Q | kl J> = 4 <i||Q||l> <j||Q||k> { i j J } 
+ //  Try again...  <ij J | Q*Q | kl J> = 4 <i||Q||l> <j||Q||k> { i j J }
  //                                                            { k l 2 }
  //
  Operator QdotQ_Op(ModelSpace& modelspace)
  {
-    
+
 //   // temporarily store <i||Q||j> in the one body part.
 //   Operator QdotQ_op = ElectricMultipoleOp(modelspace,2);
    Operator QdotQ_op(modelspace,0,0,0,2);
@@ -2214,11 +2223,11 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
      }
    }
 
-   std::cout << "Calculated 1b piece: " << std::endl << QdotQ_op.OneBody << std::endl << std::endl; 
+   std::cout << "Calculated 1b piece: " << std::endl << QdotQ_op.OneBody << std::endl << std::endl;
    std::cout << " matrix : " << std::endl << Qmat << std::endl << std::endl;
    std::cout << " matrix x matrix: " << std::endl << Qmat*Qmat << std::endl << std::endl;
    std::cout << " matrix x matrixT: " << std::endl << Qmat*arma::trans(Qmat) << std::endl << std::endl;
-//   std::cout << QdotQ_op.OneBody << std::endl << std::endl; 
+//   std::cout << QdotQ_op.OneBody << std::endl << std::endl;
    int nchan = modelspace.GetNumberTwoBodyChannels();
 
    for (int ch=0; ch<nchan; ++ch)
@@ -2238,7 +2247,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
 
          for (int iket=ibra;iket<nkets;++iket)
          {
-            
+
             Ket & ket = tbc.GetKet(iket);
             int k = ket.p;
             int l = ket.q;
@@ -2303,7 +2312,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
    Operator VCoul(modelspace, 0,0,0,2);
    double oscillator_b = sqrt(HBARC*HBARC/M_NUCLEON/modelspace.GetHbarOmega());
 //   double alpha_FS = 1.0 / 137.035999;
-  
+
 // First, the one-body piece <a|1/r|b>
 //   int norb = modelspace.GetNumberOrbits();
 //   for (int a=0; a<norb; a++)
@@ -2316,7 +2325,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
      {
        if (b<a) continue;
        Orbit& ob = modelspace.GetOrbit(b);
-       double rad_int =  RadialIntegral_RpowK(oa.n, oa.l, ob.n, ob.l, -1) ;  
+       double rad_int =  RadialIntegral_RpowK(oa.n, oa.l, ob.n, ob.l, -1) ;
        VCoul.OneBody(a,b) = rad_int;
        VCoul.OneBody(b,a) = rad_int;
      }
@@ -2338,7 +2347,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
    Operator VCoul(modelspace, 0,0,0,2);
    double oscillator_b = sqrt(HBARC*HBARC/M_NUCLEON/modelspace.GetHbarOmega());
 //   double alpha_FS = 1.0 / 137.035999;
-  
+
 //// First, the one-body piece <a|1/r|b>
 //   int norb = modelspace.GetNumberOrbits();
 //   for (int a=0; a<norb; a++)
@@ -2348,7 +2357,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
 //     for (int b : VCoul.OneBodyChannels.at({oa.l,oa.j2,oa.tz2}))
 //     {
 //       Orbit& ob = modelspace.GetOrbit(b);
-//       double rad_int =  RadialIntegral_RpowK(oa.n, oa.l, ob.n, ob.l, -1) ;  
+//       double rad_int =  RadialIntegral_RpowK(oa.n, oa.l, ob.n, ob.l, -1) ;
 //       VCoul.OneBody(a,b) = rad_int;
 //       VCoul.OneBody(b,a) = rad_int;
 //     }
@@ -2367,8 +2376,8 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
     {
       for (int l=0;l<=lrelmax ; l++)
       {
-        size_t hash      = na*(nmax+1)*(lrelmax+1) + nb*(lrelmax+1) + l;   
-        size_t flip_hash = nb*(nmax+1)*(lrelmax+1) + na*(lrelmax+1) + l;   
+        size_t hash      = na*(nmax+1)*(lrelmax+1) + nb*(lrelmax+1) + l;
+        size_t flip_hash = nb*(nmax+1)*(lrelmax+1) + na*(lrelmax+1) + l;
         double rint = RadialIntegral_RpowK(na, l, nb, l, -1);
         RadialIntegrals[hash] = rint;
         RadialIntegrals[flip_hash ] = rint;
@@ -2412,14 +2421,14 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
 
             Orbit & oc = modelspace.GetOrbit(ket.p);
             Orbit & od = modelspace.GetOrbit(ket.q);
-         
+
             int nc = oc.n;
             int nd = od.n;
-         
+
             int lc = oc.l;
             int ld = od.l;
             if (la>lmax or lb>lmax or lc>lmax or ld>lmax) continue;
-         
+
             double jc = oc.j2*0.5;
             double jd = od.j2*0.5;
             int fcd = 2*nc + 2*nd + lc + ld;
@@ -2433,7 +2442,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
               for (int Sab=0; Sab<=1; ++Sab)
               {
                 if ( std::abs(Lab-Sab)>J or Lab+Sab<J) continue;
-         
+
                 double njab = AngMom::NormNineJ(la,sa,ja, lb,sb,jb, Lab,Sab,J);
                 if (std::abs(njab) <1e-7) continue;
                 int Scd = Sab;
@@ -2453,32 +2462,32 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
                        // factor to account for antisymmetrization
                        int asymm_factor = (std::abs(bra.op->tz2+ket.op->tz2) + std::abs(bra.op->tz2+ket.oq->tz2)*modelspace.phase( lam_ab + Sab ))/ 2;
                        if ( asymm_factor ==0 ) continue;
-         
+
                        int lam_cd = lam_ab; // tcm and trel conserve lam and Lam
                        int n_ab = (fab - 2*N_ab-Lam_ab-lam_ab)/2; // n_ab is determined by energy conservation
-         
+
                        double mosh_ab = modelspace.GetMoshinsky(N_ab,Lam_ab,n_ab,lam_ab,na,la,nb,lb,Lab);
                        if (std::abs(mosh_ab)<1e-8) continue;
 //                       std::cout << "I asked for moshab: <" << N_ab << " " << Lam_ab << " " << n_ab << " " << lam_ab << " | " << na << " " << la << " " << nb << " " << lb << " >_" << Lab << std::endl;
-         
+
                        int N_cd = N_ab;
                        int n_cd = (fcd - 2*N_cd-Lam_cd-lam_cd)/2; // n_cd is determined by energy conservation
                        if (n_cd < 0) continue;
 //                       if  (n_ab != n_cd and N_ab != N_cd) continue;
-         
+
                        double mosh_cd = modelspace.GetMoshinsky(N_cd,Lam_cd,n_cd,lam_cd,nc,lc,nd,ld,Lcd);
                        if (std::abs(mosh_cd)<1e-8) continue;
 
                        double prefactor = njab * njcd * mosh_ab * mosh_cd * asymm_factor;
 
-                       size_t hash      = n_ab*(nmax+1)*(lrelmax+1) + n_cd*(lrelmax+1) + lam_ab;   
+                       size_t hash      = n_ab*(nmax+1)*(lrelmax+1) + n_cd*(lrelmax+1) + lam_ab;
                        if ( RadialIntegrals.find(hash) == RadialIntegrals.end() )
                        {
                          std::cout << "AAAHHH!!!  trying to access radial integral for " << n_ab << " " << n_cd << " " << lam_ab << "    and it's not there!!!!" << std::endl;
                        }
-                       double rad_int =  RadialIntegrals.at(hash) ;  
-//                       double rad_int_lookup =  RadialIntegrals[hash] ;  
-//                       double rad_int =  RadialIntegral_RpowK(n_ab, lam_ab, n_cd, lam_cd, -1) ;  
+                       double rad_int =  RadialIntegrals.at(hash) ;
+//                       double rad_int_lookup =  RadialIntegrals[hash] ;
+//                       double rad_int =  RadialIntegral_RpowK(n_ab, lam_ab, n_cd, lam_cd, -1) ;
 //                       if (std::abs( rad_int_lookup - rad_int)>1e-6)
 //                       {
 //                         std::cout << "discrepancy!!!  " << n_ab << " " << n_cd << " " << lam_ab << "    |   " << rad_int << "   " << rad_int_lookup << "   (maxvals) " << nmax << " " << lrelmax << std::endl;
@@ -2489,13 +2498,13 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
 //                                 << "   " << n_ab << " " << lam_ab << " " << 2*lam_ab+1 << "    " << fab << ","
 //                                 << "   " << n_cd << " " << lam_cd << " " << 2*lam_cd+1 << "    " << fcd
 //                                 << std::endl;
-//                       rinv += prefactor * VCoul.OneBody(a_eff, b_eff); 
-                       rinv += prefactor * rad_int; 
-    
+//                       rinv += prefactor * VCoul.OneBody(a_eff, b_eff);
+                       rinv += prefactor * rad_int;
+
                     } // lam_ab
                   } // Lam_ab
                 } // N_ab
-         
+
               } // Sab
             } // Lab
 
@@ -2504,7 +2513,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
 //            std::cout << "setting " << ch << " " << ibra << " " << iket << "  " << rinv << std::endl;
             VCoul.TwoBody.SetTBME(ch,ibra,iket,rinv);
             VCoul.TwoBody.SetTBME(ch,iket,ibra,rinv);
-                         
+
          }
       }
    }
@@ -2618,7 +2627,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
          }
          std::cout << "i,j,a " << i << " " << j << " " << a << " spes  " << ei << " " << ej << " " << ea << "  denominator  " << 1.0/((ep-ef)*(ei+ej-ea-ef)) << "   contribution  " << Jterm << std::endl;
        }
-     }	 
+     }
    }
    std::cout << "Amplitude is " << amplitude << std::endl;
    double SF = (op.j2+1.0) * amplitude * amplitude;
@@ -2629,12 +2638,12 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
 
  namespace atomic_fs
  { // operators related to fine structure
-  
+
    Operator Darwin(ModelSpace& modelspace, int Z )
    {
 //     double alpha_FS = 1.0 / 137.035999;
 //     double constants = M_PI * Z * alpha_FS * HBARC*HBARC*HBARC / (2*M_ELECTRON*M_ELECTRON*1e6*1e6) ; // convert to eV. M_PI is 3.1415... not the pion mass
-     double constants = PI * Z * ALPHA_FS * HBARC*HBARC*HBARC / (2*M_ELECTRON*M_ELECTRON*1e6*1e6) ; // convert to eV and nanometers.  
+     double constants = PI * Z * ALPHA_FS * HBARC*HBARC*HBARC / (2*M_ELECTRON*M_ELECTRON*1e6*1e6) ; // convert to eV and nanometers.
      Operator Hdarwin( modelspace,0,0,0,2);
      for (auto a : modelspace.all_orbits )
      {
@@ -2701,7 +2710,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
    // The orbit term, the tensor term, and the contact term
    // Hd = -0.5*alpha(hbarc)^3/(m_ec^2 m_pc^2) g_nuc I * [ r^-3 L  +1/2 g_s r^-3 ( 3(\vec{s}*\hat{r})\hat{r} - \vec{s} ) + 4pi/3 gs delta(r) \vec{s} )
    // we rewrite the tensor bit as
-   //                                 3(s*r)r-s = -sqrt{2pi}[s^(2) x Y^(2)]^(1) 
+   //                                 3(s*r)r-s = -sqrt{2pi}[s^(2) x Y^(2)]^(1)
    Operator hD(ModelSpace& modelspace )
    {
      Operator Hd( modelspace,1,0,0,2);  // J rank is 1, even parity.
@@ -2754,7 +2763,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
      return Hnms;
    }
 
-   
+
    Operator SpecificMassShift( ModelSpace& modelspace, int A )
    {
      Operator Hsms = imsrg_util::TCM_Op( modelspace ) ;  // TCM_Op returns a 1-body piece, plus the 1-body part pi*pj/mA. We don't want the 1-body part.
@@ -2766,7 +2775,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
    // Maybe we want it all in one operator
    Operator CombinedMassShift( ModelSpace& modelspace, int A )
    {
-     Operator Hcms = imsrg_util::TCM_Op( modelspace ) ; 
+     Operator Hcms = imsrg_util::TCM_Op( modelspace ) ;
      if (A!=modelspace.GetTargetMass()) Hcms *= (modelspace.GetTargetMass()/double(A));
      return Hcms;
    }
@@ -2777,7 +2786,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
 
 /// Get the first-order perturbative correction to a one-body operator
 /// The function returns a one-body operator, i.e. the two-body part is not computed.
-/// Formula is 
+/// Formula is
 /// \f[
 ///  \langle p \| O^{\lambda} \| q \rangle = \sum_{ia} (1+P_{ia}) (n_i \bar{n}_a) \sum_{J}(2J+1)
 /// \begin{Bmatrix}
@@ -2791,7 +2800,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
 //       |     ^~~~~X      |     ^
 //       |   a( )i     +   |   a( )i
 //       |_____v           |     v~~~~X
-//      q|                q|     
+//      q|                q|
 //
 //
  Operator FirstOrderCorr_1b( const Operator& OpIn, const Operator& H )
@@ -2841,7 +2850,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
              double Gamma_paiq = H.TwoBody.GetTBME_J(J,p,a,i,q);
              double Delta_paiq = H.OneBody(p,p) + H.OneBody(a,a) - H.OneBody(i,i) - H.OneBody(q,q);
              Opq += nanifactor * (2*J+1) * sixj * Oia * Gamma_paiq / Delta_paiq;
-           }           
+           }
          }
        }
        OpOut.OneBody(p,q) = Opq;
@@ -2895,7 +2904,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
      Ohp( i ) = OpIn.OneBody(h,p);
    }
 
-   
+
    // Next, construct the Mphph etc matrices
    arma::mat Mphph = GetPH_transformed_Gamma( ph_kets, ph_kets, H, Lambda );
    arma::mat Mphhp = GetPH_transformed_Gamma( ph_kets, hp_kets, H, Lambda );
@@ -3068,7 +3077,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
        {
          for (int Lam_ab=0; Lam_ab<= fab-2*N_ab; ++Lam_ab) // Lam_ab = CoM l for a,b
          {
-           int Lam_cd = Lam_ab; // Lcm and Lrel conserve lam and Lam, 
+           int Lam_cd = Lam_ab; // Lcm and Lrel conserve lam and Lam,
            for (int lam_ab=(fab-2*N_ab-Lam_ab)%2; lam_ab<= (fab-2*N_ab-Lam_ab); lam_ab+=2) // lam_ab = relative l for a,b
            {
               if (Lab<std::abs(Lam_ab-lam_ab) or Lab>(Lam_ab+lam_ab) ) continue;
@@ -3127,7 +3136,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
  // for cutoff R.  This delta is normalized to 1 when integrated over x,y,x.
  // So in spherical coordinates, the angular integration picks up a factor 4pi and the radial integration comes with r^2dr.
  //  The low energy constant g_nuNN is estimated by Cirigliano et al to be order fpi^-2
- //  where fpi is the pion decay constant. To make things dimensionless, we should 
+ //  where fpi is the pion decay constant. To make things dimensionless, we should
  // After discussing with Javier Menendez, the correct thing to do is to compute the dimensionless quantity
  // (r0 A^1/3) / mpi^2  * delta_R(r)
  // Since g_nuNN is order fpi^-2, the combination fpi^2 * g_nuNN is a dimensionless number of order 1
@@ -3182,7 +3191,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
    std::vector<std::array<size_t,2>> braketchannels;
    for ( auto channel : M0nuCT.TwoBody.MatEl ) braketchannels.push_back(channel.first);
    int nchan = braketchannels.size();
-//   #pragma omp parallel for schedule(dynamic,1)  
+//   #pragma omp parallel for schedule(dynamic,1)
    for (int ch=0; ch<nchan; ++ch)
    {
       int chbra = braketchannels[ch][0];
@@ -3213,14 +3222,14 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
 
             Orbit & oc = modelspace.GetOrbit(ket.p);
             Orbit & od = modelspace.GetOrbit(ket.q);
-         
+
             int nc = oc.n;
             int nd = od.n;
-         
+
             int lc = oc.l;
             int ld = od.l;
             if (la>lmax or lb>lmax or lc>lmax or ld>lmax) continue;
-         
+
             double jc = oc.j2*0.5;
             double jd = od.j2*0.5;
             int fcd = 2*nc + 2*nd + lc + ld;
@@ -3237,7 +3246,7 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
               for (int Sab=0; Sab<=1; ++Sab)
               {
                 if ( std::abs(Lab-Sab)>J or Lab+Sab<J) continue;
-         
+
                 double njab = AngMom::NormNineJ(la,sa,ja, lb,sb,jb, Lab,Sab,J);
                 if (std::abs(njab) <1e-7) continue;
                 int Scd = Sab;
@@ -3260,26 +3269,26 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
                        // matrix elements are < pp | M | nn >, so we need (-1)(lam + S) to be positive
                        int asymm_factor = (1 + 1*modelspace.phase( lam_ab + Sab ))/ 2;
                        if ( asymm_factor ==0 ) continue;
-         
+
                        int lam_cd = lam_ab; // tcm and trel conserve lam and Lam
                        int n_ab = (fab - 2*N_ab-Lam_ab-lam_ab)/2; // n_ab is determined by energy conservation
-         
+
                        double mosh_ab = modelspace.GetMoshinsky(N_ab,Lam_ab,n_ab,lam_ab,na,la,nb,lb,Lab);
                        if (std::abs(mosh_ab)<1e-8) continue;
-         
+
                        int N_cd = N_ab;
                        int n_cd = (fcd - 2*N_cd-Lam_cd-lam_cd)/2; // n_cd is determined by energy conservation
                        if (n_cd < 0) continue;
 //                       if  (n_ab != n_cd and N_ab != N_cd) continue;
-         
+
                        double mosh_cd = modelspace.GetMoshinsky(N_cd,Lam_cd,n_cd,lam_cd,nc,lc,nd,ld,Lcd);
                        if (std::abs(mosh_cd)<1e-8) continue;
 
                        double prefactor = njab * njcd * mosh_ab * mosh_cd * asymm_factor;
 
-                       double rad_int =  RadialIntegral_Gauss( n_ab,lam_ab, n_cd,lam_cd, sigma) ;  
- 
-                       mcont += prefactor * rad_int; 
+                       double rad_int =  RadialIntegral_Gauss( n_ab,lam_ab, n_cd,lam_cd, sigma) ;
+
+                       mcont += prefactor * rad_int;
 //                       if (verbose) std::cout << "   Nab Lamab nab lamab = " << N_ab << " " << Lam_ab << " " << n_ab << " " << lam_ab
 //                                              << "  Ncd Lamcd ncd lamcd = " << N_cd << " " << Lam_cd << " " << n_cd << " " << lam_cd
 //                                              << " mosh_ab , mosh_cd = " << mosh_ab << " " << mosh_cd << "  asymm_factor = " << asymm_factor
@@ -3290,15 +3299,15 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
 //                        for ( size_t i=0; i<rgrid.size(); i++ )
 //                        {
 //                          psirel[i] += prefactor * pow(2,-1.5)* HO_density(n_ab, lam_ab, modelspace.GetHbarOmega(), rgrid[i] /sqrt(2) );
-//                          
+//
 //                        }
 //                      }
 
-    
+
                     } // lam_ab
                   } // Lam_ab
                 } // N_ab
-         
+
               } // Sab
             } // Lab
 //            if (verbose)
@@ -3309,10 +3318,10 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
 //              }
 //            }
 
-            mcont *=  normalization / sqrt((1.0+bra.delta_pq())*(1.0+ket.delta_pq())); // normalize 
+            mcont *=  normalization / sqrt((1.0+bra.delta_pq())*(1.0+ket.delta_pq())); // normalize
 //            if (verbose) std::cout << " with normalization " << normalization << " , setting matrix element to " << mcont << std::endl;
             M0nuCT.TwoBody.SetTBME(chbra,chket,ibra,iket,mcont);
-                         
+
          }
       }
    }
@@ -3322,484 +3331,6 @@ Operator FourierBesselCoeff(ModelSpace& modelspace, int nu, double R, std::set<i
  }
 
 
-
-
-
-
-
-//////////// M0v functions written by Charlie Payne //////////////////////////
-
-/// This is the M^{0\nu} TBME from Equation (1) of [PRC 87, 064315 (2013)]
-/// it was coded up by me, ie) Charlie Payne (CP)
-/// from my thesis, I employed Equations: 
-  Operator M0nu_TBME_Op(ModelSpace& modelspace, int Nquad, std::string src)
-  {
-    // VVV~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~VVV
-    // VVV~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~VVV
-    using PhysConst::HBARC;
-    using PhysConst::PI;
-    // adjustable parameters, lines BELOW
-    //double reltol = 2*pow(10,-4); // relative tolerance for GLQ integration convergence
-//    const double mpro = 938.27231; // the proton mass [MeV] for the g-factors
-//    const double mpion = 139.57; // the pion mass [MeV] for the g-factors
-//    const double magmom = 3.706; // the difference between the (anomolous?) magnetic moment of a proton and neutron (units of \mu_N)
-    const double mpro = PhysConst::M_PROTON; // the proton mass [MeV] for the g-factors
-    const double mpion = PhysConst::M_PION_CHARGED; // the pion mass [MeV] for the g-factors
-    const double magmom = (PhysConst::PROTON_SPIN_G-2 - PhysConst::NEUTRON_SPIN_G)/2.0; // the difference between the (anomolous?) magnetic moment of a proton and neutron (units of \mu_N)
-//    const double g0V = 1.0; // the vector g-factor at zero momentum
-//    const double g0A = 1.27; // the axial-vector g-factor at zero momentum
-    const double g0V = PhysConst::NUCLEON_VECTOR_G ; // the vector g-factor at zero momentum
-    const double g0A = PhysConst::NUCLEON_AXIAL_G ; // the axial-vector g-factor at zero momentum
-    const double cutoffV = 850.0; // the vector finite-size parameter [MeV]
-    const double cutoffA = 1086.0; // the axial-vector finite-size parameter [MeV]
-    const double Ebar = 5.0; // the ref-closure energy [MeV], should be roughly independent of this...
-    const double Ei = 0.0; // the initial energy [MeV] in the closure energy (4.26798)
-    const double Ef = 0.0; // " final " [MeV] " " " "
-    //const double mnusq = pow(1.2,-14); // the (max) electron-neutrino mass squared [MeV^2] (this is primarily for testing)
-    // adjustable parameters, lines ABOVE
-    // ^^^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^
-    // ^^^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^
-    Operator M0nu_TBME(modelspace,0,2,0,2); // NOTE: from the constructor -- Operator::Operator(ModelSpace& ms, int Jrank, int Trank, int p, int part_rank)
-    M0nu_TBME.SetHermitian(); // it should be Hermitian...
-    const double Rnuc = (1.2/HBARC)*pow(modelspace.GetTargetMass(),1.0/3.0); // the nuclear radius [MeV^-1]
-    const double prefact = 2*(2*Rnuc)/(PI*g0A*g0A); // factor in-front of M0nu TBME [MeV^-1], factor of 2 from sum_{ab} = 2sum_{a<b} to match with JE
-    const double Ediff = Ebar - ((Ei + Ef)/2.0); // the closure energy [MeV]
-    // set the SRC parameters a,b,c in the Jastrow-type correlation function
-    double aa,bb; // [MeV^2]
-    double cc; // [Unitless]
-    std::string argstr = "Argonne";
-    std::string cdbstr = "CD-Bonn";
-    std::string masstr = "Miller-Spencer";
-    if (src == argstr)
-    {
-      aa = 1.59*HBARC*HBARC;
-      bb = 1.45*HBARC*HBARC;
-      cc = 0.92;
-    }
-    else if (src == cdbstr)
-    {
-      aa = 1.52*HBARC*HBARC;
-      bb = 1.88*HBARC*HBARC;
-      cc = 0.46;
-    }
-    else if (src == masstr)
-    {
-      aa = 1.1*HBARC*HBARC;
-      bb = 0.68*HBARC*HBARC;
-      cc = 1.0;
-    }
-    else // src == "none" or otherwise
-    {
-      aa = 0;  bb = 0;  cc = 0; // set them to zero to avoid variable warnings
-    }
-    // set the GLQ roots and weights
-    if (Nquad != 187)
-    {
-      std::cout<<"ERROR 187: please set Nquad to 187 by running the operator as M0nu_TBME_187_none"<<std::endl;
-      std::cout<<"which I do to stay consistent with previous naming conventions."<<std::endl;
-      exit(1);
-    }
-    double nodes[187][2] = { {0.00771093190434205, 0.01978880917191989},
-                               {0.04062903529180086, 0.04606592889118855},
-                               {0.09985365551375681, 0.07238518879149865},
-                               {0.1854021036766674, 0.09871291032827842},
-                               {0.2972819985528331, 0.1250482436418515},
-                               {0.4355015848139718, 0.151392567186406},
-                               {0.6000707059043154, 0.1777476120597593},
-                               {0.7910009885390217, 0.2041151966450439},
-                               {1.008305895218917, 0.2304971697691649},
-                               {1.252000745415518, 0.2568953952378961},
-                               {1.522102727728737, 0.2833117470989823},
-                               {1.818630909285556, 0.3097481082650387},
-                               {2.141606244467358, 0.3362063703580633},
-                               {2.491051583758736, 0.3626884340417398},
-                               {2.866991683053023, 0.389196209573469},
-                               {3.269453213570937, 0.4157316174666621},
-                               {3.698464772473222, 0.4422965892116879},
-                               {4.154056894213615, 0.4688930680324417},
-                               {4.636262062662657, 0.4955230096710074},
-                               {5.145114724024852, 0.5221883831886691},
-                               {5.680651300567963, 0.5488911717891486},
-                               {6.242910205181583, 0.5756333736530594},
-                               {6.831931856781384, 0.6024170027954671},
-                               {7.447758696575838, 0.6292440899340502},
-                               {8.09043520521219, 0.6561166833776932},
-                               {8.760007920819465, 0.6830368499335451},
-                               {9.456525457966828, 0.7100066758308241},
-                               {10.18003852755672, 0.7370282676660339},
-                               {10.93059995767296, 0.7641037533676859},
-                               {11.70826471540523, 0.7912352831858124},
-                               {12.5130899296724, 0.8184250306993499},
-                               {13.34513491506818, 0.8456751938532073},
-                               {14.20446119675403, 0.8729879960168208},
-                               {15.09113253642537, 0.9003656870720292},
-                               {16.00521495937847, 0.9278105445271643},
-                               {16.94677678270679, 0.9553248746614917},
-                               {17.91588864465706, 0.9829110137007926},
-                               {18.91262353517667, 1.01057132902482},
-                               {19.93705682768588, 1.038308220409159},
-                               {20.98926631210941, 1.066124121303237},
-                               {22.0693322292045, 1.094021500145207},
-                               {23.17733730622346, 1.122002861716167},
-                               {24.31336679395113, 1.15007074853609},
-                               {25.47750850515957, 1.17822774230309},
-                               {26.6698528545242, 1.20647646537708},
-                               {27.89049290004778, 1.234819582312125},
-                               {29.13952438604095, 1.263259801437972},
-                               {30.4170457877105, 1.291799876493899},
-                               {31.72315835740869, 1.320442608317681},
-                               {33.05796617259991, 1.349190846591676},
-                               {34.42157618560343, 1.378047491649795},
-                               {35.81409827517415, 1.407015496346448},
-                               {37.23564529998588, 1.436097867993353},
-                               {38.68633315408532, 1.465297670364799},
-                               {40.16628082438788, 1.494618025776432},
-                               {41.67561045029016, 1.524062117241149},
-                               {43.21444738547788, 1.553633190703724},
-                               {44.78292026201128, 1.583334557362363},
-                               {46.38116105677503, 1.613169596076766},
-                               {48.00930516038326, 1.643141755871362},
-                               {49.66749144863559, 1.67325455853451},
-                               {51.35586235662428, 1.703511601322361},
-                               {53.07456395559839, 1.733916559770406},
-                               {54.82374603269579, 1.764473190618135},
-                               {56.60356217365987, 1.795185334854757},
-                               {58.41416984866382, 1.826056920890234},
-                               {60.25573050137191, 1.85709196785874},
-                               {62.12840964137386, 1.888294589062953},
-                               {64.03237694013582, 1.919668995564201},
-                               {65.96780633061908, 1.951219499929162},
-                               {67.93487611072592, 1.98295052013875},
-                               {69.93376905074039, 2.014866583670929},
-                               {71.9646725049416, 2.046972331764233},
-                               {74.02777852757615, 2.079272523874329},
-                               {76.12328399338745, 2.111772042333272},
-                               {78.25139072291041, 2.144475897222693},
-                               {80.41230561275184, 2.177389231474337},
-                               {82.6062407710895, 2.21051732620899},
-                               {84.83341365863637, 2.243865606330362},
-                               {87.09404723533066, 2.277439646385225},
-                               {89.38837011302772, 2.311245176709602},
-                               {91.71661671448609, 2.345288089874654},
-                               {94.07902743895778, 2.379574447450897},
-                               {96.47584883471066, 2.41411048711277},
-                               {98.90733377883214, 2.448902630099688},
-                               {101.3737416646834, 2.483957489059988},
-                               {103.8753385973973, 2.519281876298236},
-                               {106.4123975978368, 2.554882812454203},
-                               {108.9851988154589, 2.590767535637621},
-                               {111.5940297505536, 2.626943511051393},
-                               {114.2391854863636, 2.663418441132556},
-                               {116.9209689316168, 2.700200276245322},
-                               {119.6396910740445, 2.73729722596323},
-                               {122.3956712454915, 2.774717770979608},
-                               {125.189237399269, 2.812470675688552},
-                               {128.0207264004418, 2.850565001482234},
-                               {130.8904843297925, 2.889010120814019},
-                               {133.7988668022529, 2.927815732081122},
-                               {136.7462393006521, 2.966991875383191},
-                               {139.7329775256874, 3.006548949222304},
-                               {142.759467763093, 3.046497728208849},
-                               {145.8261072690484, 3.08684938184865},
-                               {148.9333046749477, 3.127615494490461},
-                               {152.0814804127326, 3.168808086522331},
-                               {155.2710671620838, 3.210439636907599},
-                               {158.5025103208623, 3.25252310716648},
-                               {161.7762685003008, 3.29507196691414},
-                               {165.092814046561, 3.338100221076514},
-                               {168.4526335904016, 3.381622438918201},
-                               {171.8562286268402, 3.425653785027162},
-                               {175.3041161268443, 3.470210052418758},
-                               {178.7968291832567, 3.515307697927283},
-                               {182.3349176933386, 3.560963880085994},
-                               {185.9189490805198, 3.607196499697949},
-                               {189.5495090581641, 3.654024243333757},
-                               {193.2272024383993, 3.701466630010565},
-                               {196.9526539893333, 3.749544061332636},
-                               {200.7265093442698, 3.79827787540431},
-                               {204.5494359668643, 3.847690404859263},
-                               {208.4221241765241, 3.897805039384193},
-                               {212.3452882387537, 3.948646293160198},
-                               {216.3196675255918, 4.000239877687697},
-                               {220.3460277517803, 4.052612780516117},
-                               {224.4251622928536, 4.105793350456135},
-                               {228.5578935919482, 4.159811389922316},
-                               {232.7450746628161, 4.214698255126153},
-                               {236.9875906972909, 4.27048696492881},
-                               {241.2863607863087, 4.327212319259251},
-                               {245.6423397645486, 4.384911028115464},
-                               {250.0565201898382, 4.443621852294881},
-                               {254.5299344696856, 4.503385757145375},
-                               {259.0636571486737, 4.564246080797834},
-                               {263.6588073720075, 4.62624871853364},
-                               {268.3165515422674, 4.689442325160785},
-                               {273.0381061884222, 4.75387853753741},
-                               {277.8247410684369, 4.819612219670748},
-                               {282.6777825294121, 4.88670173317499},
-                               {287.5986171521681, 4.95520923627262},
-                               {292.5886957106057, 5.025201014998875},
-                               {297.6495374801001, 5.096747850818959},
-                               {302.7827349337207, 5.169925429530114},
-                               {307.9899588703066, 5.24481479708569},
-                               {313.2729640245108, 5.321502868882359},
-                               {318.6335952160018, 5.400083000160843},
-                               {324.0737941032713, 5.480655626428459},
-                               {329.5956066171773, 5.563328984392797},
-                               {335.2011911607244, 5.648219925738174},
-                               {340.8928276750128, 5.735454838322556},
-                               {346.67292768718, 5.825170692111637},
-                               {352.5440454750781, 5.917516230461636},
-                               {358.5088905060044, 6.012653331443834},
-                               {364.5703413339042, 6.11075856888457},
-                               {370.7314611721156, 6.212025008974579},
-                               {376.9955153982821, 6.3166642859827},
-                               {383.3659912962149, 6.424909010223284},
-                               {389.8466203984501, 6.537015573515938},
-                               {396.4414038658405, 6.653267432708673},
-                               {403.1546414304768, 6.773978971401204},
-                               {409.9909645404044, 6.899500065148414},
-                               {416.9553744854671, 7.030221508018704},
-                               {424.0532864618092, 7.166581500960829},
-                               {431.2905807597857, 7.309073458588748},
-                               {438.6736625522015, 7.458255465736875},
-                               {446.2095321389017, 7.614761815679939},
-                               {453.9058680004354, 7.779317198652938},
-                               {461.7711256711422, 7.952754297479251},
-                               {469.8146563226232, 8.136035809504971},
-                               {478.0468501423313, 8.330282285006321},
-                               {486.4793112320975, 8.536807704774064},
-                               {495.1250730378306, 8.75716549697966},
-                               {503.998866560597, 8.993208849137494},
-                               {513.1174582695169, 9.247170924190588},
-                               {522.5000815040654, 9.521773309539423},
-                               {532.1689954739326, 9.820375353805916},
-                               {542.1502218601211, 10.14718412234403},
-                               {552.4745341908956, 10.50755665060706},
-                               {563.1788163012253, 10.9084470923048},
-                               {574.3079759021866, 11.35908954153151},
-                               {585.9177225644977, 11.87208048166133},
-                               {598.0787485964511, 12.4651733647271},
-                               {610.8833037499799, 13.16442107333889},
-                               {624.4561163494692, 14.01006813896018},
-                               {638.9738566152255, 15.06861784527307},
-                               {654.70324721585, 16.46066092751913},
-                               {672.0863369696656, 18.43694351949129},
-                               {691.9752748484226, 21.65051648474522},
-                               {716.5834864211865, 28.8014926391697} }; // nodes[ row ][ 0 = roots, 1 = weights ] 
-    // pre-calculate the needed form factors, for efficency
-    double hF[Nquad]; // the Fermi form factor
-    double hGT[Nquad]; // the Gamow-Teller form factor
-    for (int i=0; i<Nquad; i++)
-    {
-      double q = nodes[i][0]; // set the transfer momentum [MeV] via the impending GLQ
-      double qsq = q*q; // q squared
-      double mprosq = mpro*mpro; // the proton mass squared
-      double mpionsq = mpion*mpion; // the pion mass squared
-      double gV = g0V/pow((1.0 + (qsq/(cutoffV*cutoffV))),2); // from Equation (4.3)
-      double gA = g0A/pow((1.0 + (qsq/(cutoffA*cutoffA))),2); // " " "
-      double gP = (2*mpro*gA)/(qsq + mpionsq); // " " "
-      double gM = magmom*gV; // " " "
-      hF[i] = -1*gV*gV; // from Equation (4.2)
-      hGT[i] = (gA*gA) - ((gA*gP*qsq)/(3*mpro)) + (pow(gP*qsq,2)/(12*mprosq)) + ((gM*gM*qsq)/(6*mprosq)); // " " "
-      //hGT[i] = (gA*gA)*( 1.0 - (2.0/3.0)*(qsq/(qsq + mpionsq)) + (1.0/3.0)*pow((qsq/(qsq + mpionsq)),2) ) + (pow(magmom,2)/(6.0*mprosq))*pow(gV,2)*qsq; // also works, le algebra
-    }
-    // create the TBME of M0nu
-    for (auto& itmat : M0nu_TBME.TwoBody.MatEl)
-    {
-      int chbra = itmat.first[0]; // grab the channel count from auto
-      int chket = itmat.first[1]; // " " " " " "
-      TwoBodyChannel& tbc_bra = modelspace.GetTwoBodyChannel(chbra); // grab the two-body channel
-      TwoBodyChannel& tbc_ket = modelspace.GetTwoBodyChannel(chket); // " " " " "
-      int nbras = tbc_bra.GetNumberKets(); // get the number of bras
-      int nkets = tbc_ket.GetNumberKets(); // get the number of kets
-      double J = tbc_bra.J; // NOTE: by construction, J := J_ab == J_cd := J'
-      double Jhat = sqrt(2*J + 1); // the hat factor of J
-      for (int ibra=0; ibra<nbras; ibra++)
-      {
-        Ket& bra = tbc_bra.GetKet(ibra); // get the final state = <ab| == <a_f,b_f|
-        int ia = bra.p; // get the integer label a
-        int ib = bra.q; // get the integer label b
-        Orbit& oa = modelspace.GetOrbit(ia); // get the <a| state orbit
-        Orbit& ob = modelspace.GetOrbit(ib); // get the <b| state prbit
-        for (int iket=0; iket<nkets; iket++)
-        {
-          Ket& ket = tbc_ket.GetKet(iket); // get the initial state = |cd> == |a_i,b_i>
-          int ic = ket.p; // get the integer label c
-          int id = ket.q; // get the integer label d
-          Orbit& oc = modelspace.GetOrbit(ic); // get the |c> state orbit
-          Orbit& od = modelspace.GetOrbit(id); // get the |d> state orbit
-          // initialize the matrix element to zero
-          double MF = 0;
-          double MGT = 0;
-          int na = oa.n; // this is just...
-          int nb = ob.n;
-          int nc = oc.n;
-          int nd = od.n;
-          int la = oa.l;
-          int lb = ob.l;
-          int lc = oc.l;
-          int ld = od.l;
-          double ja = oa.j2/2.0;
-          double jb = ob.j2/2.0;
-          double jc = oc.j2/2.0;
-          double jd = od.j2/2.0; // ...for convenience
-std::cout<<J<<" | "<<ia<<", "<<ib<<", "<<ic<<", "<<id<<" || "
-<<na<<", "<<nb<<", "<<nc<<", "<<nd<<" | "
-<<la<<", "<<lb<<", "<<lc<<", "<<ld<<" | "
-<<ja<<", "<<jb<<", "<<jc<<", "<<jd<<" |=|  ";
-          int eps_ab = 2*na + la + 2*nb + lb; // for conservation of energy in the Moshinsky brackets
-          int eps_cd = 2*nc + lc + 2*nd + ld; // ...likewise
-          double sumglqF = 0; // for the GLQ integration below (F)
-          double sumglqFas = 0; // ...anti-symmetric part (F)
-          double sumglqGT = 0; // (GT)
-          double sumglqGTas = 0; // (GT)
-          //double sumGLQ = 0; // (F+GT)
-          //double sumGLQas = 0; // (F+GT)
-          for (int i=0; i<Nquad; i++)
-          {
-            double q = nodes[i][0]; // set the transfer momentum [MeV] via the impending GLQ
-            double sumB = 0; // for the pure Bessel's Matrix Elemets (BMEs)
-            double sumBas = 0; // ...anti-symmetric part
-            double sumBSdS = 0; // for the scalar product of the Bessel's functions and Sigma dot Sigma (SdS)
-            double sumBSdSas = 0; // ...anti-symmetric part
-            for (int S=0; S<=1; S++) // sum over total spin...
-            {
-              for (int L = std::abs(la-lb); L <= la+lb; L++) // ...and sum over angular momentum coupled to l_{a_f} and l_{b_f}, NOTE: get same result if used l_{a_i} and l_{b_i} (good)
-              {
-                double tempLS = (2*L + 1)*(2*S + 1); // just for efficiency, only used in the three lines below
-                double normab = sqrt(tempLS*(2*ja + 1)*(2*jb + 1)); // normalization factor for the 9j-symbol out front
-                double nNJab = normab*modelspace.GetNineJ(la,lb,L,0.5,0.5,S,ja,jb,J); // the normalized 9j-symbol out front
-                double normcd = sqrt(tempLS*(2*jc + 1)*(2*jd + 1)); // normalization factor for the second 9j-symbol
-                double nNJcd = normcd*modelspace.GetNineJ(lc,ld,L,0.5,0.5,S,jc,jd,J); // the second normalized 9j-symbol
-                double nNJdc = normcd*modelspace.GetNineJ(ld,lc,L,0.5,0.5,S,jd,jc,J); // ...anti-symmetric part
-                double sumMT = 0; // for the Moshinsky-transformed relative BMEs (RBMEs)
-                double sumMTas = 0; // ...anti-symmetric part
-                double tempmaxnr = floor((eps_ab - L)/2.0); // just for the limits below
-                double tempmaxnpr = floor((eps_cd - L)/2.0); // " " " " "
-                for (int nr = 0; nr <= tempmaxnr; nr++)
-                {
-                  double tempmaxNcom = tempmaxnr - nr; // just for the limits below
-                  for (int Ncom = 0; Ncom <= tempmaxNcom; Ncom++)
-                  {
-                    int tempminlr = ceil((eps_ab - L)/2.0) - (nr + Ncom); // just for the limits below
-                    int tempmaxlr = floor((eps_ab + L)/2.0) - (nr + Ncom); // " " " " "
-                    for (int lr = tempminlr; lr <= tempmaxlr; lr++)
-                    {
-                      int Lam = eps_ab - 2*(nr + Ncom) - lr; // via Equation () of my thesis
-                      for (int npr = 0; npr <= tempmaxnpr; npr++) // npr = n'_r in my latex notation
-                      {
-                        double RBME; // calculate via functions below this Operator
-                        if (src == argstr or src == cdbstr or src == masstr)
-                        {
-                          RBME = CPrbmeGen(modelspace,0,q,nr,lr,npr,lr,0,0)
-                            - 2*cc*CPrbmeGen(modelspace,0,q,nr,lr,npr,lr,0,aa)
-                            + 2*cc*bb*CPrbmeGen(modelspace,0,q,nr,lr,npr,lr,2,aa)
-                            + cc*cc*CPrbmeGen(modelspace,0,q,nr,lr,npr,lr,0,2.0*aa)
-                            - 2*bb*cc*cc*CPrbmeGen(modelspace,0,q,nr,lr,npr,lr,2,2.0*aa)
-                            + cc*cc*bb*bb*CPrbmeGen(modelspace,0,q,nr,lr,npr,lr,4,2.0*aa); // testing...
-                        }
-                        else
-                        {
-                          RBME = CPrbmeGen(modelspace,0,q,nr,lr,npr,lr,0,0);
-                          //RBME = CPrbmeGLQ(modelspace,Nquad,nodes,q,nr,lr,npr,lr,0,0);
-                        }
-                        double Df = modelspace.GetMoshinsky(Ncom,Lam,nr,lr,na,la,nb,lb,L); // Ragnar has -- double mosh_ab = modelspace.GetMoshinsky(N_ab,Lam_ab,n_ab,lam_ab,na,la,nb,lb,Lab);
-                        double Di =  modelspace.GetMoshinsky(Ncom,Lam,npr,lr,nc,lc,nd,ld,L);
-                        double asDi = modelspace.GetMoshinsky(Ncom,Lam,npr,lr,nd,ld,nc,lc,L); // ...anti-symmetric part
-                        double temphat = 1.0/sqrt(2*lr + 1); // just for the several lines below
-                        double tempD = Df*Di; // " " " " " "
-                        double tempDas = Df*asDi; // " " " " " "
-                        sumMT += temphat*tempD*RBME; // perform the Talmi-Moshinsky transformation
-                        sumMTas += temphat*tempDas*RBME; // ...anti-symmetric part
-                      } // end of for-loop over: npr
-                    } // end of for-loop over: lr
-                  } // end of for-loop over: Ncom
-                } // end of for-loop over: nr
-                double temprod = nNJab*nNJcd*sumMT; // just for efficiency, only used in the lines below
-                double temprodas = nNJab*nNJdc*sumMTas; // ...anti-symmetric part
-                int tempSeval = 2*S*(S + 1) - 3; // eigenvalue of S, only used in the lines below
-                sumB += temprod; // this completes Equation (4.64), modulo Jhat
-                sumBas += temprodas; // ...anti-symmetric part
-                sumBSdS += tempSeval*temprod; // this completes Equation (4.49), modulo Jhat
-                sumBSdSas += tempSeval*temprodas; // ...anti-symmetric part
-              } // end of for-loop over: L
-            } // end of for-loop over: S
-            //
-            double integrandF = (q/(q + Ediff))*(hF[i]*sumB); // Fermi part only
-            double integrandFas = (q/(q + Ediff))*(hF[i]*sumBas); // ...anti-symmetric part
-            double integrandGT = (q/(q + Ediff))*(hGT[i]*sumBSdS); // Gamow-Teller part only
-            double integrandGTas = (q/(q + Ediff))*(hGT[i]*sumBSdSas); // ...anti-symmetric part
-            //
-            /*
-            double qsq = pow(q,2);
-            double Enu = sqrt(qsq + mnusq);
-            double integrandF = (qsq/(Enu + Ediff))*((hF[i]/Enu)*sumB);
-            double integrandFas = (qsq/(Enu + Ediff))*((hF[i]/Enu)*sumBas);
-            double integrandGT = (qsq/(Enu + Ediff))*((hGT[i]/Enu)*sumBSdS);
-            double integrandGTas = (qsq/(Enu + Ediff))*((hGT[i]/Enu)*sumBSdSas);
-            */
-            //double integrand = (q/(q + Ediff))*(hF[i]*sumB + hGT[i]*sumBSdS); // F+GT full integrand
-            //double integrandas = (q/(q + Ediff))*(hF[i]*sumBas + hGT[i]*sumBSdSas); // ...anti-symmetric part
-            sumglqF += nodes[i][1]*integrandF; // perform the GLQ integration (F)
-            sumglqFas += nodes[i][1]*integrandFas; // ...anti-symmetric part (F)
-            sumglqGT += nodes[i][1]*integrandGT; // perform the GLQ integration (GT)
-            sumglqGTas += nodes[i][1]*integrandGTas; // ...anti-symmetric part (GT)
-            //sumGLQ += nodes[i][1]*integrand; // perform the GLQ integration (F+GT)
-            //sumGLQas += nodes[i][1]*integrandas; // ...anti-symmetric part (F+GT)
-          } // end of for-loop wrt: GLQ
-          double scale = 1.0; // global factor to compare with JE
-          double tempfact = scale*prefact*Jhat; // just for the lines below
-          double tempnorm = cpNorm(ia,ib)*cpNorm(ic,id); // just for the lines below
-          double temphase = modelspace.phase(jc + jd - J); // just for the lines below
-          MF = tempnorm*tempfact*(sumglqF - temphase*sumglqFas); // see Equation () of my thesis, (F)
-          MGT = tempnorm*tempfact*(sumglqGT - temphase*sumglqGTas); // see Equation () of my thesis, (GT)
-          double Mtbme = MF + MGT; // see Equation () of my thesis
-std::cout<<MF<<",  "<<MGT<<",  "<<Mtbme<<std::endl;
-          M0nu_TBME.TwoBody.SetTBME(chbra,chket,ibra,iket,Mtbme); // set the two-body matrix elements (TBME) to M_ab
-        } // end of for-loop over: iket
-      } // end of for-loop over: ibra
-    } // end of for-loop over: auto
-    return M0nu_TBME;
-  }
- 
-
-/// testing...
-/// mm = 0,2,4
-/// pp = 0,a,2a
-  double CPrbmeGen(ModelSpace& modelspace, double rho, double x, int n, int l, int np, int lp, int mm, double pp)
-  {
-    x *= SQRT2; // this is to stay consistent with r_{rel} = (r_1 - r_2)/SQRT2 in Moshinksy brackets
-    double b = 1.0/sqrt(M_NUCLEON*modelspace.GetHbarOmega()); // the oscillator length [MeV^-1], from Equation (1.95) of my thesis
-    double bisq = 1.0/(b*b); // the inverse squared oscillator length
-    double yolo = (x*x)/(4.0*(pp + bisq)); // commonly reoccuring argument in the RBMEs
-    double normy = (1.0/pow(2,rho+1))*(1.0/pow(b,3))*sqrt((PI*gsl_sf_fact(n)*gsl_sf_fact(np))/(gsl_sf_gamma(n + l + 1.5)*gsl_sf_gamma(np + lp + 1.5))); // the normalization factor
-    double sum = 0; // initialize the double sum over k, k'
-    for (int k=0; k<=n; k++)
-    {
-      for (int kp=0; kp<=np; kp++)
-      {
-        int kappa = ((l + lp - rho + mm)/2.0) + k + kp; // rho should be divisible by 2! >:|
-        double llkk = l + lp + 2*k + 2*kp;
-        double hahaha = pow(b,-llkk)*pow((pp + bisq),-(llkk + 3 + mm)/2.0);
-        double one = modelspace.phase(k + kp)/(gsl_sf_fact(k)*gsl_sf_fact(kp));
-        double bci = gsl_sf_gamma(n + l + 1.5)/(gsl_sf_gamma(n - k + 1.0)*gsl_sf_gamma(l + k + 1.5)); // the first binomial coefficient, via taking ratios of Gamma functions
-        double bcj = gsl_sf_gamma(np + lp + 1.5)/(gsl_sf_gamma(np - kp + 1.0)*gsl_sf_gamma(lp + kp + 1.5)); // the second binomial coefficient, " " " " " "
-        double two = bci*bcj;
-        double three = gsl_sf_fact(kappa);
-        double four = gsl_sf_laguerre_n(kappa,rho+0.5,yolo); // from GSL -- L^a_n(x) = gsl_sf_laguerre_n(const int n, const double a, const double x)
-        sum += hahaha*one*two*three*four; // perform the summation
-      }
-    }
-    double rbme = normy*pow(b*x,rho)*exp(-yolo)*sum; // see Equation (4.61) in my thesis
-    return rbme;
-  }
-
-/////////////// end of M0v functions from Charlie Payne //////////////////////////
-
-
-
-
-
  // Orbital angular momentum squared L^2 in the relative coordinate.
  // This was written with the deuteron in mind. Not sure if it will be useful for other systems.
  Operator L2rel_Op(ModelSpace& modelspace)
@@ -3808,7 +3339,7 @@ std::cout<<MF<<",  "<<MGT<<",  "<<Mtbme<<std::endl;
 
    int nchan = modelspace.GetNumberTwoBodyChannels();
    modelspace.PreCalculateMoshinsky();
-   #pragma omp parallel for schedule(dynamic,1) 
+   #pragma omp parallel for schedule(dynamic,1)
    for (int ch=0; ch<nchan; ++ch)
    {
     TwoBodyChannel& tbc = modelspace.GetTwoBodyChannel(ch);
@@ -3825,44 +3356,44 @@ std::cout<<MF<<",  "<<MGT<<",  "<<Mtbme<<std::endl;
        Orbit & ob = modelspace.GetOrbit(bra.q);
        Orbit & oc = modelspace.GetOrbit(ket.p);
        Orbit & od = modelspace.GetOrbit(ket.q);
-    
+
        int na = oa.n;
        int nb = ob.n;
        int nc = oc.n;
        int nd = od.n;
-    
+
        int la = oa.l;
        int lb = ob.l;
        int lc = oc.l;
        int ld = od.l;
-    
+
        double ja = oa.j2/2.0;
        double jb = ob.j2/2.0;
        double jc = oc.j2/2.0;
        double jd = od.j2/2.0;
-    
+
        int fab = 2*na + 2*nb + la + lb;
        int fcd = 2*nc + 2*nd + lc + ld;
        if (fab != fcd) continue; // L2 conserves all the quantum numbers
-    
+
        double sa,sb,sc,sd;
        sa=sb=sc=sd=0.5;
-    
+
        double L2rel=0;
-    
+
        for (int Lab=std::abs(la-lb); Lab<= la+lb; ++Lab)
        {
          for (int Sab=0; Sab<=1; ++Sab)
          {
            if ( std::abs(Lab-Sab)>J or Lab+Sab<J) continue;
-    
+
            double njab = AngMom::NormNineJ(la,sa,ja, lb,sb,jb, Lab,Sab,J);
            if (njab == 0) continue;
            int Scd = Sab;
            int Lcd = Lab;
            double njcd = AngMom::NormNineJ(lc,sc,jc, ld,sd,jd, Lcd,Scd,J);
            if (njcd == 0) continue;
-    
+
            // Next, transform to rel / com coordinates with Moshinsky tranformation
            for (int N_ab=0; N_ab<=fab/2; ++N_ab)  // N_ab = CoM n for a,b
            {
@@ -3873,34 +3404,34 @@ std::cout<<MF<<",  "<<MGT<<",  "<<Mtbme<<std::endl;
                {
                   if (Lab<std::abs(Lam_ab-lam_ab) or Lab>(Lam_ab+lam_ab) ) continue;
                   // factor to account for antisymmetrization
-    
+
                   int asymm_factor = (std::abs(bra.op->tz2+ket.op->tz2) + std::abs(bra.op->tz2+ket.oq->tz2)*modelspace.phase( lam_ab + Sab ))/ 2;
                   if ( asymm_factor ==0 ) continue;
-    
+
                   int lam_cd = lam_ab; // tcm and trel conserve lam and Lam
                   int n_ab = (fab - 2*N_ab-Lam_ab-lam_ab)/2; // n_ab is determined by energy conservation
-    
+
                   double mosh_ab = modelspace.GetMoshinsky(N_ab,Lam_ab,n_ab,lam_ab,na,la,nb,lb,Lab);
-    
+
                   if (std::abs(mosh_ab)<1e-8) continue;
-    
+
                   for (int N_cd=std::max(0,N_ab-1); N_cd<=N_ab+1; ++N_cd) // N_cd = CoM n for c,d
                   {
                     int n_cd = (fcd - 2*N_cd-Lam_cd-lam_cd)/2; // n_cd is determined by energy conservation
                     if (n_cd < 0) continue;
                     if  (n_ab != n_cd or N_ab != N_cd) continue;
-    
+
                     double mosh_cd = modelspace.GetMoshinsky(N_cd,Lam_cd,n_cd,lam_cd,nc,lc,nd,ld,Lcd);
                     if (std::abs(mosh_cd)<1e-8) continue;
-    
+
                     double prefactor = njab * njcd * mosh_ab * mosh_cd * asymm_factor;
                     L2rel += lam_ab*(lam_ab+1) * prefactor;
-    
+
                   } // N_cd
                } // lam_ab
              } // Lam_ab
            } // N_ab
-    
+
          } // Sab
        } // Lab
 
@@ -3926,7 +3457,7 @@ std::cout<<MF<<",  "<<MGT<<",  "<<Mtbme<<std::endl;
 
    int nchan = modelspace.GetNumberTwoBodyChannels();
    modelspace.PreCalculateMoshinsky();
-//   #pragma omp parallel for schedule(dynamic,1) 
+//   #pragma omp parallel for schedule(dynamic,1)
    for (int ch=0; ch<nchan; ++ch)
    {
     TwoBodyChannel& tbc = modelspace.GetTwoBodyChannel(ch);
@@ -3960,12 +3491,12 @@ std::cout<<MF<<",  "<<MGT<<",  "<<Mtbme<<std::endl;
 //  emax = 4                         emax = 6                  emax = 8
 //  e1hf = 177.4709518              e1hf = 132.7170792          e1hf = 111.4959623
 //  e2hf = -102.1762390             e2hf = -138.2451400         e2hf = -210.3298042
-//  e3hf = 0.0000000                e3hf = 0.0000000            e3hf = 0.0000000    
-//  EHF = 75.2947127                EHF  = -5.5280608           EHF = -98.8338419   
+//  e3hf = 0.0000000                e3hf = 0.0000000            e3hf = 0.0000000
+//  EHF = 75.2947127                EHF  = -5.5280608           EHF = -98.8338419
 //  EIMSRG = -10.047908             EIMSRG = -69.170313         EIMSRG =  -144.9899081
 //  Rp2HF = 9.5591609               Rp2HF = 15.1991899          Rp2HF =  20.8748671
 //  Rp2IMSRG = 9.362856             Rp2IMSRG = 14.399832        Rp2IMSRG = 21.353270
-// 
+//
  double MinnesotaMatEl( ModelSpace& modelspace, Ket& bra, Ket& ket, int J )
  {
    double oscillator_b2 = (HBARC*HBARC/M_NUCLEON/modelspace.GetHbarOmega());
@@ -4411,7 +3942,7 @@ std::cout<<MF<<",  "<<MGT<<",  "<<Mtbme<<std::endl;
 // {
 //   return v1;
 // }
-// 
+//
 // template <typename T, typename... Args>
 // T VectorUnion(T& v1, T& v2, Args... args)
 // {
@@ -4420,7 +3951,7 @@ std::cout<<MF<<",  "<<MGT<<",  "<<Mtbme<<std::endl;
 //   copy(v2.begin(),v2.end(),vec.begin()+v1.size());
 //   return VectorUnion(vec, args...);
 // }
- 
+
 
 }// namespace imsrg_util
 
diff --git a/src/pyIMSRG.cc b/src/pyIMSRG.cc
index 16f1f77..3ab2916 100755
--- a/src/pyIMSRG.cc
+++ b/src/pyIMSRG.cc
@@ -25,7 +25,8 @@ namespace py = pybind11;
 
   void MS_SetRef(ModelSpace& self, std::string str){ self.SetReference( str);};
 
-  Operator HF_GetNormalOrderedH(HartreeFock& self){ return self.GetNormalOrderedH();};
+//  Operator HF_GetNormalOrderedH(HartreeFock& self){ return self.GetNormalOrderedH();};
+  Operator HF_GetNormalOrderedH(HartreeFock& self, int particle_rank=2){ return self.GetNormalOrderedH(particle_rank);};
 
 //BOOST_PYTHON_MODULE(pyIMSRG)
 //PYBIND11_PLUGIN(pyIMSRG)
@@ -33,6 +34,7 @@ PYBIND11_MODULE(pyIMSRG, m)
 {
   m.doc() = "python bindings for IMSRG code";
 
+
    py::class_<Orbit>(m,"Orbit")
       .def(py::init<>())
       .def_readwrite("n", &Orbit::n)
@@ -66,10 +68,10 @@ PYBIND11_MODULE(pyIMSRG, m)
    py::class_<ModelSpace>(m,"ModelSpace")
       .def(py::init<>())
       .def(py::init<const ModelSpace&>())
-      .def(py::init< int, const std::string&>())
-      .def(py::init< int, const std::string&, const std::string&>())
-      .def(py::init< int,std::vector<std::string>,std::vector<std::string> >())
-      .def(py::init< int,std::vector<std::string>,std::vector<std::string>,std::vector<std::string> >())
+      .def(py::init< int, const std::string&>(),  py::arg("emax"),py::arg("reference") )
+      .def(py::init< int, const std::string&, const std::string&>(),  py::arg("emax"),py::arg("reference"),py::arg("valence"))
+      .def(py::init< int,std::vector<std::string>,std::vector<std::string> >(), py::arg("emax"),py::arg("hole_list"),py::arg("valence_list"))
+      .def(py::init< int,std::vector<std::string>,std::vector<std::string>,std::vector<std::string> >(), py::arg("emax"),py::arg("hole_list"),py::arg("core_list"),py::arg("valence_list"))
       .def("SetHbarOmega", &ModelSpace::SetHbarOmega)
       .def("SetTargetMass", &ModelSpace::SetTargetMass)
       .def("SetE3max", &ModelSpace::SetE3max)
@@ -101,7 +103,7 @@ PYBIND11_MODULE(pyIMSRG, m)
    py::class_<Operator>(m,"Operator")
       .def(py::init<>())
       .def(py::init< ModelSpace&>())
-      .def(py::init< ModelSpace&,int,int,int,int>())
+      .def(py::init< ModelSpace&,int,int,int,int>(), py::arg("modelspace"),py::arg("j_rank"),py::arg("parity"),py::arg("t_rank"),py::arg("particle_rank"))
       .def(py::self += py::self)
       .def(py::self + py::self)
       .def(py::self -= Operator())
@@ -195,7 +197,11 @@ PYBIND11_MODULE(pyIMSRG, m)
    py::class_<ThreeBodyMEpn>(m,"ThreeBodyMEpn")
       .def(py::init<>())
 //      .def("SetME", &ThreeBodyMEpn::SetME)
-      .def("GetME", &ThreeBodyMEpn::GetME)
+//      .def("GetME", &ThreeBodyMEpn::GetME)
+      .def("GetME", [](ThreeBodyMEpn& self, int Jab, int Jde, int twoJ, int tab, int tde, int twoTabc, int twoTdef,int a, int b, int c, int d, int e, int f)
+                   { return self.GetME(Jab,Jde,twoJ,tab,tde,twoTabc,twoTdef,a,b,c,d,e,f);},
+                    py::arg("Jab"),py::arg("Jde"),py::arg("twoJ"),py::arg("tab"),py::arg("tde"),py::arg("twoTabc"),py::arg("twoTdef")
+                   ,py::arg("a"),py::arg("b"),py::arg("c"),py::arg("d"),py::arg("e"),py::arg("f")  )
 //      .def("SetME_pn", &ThreeBodyMEpn::SetME_pn)
       .def("GetME_pn", &ThreeBodyMEpn::GetME_pn)
       .def("RecouplingCoefficient",&ThreeBodyMEpn::RecouplingCoefficient)
@@ -212,24 +218,25 @@ PYBIND11_MODULE(pyIMSRG, m)
       .def_readonly_static("BAC",&ThreeBodyMEpn::BAC)
    ;
 
+
    py::class_<ReadWrite>(m,"ReadWrite")
       .def(py::init<>())
       .def("ReadTBME_Oslo", &ReadWrite::ReadTBME_Oslo)
       .def("ReadBareTBME_Jason", &ReadWrite::ReadBareTBME_Jason)
       .def("ReadBareTBME_Navratil", &ReadWrite::ReadBareTBME_Navratil)
-      .def("ReadBareTBME_Darmstadt", &ReadWrite::ReadBareTBME_Darmstadt)
-      .def("Read_Darmstadt_3body", &ReadWrite::Read_Darmstadt_3body)
+      .def("ReadBareTBME_Darmstadt", &ReadWrite::ReadBareTBME_Darmstadt, py::arg("filename"),py::arg("H"),py::arg("e1max"),py::arg("e2max"),py::arg("lmax") )
+      .def("Read_Darmstadt_3body", &ReadWrite::Read_Darmstadt_3body, py::arg("filename"),py::arg("H"),py::arg("e1max"),py::arg("e2max"),py::arg("e3max") )
 #ifndef NO_HDF5
       .def("Read3bodyHDF5", &ReadWrite::Read3bodyHDF5)
 #endif
       .def("Write_me2j", &ReadWrite::Write_me2j)
       .def("Write_me3j", &ReadWrite::Write_me3j)
       .def("WriteTBME_Navratil", &ReadWrite::WriteTBME_Navratil)
-      .def("WriteNuShellX_sps", &ReadWrite::WriteNuShellX_sps)
-      .def("WriteNuShellX_int", &ReadWrite::WriteNuShellX_int)
-      .def("WriteNuShellX_op", &ReadWrite::WriteNuShellX_op)
-      .def("ReadNuShellX_int", &ReadWrite::ReadNuShellX_int)
-      .def("ReadNuShellX_int_iso", &ReadWrite::ReadNuShellX_int_iso)
+      .def("WriteNuShellX_sps",  &ReadWrite::WriteNuShellX_sps, py::arg("op"), py::arg("filename") )
+      .def("WriteNuShellX_int",  &ReadWrite::WriteNuShellX_int, py::arg("op"), py::arg("filename") )
+      .def("WriteNuShellX_op",   &ReadWrite::WriteNuShellX_op,  py::arg("op"), py::arg("filename") )
+      .def("ReadNuShellX_int",   &ReadWrite::ReadNuShellX_int,  py::arg("op"), py::arg("filename") )
+      .def("ReadNuShellX_int_iso", &ReadWrite::ReadNuShellX_int_iso, py::arg("op"), py::arg("filename") )
       .def("WriteAntoine_int", &ReadWrite::WriteAntoine_int)
       .def("WriteAntoine_input", &ReadWrite::WriteAntoine_input)
       .def("WriteOperator", &ReadWrite::WriteOperator)
@@ -265,7 +272,8 @@ PYBIND11_MODULE(pyIMSRG, m)
       .def("Solve",&HartreeFock::Solve)
       .def("TransformToHFBasis",&HartreeFock::TransformToHFBasis)
       .def("GetHbare",&HartreeFock::GetHbare)
-      .def("GetNormalOrderedH",&HF_GetNormalOrderedH)
+//      .def("GetNormalOrderedH",&HF_GetNormalOrderedH)
+      .def("GetNormalOrderedH",&HF_GetNormalOrderedH, py::arg("particle_rank")=2 )
       .def("GetOmega",&HartreeFock::GetOmega)
       .def("PrintSPE",&HartreeFock::PrintSPE)
       .def("PrintSPEandWF",&HartreeFock::PrintSPEandWF)
@@ -292,7 +300,6 @@ PYBIND11_MODULE(pyIMSRG, m)
    ;
 
 
-
    // Define which overloaded version of IMSRGSolver::Transform I want to expose
    Operator (IMSRGSolver::*Transform_ref)(Operator&) = &IMSRGSolver::Transform;
 
@@ -327,6 +334,7 @@ PYBIND11_MODULE(pyIMSRG, m)
       .def("AddOperator", &IMSRGSolver::AddOperator)
       .def("GetOperator", &IMSRGSolver::GetOperator)
       .def("EstimateBCHError", &IMSRGSolver::EstimateBCHError)
+      .def("UpdateEta", &IMSRGSolver::UpdateEta)
       .def_readwrite("Eta", &IMSRGSolver::Eta)
    ;
 
@@ -362,6 +370,7 @@ PYBIND11_MODULE(pyIMSRG, m)
    py::module Commutator = m.def_submodule("Commutator", "Commutator namespace");
       Commutator.def("Set_BCH_Transform_Threshold", &Commutator::Set_BCH_Transform_Threshold);
       Commutator.def("Set_BCH_Product_Threshold", &Commutator::Set_BCH_Product_Threshold);
+      Commutator.def("Commutator",&Commutator::Commutator);
       Commutator.def("BCH_Transform", &Commutator::BCH_Transform);
       Commutator.def("BCH_Product", &Commutator::BCH_Product);
       Commutator.def("EstimateBCHError", &Commutator::EstimateBCHError);
@@ -391,6 +400,7 @@ PYBIND11_MODULE(pyIMSRG, m)
       .def("TestDaggerCommutatorsAlln",&UnitTest::TestDaggerCommutatorsAlln)
       .def("Test3BodyAntisymmetry",&UnitTest::Test3BodyAntisymmetry)
       .def("Test3BodyHermiticity",&UnitTest::Test3BodyHermiticity)
+      .def("SanityCheck",&UnitTest::SanityCheck)
 //      .def("Test3BodySetGet",&UnitTest::Test3BodySetGet)
    ;
 
@@ -447,6 +457,4 @@ PYBIND11_MODULE(pyIMSRG, m)
    m.def("SetUseIMSRG3",Commutator::SetUseIMSRG3);
 
 
-//  return m.ptr();
-
 }
diff --git a/src/pybind11/.appveyor.yml b/src/pybind11/.appveyor.yml
new file mode 100644
index 0000000..8fbb726
--- /dev/null
+++ b/src/pybind11/.appveyor.yml
@@ -0,0 +1,70 @@
+version: 1.0.{build}
+image:
+- Visual Studio 2017
+- Visual Studio 2015
+test: off
+skip_branch_with_pr: true
+build:
+  parallel: true
+platform:
+- x64
+- x86
+environment:
+  matrix:
+  - PYTHON: 36
+    CPP: 14
+    CONFIG: Debug
+  - PYTHON: 27
+    CPP: 14
+    CONFIG: Debug
+  - CONDA: 36
+    CPP: latest
+    CONFIG: Release
+matrix:
+  exclude:
+    - image: Visual Studio 2015
+      platform: x86
+    - image: Visual Studio 2015
+      CPP: latest
+    - image: Visual Studio 2017
+      CPP: latest
+      platform: x86
+install:
+- ps: |
+    if ($env:PLATFORM -eq "x64") { $env:CMAKE_ARCH = "x64" }
+    if ($env:APPVEYOR_JOB_NAME -like "*Visual Studio 2017*") {
+      $env:CMAKE_GENERATOR = "Visual Studio 15 2017"
+      $env:CMAKE_INCLUDE_PATH = "C:\Libraries\boost_1_64_0"
+      $env:CXXFLAGS = "-permissive-"
+    } else {
+      $env:CMAKE_GENERATOR = "Visual Studio 14 2015"
+    }
+    if ($env:PYTHON) {
+      if ($env:PLATFORM -eq "x64") { $env:PYTHON = "$env:PYTHON-x64" }
+      $env:PATH = "C:\Python$env:PYTHON\;C:\Python$env:PYTHON\Scripts\;$env:PATH"
+      python -W ignore -m pip install --upgrade pip wheel
+      python -W ignore -m pip install pytest numpy --no-warn-script-location
+    } elseif ($env:CONDA) {
+      if ($env:CONDA -eq "27") { $env:CONDA = "" }
+      if ($env:PLATFORM -eq "x64") { $env:CONDA = "$env:CONDA-x64" }
+      $env:PATH = "C:\Miniconda$env:CONDA\;C:\Miniconda$env:CONDA\Scripts\;$env:PATH"
+      $env:PYTHONHOME = "C:\Miniconda$env:CONDA"
+      conda --version
+      conda install -y -q pytest numpy scipy
+    }
+- ps: |
+    Start-FileDownload 'http://bitbucket.org/eigen/eigen/get/3.3.3.zip'
+    7z x 3.3.3.zip -y > $null
+    $env:CMAKE_INCLUDE_PATH = "eigen-eigen-67e894c6cd8f;$env:CMAKE_INCLUDE_PATH"
+build_script:
+- cmake -G "%CMAKE_GENERATOR%" -A "%CMAKE_ARCH%"
+    -DPYBIND11_CPP_STANDARD=/std:c++%CPP%
+    -DPYBIND11_WERROR=ON
+    -DDOWNLOAD_CATCH=ON
+    -DCMAKE_SUPPRESS_REGENERATION=1
+    .
+- set MSBuildLogger="C:\Program Files\AppVeyor\BuildAgent\Appveyor.MSBuildLogger.dll"
+- cmake --build . --config %CONFIG% --target pytest -- /m /v:m /logger:%MSBuildLogger%
+- cmake --build . --config %CONFIG% --target cpptest -- /m /v:m /logger:%MSBuildLogger%
+- if "%CPP%"=="latest" (cmake --build . --config %CONFIG% --target test_cmake_build -- /m /v:m /logger:%MSBuildLogger%)
+on_failure: if exist "tests\test_cmake_build" type tests\test_cmake_build\*.log*
diff --git a/src/pybind11/.gitignore b/src/pybind11/.gitignore
new file mode 100644
index 0000000..979fd44
--- /dev/null
+++ b/src/pybind11/.gitignore
@@ -0,0 +1,38 @@
+CMakeCache.txt
+CMakeFiles
+Makefile
+cmake_install.cmake
+.DS_Store
+*.so
+*.pyd
+*.dll
+*.sln
+*.sdf
+*.opensdf
+*.vcxproj
+*.filters
+example.dir
+Win32
+x64
+Release
+Debug
+.vs
+CTestTestfile.cmake
+Testing
+autogen
+MANIFEST
+/.ninja_*
+/*.ninja
+/docs/.build
+*.py[co]
+*.egg-info
+*~
+.*.swp
+.DS_Store
+/dist
+/build
+/cmake/
+.cache/
+sosize-*.txt
+pybind11Config*.cmake
+pybind11Targets.cmake
diff --git a/src/pybind11/.gitmodules b/src/pybind11/.gitmodules
new file mode 100644
index 0000000..d063a8e
--- /dev/null
+++ b/src/pybind11/.gitmodules
@@ -0,0 +1,3 @@
+[submodule "tools/clang"]
+	path = tools/clang
+	url = ../../wjakob/clang-cindex-python3
diff --git a/src/pybind11/.readthedocs.yml b/src/pybind11/.readthedocs.yml
new file mode 100644
index 0000000..c9c6161
--- /dev/null
+++ b/src/pybind11/.readthedocs.yml
@@ -0,0 +1,3 @@
+python:
+  version: 3
+requirements_file: docs/requirements.txt
diff --git a/src/pybind11/.travis.yml b/src/pybind11/.travis.yml
new file mode 100644
index 0000000..d81cd8c
--- /dev/null
+++ b/src/pybind11/.travis.yml
@@ -0,0 +1,306 @@
+language: cpp
+matrix:
+  include:
+  # This config does a few things:
+  # - Checks C++ and Python code styles (check-style.sh and flake8).
+  # - Makes sure sphinx can build the docs without any errors or warnings.
+  # - Tests setup.py sdist and install (all header files should be present).
+  # - Makes sure that everything still works without optional deps (numpy/scipy/eigen) and
+  #   also tests the automatic discovery functions in CMake (Python version, C++ standard).
+  - os: linux
+    dist: xenial # Necessary to run doxygen 1.8.15
+    name: Style, docs, and pip
+    cache: false
+    before_install:
+    - pyenv global $(pyenv whence 2to3)  # activate all python versions
+    - PY_CMD=python3
+    - $PY_CMD -m pip install --user --upgrade pip wheel setuptools
+    install:
+    # breathe 4.14 doesn't work with bit fields. See https://github.com/michaeljones/breathe/issues/462
+    - $PY_CMD -m pip install --user --upgrade sphinx sphinx_rtd_theme breathe==4.13.1 flake8 pep8-naming pytest
+    - curl -fsSL https://sourceforge.net/projects/doxygen/files/rel-1.8.15/doxygen-1.8.15.linux.bin.tar.gz/download | tar xz
+    - export PATH="$PWD/doxygen-1.8.15/bin:$PATH"
+    script:
+    - tools/check-style.sh
+    - flake8
+    - $PY_CMD -m sphinx -W -b html docs docs/.build
+    - |
+      # Make sure setup.py distributes and installs all the headers
+      $PY_CMD setup.py sdist
+      $PY_CMD -m pip install --user -U ./dist/*
+      installed=$($PY_CMD -c "import pybind11; print(pybind11.get_include(True) + '/pybind11')")
+      diff -rq $installed ./include/pybind11
+    - |
+      # Barebones build
+      cmake -DCMAKE_BUILD_TYPE=Debug -DPYBIND11_WERROR=ON -DDOWNLOAD_CATCH=ON -DPYTHON_EXECUTABLE=$(which $PY_CMD) .
+      make pytest -j 2 && make cpptest -j 2
+  # The following are regular test configurations, including optional dependencies.
+  # With regard to each other they differ in Python version, C++ standard and compiler.
+  - os: linux
+    dist: trusty
+    name: Python 2.7, c++11, gcc 4.8
+    env: PYTHON=2.7 CPP=11 GCC=4.8
+    addons:
+      apt:
+        packages:
+          - cmake=2.\*
+          - cmake-data=2.\*
+  - os: linux
+    dist: trusty
+    name: Python 3.6, c++11, gcc 4.8
+    env: PYTHON=3.6 CPP=11 GCC=4.8
+    addons:
+      apt:
+        sources:
+          - deadsnakes
+        packages:
+          - python3.6-dev
+          - python3.6-venv
+          - cmake=2.\*
+          - cmake-data=2.\*
+  - os: linux
+    dist: trusty
+    env: PYTHON=2.7 CPP=14 GCC=6 CMAKE=1
+    name: Python 2.7, c++14, gcc 6, CMake test
+    addons:
+      apt:
+        sources:
+          - ubuntu-toolchain-r-test
+        packages:
+          - g++-6
+  - os: linux
+    dist: trusty
+    name: Python 3.5, c++14, gcc 6, Debug build
+    # N.B. `ensurepip` could be installed transitively by `python3.5-venv`, but
+    # seems to have apt conflicts (at least for Trusty). Use Docker instead.
+    services: docker
+    env: DOCKER=debian:stretch PYTHON=3.5 CPP=14 GCC=6 DEBUG=1
+  - os: linux
+    dist: xenial
+    env: PYTHON=3.6 CPP=17 GCC=7
+    name: Python 3.6, c++17, gcc 7
+    addons:
+      apt:
+        sources:
+          - deadsnakes
+          - ubuntu-toolchain-r-test
+        packages:
+          - g++-7
+          - python3.6-dev
+          - python3.6-venv
+  - os: linux
+    dist: xenial
+    env: PYTHON=3.6 CPP=17 CLANG=7
+    name: Python 3.6, c++17, Clang 7
+    addons:
+      apt:
+        sources:
+          - deadsnakes
+          - llvm-toolchain-xenial-7
+        packages:
+          - python3.6-dev
+          - python3.6-venv
+          - clang-7
+          - libclang-7-dev
+          - llvm-7-dev
+          - lld-7
+          - libc++-7-dev
+          - libc++abi-7-dev  # Why is this necessary???
+  - os: linux
+    dist: xenial
+    env: PYTHON=3.8 CPP=17 GCC=7
+    name: Python 3.8, c++17, gcc 7 (w/o numpy/scipy) # TODO: update build name when the numpy/scipy wheels become available
+    addons:
+      apt:
+        sources:
+          - deadsnakes
+          - ubuntu-toolchain-r-test
+        packages:
+          - g++-7
+          - python3.8-dev
+          - python3.8-venv
+    # Currently there is no numpy/scipy wheels available for python3.8
+    # TODO: remove next before_install, install and script clause when the wheels become available
+    before_install:
+      - pyenv global $(pyenv whence 2to3)  # activate all python versions
+      - PY_CMD=python3
+      - $PY_CMD -m pip install --user --upgrade pip wheel setuptools
+    install:
+      - $PY_CMD -m pip install --user --upgrade pytest
+    script:
+      - |
+        # Barebones build
+        cmake -DCMAKE_BUILD_TYPE=Debug -DPYBIND11_WERROR=ON -DDOWNLOAD_CATCH=ON -DPYTHON_EXECUTABLE=$(which $PY_CMD) .
+        make pytest -j 2 && make cpptest -j 2
+  - os: osx
+    name: Python 2.7, c++14, AppleClang 7.3, CMake test
+    osx_image: xcode7.3
+    env: PYTHON=2.7 CPP=14 CLANG CMAKE=1
+  - os: osx
+    name: Python 3.7, c++14, AppleClang 9, Debug build
+    osx_image: xcode9.4
+    env: PYTHON=3.7 CPP=14 CLANG DEBUG=1
+  # Test a PyPy 2.7 build
+  - os: linux
+    dist: trusty
+    env: PYPY=5.8 PYTHON=2.7 CPP=11 GCC=4.8
+    name: PyPy 5.8, Python 2.7, c++11, gcc 4.8
+    addons:
+      apt:
+        packages:
+          - libblas-dev
+          - liblapack-dev
+          - gfortran
+  # Build in 32-bit mode and tests against the CMake-installed version
+  - os: linux
+    dist: trusty
+    services: docker
+    env: DOCKER=i386/debian:stretch PYTHON=3.5 CPP=14 GCC=6 INSTALL=1
+    name: Python 3.5, c++14, gcc 6, 32-bit
+    script:
+      - |
+        # Consolidated 32-bit Docker Build + Install
+        set -ex
+        $SCRIPT_RUN_PREFIX sh -c "
+          set -ex
+          cmake ${CMAKE_EXTRA_ARGS} -DPYBIND11_INSTALL=1 -DPYBIND11_TEST=0 .
+          make install
+          cp -a tests /pybind11-tests
+          mkdir /build-tests && cd /build-tests
+          cmake ../pybind11-tests ${CMAKE_EXTRA_ARGS} -DPYBIND11_WERROR=ON
+          make pytest -j 2"
+        set +ex
+cache:
+  directories:
+  - $HOME/.local/bin
+  - $HOME/.local/lib
+  - $HOME/.local/include
+  - $HOME/Library/Python
+before_install:
+- |
+  # Configure build variables
+  set -ex
+  if [ "$TRAVIS_OS_NAME" = "linux" ]; then
+    if [ -n "$CLANG" ]; then
+      export CXX=clang++-$CLANG CC=clang-$CLANG
+      EXTRA_PACKAGES+=" clang-$CLANG llvm-$CLANG-dev"
+    else
+      if [ -z "$GCC" ]; then GCC=4.8
+      else EXTRA_PACKAGES+=" g++-$GCC"
+      fi
+      export CXX=g++-$GCC CC=gcc-$GCC
+    fi
+  elif [ "$TRAVIS_OS_NAME" = "osx" ]; then
+    export CXX=clang++ CC=clang;
+  fi
+  if [ -n "$CPP" ]; then CPP=-std=c++$CPP; fi
+  if [ "${PYTHON:0:1}" = "3" ]; then PY=3; fi
+  if [ -n "$DEBUG" ]; then CMAKE_EXTRA_ARGS+=" -DCMAKE_BUILD_TYPE=Debug"; fi
+  set +ex
+- |
+  # Initialize environment
+  set -ex
+  if [ -n "$DOCKER" ]; then
+    docker pull $DOCKER
+
+    containerid=$(docker run --detach --tty \
+      --volume="$PWD":/pybind11 --workdir=/pybind11 \
+      --env="CC=$CC" --env="CXX=$CXX" --env="DEBIAN_FRONTEND=$DEBIAN_FRONTEND" \
+      --env=GCC_COLORS=\  \
+      $DOCKER)
+    SCRIPT_RUN_PREFIX="docker exec --tty $containerid"
+    $SCRIPT_RUN_PREFIX sh -c 'for s in 0 15; do sleep $s; apt-get update && apt-get -qy dist-upgrade && break; done'
+  else
+    if [ "$PYPY" = "5.8" ]; then
+      curl -fSL https://bitbucket.org/pypy/pypy/downloads/pypy2-v5.8.0-linux64.tar.bz2 | tar xj
+      PY_CMD=$(echo `pwd`/pypy2-v5.8.0-linux64/bin/pypy)
+      CMAKE_EXTRA_ARGS+=" -DPYTHON_EXECUTABLE:FILEPATH=$PY_CMD"
+    else
+      PY_CMD=python$PYTHON
+      if [ "$TRAVIS_OS_NAME" = "osx" ]; then
+        if [ "$PY" = "3" ]; then
+          brew update && brew unlink python@2 && brew upgrade python
+        else
+          curl -fsSL https://bootstrap.pypa.io/get-pip.py | $PY_CMD - --user
+        fi
+      fi
+    fi
+    if [ "$PY" = 3 ] || [ -n "$PYPY" ]; then
+      $PY_CMD -m ensurepip --user
+    fi
+    $PY_CMD --version
+    $PY_CMD -m pip install --user --upgrade pip wheel
+  fi
+  set +ex
+install:
+- |
+  # Install dependencies
+  set -ex
+  cmake --version
+  if [ -n "$DOCKER" ]; then
+    if [ -n "$DEBUG" ]; then
+      PY_DEBUG="python$PYTHON-dbg python$PY-scipy-dbg"
+      CMAKE_EXTRA_ARGS+=" -DPYTHON_EXECUTABLE=/usr/bin/python${PYTHON}dm"
+    fi
+    $SCRIPT_RUN_PREFIX sh -c "for s in 0 15; do sleep \$s; \
+      apt-get -qy --no-install-recommends install \
+        $PY_DEBUG python$PYTHON-dev python$PY-pytest python$PY-scipy \
+        libeigen3-dev libboost-dev cmake make ${EXTRA_PACKAGES} && break; done"
+  else
+
+    if [ "$CLANG" = "7" ]; then
+      export CXXFLAGS="-stdlib=libc++"
+    fi
+
+    export NPY_NUM_BUILD_JOBS=2
+    echo "Installing pytest, numpy, scipy..."
+    local PIP_CMD=""
+    if [ -n $PYPY ]; then
+      # For expediency, install only versions that are available on the extra index.
+      travis_wait 30 \
+        $PY_CMD -m pip install --user --upgrade --extra-index-url https://imaginary.ca/trusty-pypi \
+          pytest numpy==1.15.4 scipy==1.2.0
+    else
+      $PY_CMD -m pip install --user --upgrade pytest numpy scipy
+    fi
+    echo "done."
+
+    mkdir eigen
+    curl -fsSL https://bitbucket.org/eigen/eigen/get/3.3.4.tar.bz2 | \
+        tar --extract -j --directory=eigen --strip-components=1
+    export CMAKE_INCLUDE_PATH="${CMAKE_INCLUDE_PATH:+$CMAKE_INCLUDE_PATH:}$PWD/eigen"
+  fi
+  set +ex
+script:
+- |
+  # CMake Configuration
+  set -ex
+  $SCRIPT_RUN_PREFIX cmake ${CMAKE_EXTRA_ARGS} \
+    -DPYBIND11_PYTHON_VERSION=$PYTHON \
+    -DPYBIND11_CPP_STANDARD=$CPP \
+    -DPYBIND11_WERROR=${WERROR:-ON} \
+    -DDOWNLOAD_CATCH=${DOWNLOAD_CATCH:-ON} \
+    .
+  set +ex
+- |
+  # pytest
+  set -ex
+  $SCRIPT_RUN_PREFIX make pytest -j 2 VERBOSE=1
+  set +ex
+- |
+  # cpptest
+  set -ex
+  $SCRIPT_RUN_PREFIX make cpptest -j 2
+  set +ex
+- |
+  # CMake Build Interface
+  set -ex
+  if [ -n "$CMAKE" ]; then $SCRIPT_RUN_PREFIX make test_cmake_build; fi
+  set +ex
+after_failure: cat tests/test_cmake_build/*.log*
+after_script:
+- |
+  # Cleanup (Docker)
+  set -ex
+  if [ -n "$DOCKER" ]; then docker stop "$containerid"; docker rm "$containerid"; fi
+  set +ex
diff --git a/src/pybind11/CMakeLists.txt b/src/pybind11/CMakeLists.txt
index 2179e3a..85ecd90 100644
--- a/src/pybind11/CMakeLists.txt
+++ b/src/pybind11/CMakeLists.txt
@@ -12,7 +12,12 @@ if (POLICY CMP0048)
   cmake_policy(SET CMP0048 NEW)
 endif()
 
-project(pybind11)
+# CMake versions < 3.4.0 do not support try_compile/pthread checks without C as active language.
+if(CMAKE_VERSION VERSION_LESS 3.4.0)
+  project(pybind11)
+else()
+  project(pybind11 CXX)
+endif()
 
 # Check if pybind11 is being used directly or via add_subdirectory
 set(PYBIND11_MASTER_PROJECT OFF)
@@ -33,17 +38,23 @@ set(PYTHON_INCLUDE_DIRS ${PYTHON_INCLUDE_DIRS} CACHE INTERNAL "")
 set(PYTHON_LIBRARIES ${PYTHON_LIBRARIES} CACHE INTERNAL "")
 set(PYTHON_MODULE_PREFIX ${PYTHON_MODULE_PREFIX} CACHE INTERNAL "")
 set(PYTHON_MODULE_EXTENSION ${PYTHON_MODULE_EXTENSION} CACHE INTERNAL "")
+set(PYTHON_VERSION_MAJOR ${PYTHON_VERSION_MAJOR} CACHE INTERNAL "")
+set(PYTHON_VERSION_MINOR ${PYTHON_VERSION_MINOR} CACHE INTERNAL "")
 
 # NB: when adding a header don't forget to also add it to setup.py
 set(PYBIND11_HEADERS
+  include/pybind11/detail/class.h
+  include/pybind11/detail/common.h
+  include/pybind11/detail/descr.h
+  include/pybind11/detail/init.h
+  include/pybind11/detail/internals.h
+  include/pybind11/detail/typeid.h
   include/pybind11/attr.h
   include/pybind11/buffer_info.h
   include/pybind11/cast.h
   include/pybind11/chrono.h
-  include/pybind11/class_support.h
   include/pybind11/common.h
   include/pybind11/complex.h
-  include/pybind11/descr.h
   include/pybind11/options.h
   include/pybind11/eigen.h
   include/pybind11/embed.h
@@ -55,7 +66,6 @@ set(PYBIND11_HEADERS
   include/pybind11/pytypes.h
   include/pybind11/stl.h
   include/pybind11/stl_bind.h
-  include/pybind11/typeid.h
 )
 string(REPLACE "include/" "${CMAKE_CURRENT_SOURCE_DIR}/include/"
        PYBIND11_HEADERS "${PYBIND11_HEADERS}")
@@ -68,7 +78,7 @@ include(GNUInstallDirs)
 include(CMakePackageConfigHelpers)
 
 # extract project version from source
-file(STRINGS "${PYBIND11_INCLUDE_DIR}/pybind11/common.h" pybind11_version_defines
+file(STRINGS "${PYBIND11_INCLUDE_DIR}/pybind11/detail/common.h" pybind11_version_defines
      REGEX "#define PYBIND11_VERSION_(MAJOR|MINOR|PATCH) ")
 foreach(ver ${pybind11_version_defines})
   if (ver MATCHES "#define PYBIND11_VERSION_(MAJOR|MINOR|PATCH) +([^ ]+)$")
@@ -94,6 +104,9 @@ if(NOT (CMAKE_VERSION VERSION_LESS 3.0))  # CMake >= 3.0
 
   add_library(module INTERFACE)
   add_library(pybind11::module ALIAS module)
+  if(NOT MSVC)
+    target_compile_options(module INTERFACE -fvisibility=hidden)
+  endif()
   target_link_libraries(module INTERFACE pybind11::pybind11)
   if(WIN32 OR CYGWIN)
     target_link_libraries(module INTERFACE $<BUILD_INTERFACE:${PYTHON_LIBRARIES}>)
@@ -107,8 +120,7 @@ if(NOT (CMAKE_VERSION VERSION_LESS 3.0))  # CMake >= 3.0
 endif()
 
 if (PYBIND11_INSTALL)
-  install(FILES ${PYBIND11_HEADERS}
-          DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/pybind11)
+  install(DIRECTORY ${PYBIND11_INCLUDE_DIR}/pybind11 DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})
   # GNUInstallDirs "DATADIR" wrong here; CMake search path wants "share".
   set(PYBIND11_CMAKECONFIG_INSTALL_DIR "share/cmake/${PROJECT_NAME}" CACHE STRING "install path for pybind11Config.cmake")
 
@@ -130,10 +142,16 @@ if (PYBIND11_INSTALL)
           DESTINATION ${PYBIND11_CMAKECONFIG_INSTALL_DIR})
 
   if(NOT (CMAKE_VERSION VERSION_LESS 3.0))
+    if(NOT PYBIND11_EXPORT_NAME)
+      set(PYBIND11_EXPORT_NAME "${PROJECT_NAME}Targets")
+    endif()
+
     install(TARGETS pybind11 module embed
-            EXPORT "${PROJECT_NAME}Targets")
-    install(EXPORT "${PROJECT_NAME}Targets"
-            NAMESPACE "${PROJECT_NAME}::"
-            DESTINATION ${PYBIND11_CMAKECONFIG_INSTALL_DIR})
+            EXPORT "${PYBIND11_EXPORT_NAME}")
+    if(PYBIND11_MASTER_PROJECT)
+      install(EXPORT "${PYBIND11_EXPORT_NAME}"
+              NAMESPACE "${PROJECT_NAME}::"
+              DESTINATION ${PYBIND11_CMAKECONFIG_INSTALL_DIR})
+    endif()
   endif()
 endif()
diff --git a/src/pybind11/CONTRIBUTING.md b/src/pybind11/CONTRIBUTING.md
index 2beaf8d..01596d9 100644
--- a/src/pybind11/CONTRIBUTING.md
+++ b/src/pybind11/CONTRIBUTING.md
@@ -27,11 +27,23 @@ adhere to the following rules to make the process as smooth as possible:
   do add value by themselves.
 * Add tests for any new functionality and run the test suite (``make pytest``)
   to ensure that no existing features break.
+* Please run ``flake8`` and ``tools/check-style.sh`` to check your code matches
+  the project style. (Note that ``check-style.sh`` requires ``gawk``.)
 * This project has a strong focus on providing general solutions using a
   minimal amount of code, thus small pull requests are greatly preferred.
 
-### License
+### Licensing of contributions
 
 pybind11 is provided under a BSD-style license that can be found in the
 ``LICENSE`` file. By using, distributing, or contributing to this project, you
 agree to the terms and conditions of this license.
+
+You are under no obligation whatsoever to provide any bug fixes, patches, or
+upgrades to the features, functionality or performance of the source code
+("Enhancements") to anyone; however, if you choose to make your Enhancements
+available either publicly, or directly to the author of this software, without
+imposing a separate written license agreement for such Enhancements, then you
+hereby grant the following license: a non-exclusive, royalty-free perpetual
+license to install, use, modify, prepare derivative works, incorporate into
+other computer software, distribute, and sublicense such enhancements or
+derivative works thereof, in binary and source code form.
diff --git a/src/pybind11/LICENSE b/src/pybind11/LICENSE
index ccf4e97..6f15578 100644
--- a/src/pybind11/LICENSE
+++ b/src/pybind11/LICENSE
@@ -25,12 +25,5 @@ CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-You are under no obligation whatsoever to provide any bug fixes, patches, or
-upgrades to the features, functionality or performance of the source code
-("Enhancements") to anyone; however, if you choose to make your Enhancements
-available either publicly, or directly to the author of this software, without
-imposing a separate written license agreement for such Enhancements, then you
-hereby grant the following license: a non-exclusive, royalty-free perpetual
-license to install, use, modify, prepare derivative works, incorporate into
-other computer software, distribute, and sublicense such enhancements or
-derivative works thereof, in binary and source code form.
+Please also refer to the file CONTRIBUTING.md, which clarifies licensing of
+external contributions to this project including patches, pull requests, etc.
diff --git a/src/pybind11/MANIFEST.in b/src/pybind11/MANIFEST.in
index aa51d01..6e57bae 100644
--- a/src/pybind11/MANIFEST.in
+++ b/src/pybind11/MANIFEST.in
@@ -1,2 +1,2 @@
-include include/pybind11/*.h
+recursive-include include/pybind11 *.h
 include LICENSE README.md CONTRIBUTING.md
diff --git a/src/pybind11/README.md b/src/pybind11/README.md
index 4477882..35d2d76 100644
--- a/src/pybind11/README.md
+++ b/src/pybind11/README.md
@@ -51,7 +51,6 @@ pybind11 can map the following core C++ features to Python
 - Custom operators
 - Single and multiple inheritance
 - STL data structures
-- Iterators and ranges
 - Smart pointers with reference counting like ``std::shared_ptr``
 - Internal references with correct reference counting
 - C++ classes with virtual (and pure virtual) methods can be extended in Python
@@ -87,9 +86,8 @@ In addition to the core functionality, pybind11 provides some extra goodies:
   [reported](http://graylab.jhu.edu/RosettaCon2016/PyRosetta-4.pdf) a binary
   size reduction of **5.4x** and compile time reduction by **5.8x**.
 
-- When supported by the compiler, two new C++14 features (relaxed constexpr and
-  return value deduction) are used to precompute function signatures at compile
-  time, leading to smaller binaries.
+- Function signatures are precomputed at compile time (using ``constexpr``),
+  leading to smaller binaries.
 
 - With little extra effort, C++ types can be pickled and unpickled similar to
   regular Python objects.
@@ -99,7 +97,7 @@ In addition to the core functionality, pybind11 provides some extra goodies:
 1. Clang/LLVM 3.3 or newer (for Apple Xcode's clang, this is 5.0.0 or newer)
 2. GCC 4.8 or newer
 3. Microsoft Visual Studio 2015 Update 3 or newer
-4. Intel C++ compiler 16 or newer (15 with a [workaround](https://github.com/pybind/pybind11/issues/276))
+4. Intel C++ compiler 17 or newer (16 with pybind11 v2.0 and 15 with pybind11 v2.0 and a [workaround](https://github.com/pybind/pybind11/issues/276))
 5. Cygwin/GCC (tested on 2.5.1)
 
 ## About
@@ -107,6 +105,7 @@ In addition to the core functionality, pybind11 provides some extra goodies:
 This project was created by [Wenzel Jakob](http://rgl.epfl.ch/people/wjakob).
 Significant features and/or improvements to the code were contributed by
 Jonas Adler,
+Lori A. Burns,
 Sylvain Corlay,
 Trent Houliston,
 Axel Huebl,
@@ -119,6 +118,7 @@ Ben Pritchard,
 Jason Rhinelander,
 Boris Schäling,
 Pim Schellart,
+Henry Schreiner,
 Ivan Smirnov, and
 Patrick Stewart.
 
diff --git a/src/pybind11/docs/Doxyfile b/src/pybind11/docs/Doxyfile
index 4dc8bf0..1b9d129 100644
--- a/src/pybind11/docs/Doxyfile
+++ b/src/pybind11/docs/Doxyfile
@@ -1,5 +1,6 @@
 PROJECT_NAME           = pybind11
 INPUT                  = ../include/pybind11/
+RECURSIVE              = YES
 
 GENERATE_HTML          = NO
 GENERATE_LATEX         = NO
diff --git a/src/pybind11/docs/advanced/cast/chrono.rst b/src/pybind11/docs/advanced/cast/chrono.rst
index 8c6b3d7..fbd4605 100644
--- a/src/pybind11/docs/advanced/cast/chrono.rst
+++ b/src/pybind11/docs/advanced/cast/chrono.rst
@@ -59,7 +59,7 @@ Provided conversions
 
 .. rubric:: Python to C++
 
-- ``datetime.datetime`` → ``std::chrono::system_clock::time_point``
+- ``datetime.datetime`` or ``datetime.date`` or ``datetime.time`` → ``std::chrono::system_clock::time_point``
     Date/time objects are converted into system clock timepoints. Any
     timezone information is ignored and the type is treated as a naive
     object.
diff --git a/src/pybind11/docs/advanced/cast/custom.rst b/src/pybind11/docs/advanced/cast/custom.rst
index c854e7f..e4f99ac 100644
--- a/src/pybind11/docs/advanced/cast/custom.rst
+++ b/src/pybind11/docs/advanced/cast/custom.rst
@@ -78,6 +78,12 @@ type is explicitly allowed.
         };
     }} // namespace pybind11::detail
 
+.. note::
+
+    A ``type_caster<T>`` defined with ``PYBIND11_TYPE_CASTER(T, ...)`` requires
+    that ``T`` is default-constructible (``value`` is first default constructed
+    and then ``load()`` assigns to it).
+
 .. warning::
 
     When using custom type casters, it's important to declare them consistently
diff --git a/src/pybind11/docs/advanced/cast/eigen.rst b/src/pybind11/docs/advanced/cast/eigen.rst
index 5b0b08c..59ba08c 100644
--- a/src/pybind11/docs/advanced/cast/eigen.rst
+++ b/src/pybind11/docs/advanced/cast/eigen.rst
@@ -37,11 +37,11 @@ that maps into the source ``numpy.ndarray`` data: this requires both that the
 data types are the same (e.g. ``dtype='float64'`` and ``MatrixType::Scalar`` is
 ``double``); and that the storage is layout compatible.  The latter limitation
 is discussed in detail in the section below, and requires careful
-consideration: by default, numpy matrices and eigen matrices are *not* storage
+consideration: by default, numpy matrices and Eigen matrices are *not* storage
 compatible.
 
 If the numpy matrix cannot be used as is (either because its types differ, e.g.
-passing an array of integers to an Eigen paramater requiring doubles, or
+passing an array of integers to an Eigen parameter requiring doubles, or
 because the storage is incompatible), pybind11 makes a temporary copy and
 passes the copy instead.
 
@@ -57,7 +57,7 @@ expected:
 
 .. code-block:: cpp
 
-    void scale_by_2(Eigen::Ref<Eigen::VectorXd> m) {
+    void scale_by_2(Eigen::Ref<Eigen::VectorXd> v) {
         v *= 2;
     }
 
@@ -89,7 +89,7 @@ as dictated by the binding function's return value policy (see the
 documentation on :ref:`return_value_policies` for full details).  That means,
 without an explicit return value policy, lvalue references will be copied and
 pointers will be managed by pybind11.  In order to avoid copying, you should
-explictly specify an appropriate return value policy, as in the following
+explicitly specify an appropriate return value policy, as in the following
 example:
 
 .. code-block:: cpp
@@ -226,7 +226,7 @@ order.
 Failing rather than copying
 ===========================
 
-The default behaviour when binding ``Eigen::Ref<const MatrixType>`` eigen
+The default behaviour when binding ``Eigen::Ref<const MatrixType>`` Eigen
 references is to copy matrix values when passed a numpy array that does not
 conform to the element type of ``MatrixType`` or does not have a compatible
 stride layout.  If you want to explicitly avoid copying in such a case, you
@@ -252,11 +252,11 @@ copying to take place:
     using namespace pybind11::literals; // for "arg"_a
     py::class_<MyClass>(m, "MyClass")
         // ... other class definitions
-        .def("some_method", &MyClass::some_method, py::arg().nocopy());
+        .def("some_method", &MyClass::some_method, py::arg().noconvert());
 
     m.def("some_function", &some_function,
-        "big"_a.nocopy(), // <- Don't allow copying for this arg
-        "small"_a         // <- This one can be copied if needed
+        "big"_a.noconvert(), // <- Don't allow copying for this arg
+        "small"_a            // <- This one can be copied if needed
     );
 
 With the above binding code, attempting to call the the ``some_method(m)``
@@ -275,7 +275,7 @@ Vectors versus column/row matrices
 Eigen and numpy have fundamentally different notions of a vector.  In Eigen, a
 vector is simply a matrix with the number of columns or rows set to 1 at
 compile time (for a column vector or row vector, respectively).  Numpy, in
-contast, has comparable 2-dimensional 1xN and Nx1 arrays, but *also* has
+contrast, has comparable 2-dimensional 1xN and Nx1 arrays, but *also* has
 1-dimensional arrays of size N.
 
 When passing a 2-dimensional 1xN or Nx1 array to Eigen, the Eigen type must
@@ -287,15 +287,15 @@ On the other hand, pybind11 allows you to pass 1-dimensional arrays of length N
 as Eigen parameters.  If the Eigen type can hold a column vector of length N it
 will be passed as such a column vector.  If not, but the Eigen type constraints
 will accept a row vector, it will be passed as a row vector.  (The column
-vector takes precendence when both are supported, for example, when passing a
+vector takes precedence when both are supported, for example, when passing a
 1D numpy array to a MatrixXd argument).  Note that the type need not be
-expicitly a vector: it is permitted to pass a 1D numpy array of size 5 to an
+explicitly a vector: it is permitted to pass a 1D numpy array of size 5 to an
 Eigen ``Matrix<double, Dynamic, 5>``: you would end up with a 1x5 Eigen matrix.
 Passing the same to an ``Eigen::MatrixXd`` would result in a 5x1 Eigen matrix.
 
-When returning an eigen vector to numpy, the conversion is ambiguous: a row
+When returning an Eigen vector to numpy, the conversion is ambiguous: a row
 vector of length 4 could be returned as either a 1D array of length 4, or as a
-2D array of size 1x4.  When encoutering such a situation, pybind11 compromises
+2D array of size 1x4.  When encountering such a situation, pybind11 compromises
 by considering the returned Eigen type: if it is a compile-time vector--that
 is, the type has either the number of rows or columns set to 1 at compile
 time--pybind11 converts to a 1D numpy array when returning the value.  For
diff --git a/src/pybind11/docs/advanced/cast/overview.rst b/src/pybind11/docs/advanced/cast/overview.rst
index 2ac7d30..b0e32a5 100644
--- a/src/pybind11/docs/advanced/cast/overview.rst
+++ b/src/pybind11/docs/advanced/cast/overview.rst
@@ -131,6 +131,8 @@ as arguments and return values, refer to the section on binding :ref:`classes`.
 +------------------------------------+---------------------------+-------------------------------+
 | ``std::vector<T>``                 | STL dynamic array         | :file:`pybind11/stl.h`        |
 +------------------------------------+---------------------------+-------------------------------+
+| ``std::deque<T>``                  | STL double-ended queue    | :file:`pybind11/stl.h`        |
++------------------------------------+---------------------------+-------------------------------+
 | ``std::valarray<T>``               | STL value array           | :file:`pybind11/stl.h`        |
 +------------------------------------+---------------------------+-------------------------------+
 | ``std::list<T>``                   | STL linked list           | :file:`pybind11/stl.h`        |
diff --git a/src/pybind11/docs/advanced/cast/stl.rst b/src/pybind11/docs/advanced/cast/stl.rst
index 23e6751..e48409f 100644
--- a/src/pybind11/docs/advanced/cast/stl.rst
+++ b/src/pybind11/docs/advanced/cast/stl.rst
@@ -5,7 +5,7 @@ Automatic conversion
 ====================
 
 When including the additional header file :file:`pybind11/stl.h`, conversions
-between ``std::vector<>``/``std::list<>``/``std::array<>``,
+between ``std::vector<>``/``std::deque<>``/``std::list<>``/``std::array<>``,
 ``std::set<>``/``std::unordered_set<>``, and
 ``std::map<>``/``std::unordered_map<>`` and the Python ``list``, ``set`` and
 ``dict`` data structures are automatically enabled. The types ``std::pair<>``
@@ -26,6 +26,8 @@ next sections for more details and alternative approaches that avoid this.
     The file :file:`tests/test_stl.cpp` contains a complete
     example that demonstrates how to pass STL data types in more detail.
 
+.. _cpp17_container_casters:
+
 C++17 library containers
 ========================
 
@@ -60,9 +62,8 @@ for custom variant types:
         template <>
         struct visit_helper<boost::variant> {
             template <typename... Args>
-            static auto call(Args &&...args)
-                -> decltype(boost::apply_visitor(std::forward<Args>(args)...)) {
-                return boost::apply_visitor(std::forward<Args>(args)...);
+            static auto call(Args &&...args) -> decltype(boost::apply_visitor(args...)) {
+                return boost::apply_visitor(args...);
             }
         };
     }} // namespace pybind11::detail
@@ -71,6 +72,13 @@ The ``visit_helper`` specialization is not required if your ``name::variant`` pr
 a ``name::visit()`` function. For any other function name, the specialization must be
 included to tell pybind11 how to visit the variant.
 
+.. note::
+
+    pybind11 only supports the modern implementation of ``boost::variant``
+    which makes use of variadic templates. This requires Boost 1.56 or newer.
+    Additionally, on Windows, MSVC 2017 is required because ``boost::variant``
+    falls back to the old non-variadic implementation on MSVC 2015.
+
 .. _opaque:
 
 Making opaque types
@@ -150,10 +158,10 @@ the declaration
 before any binding code (e.g. invocations to ``class_::def()``, etc.). This
 macro must be specified at the top level (and outside of any namespaces), since
 it instantiates a partial template overload. If your binding code consists of
-multiple compilation units, it must be present in every file preceding any
-usage of ``std::vector<int>``. Opaque types must also have a corresponding
-``class_`` declaration to associate them with a name in Python, and to define a
-set of available operations, e.g.:
+multiple compilation units, it must be present in every file (typically via a
+common header) preceding any usage of ``std::vector<int>``. Opaque types must
+also have a corresponding ``class_`` declaration to associate them with a name
+in Python, and to define a set of available operations, e.g.:
 
 .. code-block:: cpp
 
@@ -167,6 +175,17 @@ set of available operations, e.g.:
         }, py::keep_alive<0, 1>()) /* Keep vector alive while iterator is used */
         // ....
 
+.. seealso::
+
+    The file :file:`tests/test_opaque_types.cpp` contains a complete
+    example that demonstrates how to create and expose opaque types using
+    pybind11 in more detail.
+
+.. _stl_bind:
+
+Binding STL containers
+======================
+
 The ability to expose STL containers as native Python objects is a fairly
 common request, hence pybind11 also provides an optional header file named
 :file:`pybind11/stl_bind.h` that does exactly this. The mapped containers try
@@ -188,14 +207,34 @@ The following example showcases usage of :file:`pybind11/stl_bind.h`:
     py::bind_vector<std::vector<int>>(m, "VectorInt");
     py::bind_map<std::map<std::string, double>>(m, "MapStringDouble");
 
-Please take a look at the :ref:`macro_notes` before using the
-``PYBIND11_MAKE_OPAQUE`` macro.
+When binding STL containers pybind11 considers the types of the container's
+elements to decide whether the container should be confined to the local module
+(via the :ref:`module_local` feature).  If the container element types are
+anything other than already-bound custom types bound without
+``py::module_local()`` the container binding will have ``py::module_local()``
+applied.  This includes converting types such as numeric types, strings, Eigen
+types; and types that have not yet been bound at the time of the stl container
+binding.  This module-local binding is designed to avoid potential conflicts
+between module bindings (for example, from two separate modules each attempting
+to bind ``std::vector<int>`` as a python type).
+
+It is possible to override this behavior to force a definition to be either
+module-local or global.  To do so, you can pass the attributes
+``py::module_local()`` (to make the binding module-local) or
+``py::module_local(false)`` (to make the binding global) into the
+``py::bind_vector`` or ``py::bind_map`` arguments:
 
-.. seealso::
+.. code-block:: cpp
 
-    The file :file:`tests/test_opaque_types.cpp` contains a complete
-    example that demonstrates how to create and expose opaque types using
-    pybind11 in more detail.
+    py::bind_vector<std::vector<int>>(m, "VectorInt", py::module_local(false));
+
+Note, however, that such a global binding would make it impossible to load this
+module at the same time as any other pybind module that also attempts to bind
+the same container type (``std::vector<int>`` in the above example).
+
+See :ref:`module_local` for more details on module-local bindings.
+
+.. seealso::
 
     The file :file:`tests/test_stl_binders.cpp` shows how to use the
     convenience STL container wrappers.
diff --git a/src/pybind11/docs/advanced/cast/strings.rst b/src/pybind11/docs/advanced/cast/strings.rst
index 2cdbade..e25701e 100644
--- a/src/pybind11/docs/advanced/cast/strings.rst
+++ b/src/pybind11/docs/advanced/cast/strings.rst
@@ -58,7 +58,9 @@ Passing bytes to C++
 --------------------
 
 A Python ``bytes`` object will be passed to C++ functions that accept
-``std::string`` or ``char*`` *without* conversion.
+``std::string`` or ``char*`` *without* conversion.  On Python 3, in order to
+make a function *only* accept ``bytes`` (and not ``str``), declare it as taking
+a ``py::bytes`` argument.
 
 
 Returning C++ strings to Python
diff --git a/src/pybind11/docs/advanced/classes.rst b/src/pybind11/docs/advanced/classes.rst
index 87bbe24..ae5907d 100644
--- a/src/pybind11/docs/advanced/classes.rst
+++ b/src/pybind11/docs/advanced/classes.rst
@@ -46,11 +46,10 @@ Normally, the binding code for these classes would look as follows:
 .. code-block:: cpp
 
     PYBIND11_MODULE(example, m) {
-        py::class_<Animal> animal(m, "Animal");
-        animal
+        py::class_<Animal>(m, "Animal")
             .def("go", &Animal::go);
 
-        py::class_<Dog>(m, "Dog", animal)
+        py::class_<Dog, Animal>(m, "Dog")
             .def(py::init<>());
 
         m.def("call_go", &call_go);
@@ -81,27 +80,26 @@ helper class that is defined as follows:
         }
     };
 
-The macro :func:`PYBIND11_OVERLOAD_PURE` should be used for pure virtual
-functions, and :func:`PYBIND11_OVERLOAD` should be used for functions which have
-a default implementation.  There are also two alternate macros
-:func:`PYBIND11_OVERLOAD_PURE_NAME` and :func:`PYBIND11_OVERLOAD_NAME` which
+The macro :c:macro:`PYBIND11_OVERLOAD_PURE` should be used for pure virtual
+functions, and :c:macro:`PYBIND11_OVERLOAD` should be used for functions which have
+a default implementation.  There are also two alternate macros 
+:c:macro:`PYBIND11_OVERLOAD_PURE_NAME` and :c:macro:`PYBIND11_OVERLOAD_NAME` which
 take a string-valued name argument between the *Parent class* and *Name of the
-function* slots, which defines the name of function in Python. This is required 
+function* slots, which defines the name of function in Python. This is required
 when the C++ and Python versions of the
 function have different names, e.g.  ``operator()`` vs ``__call__``.
 
 The binding code also needs a few minor adaptations (highlighted):
 
 .. code-block:: cpp
-    :emphasize-lines: 2,4,5
+    :emphasize-lines: 2,3
 
     PYBIND11_MODULE(example, m) {
-        py::class_<Animal, PyAnimal /* <--- trampoline*/> animal(m, "Animal");
-        animal
+        py::class_<Animal, PyAnimal /* <--- trampoline*/>(m, "Animal")
             .def(py::init<>())
             .def("go", &Animal::go);
 
-        py::class_<Dog>(m, "Dog", animal)
+        py::class_<Dog, Animal>(m, "Dog")
             .def(py::init<>());
 
         m.def("call_go", &call_go);
@@ -116,14 +114,14 @@ define a constructor as usual.
 Bindings should be made against the actual class, not the trampoline helper class.
 
 .. code-block:: cpp
+    :emphasize-lines: 3
 
-    py::class_<Animal, PyAnimal /* <--- trampoline*/> animal(m, "Animal");
-        animal
-            .def(py::init<>())
-            .def("go", &PyAnimal::go); /* <--- THIS IS WRONG, use &Animal::go */
+    py::class_<Animal, PyAnimal /* <--- trampoline*/>(m, "Animal");
+        .def(py::init<>())
+        .def("go", &PyAnimal::go); /* <--- THIS IS WRONG, use &Animal::go */
 
 Note, however, that the above is sufficient for allowing python classes to
-extend ``Animal``, but not ``Dog``: see ref:`virtual_and_inheritance` for the
+extend ``Animal``, but not ``Dog``: see :ref:`virtual_and_inheritance` for the
 necessary steps required to providing proper overload support for inherited
 classes.
 
@@ -144,6 +142,30 @@ a virtual method call.
     >>> call_go(c)
     u'meow! meow! meow! '
 
+If you are defining a custom constructor in a derived Python class, you *must*
+ensure that you explicitly call the bound C++ constructor using ``__init__``,
+*regardless* of whether it is a default constructor or not. Otherwise, the
+memory for the C++ portion of the instance will be left uninitialized, which
+will generally leave the C++ instance in an invalid state and cause undefined
+behavior if the C++ instance is subsequently used.
+
+Here is an example:
+
+.. code-block:: python
+
+    class Dachshund(Dog):
+        def __init__(self, name):
+            Dog.__init__(self) # Without this, undefined behavior may occur if the C++ portions are referenced.
+            self.name = name
+        def bark(self):
+            return "yap!"
+
+Note that a direct ``__init__`` constructor *should be called*, and ``super()``
+should not be used. For simple cases of linear inheritance, ``super()``
+may work, but once you begin mixing Python and C++ multiple inheritance,
+things will fall apart due to differences between Python's MRO and C++'s
+mechanisms.
+
 Please take a look at the :ref:`macro_notes` before using this feature.
 
 .. note::
@@ -217,7 +239,7 @@ override the ``name()`` method):
     class PyDog : public Dog {
     public:
         using Dog::Dog; // Inherit constructors
-        std::string go(int n_times) override { PYBIND11_OVERLOAD_PURE(std::string, Dog, go, n_times); }
+        std::string go(int n_times) override { PYBIND11_OVERLOAD(std::string, Dog, go, n_times); }
         std::string name() override { PYBIND11_OVERLOAD(std::string, Dog, name, ); }
         std::string bark() override { PYBIND11_OVERLOAD(std::string, Dog, bark, ); }
     };
@@ -298,9 +320,15 @@ can now create a python class that inherits from ``Dog``:
     See the file :file:`tests/test_virtual_functions.cpp` for complete examples
     using both the duplication and templated trampoline approaches.
 
+.. _extended_aliases:
+
 Extended trampoline class functionality
 =======================================
 
+.. _extended_class_functionality_forced_trampoline:
+
+Forced trampoline class initialisation
+--------------------------------------
 The trampoline classes described in the previous sections are, by default, only
 initialized when needed.  More specifically, they are initialized when a python
 class actually inherits from a registered type (instead of merely creating an
@@ -328,35 +356,174 @@ ensuring member initialization and (eventual) destruction.
     See the file :file:`tests/test_virtual_functions.cpp` for complete examples
     showing both normal and forced trampoline instantiation.
 
+Different method signatures
+---------------------------
+The macro's introduced in :ref:`overriding_virtuals` cover most of the standard
+use cases when exposing C++ classes to Python. Sometimes it is hard or unwieldy
+to create a direct one-on-one mapping between the arguments and method return
+type.
+
+An example would be when the C++ signature contains output arguments using
+references (See also :ref:`faq_reference_arguments`). Another way of solving
+this is to use the method body of the trampoline class to do conversions to the
+input and return of the Python method.
+
+The main building block to do so is the :func:`get_overload`, this function
+allows retrieving a method implemented in Python from within the trampoline's
+methods. Consider for example a C++ method which has the signature
+``bool myMethod(int32_t& value)``, where the return indicates whether
+something should be done with the ``value``. This can be made convenient on the
+Python side by allowing the Python function to return ``None`` or an ``int``:
+
+.. code-block:: cpp
+
+    bool MyClass::myMethod(int32_t& value)
+    {
+        pybind11::gil_scoped_acquire gil;  // Acquire the GIL while in this scope.
+        // Try to look up the overloaded method on the Python side.
+        pybind11::function overload = pybind11::get_overload(this, "myMethod");
+        if (overload) {  // method is found
+            auto obj = overload(value);  // Call the Python function.
+            if (py::isinstance<py::int_>(obj)) {  // check if it returned a Python integer type
+                value = obj.cast<int32_t>();  // Cast it and assign it to the value.
+                return true;  // Return true; value should be used.
+            } else {
+                return false;  // Python returned none, return false.
+            }
+        }
+        return false;  // Alternatively return MyClass::myMethod(value);
+    }
+
+
 .. _custom_constructors:
 
 Custom constructors
 ===================
 
 The syntax for binding constructors was previously introduced, but it only
-works when a constructor with the given parameters actually exists on the C++
-side. To extend this to more general cases, let's take a look at what actually
-happens under the hood: the following statement
+works when a constructor of the appropriate arguments actually exists on the
+C++ side.  To extend this to more general cases, pybind11 makes it possible
+to bind factory functions as constructors. For example, suppose you have a
+class like this:
 
 .. code-block:: cpp
 
+    class Example {
+    private:
+        Example(int); // private constructor
+    public:
+        // Factory function:
+        static Example create(int a) { return Example(a); }
+    };
+
     py::class_<Example>(m, "Example")
-        .def(py::init<int>());
+        .def(py::init(&Example::create));
+
+While it is possible to create a straightforward binding of the static
+``create`` method, it may sometimes be preferable to expose it as a constructor
+on the Python side. This can be accomplished by calling ``.def(py::init(...))``
+with the function reference returning the new instance passed as an argument.
+It is also possible to use this approach to bind a function returning a new
+instance by raw pointer or by the holder (e.g. ``std::unique_ptr``).
 
-is short hand notation for
+The following example shows the different approaches:
 
 .. code-block:: cpp
 
+    class Example {
+    private:
+        Example(int); // private constructor
+    public:
+        // Factory function - returned by value:
+        static Example create(int a) { return Example(a); }
+
+        // These constructors are publicly callable:
+        Example(double);
+        Example(int, int);
+        Example(std::string);
+    };
+
     py::class_<Example>(m, "Example")
-        .def("__init__",
-            [](Example &instance, int arg) {
-                new (&instance) Example(arg);
-            }
-        );
+        // Bind the factory function as a constructor:
+        .def(py::init(&Example::create))
+        // Bind a lambda function returning a pointer wrapped in a holder:
+        .def(py::init([](std::string arg) {
+            return std::unique_ptr<Example>(new Example(arg));
+        }))
+        // Return a raw pointer:
+        .def(py::init([](int a, int b) { return new Example(a, b); }))
+        // You can mix the above with regular C++ constructor bindings as well:
+        .def(py::init<double>())
+        ;
+
+When the constructor is invoked from Python, pybind11 will call the factory
+function and store the resulting C++ instance in the Python instance.
+
+When combining factory functions constructors with :ref:`virtual function
+trampolines <overriding_virtuals>` there are two approaches.  The first is to
+add a constructor to the alias class that takes a base value by
+rvalue-reference.  If such a constructor is available, it will be used to
+construct an alias instance from the value returned by the factory function.
+The second option is to provide two factory functions to ``py::init()``: the
+first will be invoked when no alias class is required (i.e. when the class is
+being used but not inherited from in Python), and the second will be invoked
+when an alias is required.
+
+You can also specify a single factory function that always returns an alias
+instance: this will result in behaviour similar to ``py::init_alias<...>()``,
+as described in the :ref:`extended trampoline class documentation
+<extended_aliases>`.
+
+The following example shows the different factory approaches for a class with
+an alias:
+
+.. code-block:: cpp
+
+    #include <pybind11/factory.h>
+    class Example {
+    public:
+        // ...
+        virtual ~Example() = default;
+    };
+    class PyExample : public Example {
+    public:
+        using Example::Example;
+        PyExample(Example &&base) : Example(std::move(base)) {}
+    };
+    py::class_<Example, PyExample>(m, "Example")
+        // Returns an Example pointer.  If a PyExample is needed, the Example
+        // instance will be moved via the extra constructor in PyExample, above.
+        .def(py::init([]() { return new Example(); }))
+        // Two callbacks:
+        .def(py::init([]() { return new Example(); } /* no alias needed */,
+                      []() { return new PyExample(); } /* alias needed */))
+        // *Always* returns an alias instance (like py::init_alias<>())
+        .def(py::init([]() { return new PyExample(); }))
+        ;
+
+Brace initialization
+--------------------
+
+``pybind11::init<>`` internally uses C++11 brace initialization to call the
+constructor of the target class. This means that it can be used to bind
+*implicit* constructors as well:
+
+.. code-block:: cpp
+
+    struct Aggregate {
+        int a;
+        std::string b;
+    };
+
+    py::class_<Aggregate>(m, "Aggregate")
+        .def(py::init<int, const std::string &>());
+
+.. note::
 
-In other words, :func:`init` creates an anonymous function that invokes an
-in-place constructor. Memory allocation etc. is already take care of beforehand
-within pybind11.
+    Note that brace initialization preferentially invokes constructor overloads
+    taking a ``std::initializer_list``. In the rare event that this causes an
+    issue, you can work around it by using ``py::init(...)`` with a lambda
+    function that constructs the new object as desired.
 
 .. _classes_with_non_public_destructors:
 
@@ -427,6 +594,10 @@ Python side:
     Implicit conversions from ``A`` to ``B`` only work when ``B`` is a custom
     data type that is exposed to Python via pybind11.
 
+    To prevent runaway recursion, implicit conversions are non-reentrant: an
+    implicit conversion invoked as part of another implicit conversion of the
+    same type (i.e. from ``A`` to ``B``) will fail.
+
 .. _static_properties:
 
 Static properties
@@ -491,6 +662,7 @@ to Python.
             .def(py::self *= float())
             .def(float() * py::self)
             .def(py::self * float())
+            .def(-py::self)
             .def("__repr__", &Vector2::toString);
     }
 
@@ -525,13 +697,15 @@ throwing a type error.
     complete example that demonstrates how to work with overloaded operators in
     more detail.
 
+.. _pickling:
+
 Pickling support
 ================
 
 Python's ``pickle`` module provides a powerful facility to serialize and
 de-serialize a Python object graph into a binary data stream. To pickle and
-unpickle C++ classes using pybind11, two additional functions must be provided.
-Suppose the class in question has the following signature:
+unpickle C++ classes using pybind11, a ``py::pickle()`` definition must be
+provided. Suppose the class in question has the following signature:
 
 .. code-block:: cpp
 
@@ -547,8 +721,9 @@ Suppose the class in question has the following signature:
         int m_extra = 0;
     };
 
-The binding code including the requisite ``__setstate__`` and ``__getstate__`` methods [#f3]_
-looks as follows:
+Pickling support in Python is enabled by defining the ``__setstate__`` and
+``__getstate__`` methods [#f3]_. For pybind11 classes, use ``py::pickle()``
+to bind these two functions:
 
 .. code-block:: cpp
 
@@ -557,21 +732,28 @@ looks as follows:
         .def("value", &Pickleable::value)
         .def("extra", &Pickleable::extra)
         .def("setExtra", &Pickleable::setExtra)
-        .def("__getstate__", [](const Pickleable &p) {
-            /* Return a tuple that fully encodes the state of the object */
-            return py::make_tuple(p.value(), p.extra());
-        })
-        .def("__setstate__", [](Pickleable &p, py::tuple t) {
-            if (t.size() != 2)
-                throw std::runtime_error("Invalid state!");
-
-            /* Invoke the in-place constructor. Note that this is needed even
-               when the object just has a trivial default constructor */
-            new (&p) Pickleable(t[0].cast<std::string>());
-
-            /* Assign any additional state */
-            p.setExtra(t[1].cast<int>());
-        });
+        .def(py::pickle(
+            [](const Pickleable &p) { // __getstate__
+                /* Return a tuple that fully encodes the state of the object */
+                return py::make_tuple(p.value(), p.extra());
+            },
+            [](py::tuple t) { // __setstate__
+                if (t.size() != 2)
+                    throw std::runtime_error("Invalid state!");
+
+                /* Create a new C++ instance */
+                Pickleable p(t[0].cast<std::string>());
+
+                /* Assign any additional state */
+                p.setExtra(t[1].cast<int>());
+
+                return p;
+            }
+        ));
+
+The ``__setstate__`` part of the ``py::picke()`` definition follows the same
+rules as the single-argument version of ``py::init()``. The return type can be
+a value, pointer or holder type. See :ref:`custom_constructors` for details.
 
 An instance can now be pickled as follows:
 
@@ -620,7 +802,7 @@ document)---pybind11 will automatically find out which is which. The only
 requirement is that the first template argument is the type to be declared.
 
 It is also permitted to inherit multiply from exported C++ classes in Python,
-as well as inheriting from multiple Python and/or pybind-exported classes.
+as well as inheriting from multiple Python and/or pybind11-exported classes.
 
 There is one caveat regarding the implementation of this feature:
 
@@ -635,3 +817,310 @@ inheritance, which can lead to undefined behavior. In such cases, add the tag
 
 The tag is redundant and does not need to be specified when multiple base types
 are listed.
+
+.. _module_local:
+
+Module-local class bindings
+===========================
+
+When creating a binding for a class, pybind11 by default makes that binding
+"global" across modules.  What this means is that a type defined in one module
+can be returned from any module resulting in the same Python type.  For
+example, this allows the following:
+
+.. code-block:: cpp
+
+    // In the module1.cpp binding code for module1:
+    py::class_<Pet>(m, "Pet")
+        .def(py::init<std::string>())
+        .def_readonly("name", &Pet::name);
+
+.. code-block:: cpp
+
+    // In the module2.cpp binding code for module2:
+    m.def("create_pet", [](std::string name) { return new Pet(name); });
+
+.. code-block:: pycon
+
+    >>> from module1 import Pet
+    >>> from module2 import create_pet
+    >>> pet1 = Pet("Kitty")
+    >>> pet2 = create_pet("Doggy")
+    >>> pet2.name()
+    'Doggy'
+
+When writing binding code for a library, this is usually desirable: this
+allows, for example, splitting up a complex library into multiple Python
+modules.
+
+In some cases, however, this can cause conflicts.  For example, suppose two
+unrelated modules make use of an external C++ library and each provide custom
+bindings for one of that library's classes.  This will result in an error when
+a Python program attempts to import both modules (directly or indirectly)
+because of conflicting definitions on the external type:
+
+.. code-block:: cpp
+
+    // dogs.cpp
+
+    // Binding for external library class:
+    py::class<pets::Pet>(m, "Pet")
+        .def("name", &pets::Pet::name);
+
+    // Binding for local extension class:
+    py::class<Dog, pets::Pet>(m, "Dog")
+        .def(py::init<std::string>());
+
+.. code-block:: cpp
+
+    // cats.cpp, in a completely separate project from the above dogs.cpp.
+
+    // Binding for external library class:
+    py::class<pets::Pet>(m, "Pet")
+        .def("get_name", &pets::Pet::name);
+
+    // Binding for local extending class:
+    py::class<Cat, pets::Pet>(m, "Cat")
+        .def(py::init<std::string>());
+
+.. code-block:: pycon
+
+    >>> import cats
+    >>> import dogs
+    Traceback (most recent call last):
+      File "<stdin>", line 1, in <module>
+    ImportError: generic_type: type "Pet" is already registered!
+
+To get around this, you can tell pybind11 to keep the external class binding
+localized to the module by passing the ``py::module_local()`` attribute into
+the ``py::class_`` constructor:
+
+.. code-block:: cpp
+
+    // Pet binding in dogs.cpp:
+    py::class<pets::Pet>(m, "Pet", py::module_local())
+        .def("name", &pets::Pet::name);
+
+.. code-block:: cpp
+
+    // Pet binding in cats.cpp:
+    py::class<pets::Pet>(m, "Pet", py::module_local())
+        .def("get_name", &pets::Pet::name);
+
+This makes the Python-side ``dogs.Pet`` and ``cats.Pet`` into distinct classes,
+avoiding the conflict and allowing both modules to be loaded.  C++ code in the
+``dogs`` module that casts or returns a ``Pet`` instance will result in a
+``dogs.Pet`` Python instance, while C++ code in the ``cats`` module will result
+in a ``cats.Pet`` Python instance.
+
+This does come with two caveats, however: First, external modules cannot return
+or cast a ``Pet`` instance to Python (unless they also provide their own local
+bindings).  Second, from the Python point of view they are two distinct classes.
+
+Note that the locality only applies in the C++ -> Python direction.  When
+passing such a ``py::module_local`` type into a C++ function, the module-local
+classes are still considered.  This means that if the following function is
+added to any module (including but not limited to the ``cats`` and ``dogs``
+modules above) it will be callable with either a ``dogs.Pet`` or ``cats.Pet``
+argument:
+
+.. code-block:: cpp
+
+    m.def("pet_name", [](const pets::Pet &pet) { return pet.name(); });
+
+For example, suppose the above function is added to each of ``cats.cpp``,
+``dogs.cpp`` and ``frogs.cpp`` (where ``frogs.cpp`` is some other module that
+does *not* bind ``Pets`` at all).
+
+.. code-block:: pycon
+
+    >>> import cats, dogs, frogs  # No error because of the added py::module_local()
+    >>> mycat, mydog = cats.Cat("Fluffy"), dogs.Dog("Rover")
+    >>> (cats.pet_name(mycat), dogs.pet_name(mydog))
+    ('Fluffy', 'Rover')
+    >>> (cats.pet_name(mydog), dogs.pet_name(mycat), frogs.pet_name(mycat))
+    ('Rover', 'Fluffy', 'Fluffy')
+
+It is possible to use ``py::module_local()`` registrations in one module even
+if another module registers the same type globally: within the module with the
+module-local definition, all C++ instances will be cast to the associated bound
+Python type.  In other modules any such values are converted to the global
+Python type created elsewhere.
+
+.. note::
+
+    STL bindings (as provided via the optional :file:`pybind11/stl_bind.h`
+    header) apply ``py::module_local`` by default when the bound type might
+    conflict with other modules; see :ref:`stl_bind` for details.
+
+.. note::
+
+    The localization of the bound types is actually tied to the shared object
+    or binary generated by the compiler/linker.  For typical modules created
+    with ``PYBIND11_MODULE()``, this distinction is not significant.  It is
+    possible, however, when :ref:`embedding` to embed multiple modules in the
+    same binary (see :ref:`embedding_modules`).  In such a case, the
+    localization will apply across all embedded modules within the same binary.
+
+.. seealso::
+
+    The file :file:`tests/test_local_bindings.cpp` contains additional examples
+    that demonstrate how ``py::module_local()`` works.
+
+Binding protected member functions
+==================================
+
+It's normally not possible to expose ``protected`` member functions to Python:
+
+.. code-block:: cpp
+
+    class A {
+    protected:
+        int foo() const { return 42; }
+    };
+
+    py::class_<A>(m, "A")
+        .def("foo", &A::foo); // error: 'foo' is a protected member of 'A'
+
+On one hand, this is good because non-``public`` members aren't meant to be
+accessed from the outside. But we may want to make use of ``protected``
+functions in derived Python classes.
+
+The following pattern makes this possible:
+
+.. code-block:: cpp
+
+    class A {
+    protected:
+        int foo() const { return 42; }
+    };
+
+    class Publicist : public A { // helper type for exposing protected functions
+    public:
+        using A::foo; // inherited with different access modifier
+    };
+
+    py::class_<A>(m, "A") // bind the primary class
+        .def("foo", &Publicist::foo); // expose protected methods via the publicist
+
+This works because ``&Publicist::foo`` is exactly the same function as
+``&A::foo`` (same signature and address), just with a different access
+modifier. The only purpose of the ``Publicist`` helper class is to make
+the function name ``public``.
+
+If the intent is to expose ``protected`` ``virtual`` functions which can be
+overridden in Python, the publicist pattern can be combined with the previously
+described trampoline:
+
+.. code-block:: cpp
+
+    class A {
+    public:
+        virtual ~A() = default;
+
+    protected:
+        virtual int foo() const { return 42; }
+    };
+
+    class Trampoline : public A {
+    public:
+        int foo() const override { PYBIND11_OVERLOAD(int, A, foo, ); }
+    };
+
+    class Publicist : public A {
+    public:
+        using A::foo;
+    };
+
+    py::class_<A, Trampoline>(m, "A") // <-- `Trampoline` here
+        .def("foo", &Publicist::foo); // <-- `Publicist` here, not `Trampoline`!
+
+.. note::
+
+    MSVC 2015 has a compiler bug (fixed in version 2017) which
+    requires a more explicit function binding in the form of
+    ``.def("foo", static_cast<int (A::*)() const>(&Publicist::foo));``
+    where ``int (A::*)() const`` is the type of ``A::foo``.
+
+Custom automatic downcasters
+============================
+
+As explained in :ref:`inheritance`, pybind11 comes with built-in
+understanding of the dynamic type of polymorphic objects in C++; that
+is, returning a Pet to Python produces a Python object that knows it's
+wrapping a Dog, if Pet has virtual methods and pybind11 knows about
+Dog and this Pet is in fact a Dog. Sometimes, you might want to
+provide this automatic downcasting behavior when creating bindings for
+a class hierarchy that does not use standard C++ polymorphism, such as
+LLVM [#f4]_. As long as there's some way to determine at runtime
+whether a downcast is safe, you can proceed by specializing the
+``pybind11::polymorphic_type_hook`` template:
+
+.. code-block:: cpp
+
+    enum class PetKind { Cat, Dog, Zebra };
+    struct Pet {   // Not polymorphic: has no virtual methods
+        const PetKind kind;
+        int age = 0;
+      protected:
+        Pet(PetKind _kind) : kind(_kind) {}
+    };
+    struct Dog : Pet {
+        Dog() : Pet(PetKind::Dog) {}
+        std::string sound = "woof!";
+        std::string bark() const { return sound; }
+    };
+
+    namespace pybind11 {
+        template<> struct polymorphic_type_hook<Pet> {
+            static const void *get(const Pet *src, const std::type_info*& type) {
+                // note that src may be nullptr
+                if (src && src->kind == PetKind::Dog) {
+                    type = &typeid(Dog);
+                    return static_cast<const Dog*>(src);
+                }
+                return src;
+            }
+        };
+    } // namespace pybind11
+
+When pybind11 wants to convert a C++ pointer of type ``Base*`` to a
+Python object, it calls ``polymorphic_type_hook<Base>::get()`` to
+determine if a downcast is possible. The ``get()`` function should use
+whatever runtime information is available to determine if its ``src``
+parameter is in fact an instance of some class ``Derived`` that
+inherits from ``Base``. If it finds such a ``Derived``, it sets ``type
+= &typeid(Derived)`` and returns a pointer to the ``Derived`` object
+that contains ``src``. Otherwise, it just returns ``src``, leaving
+``type`` at its default value of nullptr. If you set ``type`` to a
+type that pybind11 doesn't know about, no downcasting will occur, and
+the original ``src`` pointer will be used with its static type
+``Base*``.
+
+It is critical that the returned pointer and ``type`` argument of
+``get()`` agree with each other: if ``type`` is set to something
+non-null, the returned pointer must point to the start of an object
+whose type is ``type``. If the hierarchy being exposed uses only
+single inheritance, a simple ``return src;`` will achieve this just
+fine, but in the general case, you must cast ``src`` to the
+appropriate derived-class pointer (e.g. using
+``static_cast<Derived>(src)``) before allowing it to be returned as a
+``void*``.
+
+.. [#f4] https://llvm.org/docs/HowToSetUpLLVMStyleRTTI.html
+
+.. note::
+
+    pybind11's standard support for downcasting objects whose types
+    have virtual methods is implemented using
+    ``polymorphic_type_hook`` too, using the standard C++ ability to
+    determine the most-derived type of a polymorphic object using
+    ``typeid()`` and to cast a base pointer to that most-derived type
+    (even if you don't know what it is) using ``dynamic_cast<void*>``.
+
+.. seealso::
+
+    The file :file:`tests/test_tagbased_polymorphic.cpp` contains a
+    more complete example, including a demonstration of how to provide
+    automatic downcasting for an entire class hierarchy without
+    writing one get() function for each class.
diff --git a/src/pybind11/docs/advanced/embedding.rst b/src/pybind11/docs/advanced/embedding.rst
index 5354eee..3930316 100644
--- a/src/pybind11/docs/advanced/embedding.rst
+++ b/src/pybind11/docs/advanced/embedding.rst
@@ -1,3 +1,5 @@
+.. _embedding:
+
 Embedding the interpreter
 #########################
 
@@ -131,6 +133,12 @@ embedding the interpreter. This makes it easy to import local Python files:
     int n = result.cast<int>();
     assert(n == 3);
 
+Modules can be reloaded using `module::reload()` if the source is modified e.g.
+by an external process. This can be useful in scenarios where the application
+imports a user defined data processing script which needs to be updated after
+changes by the user. Note that this function does not reload modules recursively.
+
+.. _embedding_modules:
 
 Adding embedded modules
 =======================
@@ -182,7 +190,7 @@ naturally:
     namespace py = pybind11;
 
     PYBIND11_EMBEDDED_MODULE(cpp_module, m) {
-        m.attr("a") = 1
+        m.attr("a") = 1;
     }
 
     int main() {
diff --git a/src/pybind11/docs/advanced/exceptions.rst b/src/pybind11/docs/advanced/exceptions.rst
index 3483379..75ad7f7 100644
--- a/src/pybind11/docs/advanced/exceptions.rst
+++ b/src/pybind11/docs/advanced/exceptions.rst
@@ -11,45 +11,47 @@ exceptions:
 
 .. tabularcolumns:: |p{0.5\textwidth}|p{0.45\textwidth}|
 
-+--------------------------------------+------------------------------+
-|  C++ exception type                  |  Python exception type       |
-+======================================+==============================+
-| :class:`std::exception`              | ``RuntimeError``             |
-+--------------------------------------+------------------------------+
-| :class:`std::bad_alloc`              | ``MemoryError``              |
-+--------------------------------------+------------------------------+
-| :class:`std::domain_error`           | ``ValueError``               |
-+--------------------------------------+------------------------------+
-| :class:`std::invalid_argument`       | ``ValueError``               |
-+--------------------------------------+------------------------------+
-| :class:`std::length_error`           | ``ValueError``               |
-+--------------------------------------+------------------------------+
-| :class:`std::out_of_range`           | ``ValueError``               |
-+--------------------------------------+------------------------------+
-| :class:`std::range_error`            | ``ValueError``               |
-+--------------------------------------+------------------------------+
-| :class:`pybind11::stop_iteration`    | ``StopIteration`` (used to   |
-|                                      | implement custom iterators)  |
-+--------------------------------------+------------------------------+
-| :class:`pybind11::index_error`       | ``IndexError`` (used to      |
-|                                      | indicate out of bounds       |
-|                                      | accesses in ``__getitem__``, |
-|                                      | ``__setitem__``, etc.)       |
-+--------------------------------------+------------------------------+
-| :class:`pybind11::value_error`       | ``ValueError`` (used to      |
-|                                      | indicate wrong value passed  |
-|                                      | in ``container.remove(...)`` |
-+--------------------------------------+------------------------------+
-| :class:`pybind11::key_error`         | ``KeyError`` (used to        |
-|                                      | indicate out of bounds       |
-|                                      | accesses in ``__getitem__``, |
-|                                      | ``__setitem__`` in dict-like |
-|                                      | objects, etc.)               |
-+--------------------------------------+------------------------------+
-| :class:`pybind11::error_already_set` | Indicates that the Python    |
-|                                      | exception flag has already   |
-|                                      | been initialized             |
-+--------------------------------------+------------------------------+
++--------------------------------------+--------------------------------------+
+|  C++ exception type                  |  Python exception type               |
++======================================+======================================+
+| :class:`std::exception`              | ``RuntimeError``                     |
++--------------------------------------+--------------------------------------+
+| :class:`std::bad_alloc`              | ``MemoryError``                      |
++--------------------------------------+--------------------------------------+
+| :class:`std::domain_error`           | ``ValueError``                       |
++--------------------------------------+--------------------------------------+
+| :class:`std::invalid_argument`       | ``ValueError``                       |
++--------------------------------------+--------------------------------------+
+| :class:`std::length_error`           | ``ValueError``                       |
++--------------------------------------+--------------------------------------+
+| :class:`std::out_of_range`           | ``IndexError``                       |
++--------------------------------------+--------------------------------------+
+| :class:`std::range_error`            | ``ValueError``                       |
++--------------------------------------+--------------------------------------+
+| :class:`std::overflow_error`         | ``OverflowError``                    |
++--------------------------------------+--------------------------------------+
+| :class:`pybind11::stop_iteration`    | ``StopIteration`` (used to implement |
+|                                      | custom iterators)                    |
++--------------------------------------+--------------------------------------+
+| :class:`pybind11::index_error`       | ``IndexError`` (used to indicate out |
+|                                      | of bounds access in ``__getitem__``, |
+|                                      | ``__setitem__``, etc.)               |
++--------------------------------------+--------------------------------------+
+| :class:`pybind11::value_error`       | ``ValueError`` (used to indicate     |
+|                                      | wrong value passed in                |
+|                                      | ``container.remove(...)``)           |
++--------------------------------------+--------------------------------------+
+| :class:`pybind11::key_error`         | ``KeyError`` (used to indicate out   |
+|                                      | of bounds access in ``__getitem__``, |
+|                                      | ``__setitem__`` in dict-like         |
+|                                      | objects, etc.)                       |
++--------------------------------------+--------------------------------------+
+| :class:`pybind11::error_already_set` | Indicates that the Python exception  |
+|                                      | flag has already been set via Python |
+|                                      | API calls from C++ code; this C++    |
+|                                      | exception is used to propagate such  |
+|                                      | a Python exception back to Python.   |
++--------------------------------------+--------------------------------------+
 
 When a Python function invoked from C++ throws an exception, it is converted
 into a C++ exception of type :class:`error_already_set` whose string payload
@@ -138,5 +140,5 @@ section.
     error return without exception set``.
 
     Exceptions that you do not plan to handle should simply not be caught, or
-    may be explicity (re-)thrown to delegate it to the other,
+    may be explicitly (re-)thrown to delegate it to the other,
     previously-declared existing exception translators.
diff --git a/src/pybind11/docs/advanced/functions.rst b/src/pybind11/docs/advanced/functions.rst
index a7807dc..3e1a3ff 100644
--- a/src/pybind11/docs/advanced/functions.rst
+++ b/src/pybind11/docs/advanced/functions.rst
@@ -126,7 +126,7 @@ targeted arguments can be passed through the :class:`cpp_function` constructor:
 
 .. warning::
 
-    Code with invalid return value policies might access unitialized memory or
+    Code with invalid return value policies might access uninitialized memory or
     free data structures multiple times, which can lead to hard-to-debug
     non-determinism and segmentation faults, hence it is worth spending the
     time to understand all the different options in the table above.
@@ -177,9 +177,10 @@ indices start at one, while zero refers to the return value. For methods, index
 index ``2``. Arbitrarily many call policies can be specified. When a ``Nurse``
 with value ``None`` is detected at runtime, the call policy does nothing.
 
-This feature internally relies on the ability to create a *weak reference* to
-the nurse object, which is permitted by all classes exposed via pybind11. When
-the nurse object does not support weak references, an exception will be thrown.
+When the nurse is not a pybind11-registered type, the implementation internally
+relies on the ability to create a *weak reference* to the nurse object. When
+the nurse object is not a pybind11-registered type and does not support weak
+references, an exception will be thrown.
 
 Consider the following example: here, the binding code for a list append
 operation ties the lifetime of the newly added element to the underlying
@@ -190,6 +191,17 @@ container:
     py::class_<List>(m, "List")
         .def("append", &List::append, py::keep_alive<1, 2>());
 
+For consistency, the argument indexing is identical for constructors. Index
+``1`` still refers to the implicit ``this`` pointer, i.e. the object which is
+being constructed. Index ``0`` refers to the return type which is presumed to
+be ``void`` when a constructor is viewed like a function. The following example
+ties the lifetime of the constructor element to the constructed object:
+
+.. code-block:: cpp
+
+    py::class_<Nurse>(m, "Nurse")
+        .def(py::init<Patient &>(), py::keep_alive<1, 2>());
+
 .. note::
 
     ``keep_alive`` is analogous to the ``with_custodian_and_ward`` (if Nurse,
@@ -406,6 +418,8 @@ name, i.e. by specifying ``py::arg().noconvert()``.
     need to specify a ``py::arg()`` annotation for each argument with the
     no-convert argument modified to ``py::arg().noconvert()``.
 
+.. _none_arguments:
+
 Allow/Prohibiting None arguments
 ================================
 
@@ -424,7 +438,7 @@ To explicitly enable or disable this behaviour, using the
     py::class_<Cat>(m, "Cat").def(py::init<>());
     m.def("bark", [](Dog *dog) -> std::string {
         if (dog) return "woof!"; /* Called with a Dog instance */
-        else return "(no dog)"; /* Called with None, d == nullptr */
+        else return "(no dog)"; /* Called with None, dog == nullptr */
     }, py::arg("dog").none(true));
     m.def("meow", [](Cat *cat) -> std::string {
         // Can't be called with None argument
@@ -453,13 +467,22 @@ dog)"``, while attempting to call ``meow(None)`` will raise a ``TypeError``:
 
 The default behaviour when the tag is unspecified is to allow ``None``.
 
+.. note::
+
+    Even when ``.none(true)`` is specified for an argument, ``None`` will be converted to a
+    ``nullptr`` *only* for custom and :ref:`opaque <opaque>` types. Pointers to built-in types
+    (``double *``, ``int *``, ...) and STL types (``std::vector<T> *``, ...; if ``pybind11/stl.h``
+    is included) are copied when converted to C++ (see :doc:`/advanced/cast/overview`) and will
+    not allow ``None`` as argument.  To pass optional argument of these copied types consider
+    using ``std::optional<T>``
+
 Overload resolution order
 =========================
 
 When a function or method with multiple overloads is called from Python,
 pybind11 determines which overload to call in two passes.  The first pass
 attempts to call each overload without allowing argument conversion (as if
-every argument had been specified as ``py::arg().noconvert()`` as decribed
+every argument had been specified as ``py::arg().noconvert()`` as described
 above).
 
 If no overload succeeds in the no-conversion first pass, a second pass is
diff --git a/src/pybind11/docs/advanced/misc.rst b/src/pybind11/docs/advanced/misc.rst
index 8751faf..5b38ec7 100644
--- a/src/pybind11/docs/advanced/misc.rst
+++ b/src/pybind11/docs/advanced/misc.rst
@@ -7,13 +7,32 @@ General notes regarding convenience macros
 ==========================================
 
 pybind11 provides a few convenience macros such as
-:func:`PYBIND11_MAKE_OPAQUE` and :func:`PYBIND11_DECLARE_HOLDER_TYPE`, and
-``PYBIND11_OVERLOAD_*``. Since these are "just" macros that are evaluated
-in the preprocessor (which has no concept of types), they *will* get confused
-by commas in a template argument such as ``PYBIND11_OVERLOAD(MyReturnValue<T1,
-T2>, myFunc)``. In this case, the preprocessor assumes that the comma indicates
-the beginning of the next parameter. Use a ``typedef`` to bind the template to
-another name and use it in the macro to avoid this problem.
+:func:`PYBIND11_DECLARE_HOLDER_TYPE` and ``PYBIND11_OVERLOAD_*``. Since these
+are "just" macros that are evaluated in the preprocessor (which has no concept
+of types), they *will* get confused by commas in a template argument; for
+example, consider:
+
+.. code-block:: cpp
+
+    PYBIND11_OVERLOAD(MyReturnType<T1, T2>, Class<T3, T4>, func)
+
+The limitation of the C preprocessor interprets this as five arguments (with new
+arguments beginning after each comma) rather than three.  To get around this,
+there are two alternatives: you can use a type alias, or you can wrap the type
+using the ``PYBIND11_TYPE`` macro:
+
+.. code-block:: cpp
+
+    // Version 1: using a type alias
+    using ReturnType = MyReturnType<T1, T2>;
+    using ClassType = Class<T3, T4>;
+    PYBIND11_OVERLOAD(ReturnType, ClassType, func);
+
+    // Version 2: using the PYBIND11_TYPE macro:
+    PYBIND11_OVERLOAD(PYBIND11_TYPE(MyReturnType<T1, T2>),
+                      PYBIND11_TYPE(Class<T3, T4>), func)
+
+The ``PYBIND11_MAKE_OPAQUE`` macro does *not* require the above workarounds.
 
 .. _gil:
 
@@ -135,22 +154,16 @@ has been executed:
 
 Naturally, both methods will fail when there are cyclic dependencies.
 
-Note that compiling code which has its default symbol visibility set to
-*hidden* (e.g. via the command line flag ``-fvisibility=hidden`` on GCC/Clang) can interfere with the
-ability to access types defined in another extension module. Workarounds
-include changing the global symbol visibility (not recommended, because it will
-lead unnecessarily large binaries) or manually exporting types that are
-accessed by multiple extension modules:
+Note that pybind11 code compiled with hidden-by-default symbol visibility (e.g.
+via the command line flag ``-fvisibility=hidden`` on GCC/Clang), which is
+required for proper pybind11 functionality, can interfere with the ability to
+access types defined in another extension module.  Working around this requires
+manually exporting types that are accessed by multiple extension modules;
+pybind11 provides a macro to do just this:
 
 .. code-block:: cpp
 
-    #ifdef _WIN32
-    #  define EXPORT_TYPE __declspec(dllexport)
-    #else
-    #  define EXPORT_TYPE __attribute__ ((visibility("default")))
-    #endif
-
-    class EXPORT_TYPE Dog : public Animal {
+    class PYBIND11_EXPORT Dog : public Animal {
         ...
     };
 
@@ -179,7 +192,8 @@ Module Destructors
 
 pybind11 does not provide an explicit mechanism to invoke cleanup code at
 module destruction time. In rare cases where such functionality is required, it
-is possible to emulate it using Python capsules with a destruction callback.
+is possible to emulate it using Python capsules or weak references with a
+destruction callback.
 
 .. code-block:: cpp
 
@@ -189,6 +203,54 @@ is possible to emulate it using Python capsules with a destruction callback.
 
     m.add_object("_cleanup", py::capsule(cleanup_callback));
 
+This approach has the potential downside that instances of classes exposed
+within the module may still be alive when the cleanup callback is invoked
+(whether this is acceptable will generally depend on the application).
+
+Alternatively, the capsule may also be stashed within a type object, which
+ensures that it not called before all instances of that type have been
+collected:
+
+.. code-block:: cpp
+
+    auto cleanup_callback = []() { /* ... */ };
+    m.attr("BaseClass").attr("_cleanup") = py::capsule(cleanup_callback);
+
+Both approaches also expose a potentially dangerous ``_cleanup`` attribute in
+Python, which may be undesirable from an API standpoint (a premature explicit
+call from Python might lead to undefined behavior). Yet another approach that 
+avoids this issue involves weak reference with a cleanup callback:
+
+.. code-block:: cpp
+
+    // Register a callback function that is invoked when the BaseClass object is colelcted
+    py::cpp_function cleanup_callback(
+        [](py::handle weakref) {
+            // perform cleanup here -- this function is called with the GIL held
+
+            weakref.dec_ref(); // release weak reference
+        }
+    );
+
+    // Create a weak reference with a cleanup callback and initially leak it
+    (void) py::weakref(m.attr("BaseClass"), cleanup_callback).release();
+
+.. note::
+
+    PyPy (at least version 5.9) does not garbage collect objects when the
+    interpreter exits. An alternative approach (which also works on CPython) is to use
+    the :py:mod:`atexit` module [#f7]_, for example:
+
+    .. code-block:: cpp
+
+        auto atexit = py::module::import("atexit");
+        atexit.attr("register")(py::cpp_function([]() {
+            // perform cleanup here -- this function is called with the GIL held
+        }));
+
+    .. [#f7] https://docs.python.org/3/library/atexit.html
+
+
 Generating documentation using Sphinx
 =====================================
 
diff --git a/src/pybind11/docs/advanced/pycpp/numpy.rst b/src/pybind11/docs/advanced/pycpp/numpy.rst
index 98b0c25..458f99e 100644
--- a/src/pybind11/docs/advanced/pycpp/numpy.rst
+++ b/src/pybind11/docs/advanced/pycpp/numpy.rst
@@ -41,7 +41,7 @@ completely avoid copy operations with Python expressions like
                 py::format_descriptor<float>::format(), /* Python struct-style format descriptor */
                 2,                                      /* Number of dimensions */
                 { m.rows(), m.cols() },                 /* Buffer dimensions */
-                { sizeof(float) * m.rows(),             /* Strides (in bytes) for each index */
+                { sizeof(float) * m.cols(),             /* Strides (in bytes) for each index */
                   sizeof(float) }
             );
         });
@@ -261,7 +261,7 @@ simply using ``vectorize``).
     namespace py = pybind11;
 
     py::array_t<double> add_arrays(py::array_t<double> input1, py::array_t<double> input2) {
-        auto buf1 = input1.request(), buf2 = input2.request();
+        py::buffer_info buf1 = input1.request(), buf2 = input2.request();
 
         if (buf1.ndim != 1 || buf2.ndim != 1)
             throw std::runtime_error("Number of dimensions must be one");
@@ -272,7 +272,7 @@ simply using ``vectorize``).
         /* No pointer is passed, so NumPy will allocate the buffer */
         auto result = py::array_t<double>(buf1.size);
 
-        auto buf3 = result.request();
+        py::buffer_info buf3 = result.request();
 
         double *ptr1 = (double *) buf1.ptr,
                *ptr2 = (double *) buf2.ptr,
@@ -364,3 +364,23 @@ uses of ``py::array``:
 
     The file :file:`tests/test_numpy_array.cpp` contains additional examples
     demonstrating the use of this feature.
+
+Ellipsis
+========
+
+Python 3 provides a convenient ``...`` ellipsis notation that is often used to
+slice multidimensional arrays. For instance, the following snippet extracts the
+middle dimensions of a tensor with the first and last index set to zero.
+
+.. code-block:: python
+
+   a = # a NumPy array
+   b = a[0, ..., 0]
+
+The function ``py::ellipsis()`` function can be used to perform the same
+operation on the C++ side:
+
+.. code-block:: cpp
+
+   py::array a = /* A NumPy array */;
+   py::array b = a[py::make_tuple(0, py::ellipsis(), 0)];
diff --git a/src/pybind11/docs/advanced/pycpp/object.rst b/src/pybind11/docs/advanced/pycpp/object.rst
index c9728e9..117131e 100644
--- a/src/pybind11/docs/advanced/pycpp/object.rst
+++ b/src/pybind11/docs/advanced/pycpp/object.rst
@@ -33,12 +33,50 @@ The reverse direction uses the following syntax:
 
 When conversion fails, both directions throw the exception :class:`cast_error`.
 
+.. _python_libs:
+
+Accessing Python libraries from C++
+===================================
+
+It is also possible to import objects defined in the Python standard
+library or available in the current Python environment (``sys.path``) and work
+with these in C++.
+
+This example obtains a reference to the Python ``Decimal`` class.
+
+.. code-block:: cpp
+
+    // Equivalent to "from decimal import Decimal"
+    py::object Decimal = py::module::import("decimal").attr("Decimal");
+
+.. code-block:: cpp
+
+    // Try to import scipy
+    py::object scipy = py::module::import("scipy");
+    return scipy.attr("__version__");
+
 .. _calling_python_functions:
 
 Calling Python functions
 ========================
 
-It is also possible to call python functions via ``operator()``.
+It is also possible to call Python classes, functions and methods 
+via ``operator()``.
+
+.. code-block:: cpp
+
+    // Construct a Python object of class Decimal
+    py::object pi = Decimal("3.14159");
+
+.. code-block:: cpp
+
+    // Use Python to make our directories
+    py::object os = py::module::import("os");
+    py::object makedirs = os.attr("makedirs");
+    makedirs("/tmp/path/to/somewhere");
+
+One can convert the result obtained from Python to a pure C++ version 
+if a ``py::class_`` or type conversion is defined.
 
 .. code-block:: cpp
 
@@ -46,6 +84,37 @@ It is also possible to call python functions via ``operator()``.
     py::object result_py = f(1234, "hello", some_instance);
     MyClass &result = result_py.cast<MyClass>();
 
+.. _calling_python_methods:
+
+Calling Python methods
+========================
+
+To call an object's method, one can again use ``.attr`` to obtain access to the
+Python method.
+
+.. code-block:: cpp
+
+    // Calculate e^π in decimal
+    py::object exp_pi = pi.attr("exp")();
+    py::print(py::str(exp_pi));
+
+In the example above ``pi.attr("exp")`` is a *bound method*: it will always call
+the method for that same instance of the class. Alternately one can create an 
+*unbound method* via the Python class (instead of instance) and pass the ``self`` 
+object explicitly, followed by other arguments.
+
+.. code-block:: cpp
+
+    py::object decimal_exp = Decimal.attr("exp");
+
+    // Compute the e^n for n=0..4
+    for (int n = 0; n < 5; n++) {
+        py::print(decimal_exp(Decimal(n));
+    }
+
+Keyword arguments
+=================
+
 Keyword arguments are also supported. In Python, there is the usual call syntax:
 
 .. code-block:: python
@@ -62,6 +131,9 @@ In C++, the same call can be made using:
     using namespace pybind11::literals; // to bring in the `_a` literal
     f(1234, "say"_a="hello", "to"_a=some_instance); // keyword call in C++
 
+Unpacking arguments
+===================
+
 Unpacking of ``*args`` and ``**kwargs`` is also possible and can be mixed with
 other arguments:
 
diff --git a/src/pybind11/docs/advanced/pycpp/utilities.rst b/src/pybind11/docs/advanced/pycpp/utilities.rst
index 171a885..369e7c9 100644
--- a/src/pybind11/docs/advanced/pycpp/utilities.rst
+++ b/src/pybind11/docs/advanced/pycpp/utilities.rst
@@ -21,6 +21,72 @@ expected in Python:
     auto args = py::make_tuple("unpacked", true);
     py::print("->", *args, "end"_a="<-"); // -> unpacked True <-
 
+.. _ostream_redirect:
+
+Capturing standard output from ostream
+======================================
+
+Often, a library will use the streams ``std::cout`` and ``std::cerr`` to print,
+but this does not play well with Python's standard ``sys.stdout`` and ``sys.stderr``
+redirection. Replacing a library's printing with `py::print <print>` may not
+be feasible. This can be fixed using a guard around the library function that
+redirects output to the corresponding Python streams:
+
+.. code-block:: cpp
+
+    #include <pybind11/iostream.h>
+
+    ...
+
+    // Add a scoped redirect for your noisy code
+    m.def("noisy_func", []() {
+        py::scoped_ostream_redirect stream(
+            std::cout,                               // std::ostream&
+            py::module::import("sys").attr("stdout") // Python output
+        );
+        call_noisy_func();
+    });
+
+This method respects flushes on the output streams and will flush if needed
+when the scoped guard is destroyed. This allows the output to be redirected in
+real time, such as to a Jupyter notebook. The two arguments, the C++ stream and
+the Python output, are optional, and default to standard output if not given. An
+extra type, `py::scoped_estream_redirect <scoped_estream_redirect>`, is identical
+except for defaulting to ``std::cerr`` and ``sys.stderr``; this can be useful with
+`py::call_guard`, which allows multiple items, but uses the default constructor:
+
+.. code-block:: py
+
+    // Alternative: Call single function using call guard
+    m.def("noisy_func", &call_noisy_function,
+          py::call_guard<py::scoped_ostream_redirect,
+                         py::scoped_estream_redirect>());
+
+The redirection can also be done in Python with the addition of a context
+manager, using the `py::add_ostream_redirect() <add_ostream_redirect>` function:
+
+.. code-block:: cpp
+
+    py::add_ostream_redirect(m, "ostream_redirect");
+
+The name in Python defaults to ``ostream_redirect`` if no name is passed.  This
+creates the following context manager in Python:
+
+.. code-block:: python
+
+    with ostream_redirect(stdout=True, stderr=True):
+        noisy_function()
+
+It defaults to redirecting both streams, though you can use the keyword
+arguments to disable one of the streams if needed.
+
+.. note::
+
+    The above methods will not redirect C-level output to file descriptors, such
+    as ``fprintf``. For those cases, you'll need to redirect the file
+    descriptors either directly in C or with Python's ``os.dup2`` function
+    in an operating-system dependent way.
+
 .. _eval:
 
 Evaluating Python expressions from strings and files
diff --git a/src/pybind11/docs/basics.rst b/src/pybind11/docs/basics.rst
index 2ae8c0c..7bf4d42 100644
--- a/src/pybind11/docs/basics.rst
+++ b/src/pybind11/docs/basics.rst
@@ -73,6 +73,8 @@ For brevity, all code examples assume that the following two lines are present:
 
 Some features may require additional headers, but those will be specified as needed.
 
+.. _simple_example:
+
 Creating bindings for a simple function
 =======================================
 
@@ -120,23 +122,31 @@ generates binding code that exposes the ``add()`` function to Python.
     approach and the used syntax are borrowed from Boost.Python, though the
     underlying implementation is very different.
 
-pybind11 is a header-only-library, hence it is not necessary to link against
-any special libraries (other than Python itself). On Windows, use the CMake
-build file discussed in section :ref:`cmake`. On Linux and Mac OS, the above
-example can be compiled using the following command
+pybind11 is a header-only library, hence it is not necessary to link against
+any special libraries and there are no intermediate (magic) translation steps.
+On Linux, the above example can be compiled using the following command:
 
 .. code-block:: bash
 
-    $ c++ -O3 -shared -std=c++11 -I <path-to-pybind11>/include `python-config --cflags --ldflags` example.cpp -o example.so
+    $ c++ -O3 -Wall -shared -std=c++11 -fPIC `python3 -m pybind11 --includes` example.cpp -o example`python3-config --extension-suffix`
+
+For more details on the required compiler flags on Linux and MacOS, see
+:ref:`building_manually`. For complete cross-platform compilation instructions,
+refer to the :ref:`compiling` page.
+
+The `python_example`_ and `cmake_example`_ repositories are also a good place
+to start. They are both complete project examples with cross-platform build
+systems. The only difference between the two is that `python_example`_ uses
+Python's ``setuptools`` to build the module, while `cmake_example`_ uses CMake
+(which may be preferable for existing C++ projects).
 
-In general, it is advisable to include several additional build parameters
-that can considerably reduce the size of the created binary. Refer to section
-:ref:`cmake` for a detailed example of a suitable cross-platform CMake-based
-build system.
+.. _python_example: https://github.com/pybind/python_example
+.. _cmake_example: https://github.com/pybind/cmake_example
 
-Assuming that the created file :file:`example.so` (:file:`example.pyd` on Windows)
-is located in the current directory, the following interactive Python session
-shows how to load and execute the example.
+Building the above C++ code will produce a binary module file that can be
+imported to Python. Assuming that the compiled module is located in the
+current directory, the following interactive Python session shows how to
+load and execute the example:
 
 .. code-block:: pycon
 
@@ -154,7 +164,7 @@ shows how to load and execute the example.
 Keyword arguments
 =================
 
-With a simple modification code, it is possible to inform Python about the
+With a simple code modification, it is possible to inform Python about the
 names of the arguments ("i" and "j" in this case).
 
 .. code-block:: cpp
diff --git a/src/pybind11/docs/changelog.rst b/src/pybind11/docs/changelog.rst
index b616a6e..2def2b0 100644
--- a/src/pybind11/docs/changelog.rst
+++ b/src/pybind11/docs/changelog.rst
@@ -6,10 +6,715 @@ Changelog
 Starting with version 1.8.0, pybind11 releases use a `semantic versioning
 <http://semver.org>`_ policy.
 
-v2.2.0 (Not yet released)
+v2.5.0 (Mar 31, 2020)
 -----------------------------------------------------
 
-* TBD
+* Use C++17 fold expressions in type casters, if available. This can
+  improve performance during overload resolution when functions have
+  multiple arguments.
+  `#2043 <https://github.com/pybind/pybind11/pull/2043>`_.
+
+* Changed include directory resolution in ``pybind11/__init__.py``
+  and installation in ``setup.py``. This fixes a number of open issues
+  where pybind11 headers could not be found in certain environments.
+  `#1995 <https://github.com/pybind/pybind11/pull/1995>`_.
+
+* C++20 ``char8_t`` and ``u8string`` support. `#2026
+  <https://github.com/pybind/pybind11/pull/2026>`_.
+
+* CMake: search for Python 3.9. `bb9c91
+  <https://github.com/pybind/pybind11/commit/bb9c91>`_.
+
+* Fixes for MSYS-based build environments.
+  `#2087 <https://github.com/pybind/pybind11/pull/2087>`_,
+  `#2053 <https://github.com/pybind/pybind11/pull/2053>`_.
+
+* STL bindings for ``std::vector<...>::clear``. `#2074
+  <https://github.com/pybind/pybind11/pull/2074>`_.
+
+* Read-only flag for ``py::buffer``. `#1466
+  <https://github.com/pybind/pybind11/pull/1466>`_.
+
+* Exception handling during module initialization.
+  `bf2b031 <https://github.com/pybind/pybind11/commit/bf2b031>`_.
+
+* Support linking against a CPython debug build.
+  `#2025 <https://github.com/pybind/pybind11/pull/2025>`_.
+
+* Fixed issues involving the availability and use of aligned ``new`` and
+  ``delete``. `#1988 <https://github.com/pybind/pybind11/pull/1988>`_,
+  `759221 <https://github.com/pybind/pybind11/commit/759221>`_.
+
+* Fixed a resource leak upon interpreter shutdown.
+  `#2020 <https://github.com/pybind/pybind11/pull/2020>`_.
+
+* Fixed error handling in the boolean caster.
+  `#1976 <https://github.com/pybind/pybind11/pull/1976>`_.
+
+v2.4.3 (Oct 15, 2019)
+-----------------------------------------------------
+
+* Adapt pybind11 to a C API convention change in Python 3.8. `#1950
+  <https://github.com/pybind/pybind11/pull/1950>`_.
+
+v2.4.2 (Sep 21, 2019)
+-----------------------------------------------------
+
+* Replaced usage of a C++14 only construct. `#1929
+  <https://github.com/pybind/pybind11/pull/1929>`_.
+
+* Made an ifdef future-proof for Python >= 4. `f3109d
+  <https://github.com/pybind/pybind11/commit/f3109d>`_.
+
+v2.4.1 (Sep 20, 2019)
+-----------------------------------------------------
+
+* Fixed a problem involving implicit conversion from enumerations to integers
+  on Python 3.8. `#1780 <https://github.com/pybind/pybind11/pull/1780>`_.
+
+v2.4.0 (Sep 19, 2019)
+-----------------------------------------------------
+
+* Try harder to keep pybind11-internal data structures separate when there
+  are potential ABI incompatibilities. Fixes crashes that occurred when loading
+  multiple pybind11 extensions that were e.g. compiled by GCC (libstdc++)
+  and Clang (libc++).
+  `#1588 <https://github.com/pybind/pybind11/pull/1588>`_ and
+  `c9f5a <https://github.com/pybind/pybind11/commit/c9f5a>`_.
+
+* Added support for ``__await__``, ``__aiter__``, and ``__anext__`` protocols.
+  `#1842 <https://github.com/pybind/pybind11/pull/1842>`_.
+
+* ``pybind11_add_module()``: don't strip symbols when compiling in
+  ``RelWithDebInfo`` mode. `#1980
+  <https://github.com/pybind/pybind11/pull/1980>`_.
+
+* ``enum_``: Reproduce Python behavior when comparing against invalid values
+  (e.g. ``None``, strings, etc.). Add back support for ``__invert__()``.
+  `#1912 <https://github.com/pybind/pybind11/pull/1912>`_,
+  `#1907 <https://github.com/pybind/pybind11/pull/1907>`_.
+
+* List insertion operation for ``py::list``.
+  Added ``.empty()`` to all collection types.
+  Added ``py::set::contains()`` and ``py::dict::contains()``.
+  `#1887 <https://github.com/pybind/pybind11/pull/1887>`_,
+  `#1884 <https://github.com/pybind/pybind11/pull/1884>`_,
+  `#1888 <https://github.com/pybind/pybind11/pull/1888>`_.
+
+* ``py::details::overload_cast_impl`` is available in C++11 mode, can be used
+  like ``overload_cast`` with an additional set of parantheses.
+  `#1581 <https://github.com/pybind/pybind11/pull/1581>`_.
+
+* Fixed ``get_include()`` on Conda.
+  `#1877 <https://github.com/pybind/pybind11/pull/1877>`_.
+
+* ``stl_bind.h``: negative indexing support.
+  `#1882 <https://github.com/pybind/pybind11/pull/1882>`_.
+
+* Minor CMake fix to add MinGW compatibility.
+  `#1851 <https://github.com/pybind/pybind11/pull/1851>`_.
+
+* GIL-related fixes.
+  `#1836 <https://github.com/pybind/pybind11/pull/1836>`_,
+  `8b90b <https://github.com/pybind/pybind11/commit/8b90b>`_.
+
+* Other very minor/subtle fixes and improvements.
+  `#1329 <https://github.com/pybind/pybind11/pull/1329>`_,
+  `#1910 <https://github.com/pybind/pybind11/pull/1910>`_,
+  `#1863 <https://github.com/pybind/pybind11/pull/1863>`_,
+  `#1847 <https://github.com/pybind/pybind11/pull/1847>`_,
+  `#1890 <https://github.com/pybind/pybind11/pull/1890>`_,
+  `#1860 <https://github.com/pybind/pybind11/pull/1860>`_,
+  `#1848 <https://github.com/pybind/pybind11/pull/1848>`_,
+  `#1821 <https://github.com/pybind/pybind11/pull/1821>`_,
+  `#1837 <https://github.com/pybind/pybind11/pull/1837>`_,
+  `#1833 <https://github.com/pybind/pybind11/pull/1833>`_,
+  `#1748 <https://github.com/pybind/pybind11/pull/1748>`_,
+  `#1852 <https://github.com/pybind/pybind11/pull/1852>`_.
+
+v2.3.0 (June 11, 2019)
+-----------------------------------------------------
+
+* Significantly reduced module binary size (10-20%) when compiled in C++11 mode
+  with GCC/Clang, or in any mode with MSVC. Function signatures are now always
+  precomputed at compile time (this was previously only available in C++14 mode
+  for non-MSVC compilers).
+  `#934 <https://github.com/pybind/pybind11/pull/934>`_.
+
+* Add basic support for tag-based static polymorphism, where classes
+  provide a method to returns the desired type of an instance.
+  `#1326 <https://github.com/pybind/pybind11/pull/1326>`_.
+
+* Python type wrappers (``py::handle``, ``py::object``, etc.)
+  now support map Python's number protocol onto C++ arithmetic
+  operators such as ``operator+``, ``operator/=``, etc.
+  `#1511 <https://github.com/pybind/pybind11/pull/1511>`_.
+
+* A number of improvements related to enumerations:
+
+   1. The ``enum_`` implementation was rewritten from scratch to reduce
+      code bloat. Rather than instantiating a full implementation for each
+      enumeration, most code is now contained in a generic base class.
+      `#1511 <https://github.com/pybind/pybind11/pull/1511>`_.
+
+   2. The ``value()``  method of ``py::enum_`` now accepts an optional
+      docstring that will be shown in the documentation of the associated
+      enumeration. `#1160 <https://github.com/pybind/pybind11/pull/1160>`_.
+
+   3. check for already existing enum value and throw an error if present.
+      `#1453 <https://github.com/pybind/pybind11/pull/1453>`_.
+
+* Support for over-aligned type allocation via C++17's aligned ``new``
+  statement. `#1582 <https://github.com/pybind/pybind11/pull/1582>`_.
+
+* Added ``py::ellipsis()`` method for slicing of multidimensional NumPy arrays
+  `#1502 <https://github.com/pybind/pybind11/pull/1502>`_.
+
+* Numerous Improvements to the ``mkdoc.py`` script for extracting documentation
+  from C++ header files.
+  `#1788 <https://github.com/pybind/pybind11/pull/1788>`_.
+
+* ``pybind11_add_module()``: allow including Python as a ``SYSTEM`` include path.
+  `#1416 <https://github.com/pybind/pybind11/pull/1416>`_.
+
+* ``pybind11/stl.h`` does not convert strings to ``vector<string>`` anymore.
+  `#1258 <https://github.com/pybind/pybind11/issues/1258>`_.
+
+* Mark static methods as such to fix auto-generated Sphinx documentation.
+  `#1732 <https://github.com/pybind/pybind11/pull/1732>`_.
+
+* Re-throw forced unwind exceptions (e.g. during pthread termination).
+  `#1208 <https://github.com/pybind/pybind11/pull/1208>`_.
+
+* Added ``__contains__`` method to the bindings of maps (``std::map``,
+  ``std::unordered_map``).
+  `#1767 <https://github.com/pybind/pybind11/pull/1767>`_.
+
+* Improvements to ``gil_scoped_acquire``.
+  `#1211 <https://github.com/pybind/pybind11/pull/1211>`_.
+
+* Type caster support for ``std::deque<T>``.
+  `#1609 <https://github.com/pybind/pybind11/pull/1609>`_.
+
+* Support for ``std::unique_ptr`` holders, whose deleters differ between a base and derived
+  class. `#1353 <https://github.com/pybind/pybind11/pull/1353>`_.
+
+* Construction of STL array/vector-like data structures from
+  iterators. Added an ``extend()`` operation.
+  `#1709 <https://github.com/pybind/pybind11/pull/1709>`_,
+
+* CMake build system improvements for projects that include non-C++
+  files (e.g. plain C, CUDA) in ``pybind11_add_module`` et al.
+  `#1678 <https://github.com/pybind/pybind11/pull/1678>`_.
+
+* Fixed asynchronous invocation and deallocation of Python functions
+  wrapped in ``std::function``.
+  `#1595 <https://github.com/pybind/pybind11/pull/1595>`_.
+
+* Fixes regarding return value policy propagation in STL type casters.
+  `#1603 <https://github.com/pybind/pybind11/pull/1603>`_.
+
+* Fixed scoped enum comparisons.
+  `#1571 <https://github.com/pybind/pybind11/pull/1571>`_.
+
+* Fixed iostream redirection for code that releases the GIL.
+  `#1368 <https://github.com/pybind/pybind11/pull/1368>`_,
+
+* A number of CI-related fixes.
+  `#1757 <https://github.com/pybind/pybind11/pull/1757>`_,
+  `#1744 <https://github.com/pybind/pybind11/pull/1744>`_,
+  `#1670 <https://github.com/pybind/pybind11/pull/1670>`_.
+
+v2.2.4 (September 11, 2018)
+-----------------------------------------------------
+
+* Use new Python 3.7 Thread Specific Storage (TSS) implementation if available.
+  `#1454 <https://github.com/pybind/pybind11/pull/1454>`_,
+  `#1517 <https://github.com/pybind/pybind11/pull/1517>`_.
+
+* Fixes for newer MSVC versions and C++17 mode.
+  `#1347 <https://github.com/pybind/pybind11/pull/1347>`_,
+  `#1462 <https://github.com/pybind/pybind11/pull/1462>`_.
+
+* Propagate return value policies to type-specific casters
+  when casting STL containers.
+  `#1455 <https://github.com/pybind/pybind11/pull/1455>`_.
+
+* Allow ostream-redirection of more than 1024 characters.
+  `#1479 <https://github.com/pybind/pybind11/pull/1479>`_.
+
+* Set ``Py_DEBUG`` define when compiling against a debug Python build.
+  `#1438 <https://github.com/pybind/pybind11/pull/1438>`_.
+
+* Untangle integer logic in number type caster to work for custom
+  types that may only be castable to a restricted set of builtin types.
+  `#1442 <https://github.com/pybind/pybind11/pull/1442>`_.
+
+* CMake build system: Remember Python version in cache file.
+  `#1434 <https://github.com/pybind/pybind11/pull/1434>`_.
+
+* Fix for custom smart pointers: use ``std::addressof`` to obtain holder
+  address instead of ``operator&``.
+  `#1435 <https://github.com/pybind/pybind11/pull/1435>`_.
+
+* Properly report exceptions thrown during module initialization.
+  `#1362 <https://github.com/pybind/pybind11/pull/1362>`_.
+
+* Fixed a segmentation fault when creating empty-shaped NumPy array.
+  `#1371 <https://github.com/pybind/pybind11/pull/1371>`_.
+
+* The version of Intel C++ compiler must be >= 2017, and this is now checked by
+  the header files. `#1363 <https://github.com/pybind/pybind11/pull/1363>`_.
+
+* A few minor typo fixes and improvements to the test suite, and
+  patches that silence compiler warnings.
+
+* Vectors now support construction from generators, as well as ``extend()`` from a
+  list or generator.
+  `#1496 <https://github.com/pybind/pybind11/pull/1496>`_.
+
+
+v2.2.3 (April 29, 2018)
+-----------------------------------------------------
+
+* The pybind11 header location detection was replaced by a new implementation
+  that no longer depends on ``pip`` internals (the recently released ``pip``
+  10 has restricted access to this API).
+  `#1190 <https://github.com/pybind/pybind11/pull/1190>`_.
+
+* Small adjustment to an implementation detail to work around a compiler segmentation fault in Clang 3.3/3.4.
+  `#1350 <https://github.com/pybind/pybind11/pull/1350>`_.
+
+* The minimal supported version of the Intel compiler was >= 17.0 since
+  pybind11 v2.1. This check is now explicit, and a compile-time error is raised
+  if the compiler meet the requirement.
+  `#1363 <https://github.com/pybind/pybind11/pull/1363>`_.
+
+* Fixed an endianness-related fault in the test suite.
+  `#1287 <https://github.com/pybind/pybind11/pull/1287>`_.
+
+v2.2.2 (February 7, 2018)
+-----------------------------------------------------
+
+* Fixed a segfault when combining embedded interpreter
+  shutdown/reinitialization with external loaded pybind11 modules.
+  `#1092 <https://github.com/pybind/pybind11/pull/1092>`_.
+
+* Eigen support: fixed a bug where Nx1/1xN numpy inputs couldn't be passed as
+  arguments to Eigen vectors (which for Eigen are simply compile-time fixed
+  Nx1/1xN matrices).
+  `#1106 <https://github.com/pybind/pybind11/pull/1106>`_.
+
+* Clarified to license by moving the licensing of contributions from
+  ``LICENSE`` into ``CONTRIBUTING.md``: the licensing of contributions is not
+  actually part of the software license as distributed.  This isn't meant to be
+  a substantial change in the licensing of the project, but addresses concerns
+  that the clause made the license non-standard.
+  `#1109 <https://github.com/pybind/pybind11/issues/1109>`_.
+
+* Fixed a regression introduced in 2.1 that broke binding functions with lvalue
+  character literal arguments.
+  `#1128 <https://github.com/pybind/pybind11/pull/1128>`_.
+
+* MSVC: fix for compilation failures under /permissive-, and added the flag to
+  the appveyor test suite.
+  `#1155 <https://github.com/pybind/pybind11/pull/1155>`_.
+
+* Fixed ``__qualname__`` generation, and in turn, fixes how class names
+  (especially nested class names) are shown in generated docstrings.
+  `#1171 <https://github.com/pybind/pybind11/pull/1171>`_.
+
+* Updated the FAQ with a suggested project citation reference.
+  `#1189 <https://github.com/pybind/pybind11/pull/1189>`_.
+
+* Added fixes for deprecation warnings when compiled under C++17 with
+  ``-Wdeprecated`` turned on, and add ``-Wdeprecated`` to the test suite
+  compilation flags.
+  `#1191 <https://github.com/pybind/pybind11/pull/1191>`_.
+
+* Fixed outdated PyPI URLs in ``setup.py``.
+  `#1213 <https://github.com/pybind/pybind11/pull/1213>`_.
+
+* Fixed a refcount leak for arguments that end up in a ``py::args`` argument
+  for functions with both fixed positional and ``py::args`` arguments.
+  `#1216 <https://github.com/pybind/pybind11/pull/1216>`_.
+
+* Fixed a potential segfault resulting from possible premature destruction of
+  ``py::args``/``py::kwargs`` arguments with overloaded functions.
+  `#1223 <https://github.com/pybind/pybind11/pull/1223>`_.
+
+* Fixed ``del map[item]`` for a ``stl_bind.h`` bound stl map.
+  `#1229 <https://github.com/pybind/pybind11/pull/1229>`_.
+
+* Fixed a regression from v2.1.x where the aggregate initialization could
+  unintentionally end up at a constructor taking a templated
+  ``std::initializer_list<T>`` argument.
+  `#1249 <https://github.com/pybind/pybind11/pull/1249>`_.
+
+* Fixed an issue where calling a function with a keep_alive policy on the same
+  nurse/patient pair would cause the internal patient storage to needlessly
+  grow (unboundedly, if the nurse is long-lived).
+  `#1251 <https://github.com/pybind/pybind11/issues/1251>`_.
+
+* Various other minor fixes.
+
+v2.2.1 (September 14, 2017)
+-----------------------------------------------------
+
+* Added ``py::module::reload()`` member function for reloading a module.
+  `#1040 <https://github.com/pybind/pybind11/pull/1040>`_.
+
+* Fixed a reference leak in the number converter.
+  `#1078 <https://github.com/pybind/pybind11/pull/1078>`_.
+
+* Fixed compilation with Clang on host GCC < 5 (old libstdc++ which isn't fully
+  C++11 compliant). `#1062 <https://github.com/pybind/pybind11/pull/1062>`_.
+
+* Fixed a regression where the automatic ``std::vector<bool>`` caster would
+  fail to compile. The same fix also applies to any container which returns
+  element proxies instead of references.
+  `#1053 <https://github.com/pybind/pybind11/pull/1053>`_.
+
+* Fixed a regression where the ``py::keep_alive`` policy could not be applied
+  to constructors. `#1065 <https://github.com/pybind/pybind11/pull/1065>`_.
+
+* Fixed a nullptr dereference when loading a ``py::module_local`` type
+  that's only registered in an external module.
+  `#1058 <https://github.com/pybind/pybind11/pull/1058>`_.
+
+* Fixed implicit conversion of accessors to types derived from ``py::object``.
+  `#1076 <https://github.com/pybind/pybind11/pull/1076>`_.
+
+* The ``name`` in ``PYBIND11_MODULE(name, variable)`` can now be a macro.
+  `#1082 <https://github.com/pybind/pybind11/pull/1082>`_.
+
+* Relaxed overly strict ``py::pickle()`` check for matching get and set types.
+  `#1064 <https://github.com/pybind/pybind11/pull/1064>`_.
+
+* Conversion errors now try to be more informative when it's likely that
+  a missing header is the cause (e.g. forgetting ``<pybind11/stl.h>``).
+  `#1077 <https://github.com/pybind/pybind11/pull/1077>`_.
+
+v2.2.0 (August 31, 2017)
+-----------------------------------------------------
+
+* Support for embedding the Python interpreter. See the
+  :doc:`documentation page </advanced/embedding>` for a
+  full overview of the new features.
+  `#774 <https://github.com/pybind/pybind11/pull/774>`_,
+  `#889 <https://github.com/pybind/pybind11/pull/889>`_,
+  `#892 <https://github.com/pybind/pybind11/pull/892>`_,
+  `#920 <https://github.com/pybind/pybind11/pull/920>`_.
+
+  .. code-block:: cpp
+
+      #include <pybind11/embed.h>
+      namespace py = pybind11;
+
+      int main() {
+          py::scoped_interpreter guard{}; // start the interpreter and keep it alive
+
+          py::print("Hello, World!"); // use the Python API
+      }
+
+* Support for inheriting from multiple C++ bases in Python.
+  `#693 <https://github.com/pybind/pybind11/pull/693>`_.
+
+  .. code-block:: python
+
+      from cpp_module import CppBase1, CppBase2
+
+      class PyDerived(CppBase1, CppBase2):
+          def __init__(self):
+              CppBase1.__init__(self)  # C++ bases must be initialized explicitly
+              CppBase2.__init__(self)
+
+* ``PYBIND11_MODULE`` is now the preferred way to create module entry points.
+  ``PYBIND11_PLUGIN`` is deprecated. See :ref:`macros` for details.
+  `#879 <https://github.com/pybind/pybind11/pull/879>`_.
+
+  .. code-block:: cpp
+
+      // new
+      PYBIND11_MODULE(example, m) {
+          m.def("add", [](int a, int b) { return a + b; });
+      }
+
+      // old
+      PYBIND11_PLUGIN(example) {
+          py::module m("example");
+          m.def("add", [](int a, int b) { return a + b; });
+          return m.ptr();
+      }
+
+* pybind11's headers and build system now more strictly enforce hidden symbol
+  visibility for extension modules. This should be seamless for most users,
+  but see the :doc:`upgrade` if you use a custom build system.
+  `#995 <https://github.com/pybind/pybind11/pull/995>`_.
+
+* Support for ``py::module_local`` types which allow multiple modules to
+  export the same C++ types without conflicts. This is useful for opaque
+  types like ``std::vector<int>``. ``py::bind_vector`` and ``py::bind_map``
+  now default to ``py::module_local`` if their elements are builtins or
+  local types. See :ref:`module_local` for details.
+  `#949 <https://github.com/pybind/pybind11/pull/949>`_,
+  `#981 <https://github.com/pybind/pybind11/pull/981>`_,
+  `#995 <https://github.com/pybind/pybind11/pull/995>`_,
+  `#997 <https://github.com/pybind/pybind11/pull/997>`_.
+
+* Custom constructors can now be added very easily using lambdas or factory
+  functions which return a class instance by value, pointer or holder. This
+  supersedes the old placement-new ``__init__`` technique.
+  See :ref:`custom_constructors` for details.
+  `#805 <https://github.com/pybind/pybind11/pull/805>`_,
+  `#1014 <https://github.com/pybind/pybind11/pull/1014>`_.
+
+  .. code-block:: cpp
+
+      struct Example {
+          Example(std::string);
+      };
+
+      py::class_<Example>(m, "Example")
+          .def(py::init<std::string>()) // existing constructor
+          .def(py::init([](int n) { // custom constructor
+              return std::make_unique<Example>(std::to_string(n));
+          }));
+
+* Similarly to custom constructors, pickling support functions are now bound
+  using the ``py::pickle()`` adaptor which improves type safety. See the
+  :doc:`upgrade` and :ref:`pickling` for details.
+  `#1038 <https://github.com/pybind/pybind11/pull/1038>`_.
+
+* Builtin support for converting C++17 standard library types and general
+  conversion improvements:
+
+  1. C++17 ``std::variant`` is supported right out of the box. C++11/14
+     equivalents (e.g. ``boost::variant``) can also be added with a simple
+     user-defined specialization. See :ref:`cpp17_container_casters` for details.
+     `#811 <https://github.com/pybind/pybind11/pull/811>`_,
+     `#845 <https://github.com/pybind/pybind11/pull/845>`_,
+     `#989 <https://github.com/pybind/pybind11/pull/989>`_.
+
+  2. Out-of-the-box support for C++17 ``std::string_view``.
+     `#906 <https://github.com/pybind/pybind11/pull/906>`_.
+
+  3. Improved compatibility of the builtin ``optional`` converter.
+     `#874 <https://github.com/pybind/pybind11/pull/874>`_.
+
+  4. The ``bool`` converter now accepts ``numpy.bool_`` and types which
+     define ``__bool__`` (Python 3.x) or ``__nonzero__`` (Python 2.7).
+     `#925 <https://github.com/pybind/pybind11/pull/925>`_.
+
+  5. C++-to-Python casters are now more efficient and move elements out
+     of rvalue containers whenever possible.
+     `#851 <https://github.com/pybind/pybind11/pull/851>`_,
+     `#936 <https://github.com/pybind/pybind11/pull/936>`_,
+     `#938 <https://github.com/pybind/pybind11/pull/938>`_.
+
+  6. Fixed ``bytes`` to ``std::string/char*`` conversion on Python 3.
+     `#817 <https://github.com/pybind/pybind11/pull/817>`_.
+
+  7. Fixed lifetime of temporary C++ objects created in Python-to-C++ conversions.
+     `#924 <https://github.com/pybind/pybind11/pull/924>`_.
+
+* Scope guard call policy for RAII types, e.g. ``py::call_guard<py::gil_scoped_release>()``,
+  ``py::call_guard<py::scoped_ostream_redirect>()``. See :ref:`call_policies` for details.
+  `#740 <https://github.com/pybind/pybind11/pull/740>`_.
+
+* Utility for redirecting C++ streams to Python (e.g. ``std::cout`` ->
+  ``sys.stdout``). Scope guard ``py::scoped_ostream_redirect`` in C++ and
+  a context manager in Python. See :ref:`ostream_redirect`.
+  `#1009 <https://github.com/pybind/pybind11/pull/1009>`_.
+
+* Improved handling of types and exceptions across module boundaries.
+  `#915 <https://github.com/pybind/pybind11/pull/915>`_,
+  `#951 <https://github.com/pybind/pybind11/pull/951>`_,
+  `#995 <https://github.com/pybind/pybind11/pull/995>`_.
+
+* Fixed destruction order of ``py::keep_alive`` nurse/patient objects
+  in reference cycles.
+  `#856 <https://github.com/pybind/pybind11/pull/856>`_.
+
+* Numpy and buffer protocol related improvements:
+
+  1. Support for negative strides in Python buffer objects/numpy arrays. This
+     required changing integers from unsigned to signed for the related C++ APIs.
+     Note: If you have compiler warnings enabled, you may notice some new conversion
+     warnings after upgrading. These can be resolved with ``static_cast``.
+     `#782 <https://github.com/pybind/pybind11/pull/782>`_.
+
+  2. Support ``std::complex`` and arrays inside ``PYBIND11_NUMPY_DTYPE``.
+     `#831 <https://github.com/pybind/pybind11/pull/831>`_,
+     `#832 <https://github.com/pybind/pybind11/pull/832>`_.
+
+  3. Support for constructing ``py::buffer_info`` and ``py::arrays`` using
+     arbitrary containers or iterators instead of requiring a ``std::vector``.
+     `#788 <https://github.com/pybind/pybind11/pull/788>`_,
+     `#822 <https://github.com/pybind/pybind11/pull/822>`_,
+     `#860 <https://github.com/pybind/pybind11/pull/860>`_.
+
+  4. Explicitly check numpy version and require >= 1.7.0.
+     `#819 <https://github.com/pybind/pybind11/pull/819>`_.
+
+* Support for allowing/prohibiting ``None`` for specific arguments and improved
+  ``None`` overload resolution order. See :ref:`none_arguments` for details.
+  `#843 <https://github.com/pybind/pybind11/pull/843>`_.
+  `#859 <https://github.com/pybind/pybind11/pull/859>`_.
+
+* Added ``py::exec()`` as a shortcut for ``py::eval<py::eval_statements>()``
+  and support for C++11 raw string literals as input. See :ref:`eval`.
+  `#766 <https://github.com/pybind/pybind11/pull/766>`_,
+  `#827 <https://github.com/pybind/pybind11/pull/827>`_.
+
+* ``py::vectorize()`` ignores non-vectorizable arguments and supports
+  member functions.
+  `#762 <https://github.com/pybind/pybind11/pull/762>`_.
+
+* Support for bound methods as callbacks (``pybind11/functional.h``).
+  `#815 <https://github.com/pybind/pybind11/pull/815>`_.
+
+* Allow aliasing pybind11 methods: ``cls.attr("foo") = cls.attr("bar")``.
+  `#802 <https://github.com/pybind/pybind11/pull/802>`_.
+
+* Don't allow mixed static/non-static overloads.
+  `#804 <https://github.com/pybind/pybind11/pull/804>`_.
+
+* Fixed overriding static properties in derived classes.
+  `#784 <https://github.com/pybind/pybind11/pull/784>`_.
+
+* Added support for write only properties.
+  `#1144 <https://github.com/pybind/pybind11/pull/1144>`_.
+
+* Improved deduction of member functions of a derived class when its bases
+  aren't registered with pybind11.
+  `#855 <https://github.com/pybind/pybind11/pull/855>`_.
+
+  .. code-block:: cpp
+
+      struct Base {
+          int foo() { return 42; }
+      }
+
+      struct Derived : Base {}
+
+      // Now works, but previously required also binding `Base`
+      py::class_<Derived>(m, "Derived")
+          .def("foo", &Derived::foo); // function is actually from `Base`
+
+* The implementation of ``py::init<>`` now uses C++11 brace initialization
+  syntax to construct instances, which permits binding implicit constructors of
+  aggregate types. `#1015 <https://github.com/pybind/pybind11/pull/1015>`_.
+
+    .. code-block:: cpp
+
+        struct Aggregate {
+            int a;
+            std::string b;
+        };
+
+        py::class_<Aggregate>(m, "Aggregate")
+            .def(py::init<int, const std::string &>());
+
+* Fixed issues with multiple inheritance with offset base/derived pointers.
+  `#812 <https://github.com/pybind/pybind11/pull/812>`_,
+  `#866 <https://github.com/pybind/pybind11/pull/866>`_,
+  `#960 <https://github.com/pybind/pybind11/pull/960>`_.
+
+* Fixed reference leak of type objects.
+  `#1030 <https://github.com/pybind/pybind11/pull/1030>`_.
+
+* Improved support for the ``/std:c++14`` and ``/std:c++latest`` modes
+  on MSVC 2017.
+  `#841 <https://github.com/pybind/pybind11/pull/841>`_,
+  `#999 <https://github.com/pybind/pybind11/pull/999>`_.
+
+* Fixed detection of private operator new on MSVC.
+  `#893 <https://github.com/pybind/pybind11/pull/893>`_,
+  `#918 <https://github.com/pybind/pybind11/pull/918>`_.
+
+* Intel C++ compiler compatibility fixes.
+  `#937 <https://github.com/pybind/pybind11/pull/937>`_.
+
+* Fixed implicit conversion of `py::enum_` to integer types on Python 2.7.
+  `#821 <https://github.com/pybind/pybind11/pull/821>`_.
+
+* Added ``py::hash`` to fetch the hash value of Python objects, and
+  ``.def(hash(py::self))`` to provide the C++ ``std::hash`` as the Python
+  ``__hash__`` method.
+  `#1034 <https://github.com/pybind/pybind11/pull/1034>`_.
+
+* Fixed ``__truediv__`` on Python 2 and ``__itruediv__`` on Python 3.
+  `#867 <https://github.com/pybind/pybind11/pull/867>`_.
+
+* ``py::capsule`` objects now support the ``name`` attribute. This is useful
+  for interfacing with ``scipy.LowLevelCallable``.
+  `#902 <https://github.com/pybind/pybind11/pull/902>`_.
+
+* Fixed ``py::make_iterator``'s ``__next__()`` for past-the-end calls.
+  `#897 <https://github.com/pybind/pybind11/pull/897>`_.
+
+* Added ``error_already_set::matches()`` for checking Python exceptions.
+  `#772 <https://github.com/pybind/pybind11/pull/772>`_.
+
+* Deprecated ``py::error_already_set::clear()``. It's no longer needed
+  following a simplification of the ``py::error_already_set`` class.
+  `#954 <https://github.com/pybind/pybind11/pull/954>`_.
+
+* Deprecated ``py::handle::operator==()`` in favor of ``py::handle::is()``
+  `#825 <https://github.com/pybind/pybind11/pull/825>`_.
+
+* Deprecated ``py::object::borrowed``/``py::object::stolen``.
+  Use ``py::object::borrowed_t{}``/``py::object::stolen_t{}`` instead.
+  `#771 <https://github.com/pybind/pybind11/pull/771>`_.
+
+* Changed internal data structure versioning to avoid conflicts between
+  modules compiled with different revisions of pybind11.
+  `#1012 <https://github.com/pybind/pybind11/pull/1012>`_.
+
+* Additional compile-time and run-time error checking and more informative messages.
+  `#786 <https://github.com/pybind/pybind11/pull/786>`_,
+  `#794 <https://github.com/pybind/pybind11/pull/794>`_,
+  `#803 <https://github.com/pybind/pybind11/pull/803>`_.
+
+* Various minor improvements and fixes.
+  `#764 <https://github.com/pybind/pybind11/pull/764>`_,
+  `#791 <https://github.com/pybind/pybind11/pull/791>`_,
+  `#795 <https://github.com/pybind/pybind11/pull/795>`_,
+  `#840 <https://github.com/pybind/pybind11/pull/840>`_,
+  `#844 <https://github.com/pybind/pybind11/pull/844>`_,
+  `#846 <https://github.com/pybind/pybind11/pull/846>`_,
+  `#849 <https://github.com/pybind/pybind11/pull/849>`_,
+  `#858 <https://github.com/pybind/pybind11/pull/858>`_,
+  `#862 <https://github.com/pybind/pybind11/pull/862>`_,
+  `#871 <https://github.com/pybind/pybind11/pull/871>`_,
+  `#872 <https://github.com/pybind/pybind11/pull/872>`_,
+  `#881 <https://github.com/pybind/pybind11/pull/881>`_,
+  `#888 <https://github.com/pybind/pybind11/pull/888>`_,
+  `#899 <https://github.com/pybind/pybind11/pull/899>`_,
+  `#928 <https://github.com/pybind/pybind11/pull/928>`_,
+  `#931 <https://github.com/pybind/pybind11/pull/931>`_,
+  `#944 <https://github.com/pybind/pybind11/pull/944>`_,
+  `#950 <https://github.com/pybind/pybind11/pull/950>`_,
+  `#952 <https://github.com/pybind/pybind11/pull/952>`_,
+  `#962 <https://github.com/pybind/pybind11/pull/962>`_,
+  `#965 <https://github.com/pybind/pybind11/pull/965>`_,
+  `#970 <https://github.com/pybind/pybind11/pull/970>`_,
+  `#978 <https://github.com/pybind/pybind11/pull/978>`_,
+  `#979 <https://github.com/pybind/pybind11/pull/979>`_,
+  `#986 <https://github.com/pybind/pybind11/pull/986>`_,
+  `#1020 <https://github.com/pybind/pybind11/pull/1020>`_,
+  `#1027 <https://github.com/pybind/pybind11/pull/1027>`_,
+  `#1037 <https://github.com/pybind/pybind11/pull/1037>`_.
+
+* Testing improvements.
+  `#798 <https://github.com/pybind/pybind11/pull/798>`_,
+  `#882 <https://github.com/pybind/pybind11/pull/882>`_,
+  `#898 <https://github.com/pybind/pybind11/pull/898>`_,
+  `#900 <https://github.com/pybind/pybind11/pull/900>`_,
+  `#921 <https://github.com/pybind/pybind11/pull/921>`_,
+  `#923 <https://github.com/pybind/pybind11/pull/923>`_,
+  `#963 <https://github.com/pybind/pybind11/pull/963>`_.
 
 v2.1.1 (April 7, 2017)
 -----------------------------------------------------
@@ -148,7 +853,7 @@ Happy Christmas!
   being (notably dynamic attributes in custom types).
   `#527 <https://github.com/pybind/pybind11/pull/527>`_.
 
-* Significant work on the documentation -- in particular, the monolitic
+* Significant work on the documentation -- in particular, the monolithic
   ``advanced.rst`` file was restructured into a easier to read hierarchical
   organization. `#448 <https://github.com/pybind/pybind11/pull/448>`_.
 
@@ -216,8 +921,8 @@ Happy Christmas!
        <https://github.com/pybind/pybind11/pull/527>`_.
 
 
-    3. This version of pybind11 uses a redesigned mechnism for instantiating
-       trempoline classes that are used to override virtual methods from within
+    3. This version of pybind11 uses a redesigned mechanism for instantiating
+       trampoline classes that are used to override virtual methods from within
        Python. This led to the following user-visible syntax change: instead of
 
        .. code-block:: cpp
diff --git a/src/pybind11/docs/classes.rst b/src/pybind11/docs/classes.rst
index 7696c60..a63f6a1 100644
--- a/src/pybind11/docs/classes.rst
+++ b/src/pybind11/docs/classes.rst
@@ -155,6 +155,9 @@ the setter and getter functions:
             .def_property("name", &Pet::getName, &Pet::setName)
             // ... remainder ...
 
+Write only properties can be defined by passing ``nullptr`` as the
+input for the read function.
+
 .. seealso::
 
     Similar functions :func:`class_::def_readwrite_static`,
@@ -225,8 +228,8 @@ just brings them on par.
 
 .. _inheritance:
 
-Inheritance
-===========
+Inheritance and automatic downcasting
+=====================================
 
 Suppose now that the example consists of two data structures with an
 inheritance relationship:
@@ -283,6 +286,65 @@ expose fields and methods of both types:
     >>> p.bark()
     u'woof!'
 
+The C++ classes defined above are regular non-polymorphic types with an
+inheritance relationship. This is reflected in Python:
+
+.. code-block:: cpp
+
+    // Return a base pointer to a derived instance
+    m.def("pet_store", []() { return std::unique_ptr<Pet>(new Dog("Molly")); });
+
+.. code-block:: pycon
+
+    >>> p = example.pet_store()
+    >>> type(p)  # `Dog` instance behind `Pet` pointer
+    Pet          # no pointer downcasting for regular non-polymorphic types
+    >>> p.bark()
+    AttributeError: 'Pet' object has no attribute 'bark'
+
+The function returned a ``Dog`` instance, but because it's a non-polymorphic
+type behind a base pointer, Python only sees a ``Pet``. In C++, a type is only
+considered polymorphic if it has at least one virtual function and pybind11
+will automatically recognize this:
+
+.. code-block:: cpp
+
+    struct PolymorphicPet {
+        virtual ~PolymorphicPet() = default;
+    };
+
+    struct PolymorphicDog : PolymorphicPet {
+        std::string bark() const { return "woof!"; }
+    };
+
+    // Same binding code
+    py::class_<PolymorphicPet>(m, "PolymorphicPet");
+    py::class_<PolymorphicDog, PolymorphicPet>(m, "PolymorphicDog")
+        .def(py::init<>())
+        .def("bark", &PolymorphicDog::bark);
+
+    // Again, return a base pointer to a derived instance
+    m.def("pet_store2", []() { return std::unique_ptr<PolymorphicPet>(new PolymorphicDog); });
+
+.. code-block:: pycon
+
+    >>> p = example.pet_store2()
+    >>> type(p)
+    PolymorphicDog  # automatically downcast
+    >>> p.bark()
+    u'woof!'
+
+Given a pointer to a polymorphic base, pybind11 performs automatic downcasting
+to the actual derived type. Note that this goes beyond the usual situation in
+C++: we don't just get access to the virtual functions of the base, we get the
+concrete derived type including functions and attributes that the base type may
+not even be aware of.
+
+.. seealso::
+
+    For more information about polymorphic behavior see :ref:`overriding_virtuals`.
+
+
 Overloaded methods
 ==================
 
@@ -360,6 +422,17 @@ on constness, the ``py::const_`` tag should be used:
        .def("foo_mutable", py::overload_cast<int, float>(&Widget::foo))
        .def("foo_const",   py::overload_cast<int, float>(&Widget::foo, py::const_));
 
+If you prefer the ``py::overload_cast`` syntax but have a C++11 compatible compiler only,
+you can use ``py::detail::overload_cast_impl`` with an additional set of parentheses:
+
+.. code-block:: cpp
+
+    template <typename... Args>
+    using overload_cast_ = pybind11::detail::overload_cast_impl<Args...>;
+
+    py::class_<Pet>(m, "Pet")
+        .def("set", overload_cast_<int>()(&Pet::set), "Set the pet's age")
+        .def("set", overload_cast_<const std::string &>()(&Pet::set), "Set the pet's name");
 
 .. [#cpp14] A compiler which supports the ``-std=c++14`` flag
             or Visual Studio 2015 Update 2 and newer.
@@ -426,6 +499,24 @@ The entries defined by the enumeration type are exposed in the ``__members__`` p
     >>> Pet.Kind.__members__
     {'Dog': Kind.Dog, 'Cat': Kind.Cat}
 
+The ``name`` property returns the name of the enum value as a unicode string.
+
+.. note::
+
+    It is also possible to use ``str(enum)``, however these accomplish different
+    goals. The following shows how these two approaches differ.
+
+    .. code-block:: pycon
+
+        >>> p = Pet( "Lucy", Pet.Cat )
+        >>> pet_type = p.type
+        >>> pet_type
+        Pet.Cat
+        >>> str(pet_type)
+        'Pet.Cat'
+        >>> pet_type.name
+        'Cat'
+
 .. note::
 
     When the special tag ``py::arithmetic()`` is specified to the ``enum_``
diff --git a/src/pybind11/docs/compiling.rst b/src/pybind11/docs/compiling.rst
index 91e65df..c50c7d8 100644
--- a/src/pybind11/docs/compiling.rst
+++ b/src/pybind11/docs/compiling.rst
@@ -1,3 +1,5 @@
+.. _compiling:
+
 Build systems
 #############
 
@@ -14,10 +16,10 @@ the [python_example]_ repository.
 Building with cppimport
 ========================
 
- cppimport is a small Python import hook that determines whether there is a C++
- source file whose name matches the requested module. If there is, the file is
- compiled as a Python extension using pybind11 and placed in the same folder as
- the C++ source file. Python is then able to find the module and load it.
+[cppimport]_ is a small Python import hook that determines whether there is a C++
+source file whose name matches the requested module. If there is, the file is
+compiled as a Python extension using pybind11 and placed in the same folder as
+the C++ source file. Python is then able to find the module and load it.
 
 .. [cppimport] https://github.com/tbenthompson/cppimport
 
@@ -57,7 +59,7 @@ function with the following signature:
 .. code-block:: cmake
 
     pybind11_add_module(<name> [MODULE | SHARED] [EXCLUDE_FROM_ALL]
-                        [NO_EXTRAS] [THIN_LTO] source1 [source2 ...])
+                        [NO_EXTRAS] [SYSTEM] [THIN_LTO] source1 [source2 ...])
 
 This function behaves very much like CMake's builtin ``add_library`` (in fact,
 it's a wrapper function around that command). It will add a library target
@@ -74,13 +76,19 @@ removes this target from the default build (see CMake docs for details).
 
 Since pybind11 is a template library, ``pybind11_add_module`` adds compiler
 flags to ensure high quality code generation without bloat arising from long
-symbol names and duplication of code in different translation units. The
-additional flags enable LTO (Link Time Optimization), set default visibility
-to *hidden* and strip unneeded symbols. See the :ref:`FAQ entry <faq:symhidden>`
-for a more detailed explanation. These optimizations are never applied in
-``Debug`` mode. If ``NO_EXTRAS`` is given, they will always be disabled, even
-in ``Release`` mode. However, this will result in code bloat and is generally
-not recommended.
+symbol names and duplication of code in different translation units. It
+sets default visibility to *hidden*, which is required for some pybind11
+features and functionality when attempting to load multiple pybind11 modules
+compiled under different pybind11 versions.  It also adds additional flags
+enabling LTO (Link Time Optimization) and strip unneeded symbols. See the
+:ref:`FAQ entry <faq:symhidden>` for a more detailed explanation. These
+latter optimizations are never applied in ``Debug`` mode.  If ``NO_EXTRAS`` is
+given, they will always be disabled, even in ``Release`` mode. However, this
+will result in code bloat and is generally not recommended.
+
+By default, pybind11 and Python headers will be included with ``-I``. In order
+to include pybind11 as system library, e.g. to avoid warnings in downstream
+code with warn-levels outside of pybind11's scope, set the option ``SYSTEM``.
 
 As stated above, LTO is enabled by default. Some newer compilers also support
 different flavors of LTO such as `ThinLTO`_. Setting ``THIN_LTO`` will cause
@@ -141,6 +149,18 @@ See the `Config file`_ docstring for details of relevant CMake variables.
     find_package(pybind11 REQUIRED)
     pybind11_add_module(example example.cpp)
 
+Note that ``find_package(pybind11)`` will only work correctly if pybind11
+has been correctly installed on the system, e. g. after downloading or cloning
+the pybind11 repository  :
+
+.. code-block:: bash
+
+    cd pybind11
+    mkdir build
+    cd build
+    cmake ..
+    make install
+
 Once detected, the aforementioned ``pybind11_add_module`` can be employed as
 before. The function usage and configuration variables are identical no matter
 if pybind11 is added as a subdirectory or found as an installed package. You
@@ -181,9 +201,8 @@ to an independently constructed (through ``add_library``, not
     flags (i.e. this is up to you).
 
     These include Link Time Optimization (``-flto`` on GCC/Clang/ICPC, ``/GL``
-    and ``/LTCG`` on Visual Studio). Default-hidden symbols on GCC/Clang/ICPC
-    (``-fvisibility=hidden``) and .OBJ files with many sections on Visual Studio
-    (``/bigobj``). The :ref:`FAQ <faq:symhidden>` contains an
+    and ``/LTCG`` on Visual Studio) and .OBJ files with many sections on Visual
+    Studio (``/bigobj``).  The :ref:`FAQ <faq:symhidden>` contains an
     explanation on why these are needed.
 
 Embedding the Python interpreter
@@ -206,6 +225,59 @@ information about usage in C++, see :doc:`/advanced/embedding`.
     add_executable(example main.cpp)
     target_link_libraries(example PRIVATE pybind11::embed)
 
+.. _building_manually:
+
+Building manually
+=================
+
+pybind11 is a header-only library, hence it is not necessary to link against
+any special libraries and there are no intermediate (magic) translation steps.
+
+On Linux, you can compile an example such as the one given in
+:ref:`simple_example` using the following command:
+
+.. code-block:: bash
+
+    $ c++ -O3 -Wall -shared -std=c++11 -fPIC `python3 -m pybind11 --includes` example.cpp -o example`python3-config --extension-suffix`
+
+The flags given here assume that you're using Python 3. For Python 2, just
+change the executable appropriately (to ``python`` or ``python2``).
+
+The ``python3 -m pybind11 --includes`` command fetches the include paths for
+both pybind11 and Python headers. This assumes that pybind11 has been installed
+using ``pip`` or ``conda``. If it hasn't, you can also manually specify
+``-I <path-to-pybind11>/include`` together with the Python includes path
+``python3-config --includes``.
+
+Note that Python 2.7 modules don't use a special suffix, so you should simply
+use ``example.so`` instead of ``example`python3-config --extension-suffix```.
+Besides, the ``--extension-suffix`` option may or may not be available, depending
+on the distribution; in the latter case, the module extension can be manually
+set to ``.so``.
+
+On Mac OS: the build command is almost the same but it also requires passing
+the ``-undefined dynamic_lookup`` flag so as to ignore missing symbols when
+building the module:
+
+.. code-block:: bash
+
+    $ c++ -O3 -Wall -shared -std=c++11 -undefined dynamic_lookup `python3 -m pybind11 --includes` example.cpp -o example`python3-config --extension-suffix`
+
+In general, it is advisable to include several additional build parameters
+that can considerably reduce the size of the created binary. Refer to section
+:ref:`cmake` for a detailed example of a suitable cross-platform CMake-based
+build system that works on all platforms including Windows.
+
+.. note::
+
+    On Linux and macOS, it's better to (intentionally) not link against
+    ``libpython``. The symbols will be resolved when the extension library
+    is loaded into a Python binary. This is preferable because you might
+    have several different installations of a given Python version (e.g. the
+    system-provided Python, and one that ships with a piece of commercial
+    software). In this way, the plugin will work with both versions, instead
+    of possibly importing a second Python library into a process that already
+    contains one (which will lead to a segfault).
 
 Generating binding code automatically
 =====================================
diff --git a/src/pybind11/docs/conf.py b/src/pybind11/docs/conf.py
index 9f29304..fa6332d 100644
--- a/src/pybind11/docs/conf.py
+++ b/src/pybind11/docs/conf.py
@@ -61,9 +61,9 @@ author = 'Wenzel Jakob'
 # built documents.
 #
 # The short X.Y version.
-version = '2.2'
+version = '2.5'
 # The full version, including alpha/beta/rc tags.
-release = '2.2.dev0'
+release = '2.5.0'
 
 # The language for content autogenerated by Sphinx. Refer to documentation
 # for a list of supported languages.
@@ -314,13 +314,13 @@ highlight_language = 'cpp'
 
 
 def generate_doxygen_xml(app):
-    build_dir = '.build'
+    build_dir = os.path.join(app.confdir, '.build')
     if not os.path.exists(build_dir):
         os.mkdir(build_dir)
 
     try:
         subprocess.call(['doxygen', '--version'])
-        retcode = subprocess.call(['doxygen'])
+        retcode = subprocess.call(['doxygen'], cwd=app.confdir)
         if retcode < 0:
             sys.stderr.write("doxygen error code: {}\n".format(-retcode))
     except OSError as e:
diff --git a/src/pybind11/docs/faq.rst b/src/pybind11/docs/faq.rst
index 072b157..4d491fb 100644
--- a/src/pybind11/docs/faq.rst
+++ b/src/pybind11/docs/faq.rst
@@ -4,9 +4,13 @@ Frequently asked questions
 "ImportError: dynamic module does not define init function"
 ===========================================================
 
-You are likely using an incompatible version of Python (for instance, the
-extension library was compiled against Python 2, while the interpreter is
-running on top of some version of Python 3, or vice versa).
+1. Make sure that the name specified in PYBIND11_MODULE is identical to the
+filename of the extension library (without prefixes such as .so)
+
+2. If the above did not fix the issue, you are likely using an incompatible
+version of Python (for instance, the extension library was compiled against
+Python 2, while the interpreter is running on top of some version of Python
+3, or vice versa).
 
 "Symbol not found: ``__Py_ZeroStruct`` / ``_PyInstanceMethod_Type``"
 ========================================================================
@@ -35,6 +39,8 @@ multiple versions of Python and it finds the wrong one, delete
 
     cmake -DPYTHON_EXECUTABLE:FILEPATH=<path-to-python-executable> .
 
+.. _faq_reference_arguments:
+
 Limitations involving reference arguments
 =========================================
 
@@ -116,7 +122,7 @@ following example:
 
 .. code-block:: cpp
 
-    void init_ex1(py::module &m) {
+    void init_ex2(py::module &m) {
         m.def("sub", [](int a, int b) { return a - b; });
     }
 
@@ -151,6 +157,33 @@ specifying a larger value, e.g. ``-ftemplate-depth=1024`` on GCC/Clang. The
 culprit is generally the generation of function signatures at compile time
 using C++14 template metaprogramming.
 
+.. _`faq:hidden_visibility`:
+
+"‘SomeClass’ declared with greater visibility than the type of its field ‘SomeClass::member’ [-Wattributes]"
+============================================================================================================
+
+This error typically indicates that you are compiling without the required
+``-fvisibility`` flag.  pybind11 code internally forces hidden visibility on
+all internal code, but if non-hidden (and thus *exported*) code attempts to
+include a pybind type (for example, ``py::object`` or ``py::list``) you can run
+into this warning.
+
+To avoid it, make sure you are specifying ``-fvisibility=hidden`` when
+compiling pybind code.
+
+As to why ``-fvisibility=hidden`` is necessary, because pybind modules could
+have been compiled under different versions of pybind itself, it is also
+important that the symbols defined in one module do not clash with the
+potentially-incompatible symbols defined in another.  While Python extension
+modules are usually loaded with localized symbols (under POSIX systems
+typically using ``dlopen`` with the ``RTLD_LOCAL`` flag), this Python default
+can be changed, but even if it isn't it is not always enough to guarantee
+complete independence of the symbols involved when not using
+``-fvisibility=hidden``.
+
+Additionally, ``-fvisiblity=hidden`` can deliver considerably binary size
+savings.  (See the following section for more details).
+
 
 .. _`faq:symhidden`:
 
@@ -192,52 +225,100 @@ world. So we'll generally only want to export symbols for those functions which
 are actually called from the outside.
 
 This can be achieved by specifying the parameter ``-fvisibility=hidden`` to GCC
-and Clang, which sets the default symbol visibility to *hidden*. It's best to
-do this only for release builds, since the symbol names can be helpful in
-debugging sessions. On Visual Studio, symbols are already hidden by default, so
-nothing needs to be done there. Needless to say, this has a tremendous impact
-on the final binary size of the resulting extension library.
-
-Another aspect that can require a fair bit of code are function signature
-descriptions. pybind11 automatically generates human-readable function
-signatures for docstrings, e.g.:
-
-.. code-block:: none
-
-     |  __init__(...)
-     |      __init__(*args, **kwargs)
-     |      Overloaded function.
-     |
-     |      1. __init__(example.Example1) -> NoneType
-     |
-     |      Docstring for overload #1 goes here
-     |
-     |      2. __init__(example.Example1, int) -> NoneType
-     |
-     |      Docstring for overload #2 goes here
-     |
-     |      3. __init__(example.Example1, example.Example1) -> NoneType
-     |
-     |      Docstring for overload #3 goes here
-
-
-In C++11 mode, these are generated at run time using string concatenation,
-which can amount to 10-20% of the size of the resulting binary. If you can,
-enable C++14 language features (using ``-std=c++14`` for GCC/Clang), in which
-case signatures are efficiently pre-generated at compile time. Unfortunately,
-Visual Studio's C++14 support (``constexpr``) is not good enough as of April
-2016, so it always uses the more expensive run-time approach.
-
-Working with ancient Visual Studio 2009 builds on Windows
+and Clang, which sets the default symbol visibility to *hidden*, which has a
+tremendous impact on the final binary size of the resulting extension library.
+(On Visual Studio, symbols are already hidden by default, so nothing needs to
+be done there.)
+
+In addition to decreasing binary size, ``-fvisibility=hidden`` also avoids
+potential serious issues when loading multiple modules and is required for
+proper pybind operation.  See the previous FAQ entry for more details.
+
+Working with ancient Visual Studio 2008 builds on Windows
 =========================================================
 
 The official Windows distributions of Python are compiled using truly
 ancient versions of Visual Studio that lack good C++11 support. Some users
 implicitly assume that it would be impossible to load a plugin built with
 Visual Studio 2015 into a Python distribution that was compiled using Visual
-Studio 2009. However, no such issue exists: it's perfectly legitimate to
+Studio 2008. However, no such issue exists: it's perfectly legitimate to
 interface DLLs that are built with different compilers and/or C libraries.
 Common gotchas to watch out for involve not ``free()``-ing memory region
 that that were ``malloc()``-ed in another shared library, using data
 structures with incompatible ABIs, and so on. pybind11 is very careful not
 to make these types of mistakes.
+
+How can I properly handle Ctrl-C in long-running functions?
+===========================================================
+
+Ctrl-C is received by the Python interpreter, and holds it until the GIL
+is released, so a long-running function won't be interrupted.
+
+To interrupt from inside your function, you can use the ``PyErr_CheckSignals()``
+function, that will tell if a signal has been raised on the Python side.  This
+function merely checks a flag, so its impact is negligible. When a signal has
+been received, you must either explicitly interrupt execution by throwing
+``py::error_already_set`` (which will propagate the existing
+``KeyboardInterrupt``), or clear the error (which you usually will not want):
+
+.. code-block:: cpp
+
+    PYBIND11_MODULE(example, m)
+    {
+        m.def("long running_func", []()
+        {
+            for (;;) {
+                if (PyErr_CheckSignals() != 0)
+                    throw py::error_already_set();
+                // Long running iteration
+            }
+        });
+    }
+
+Inconsistent detection of Python version in CMake and pybind11
+==============================================================
+
+The functions ``find_package(PythonInterp)`` and ``find_package(PythonLibs)`` provided by CMake
+for Python version detection are not used by pybind11 due to unreliability and limitations that make
+them unsuitable for pybind11's needs. Instead pybind provides its own, more reliable Python detection
+CMake code. Conflicts can arise, however, when using pybind11 in a project that *also* uses the CMake
+Python detection in a system with several Python versions installed.
+
+This difference may cause inconsistencies and errors if *both* mechanisms are used in the same project. Consider the following
+Cmake code executed in a system with Python 2.7 and 3.x installed:
+
+.. code-block:: cmake
+
+    find_package(PythonInterp)
+    find_package(PythonLibs)
+    find_package(pybind11)
+
+It will detect Python 2.7 and pybind11 will pick it as well.
+
+In contrast this code:
+
+.. code-block:: cmake
+
+    find_package(pybind11)
+    find_package(PythonInterp)
+    find_package(PythonLibs)
+
+will detect Python 3.x for pybind11 and may crash on ``find_package(PythonLibs)`` afterwards.
+
+It is advised to avoid using ``find_package(PythonInterp)`` and ``find_package(PythonLibs)`` from CMake and rely
+on pybind11 in detecting Python version. If this is not possible CMake machinery should be called *before* including pybind11.
+
+How to cite this project?
+=========================
+
+We suggest the following BibTeX template to cite pybind11 in scientific
+discourse:
+
+.. code-block:: bash
+
+    @misc{pybind11,
+       author = {Wenzel Jakob and Jason Rhinelander and Dean Moldovan},
+       year = {2017},
+       note = {https://github.com/pybind/pybind11},
+       title = {pybind11 -- Seamless operability between C++11 and Python}
+    }
diff --git a/src/pybind11/docs/index.rst b/src/pybind11/docs/index.rst
index 4e7a848..d236611 100644
--- a/src/pybind11/docs/index.rst
+++ b/src/pybind11/docs/index.rst
@@ -14,6 +14,7 @@ pybind11 --- Seamless operability between C++11 and Python
 
    intro
    changelog
+   upgrade
 
 .. toctree::
    :caption: The Basics
diff --git a/src/pybind11/docs/intro.rst b/src/pybind11/docs/intro.rst
index 2149c18..10e1799 100644
--- a/src/pybind11/docs/intro.rst
+++ b/src/pybind11/docs/intro.rst
@@ -41,7 +41,6 @@ The following core C++ features can be mapped to Python
 - Custom operators
 - Single and multiple inheritance
 - STL data structures
-- Iterators and ranges
 - Smart pointers with reference counting like ``std::shared_ptr``
 - Internal references with correct reference counting
 - C++ classes with virtual (and pure virtual) methods can be extended in Python
@@ -77,9 +76,8 @@ In addition to the core functionality, pybind11 provides some extra goodies:
   of `PyRosetta`_, an enormous Boost.Python binding project, reported a binary
   size reduction of **5.4x** and compile time reduction by **5.8x**.
 
-- When supported by the compiler, two new C++14 features (relaxed constexpr and
-  return value deduction) are used to precompute function signatures at compile
-  time, leading to smaller binaries.
+- Function signatures are precomputed at compile time (using ``constexpr``),
+  leading to smaller binaries.
 
 - With little extra effort, C++ types can be pickled and unpickled similar to
   regular Python objects.
@@ -92,4 +90,4 @@ Supported compilers
 1. Clang/LLVM (any non-ancient version with C++11 support)
 2. GCC 4.8 or newer
 3. Microsoft Visual Studio 2015 or newer
-4. Intel C++ compiler v15 or newer
+4. Intel C++ compiler v17 or newer (v16 with pybind11 v2.0 and v15 with pybind11 v2.0 and a `workaround <https://github.com/pybind/pybind11/issues/276>`_ )
diff --git a/src/pybind11/docs/reference.rst b/src/pybind11/docs/reference.rst
index d9dc961..a9fbe60 100644
--- a/src/pybind11/docs/reference.rst
+++ b/src/pybind11/docs/reference.rst
@@ -9,6 +9,8 @@
 Reference
 #########
 
+.. _macros:
+
 Macros
 ======
 
@@ -69,12 +71,36 @@ Embedding the interpreter
 
 .. doxygenclass:: scoped_interpreter
 
-Python build-in functions
+Redirecting C++ streams
+=======================
+
+.. doxygenclass:: scoped_ostream_redirect
+
+.. doxygenclass:: scoped_estream_redirect
+
+.. doxygenfunction:: add_ostream_redirect
+
+Python built-in functions
 =========================
 
 .. doxygengroup:: python_builtins
     :members:
 
+Inheritance
+===========
+
+See :doc:`/classes` and :doc:`/advanced/classes` for more detail.
+
+.. doxygendefine:: PYBIND11_OVERLOAD
+
+.. doxygendefine:: PYBIND11_OVERLOAD_PURE
+
+.. doxygendefine:: PYBIND11_OVERLOAD_NAME
+
+.. doxygendefine:: PYBIND11_OVERLOAD_PURE_NAME
+
+.. doxygenfunction:: get_overload
+
 Exceptions
 ==========
 
diff --git a/src/pybind11/docs/release.rst b/src/pybind11/docs/release.rst
index 30d159a..9846f97 100644
--- a/src/pybind11/docs/release.rst
+++ b/src/pybind11/docs/release.rst
@@ -2,7 +2,7 @@ To release a new version of pybind11:
 
 - Update the version number and push to pypi
     - Update ``pybind11/_version.py`` (set release version, remove 'dev').
-    - Update ``PYBIND11_VERSION_MAJOR`` etc. in ``include/pybind11/common.h``.
+    - Update ``PYBIND11_VERSION_MAJOR`` etc. in ``include/pybind11/detail/common.h``.
     - Ensure that all the information in ``setup.py`` is up-to-date.
     - Update version in ``docs/conf.py``.
     - Tag release date in ``docs/changelog.rst``.
@@ -13,9 +13,6 @@ To release a new version of pybind11:
     - ``git push --tags``.
     - ``python setup.py sdist upload``.
     - ``python setup.py bdist_wheel upload``.
-- Update conda-forge (https://github.com/conda-forge/pybind11-feedstock) via PR
-    - change version number in ``recipe/meta.yml``
-    - update checksum to match the one computed by pypi
 - Get back to work
     - Update ``_version.py`` (add 'dev' and increment minor).
     - Update version in ``docs/conf.py``
diff --git a/src/pybind11/docs/upgrade.rst b/src/pybind11/docs/upgrade.rst
new file mode 100644
index 0000000..3f56973
--- /dev/null
+++ b/src/pybind11/docs/upgrade.rst
@@ -0,0 +1,404 @@
+Upgrade guide
+#############
+
+This is a companion guide to the :doc:`changelog`. While the changelog briefly
+lists all of the new features, improvements and bug fixes, this upgrade guide
+focuses only the subset which directly impacts your experience when upgrading
+to a new version. But it goes into more detail. This includes things like
+deprecated APIs and their replacements, build system changes, general code
+modernization and other useful information.
+
+
+v2.2
+====
+
+Deprecation of the ``PYBIND11_PLUGIN`` macro
+--------------------------------------------
+
+``PYBIND11_MODULE`` is now the preferred way to create module entry points.
+The old macro emits a compile-time deprecation warning.
+
+.. code-block:: cpp
+
+    // old
+    PYBIND11_PLUGIN(example) {
+        py::module m("example", "documentation string");
+
+        m.def("add", [](int a, int b) { return a + b; });
+
+        return m.ptr();
+    }
+
+    // new
+    PYBIND11_MODULE(example, m) {
+        m.doc() = "documentation string"; // optional
+
+        m.def("add", [](int a, int b) { return a + b; });
+    }
+
+
+New API for defining custom constructors and pickling functions
+---------------------------------------------------------------
+
+The old placement-new custom constructors have been deprecated. The new approach
+uses ``py::init()`` and factory functions to greatly improve type safety.
+
+Placement-new can be called accidentally with an incompatible type (without any
+compiler errors or warnings), or it can initialize the same object multiple times
+if not careful with the Python-side ``__init__`` calls. The new-style custom
+constructors prevent such mistakes. See :ref:`custom_constructors` for details.
+
+.. code-block:: cpp
+
+    // old -- deprecated (runtime warning shown only in debug mode)
+    py::class<Foo>(m, "Foo")
+        .def("__init__", [](Foo &self, ...) {
+            new (&self) Foo(...); // uses placement-new
+        });
+
+    // new
+    py::class<Foo>(m, "Foo")
+        .def(py::init([](...) { // Note: no `self` argument
+            return new Foo(...); // return by raw pointer
+            // or: return std::make_unique<Foo>(...); // return by holder
+            // or: return Foo(...); // return by value (move constructor)
+        }));
+
+Mirroring the custom constructor changes, ``py::pickle()`` is now the preferred
+way to get and set object state. See :ref:`pickling` for details.
+
+.. code-block:: cpp
+
+    // old -- deprecated (runtime warning shown only in debug mode)
+    py::class<Foo>(m, "Foo")
+        ...
+        .def("__getstate__", [](const Foo &self) {
+            return py::make_tuple(self.value1(), self.value2(), ...);
+        })
+        .def("__setstate__", [](Foo &self, py::tuple t) {
+            new (&self) Foo(t[0].cast<std::string>(), ...);
+        });
+
+    // new
+    py::class<Foo>(m, "Foo")
+        ...
+        .def(py::pickle(
+            [](const Foo &self) { // __getstate__
+                return py::make_tuple(f.value1(), f.value2(), ...); // unchanged
+            },
+            [](py::tuple t) { // __setstate__, note: no `self` argument
+                return new Foo(t[0].cast<std::string>(), ...);
+                // or: return std::make_unique<Foo>(...); // return by holder
+                // or: return Foo(...); // return by value (move constructor)
+            }
+        ));
+
+For both the constructors and pickling, warnings are shown at module
+initialization time (on import, not when the functions are called).
+They're only visible when compiled in debug mode. Sample warning:
+
+.. code-block:: none
+
+    pybind11-bound class 'mymodule.Foo' is using an old-style placement-new '__init__'
+    which has been deprecated. See the upgrade guide in pybind11's docs.
+
+
+Stricter enforcement of hidden symbol visibility for pybind11 modules
+---------------------------------------------------------------------
+
+pybind11 now tries to actively enforce hidden symbol visibility for modules.
+If you're using either one of pybind11's :doc:`CMake or Python build systems
+<compiling>` (the two example repositories) and you haven't been exporting any
+symbols, there's nothing to be concerned about. All the changes have been done
+transparently in the background. If you were building manually or relied on
+specific default visibility, read on.
+
+Setting default symbol visibility to *hidden* has always been recommended for
+pybind11 (see :ref:`faq:symhidden`). On Linux and macOS, hidden symbol
+visibility (in conjunction with the ``strip`` utility) yields much smaller
+module binaries. `CPython's extension docs`_ also recommend hiding symbols
+by default, with the goal of avoiding symbol name clashes between modules.
+Starting with v2.2, pybind11 enforces this more strictly: (1) by declaring
+all symbols inside the ``pybind11`` namespace as hidden and (2) by including
+the ``-fvisibility=hidden`` flag on Linux and macOS (only for extension
+modules, not for embedding the interpreter).
+
+.. _CPython's extension docs: https://docs.python.org/3/extending/extending.html#providing-a-c-api-for-an-extension-module
+
+The namespace-scope hidden visibility is done automatically in pybind11's
+headers and it's generally transparent to users. It ensures that:
+
+* Modules compiled with different pybind11 versions don't clash with each other.
+
+* Some new features, like ``py::module_local`` bindings, can work as intended.
+
+The ``-fvisibility=hidden`` flag applies the same visibility to user bindings
+outside of the ``pybind11`` namespace. It's now set automatic by pybind11's
+CMake and Python build systems, but this needs to be done manually by users
+of other build systems. Adding this flag:
+
+* Minimizes the chances of symbol conflicts between modules. E.g. if two
+  unrelated modules were statically linked to different (ABI-incompatible)
+  versions of the same third-party library, a symbol clash would be likely
+  (and would end with unpredictable results).
+
+* Produces smaller binaries on Linux and macOS, as pointed out previously.
+
+Within pybind11's CMake build system, ``pybind11_add_module`` has always been
+setting the ``-fvisibility=hidden`` flag in release mode. From now on, it's
+being applied unconditionally, even in debug mode and it can no longer be opted
+out of with the ``NO_EXTRAS`` option. The ``pybind11::module`` target now also
+adds this flag to it's interface. The ``pybind11::embed`` target is unchanged.
+
+The most significant change here is for the ``pybind11::module`` target. If you
+were previously relying on default visibility, i.e. if your Python module was
+doubling as a shared library with dependents, you'll need to either export
+symbols manually (recommended for cross-platform libraries) or factor out the
+shared library (and have the Python module link to it like the other
+dependents). As a temporary workaround, you can also restore default visibility
+using the CMake code below, but this is not recommended in the long run:
+
+.. code-block:: cmake
+
+    target_link_libraries(mymodule PRIVATE pybind11::module)
+
+    add_library(restore_default_visibility INTERFACE)
+    target_compile_options(restore_default_visibility INTERFACE -fvisibility=default)
+    target_link_libraries(mymodule PRIVATE restore_default_visibility)
+
+
+Local STL container bindings
+----------------------------
+
+Previous pybind11 versions could only bind types globally -- all pybind11
+modules, even unrelated ones, would have access to the same exported types.
+However, this would also result in a conflict if two modules exported the
+same C++ type, which is especially problematic for very common types, e.g.
+``std::vector<int>``. :ref:`module_local` were added to resolve this (see
+that section for a complete usage guide).
+
+``py::class_`` still defaults to global bindings (because these types are
+usually unique across modules), however in order to avoid clashes of opaque
+types, ``py::bind_vector`` and ``py::bind_map`` will now bind STL containers
+as ``py::module_local`` if their elements are: builtins (``int``, ``float``,
+etc.), not bound using ``py::class_``, or bound as ``py::module_local``. For
+example, this change allows multiple modules to bind ``std::vector<int>``
+without causing conflicts. See :ref:`stl_bind` for more details.
+
+When upgrading to this version, if you have multiple modules which depend on
+a single global binding of an STL container, note that all modules can still
+accept foreign  ``py::module_local`` types in the direction of Python-to-C++.
+The locality only affects the C++-to-Python direction. If this is needed in
+multiple modules, you'll need to either:
+
+* Add a copy of the same STL binding to all of the modules which need it.
+
+* Restore the global status of that single binding by marking it
+  ``py::module_local(false)``.
+
+The latter is an easy workaround, but in the long run it would be best to
+localize all common type bindings in order to avoid conflicts with
+third-party modules.
+
+
+Negative strides for Python buffer objects and numpy arrays
+-----------------------------------------------------------
+
+Support for negative strides required changing the integer type from unsigned
+to signed in the interfaces of ``py::buffer_info`` and ``py::array``. If you
+have compiler warnings enabled, you may notice some new conversion warnings
+after upgrading. These can be resolved using ``static_cast``.
+
+
+Deprecation of some ``py::object`` APIs
+---------------------------------------
+
+To compare ``py::object`` instances by pointer, you should now use
+``obj1.is(obj2)`` which is equivalent to ``obj1 is obj2`` in Python.
+Previously, pybind11 used ``operator==`` for this (``obj1 == obj2``), but
+that could be confusing and is now deprecated (so that it can eventually
+be replaced with proper rich object comparison in a future release).
+
+For classes which inherit from ``py::object``, ``borrowed`` and ``stolen``
+were previously available as protected constructor tags. Now the types
+should be used directly instead: ``borrowed_t{}`` and ``stolen_t{}``
+(`#771 <https://github.com/pybind/pybind11/pull/771>`_).
+
+
+Stricter compile-time error checking
+------------------------------------
+
+Some error checks have been moved from run time to compile time. Notably,
+automatic conversion of ``std::shared_ptr<T>`` is not possible when ``T`` is
+not directly registered with ``py::class_<T>`` (e.g. ``std::shared_ptr<int>``
+or ``std::shared_ptr<std::vector<T>>`` are not automatically convertible).
+Attempting to bind a function with such arguments now results in a compile-time
+error instead of waiting to fail at run time.
+
+``py::init<...>()`` constructor definitions are also stricter and now prevent
+bindings which could cause unexpected behavior:
+
+.. code-block:: cpp
+
+    struct Example {
+        Example(int &);
+    };
+
+    py::class_<Example>(m, "Example")
+        .def(py::init<int &>()); // OK, exact match
+        // .def(py::init<int>()); // compile-time error, mismatch
+
+A non-``const`` lvalue reference is not allowed to bind to an rvalue. However,
+note that a constructor taking ``const T &`` can still be registered using
+``py::init<T>()`` because a ``const`` lvalue reference can bind to an rvalue.
+
+v2.1
+====
+
+Minimum compiler versions are enforced at compile time
+------------------------------------------------------
+
+The minimums also apply to v2.0 but the check is now explicit and a compile-time
+error is raised if the compiler does not meet the requirements:
+
+* GCC >= 4.8
+* clang >= 3.3 (appleclang >= 5.0)
+* MSVC >= 2015u3
+* Intel C++ >= 15.0
+
+
+The ``py::metaclass`` attribute is not required for static properties
+---------------------------------------------------------------------
+
+Binding classes with static properties is now possible by default. The
+zero-parameter version of ``py::metaclass()`` is deprecated. However, a new
+one-parameter ``py::metaclass(python_type)`` version was added for rare
+cases when a custom metaclass is needed to override pybind11's default.
+
+.. code-block:: cpp
+
+    // old -- emits a deprecation warning
+    py::class_<Foo>(m, "Foo", py::metaclass())
+        .def_property_readonly_static("foo", ...);
+
+    // new -- static properties work without the attribute
+    py::class_<Foo>(m, "Foo")
+        .def_property_readonly_static("foo", ...);
+
+    // new -- advanced feature, override pybind11's default metaclass
+    py::class_<Bar>(m, "Bar", py::metaclass(custom_python_type))
+        ...
+
+
+v2.0
+====
+
+Breaking changes in ``py::class_``
+----------------------------------
+
+These changes were necessary to make type definitions in pybind11
+future-proof, to support PyPy via its ``cpyext`` mechanism (`#527
+<https://github.com/pybind/pybind11/pull/527>`_), and to improve efficiency
+(`rev. 86d825 <https://github.com/pybind/pybind11/commit/86d825>`_).
+
+1. Declarations of types that provide access via the buffer protocol must
+   now include the ``py::buffer_protocol()`` annotation as an argument to
+   the ``py::class_`` constructor.
+
+   .. code-block:: cpp
+
+       py::class_<Matrix>("Matrix", py::buffer_protocol())
+           .def(py::init<...>())
+           .def_buffer(...);
+
+2. Classes which include static properties (e.g. ``def_readwrite_static()``)
+   must now include the ``py::metaclass()`` attribute. Note: this requirement
+   has since been removed in v2.1. If you're upgrading from 1.x, it's
+   recommended to skip directly to v2.1 or newer.
+
+3. This version of pybind11 uses a redesigned mechanism for instantiating
+   trampoline classes that are used to override virtual methods from within
+   Python. This led to the following user-visible syntax change:
+
+   .. code-block:: cpp
+
+       // old v1.x syntax
+       py::class_<TrampolineClass>("MyClass")
+           .alias<MyClass>()
+           ...
+
+       // new v2.x syntax
+       py::class_<MyClass, TrampolineClass>("MyClass")
+           ...
+
+   Importantly, both the original and the trampoline class are now specified
+   as arguments to the ``py::class_`` template, and the ``alias<..>()`` call
+   is gone. The new scheme has zero overhead in cases when Python doesn't
+   override any functions of the underlying C++ class.
+   `rev. 86d825 <https://github.com/pybind/pybind11/commit/86d825>`_.
+
+   The class type must be the first template argument given to ``py::class_``
+   while the trampoline can be mixed in arbitrary order with other arguments
+   (see the following section).
+
+
+Deprecation of the ``py::base<T>()`` attribute
+----------------------------------------------
+
+``py::base<T>()`` was deprecated in favor of specifying ``T`` as a template
+argument to ``py::class_``. This new syntax also supports multiple inheritance.
+Note that, while the type being exported must be the first argument in the
+``py::class_<Class, ...>`` template, the order of the following types (bases,
+holder and/or trampoline) is not important.
+
+.. code-block:: cpp
+
+    // old v1.x
+    py::class_<Derived>("Derived", py::base<Base>());
+
+    // new v2.x
+    py::class_<Derived, Base>("Derived");
+
+    // new -- multiple inheritance
+    py::class_<Derived, Base1, Base2>("Derived");
+
+    // new -- apart from `Derived` the argument order can be arbitrary
+    py::class_<Derived, Base1, Holder, Base2, Trampoline>("Derived");
+
+
+Out-of-the-box support for ``std::shared_ptr``
+----------------------------------------------
+
+The relevant type caster is now built in, so it's no longer necessary to
+include a declaration of the form:
+
+.. code-block:: cpp
+
+    PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
+
+Continuing to do so won’t cause an error or even a deprecation warning,
+but it's completely redundant.
+
+
+Deprecation of a few ``py::object`` APIs
+----------------------------------------
+
+All of the old-style calls emit deprecation warnings.
+
++---------------------------------------+---------------------------------------------+
+|  Old syntax                           |  New syntax                                 |
++=======================================+=============================================+
+| ``obj.call(args...)``                 | ``obj(args...)``                            |
++---------------------------------------+---------------------------------------------+
+| ``obj.str()``                         | ``py::str(obj)``                            |
++---------------------------------------+---------------------------------------------+
+| ``auto l = py::list(obj); l.check()`` | ``py::isinstance<py::list>(obj)``           |
++---------------------------------------+---------------------------------------------+
+| ``py::object(ptr, true)``             | ``py::reinterpret_borrow<py::object>(ptr)`` |
++---------------------------------------+---------------------------------------------+
+| ``py::object(ptr, false)``            | ``py::reinterpret_steal<py::object>(ptr)``  |
++---------------------------------------+---------------------------------------------+
+| ``if (obj.attr("foo"))``              | ``if (py::hasattr(obj, "foo"))``            |
++---------------------------------------+---------------------------------------------+
+| ``if (obj["bar"])``                   | ``if (obj.contains("bar"))``                |
++---------------------------------------+---------------------------------------------+
diff --git a/src/pybind11/include/pybind11/attr.h b/src/pybind11/include/pybind11/attr.h
index 15d6208..6962d6f 100644
--- a/src/pybind11/include/pybind11/attr.h
+++ b/src/pybind11/include/pybind11/attr.h
@@ -12,7 +12,7 @@
 
 #include "cast.h"
 
-NAMESPACE_BEGIN(pybind11)
+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
 /// \addtogroup annotations
 /// @{
@@ -64,6 +64,9 @@ struct metaclass {
     explicit metaclass(handle value) : value(value) { }
 };
 
+/// Annotation that marks a class as local to the module:
+struct module_local { const bool value; constexpr module_local(bool v = true) : value(v) { } };
+
 /// Annotation to mark enums as an arithmetic type
 struct arithmetic { };
 
@@ -113,8 +116,6 @@ enum op_id : int;
 enum op_type : int;
 struct undefined_t;
 template <op_id id, op_type ot, typename L = undefined_t, typename R = undefined_t> struct op_;
-template <typename... Args> struct init;
-template <typename... Args> struct init_alias;
 inline void keep_alive_impl(size_t Nurse, size_t Patient, function_call &call, handle ret);
 
 /// Internal data structure which holds metadata about a keyword argument
@@ -132,8 +133,8 @@ struct argument_record {
 /// Internal data structure which holds metadata about a bound function (signature, overloads, etc.)
 struct function_record {
     function_record()
-        : is_constructor(false), is_stateless(false), is_operator(false),
-          has_args(false), has_kwargs(false), is_method(false) { }
+        : is_constructor(false), is_new_style_constructor(false), is_stateless(false),
+          is_operator(false), has_args(false), has_kwargs(false), is_method(false) { }
 
     /// Function name
     char *name = nullptr; /* why no C++ strings? They generate heavier code.. */
@@ -162,6 +163,9 @@ struct function_record {
     /// True if name == '__init__'
     bool is_constructor : 1;
 
+    /// True if this is a new-style `__init__` defined in `detail/init.h`
+    bool is_new_style_constructor : 1;
+
     /// True if this is a stateless function pointer
     bool is_stateless : 1;
 
@@ -196,7 +200,8 @@ struct function_record {
 /// Special data structure which (temporarily) holds metadata about a bound class
 struct type_record {
     PYBIND11_NOINLINE type_record()
-        : multiple_inheritance(false), dynamic_attr(false), buffer_protocol(false) { }
+        : multiple_inheritance(false), dynamic_attr(false), buffer_protocol(false),
+          default_holder(true), module_local(false) { }
 
     /// Handle to the parent scope
     handle scope;
@@ -210,17 +215,20 @@ struct type_record {
     /// How large is the underlying C++ type?
     size_t type_size = 0;
 
+    /// What is the alignment of the underlying C++ type?
+    size_t type_align = 0;
+
     /// How large is the type's holder?
     size_t holder_size = 0;
 
     /// The global operator new can be overridden with a class-specific variant
-    void *(*operator_new)(size_t) = ::operator new;
+    void *(*operator_new)(size_t) = nullptr;
 
-    /// Function pointer to class_<..>::init_holder
-    void (*init_holder)(instance *, const void *) = nullptr;
+    /// Function pointer to class_<..>::init_instance
+    void (*init_instance)(instance *, const void *) = nullptr;
 
     /// Function pointer to class_<..>::dealloc
-    void (*dealloc)(const detail::value_and_holder &) = nullptr;
+    void (*dealloc)(detail::value_and_holder &) = nullptr;
 
     /// List of base classes of the newly created type
     list bases;
@@ -243,6 +251,9 @@ struct type_record {
     /// Is the default (unique_ptr) holder type used?
     bool default_holder : 1;
 
+    /// Is the class definition local to the module shared object?
+    bool module_local : 1;
+
     PYBIND11_NOINLINE void add_base(const std::type_info &base, void *(*caster)(void *)) {
         auto base_info = detail::get_type_info(base, false);
         if (!base_info) {
@@ -271,12 +282,15 @@ struct type_record {
     }
 };
 
-inline function_call::function_call(function_record &f, handle p) :
+inline function_call::function_call(const function_record &f, handle p) :
         func(f), parent(p) {
     args.reserve(f.nargs);
     args_convert.reserve(f.nargs);
 }
 
+/// Tag for a new-style `__init__` defined in `detail/init.h`
+struct is_new_style_constructor { };
+
 /**
  * Partial template specializations to process custom attributes provided to
  * cpp_function_ and class_. These are either used to initialize the respective
@@ -335,6 +349,10 @@ template <> struct process_attribute<is_operator> : process_attribute_default<is
     static void init(const is_operator &, function_record *r) { r->is_operator = true; }
 };
 
+template <> struct process_attribute<is_new_style_constructor> : process_attribute_default<is_new_style_constructor> {
+    static void init(const is_new_style_constructor &, function_record *r) { r->is_new_style_constructor = true; }
+};
+
 /// Process a keyword argument attribute (*without* a default value)
 template <> struct process_attribute<arg> : process_attribute_default<arg> {
     static void init(const arg &a, function_record *r) {
@@ -408,6 +426,10 @@ struct process_attribute<metaclass> : process_attribute_default<metaclass> {
     static void init(const metaclass &m, type_record *r) { r->metaclass = m.value; }
 };
 
+template <>
+struct process_attribute<module_local> : process_attribute_default<module_local> {
+    static void init(const module_local &l, type_record *r) { r->module_local = l.value; }
+};
 
 /// Process an 'arithmetic' attribute for enums (does nothing here)
 template <>
@@ -468,4 +490,4 @@ constexpr bool expected_num_args(size_t nargs, bool has_args, bool has_kwargs) {
 }
 
 NAMESPACE_END(detail)
-NAMESPACE_END(pybind11)
+NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/src/pybind11/include/pybind11/buffer_info.h b/src/pybind11/include/pybind11/buffer_info.h
index 6d1167d..1f4115a 100644
--- a/src/pybind11/include/pybind11/buffer_info.h
+++ b/src/pybind11/include/pybind11/buffer_info.h
@@ -9,9 +9,9 @@
 
 #pragma once
 
-#include "common.h"
+#include "detail/common.h"
 
-NAMESPACE_BEGIN(pybind11)
+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
 /// Information record describing a Python buffer object
 struct buffer_info {
@@ -21,14 +21,15 @@ struct buffer_info {
     std::string format;           // For homogeneous buffers, this should be set to format_descriptor<T>::format()
     ssize_t ndim = 0;             // Number of dimensions
     std::vector<ssize_t> shape;   // Shape of the tensor (1 entry per dimension)
-    std::vector<ssize_t> strides; // Number of entries between adjacent entries (for each per dimension)
+    std::vector<ssize_t> strides; // Number of bytes between adjacent entries (for each per dimension)
+    bool readonly = false;        // flag to indicate if the underlying storage may be written to
 
     buffer_info() { }
 
     buffer_info(void *ptr, ssize_t itemsize, const std::string &format, ssize_t ndim,
-                detail::any_container<ssize_t> shape_in, detail::any_container<ssize_t> strides_in)
+                detail::any_container<ssize_t> shape_in, detail::any_container<ssize_t> strides_in, bool readonly=false)
     : ptr(ptr), itemsize(itemsize), size(1), format(format), ndim(ndim),
-      shape(std::move(shape_in)), strides(std::move(strides_in)) {
+      shape(std::move(shape_in)), strides(std::move(strides_in)), readonly(readonly) {
         if (ndim != (ssize_t) shape.size() || ndim != (ssize_t) strides.size())
             pybind11_fail("buffer_info: ndim doesn't match shape and/or strides length");
         for (size_t i = 0; i < (size_t) ndim; ++i)
@@ -36,19 +37,23 @@ struct buffer_info {
     }
 
     template <typename T>
-    buffer_info(T *ptr, detail::any_container<ssize_t> shape_in, detail::any_container<ssize_t> strides_in)
-    : buffer_info(private_ctr_tag(), ptr, sizeof(T), format_descriptor<T>::format(), static_cast<ssize_t>(shape_in->size()), std::move(shape_in), std::move(strides_in)) { }
+    buffer_info(T *ptr, detail::any_container<ssize_t> shape_in, detail::any_container<ssize_t> strides_in, bool readonly=false)
+    : buffer_info(private_ctr_tag(), ptr, sizeof(T), format_descriptor<T>::format(), static_cast<ssize_t>(shape_in->size()), std::move(shape_in), std::move(strides_in), readonly) { }
 
-    buffer_info(void *ptr, ssize_t itemsize, const std::string &format, ssize_t size)
-    : buffer_info(ptr, itemsize, format, 1, {size}, {itemsize}) { }
+    buffer_info(void *ptr, ssize_t itemsize, const std::string &format, ssize_t size, bool readonly=false)
+    : buffer_info(ptr, itemsize, format, 1, {size}, {itemsize}, readonly) { }
 
     template <typename T>
-    buffer_info(T *ptr, ssize_t size)
-    : buffer_info(ptr, sizeof(T), format_descriptor<T>::format(), size) { }
+    buffer_info(T *ptr, ssize_t size, bool readonly=false)
+    : buffer_info(ptr, sizeof(T), format_descriptor<T>::format(), size, readonly) { }
+
+    template <typename T>
+    buffer_info(const T *ptr, ssize_t size, bool readonly=true)
+    : buffer_info(const_cast<T*>(ptr), sizeof(T), format_descriptor<T>::format(), size, readonly) { }
 
     explicit buffer_info(Py_buffer *view, bool ownview = true)
     : buffer_info(view->buf, view->itemsize, view->format, view->ndim,
-            {view->shape, view->shape + view->ndim}, {view->strides, view->strides + view->ndim}) {
+            {view->shape, view->shape + view->ndim}, {view->strides, view->strides + view->ndim}, view->readonly) {
         this->view = view;
         this->ownview = ownview;
     }
@@ -70,6 +75,7 @@ struct buffer_info {
         strides = std::move(rhs.strides);
         std::swap(view, rhs.view);
         std::swap(ownview, rhs.ownview);
+        readonly = rhs.readonly;
         return *this;
     }
 
@@ -81,8 +87,8 @@ private:
     struct private_ctr_tag { };
 
     buffer_info(private_ctr_tag, void *ptr, ssize_t itemsize, const std::string &format, ssize_t ndim,
-                detail::any_container<ssize_t> &&shape_in, detail::any_container<ssize_t> &&strides_in)
-    : buffer_info(ptr, itemsize, format, ndim, std::move(shape_in), std::move(strides_in)) { }
+                detail::any_container<ssize_t> &&shape_in, detail::any_container<ssize_t> &&strides_in, bool readonly)
+    : buffer_info(ptr, itemsize, format, ndim, std::move(shape_in), std::move(strides_in), readonly) { }
 
     Py_buffer *view = nullptr;
     bool ownview = false;
@@ -105,4 +111,4 @@ template <typename T> struct compare_buffer_info<T, detail::enable_if_t<std::is_
 };
 
 NAMESPACE_END(detail)
-NAMESPACE_END(pybind11)
+NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/src/pybind11/include/pybind11/cast.h b/src/pybind11/include/pybind11/cast.h
index 27bd053..a0b4d1b 100644
--- a/src/pybind11/include/pybind11/cast.h
+++ b/src/pybind11/include/pybind11/cast.h
@@ -11,11 +11,13 @@
 #pragma once
 
 #include "pytypes.h"
-#include "typeid.h"
-#include "descr.h"
+#include "detail/typeid.h"
+#include "detail/descr.h"
+#include "detail/internals.h"
 #include <array>
 #include <limits>
 #include <tuple>
+#include <type_traits>
 
 #if defined(PYBIND11_CPP17)
 #  if defined(__has_include)
@@ -30,86 +32,12 @@
 #include <string_view>
 #endif
 
-NAMESPACE_BEGIN(pybind11)
-NAMESPACE_BEGIN(detail)
-// Forward declarations:
-inline PyTypeObject *make_static_property_type();
-inline PyTypeObject *make_default_metaclass();
-inline PyObject *make_object_base_type(PyTypeObject *metaclass);
-struct value_and_holder;
-
-/// Additional type information which does not fit into the PyTypeObject
-struct type_info {
-    PyTypeObject *type;
-    const std::type_info *cpptype;
-    size_t type_size, holder_size_in_ptrs;
-    void *(*operator_new)(size_t);
-    void (*init_holder)(instance *, const void *);
-    void (*dealloc)(const value_and_holder &v_h);
-    std::vector<PyObject *(*)(PyObject *, PyTypeObject *)> implicit_conversions;
-    std::vector<std::pair<const std::type_info *, void *(*)(void *)>> implicit_casts;
-    std::vector<bool (*)(PyObject *, void *&)> *direct_conversions;
-    buffer_info *(*get_buffer)(PyObject *, void *) = nullptr;
-    void *get_buffer_data = nullptr;
-    /* A simple type never occurs as a (direct or indirect) parent
-     * of a class that makes use of multiple inheritance */
-    bool simple_type : 1;
-    /* True if there is no multiple inheritance in this type's inheritance tree */
-    bool simple_ancestors : 1;
-    /* for base vs derived holder_type checks */
-    bool default_holder : 1;
-};
+#if defined(__cpp_lib_char8_t) && __cpp_lib_char8_t >= 201811L
+#  define PYBIND11_HAS_U8STRING
+#endif
 
-// Store the static internals pointer in a version-specific function so that we're guaranteed it
-// will be distinct for modules compiled for different pybind11 versions.  Without this, some
-// compilers (i.e. gcc) can use the same static pointer storage location across different .so's,
-// even though the `get_internals()` function itself is local to each shared object.
-template <int = PYBIND11_VERSION_MAJOR, int = PYBIND11_VERSION_MINOR>
-internals *&get_internals_ptr() { static internals *internals_ptr = nullptr; return internals_ptr; }
-
-PYBIND11_NOINLINE inline internals &get_internals() {
-    internals *&internals_ptr = get_internals_ptr();
-    if (internals_ptr)
-        return *internals_ptr;
-    handle builtins(PyEval_GetBuiltins());
-    const char *id = PYBIND11_INTERNALS_ID;
-    if (builtins.contains(id) && isinstance<capsule>(builtins[id])) {
-        internals_ptr = *static_cast<internals **>(capsule(builtins[id]));
-    } else {
-        internals_ptr = new internals();
-        #if defined(WITH_THREAD)
-            PyEval_InitThreads();
-            PyThreadState *tstate = PyThreadState_Get();
-            internals_ptr->tstate = PyThread_create_key();
-            PyThread_set_key_value(internals_ptr->tstate, tstate);
-            internals_ptr->istate = tstate->interp;
-        #endif
-        builtins[id] = capsule(&internals_ptr);
-        internals_ptr->registered_exception_translators.push_front(
-            [](std::exception_ptr p) -> void {
-                try {
-                    if (p) std::rethrow_exception(p);
-                } catch (error_already_set &e)           { e.restore();                                    return;
-                } catch (const builtin_exception &e)     { e.set_error();                                  return;
-                } catch (const std::bad_alloc &e)        { PyErr_SetString(PyExc_MemoryError,   e.what()); return;
-                } catch (const std::domain_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return;
-                } catch (const std::invalid_argument &e) { PyErr_SetString(PyExc_ValueError,    e.what()); return;
-                } catch (const std::length_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return;
-                } catch (const std::out_of_range &e)     { PyErr_SetString(PyExc_IndexError,    e.what()); return;
-                } catch (const std::range_error &e)      { PyErr_SetString(PyExc_ValueError,    e.what()); return;
-                } catch (const std::exception &e)        { PyErr_SetString(PyExc_RuntimeError,  e.what()); return;
-                } catch (...) {
-                    PyErr_SetString(PyExc_RuntimeError, "Caught an unknown exception!");
-                    return;
-                }
-            }
-        );
-        internals_ptr->static_property_type = make_static_property_type();
-        internals_ptr->default_metaclass = make_default_metaclass();
-        internals_ptr->instance_base = make_object_base_type(internals_ptr->default_metaclass);
-    }
-    return *internals_ptr;
-}
+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+NAMESPACE_BEGIN(detail)
 
 /// A life support system for temporary objects created by `type_caster::load()`.
 /// Adding a patient will keep it alive up until the enclosing function returns.
@@ -198,7 +126,7 @@ PYBIND11_NOINLINE inline void all_type_info_populate(PyTypeObject *t, std::vecto
             // registered types
             if (i + 1 == check.size()) {
                 // When we're at the end, we can pop off the current element to avoid growing
-                // `check` when adding just one base (which is typical--.e. when there is no
+                // `check` when adding just one base (which is typical--i.e. when there is no
                 // multiple inheritance)
                 check.pop_back();
                 i--;
@@ -242,13 +170,30 @@ PYBIND11_NOINLINE inline detail::type_info* get_type_info(PyTypeObject *type) {
     return bases.front();
 }
 
-PYBIND11_NOINLINE inline detail::type_info *get_type_info(const std::type_info &tp,
-                                                          bool throw_if_missing = false) {
-    auto &types = get_internals().registered_types_cpp;
+inline detail::type_info *get_local_type_info(const std::type_index &tp) {
+    auto &locals = registered_local_types_cpp();
+    auto it = locals.find(tp);
+    if (it != locals.end())
+        return it->second;
+    return nullptr;
+}
 
-    auto it = types.find(std::type_index(tp));
+inline detail::type_info *get_global_type_info(const std::type_index &tp) {
+    auto &types = get_internals().registered_types_cpp;
+    auto it = types.find(tp);
     if (it != types.end())
-        return (detail::type_info *) it->second;
+        return it->second;
+    return nullptr;
+}
+
+/// Return the type info for a given C++ type; on lookup failure can either throw or return nullptr.
+PYBIND11_NOINLINE inline detail::type_info *get_type_info(const std::type_index &tp,
+                                                          bool throw_if_missing = false) {
+    if (auto ltype = get_local_type_info(tp))
+        return ltype;
+    if (auto gtype = get_global_type_info(tp))
+        return gtype;
+
     if (throw_if_missing) {
         std::string tname = tp.name();
         detail::clean_type_id(tname);
@@ -263,16 +208,20 @@ PYBIND11_NOINLINE inline handle get_type_handle(const std::type_info &tp, bool t
 }
 
 struct value_and_holder {
-    instance *inst;
-    size_t index;
-    const detail::type_info *type;
-    void **vh;
+    instance *inst = nullptr;
+    size_t index = 0u;
+    const detail::type_info *type = nullptr;
+    void **vh = nullptr;
 
+    // Main constructor for a found value/holder:
     value_and_holder(instance *i, const detail::type_info *type, size_t vpos, size_t index) :
         inst{i}, index{index}, type{type},
         vh{inst->simple_layout ? inst->simple_value_holder : &inst->nonsimple.values_and_holders[vpos]}
     {}
 
+    // Default constructor (used to signal a value-and-holder not found by get_value_and_holder())
+    value_and_holder() {}
+
     // Used for past-the-end iterator
     value_and_holder(size_t index) : index{index} {}
 
@@ -288,13 +237,28 @@ struct value_and_holder {
     bool holder_constructed() const {
         return inst->simple_layout
             ? inst->simple_holder_constructed
-            : inst->nonsimple.holder_constructed[index];
+            : inst->nonsimple.status[index] & instance::status_holder_constructed;
     }
-    void set_holder_constructed() {
+    void set_holder_constructed(bool v = true) {
         if (inst->simple_layout)
-            inst->simple_holder_constructed = true;
+            inst->simple_holder_constructed = v;
+        else if (v)
+            inst->nonsimple.status[index] |= instance::status_holder_constructed;
         else
-            inst->nonsimple.holder_constructed[index] = true;
+            inst->nonsimple.status[index] &= (uint8_t) ~instance::status_holder_constructed;
+    }
+    bool instance_registered() const {
+        return inst->simple_layout
+            ? inst->simple_instance_registered
+            : inst->nonsimple.status[index] & instance::status_instance_registered;
+    }
+    void set_instance_registered(bool v = true) {
+        if (inst->simple_layout)
+            inst->simple_instance_registered = v;
+        else if (v)
+            inst->nonsimple.status[index] |= instance::status_instance_registered;
+        else
+            inst->nonsimple.status[index] &= (uint8_t) ~instance::status_instance_registered;
     }
 };
 
@@ -310,15 +274,14 @@ public:
 
     struct iterator {
     private:
-        instance *inst;
-        using vec_iter = std::vector<detail::type_info *>::const_iterator;
-        vec_iter typeit;
+        instance *inst = nullptr;
+        const type_vec *types = nullptr;
         value_and_holder curr;
         friend struct values_and_holders;
-        iterator(instance *inst, const type_vec &tinfo)
-            : inst{inst}, typeit{tinfo.begin()},
+        iterator(instance *inst, const type_vec *tinfo)
+            : inst{inst}, types{tinfo},
             curr(inst /* instance */,
-                 tinfo.size() > 0 ? *typeit : nullptr /* type info */,
+                 types->empty() ? nullptr : (*types)[0] /* type info */,
                  0, /* vpos: (non-simple types only): the first vptr comes first */
                  0 /* index */)
         {}
@@ -328,18 +291,17 @@ public:
         bool operator==(const iterator &other) { return curr.index == other.curr.index; }
         bool operator!=(const iterator &other) { return curr.index != other.curr.index; }
         iterator &operator++() {
-            if (!inst->simple_layout) {
-                curr.vh += 1 + (*typeit)->holder_size_in_ptrs;
-                curr.type = *(++typeit);
-            }
+            if (!inst->simple_layout)
+                curr.vh += 1 + (*types)[curr.index]->holder_size_in_ptrs;
             ++curr.index;
+            curr.type = curr.index < types->size() ? (*types)[curr.index] : nullptr;
             return *this;
         }
         value_and_holder &operator*() { return curr; }
         value_and_holder *operator->() { return &curr; }
     };
 
-    iterator begin() { return iterator(inst, tinfo); }
+    iterator begin() { return iterator(inst, &tinfo); }
     iterator end() { return iterator(tinfo.size()); }
 
     iterator find(const type_info *find_type) {
@@ -361,7 +323,7 @@ public:
  * The returned object should be short-lived: in particular, it must not outlive the called-upon
  * instance.
  */
-PYBIND11_NOINLINE inline value_and_holder instance::get_value_and_holder(const type_info *find_type /*= nullptr default in common.h*/) {
+PYBIND11_NOINLINE inline value_and_holder instance::get_value_and_holder(const type_info *find_type /*= nullptr default in common.h*/, bool throw_if_missing /*= true in common.h*/) {
     // Optimize common case:
     if (!find_type || Py_TYPE(this) == find_type->type)
         return value_and_holder(this, find_type, 0, 0);
@@ -371,6 +333,9 @@ PYBIND11_NOINLINE inline value_and_holder instance::get_value_and_holder(const t
     if (it != vhs.end())
         return *it;
 
+    if (!throw_if_missing)
+        return value_and_holder();
+
 #if defined(NDEBUG)
     pybind11_fail("pybind11::detail::instance::get_value_and_holder: "
             "type is not a pybind11 base of the given instance "
@@ -397,6 +362,7 @@ PYBIND11_NOINLINE inline void instance::allocate_layout() {
     if (simple_layout) {
         simple_value_holder[0] = nullptr;
         simple_holder_constructed = false;
+        simple_instance_registered = false;
     }
     else { // multiple base types or a too-large holder
         // Allocate space to hold: [v1*][h1][v2*][h2]...[bb...] where [vN*] is a value pointer,
@@ -409,7 +375,7 @@ PYBIND11_NOINLINE inline void instance::allocate_layout() {
             space += t->holder_size_in_ptrs; // holder instance
         }
         size_t flags_at = space;
-        space += size_in_ptrs(n_types * sizeof(bool)); // holder constructed flags
+        space += size_in_ptrs(n_types); // status bytes (holder_constructed and instance_registered)
 
         // Allocate space for flags, values, and holders, and initialize it to 0 (flags and values,
         // in particular, need to be 0).  Use Python's memory allocation functions: in Python 3.6
@@ -424,7 +390,7 @@ PYBIND11_NOINLINE inline void instance::allocate_layout() {
         if (!nonsimple.values_and_holders) throw std::bad_alloc();
         std::memset(nonsimple.values_and_holders, 0, space * sizeof(void *));
 #endif
-        nonsimple.holder_constructed = reinterpret_cast<bool *>(&nonsimple.values_and_holders[flags_at]);
+        nonsimple.status = reinterpret_cast<uint8_t *>(&nonsimple.values_and_holders[flags_at]);
     }
     owned = true;
 }
@@ -482,7 +448,6 @@ PYBIND11_NOINLINE inline std::string error_string() {
                 handle(frame->f_code->co_name).cast<std::string>() + "\n";
             frame = frame->f_back;
         }
-        trace = trace->tb_next;
     }
 #endif
 
@@ -517,13 +482,15 @@ inline PyThreadState *get_thread_state_unchecked() {
 
 // Forward declarations
 inline void keep_alive_impl(handle nurse, handle patient);
-inline void register_instance(instance *self, void *valptr, const type_info *tinfo);
-inline PyObject *make_new_instance(PyTypeObject *type, bool allocate_value = true);
+inline PyObject *make_new_instance(PyTypeObject *type);
 
 class type_caster_generic {
 public:
     PYBIND11_NOINLINE type_caster_generic(const std::type_info &type_info)
-     : typeinfo(get_type_info(type_info)) { }
+        : typeinfo(get_type_info(type_info)), cpptype(&type_info) { }
+
+    type_caster_generic(const type_info *typeinfo)
+        : typeinfo(typeinfo), cpptype(typeinfo ? typeinfo->cpptype : nullptr) { }
 
     bool load(handle src, bool convert) {
         return load_impl<type_caster_generic>(src, convert);
@@ -544,12 +511,12 @@ public:
         auto it_instances = get_internals().registered_instances.equal_range(src);
         for (auto it_i = it_instances.first; it_i != it_instances.second; ++it_i) {
             for (auto instance_type : detail::all_type_info(Py_TYPE(it_i->second))) {
-                if (instance_type && instance_type == tinfo)
+                if (instance_type && same_type(*instance_type->cpptype, *tinfo->cpptype))
                     return handle((PyObject *) it_i->second).inc_ref();
             }
         }
 
-        auto inst = reinterpret_steal<object>(make_new_instance(tinfo->type, false /* don't allocate value */));
+        auto inst = reinterpret_steal<object>(make_new_instance(tinfo->type));
         auto wrapper = reinterpret_cast<instance *>(inst.ptr());
         wrapper->owned = false;
         void *&valueptr = values_and_holders(wrapper).begin()->value_ptr();
@@ -570,9 +537,17 @@ public:
             case return_value_policy::copy:
                 if (copy_constructor)
                     valueptr = copy_constructor(src);
-                else
-                    throw cast_error("return_value_policy = copy, but the "
-                                     "object is non-copyable!");
+                else {
+#if defined(NDEBUG)
+                    throw cast_error("return_value_policy = copy, but type is "
+                                     "non-copyable! (compile in debug mode for details)");
+#else
+                    std::string type_name(tinfo->cpptype->name());
+                    detail::clean_type_id(type_name);
+                    throw cast_error("return_value_policy = copy, but type " +
+                                     type_name + " is non-copyable!");
+#endif
+                }
                 wrapper->owned = true;
                 break;
 
@@ -581,9 +556,18 @@ public:
                     valueptr = move_constructor(src);
                 else if (copy_constructor)
                     valueptr = copy_constructor(src);
-                else
-                    throw cast_error("return_value_policy = move, but the "
-                                     "object is neither movable nor copyable!");
+                else {
+#if defined(NDEBUG)
+                    throw cast_error("return_value_policy = move, but type is neither "
+                                     "movable nor copyable! "
+                                     "(compile in debug mode for details)");
+#else
+                    std::string type_name(tinfo->cpptype->name());
+                    detail::clean_type_id(type_name);
+                    throw cast_error("return_value_policy = move, but type " +
+                                     type_name + " is neither movable nor copyable!");
+#endif
+                }
                 wrapper->owned = true;
                 break;
 
@@ -597,17 +581,30 @@ public:
                 throw cast_error("unhandled return_value_policy: should not happen!");
         }
 
-        register_instance(wrapper, valueptr, tinfo);
-        tinfo->init_holder(wrapper, existing_holder);
+        tinfo->init_instance(wrapper, existing_holder);
 
         return inst.release();
     }
 
-protected:
-
     // Base methods for generic caster; there are overridden in copyable_holder_caster
-    void load_value(const value_and_holder &v_h) {
-        value = v_h.value_ptr();
+    void load_value(value_and_holder &&v_h) {
+        auto *&vptr = v_h.value_ptr();
+        // Lazy allocation for unallocated values:
+        if (vptr == nullptr) {
+            auto *type = v_h.type ? v_h.type : typeinfo;
+            if (type->operator_new) {
+                vptr = type->operator_new(type->type_size);
+            } else {
+                #if defined(__cpp_aligned_new) && (!defined(_MSC_VER) || _MSC_VER >= 1912)
+                    if (type->type_align > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
+                        vptr = ::operator new(type->type_size,
+                                              std::align_val_t(type->type_align));
+                    else
+                #endif
+                vptr = ::operator new(type->type_size);
+            }
+        }
+        value = vptr;
     }
     bool try_implicit_casts(handle src, bool convert) {
         for (auto &cast : typeinfo->implicit_casts) {
@@ -628,13 +625,41 @@ protected:
     }
     void check_holder_compat() {}
 
+    PYBIND11_NOINLINE static void *local_load(PyObject *src, const type_info *ti) {
+        auto caster = type_caster_generic(ti);
+        if (caster.load(src, false))
+            return caster.value;
+        return nullptr;
+    }
+
+    /// Try to load with foreign typeinfo, if available. Used when there is no
+    /// native typeinfo, or when the native one wasn't able to produce a value.
+    PYBIND11_NOINLINE bool try_load_foreign_module_local(handle src) {
+        constexpr auto *local_key = PYBIND11_MODULE_LOCAL_ID;
+        const auto pytype = src.get_type();
+        if (!hasattr(pytype, local_key))
+            return false;
+
+        type_info *foreign_typeinfo = reinterpret_borrow<capsule>(getattr(pytype, local_key));
+        // Only consider this foreign loader if actually foreign and is a loader of the correct cpp type
+        if (foreign_typeinfo->module_local_load == &local_load
+            || (cpptype && !same_type(*cpptype, *foreign_typeinfo->cpptype)))
+            return false;
+
+        if (auto result = foreign_typeinfo->module_local_load(src.ptr(), foreign_typeinfo)) {
+            value = result;
+            return true;
+        }
+        return false;
+    }
+
     // Implementation of `load`; this takes the type of `this` so that it can dispatch the relevant
     // bits of code between here and copyable_holder_caster where the two classes need different
     // logic (without having to resort to virtual inheritance).
     template <typename ThisT>
     PYBIND11_NOINLINE bool load_impl(handle src, bool convert) {
-        if (!src || !typeinfo)
-            return false;
+        if (!src) return false;
+        if (!typeinfo) return try_load_foreign_module_local(src);
         if (src.is_none()) {
             // Defer accepting None to other overloads (if we aren't in convert mode):
             if (!convert) return false;
@@ -699,7 +724,17 @@ protected:
             if (this_.try_direct_conversions(src))
                 return true;
         }
-        return false;
+
+        // Failed to match local typeinfo. Try again with global.
+        if (typeinfo->module_local) {
+            if (auto gtype = get_global_type_info(*typeinfo->cpptype)) {
+                typeinfo = gtype;
+                return load(src, false);
+            }
+        }
+
+        // Global typeinfo has precedence over foreign module_local
+        return try_load_foreign_module_local(src);
     }
 
 
@@ -708,10 +743,8 @@ protected:
     // with .second = nullptr.  (p.first = nullptr is not an error: it becomes None).
     PYBIND11_NOINLINE static std::pair<const void *, const type_info *> src_and_type(
             const void *src, const std::type_info &cast_type, const std::type_info *rtti_type = nullptr) {
-        auto &internals = get_internals();
-        auto it = internals.registered_types_cpp.find(std::type_index(cast_type));
-        if (it != internals.registered_types_cpp.end())
-            return {src, (const type_info *) it->second};
+        if (auto *tpi = get_type_info(cast_type))
+            return {src, const_cast<const type_info *>(tpi)};
 
         // Not found, set error:
         std::string tname = rtti_type ? rtti_type->name() : cast_type.name();
@@ -722,6 +755,7 @@ protected:
     }
 
     const type_info *typeinfo = nullptr;
+    const std::type_info *cpptype = nullptr;
     void *value = nullptr;
 };
 
@@ -760,16 +794,69 @@ template <typename T, typename SFINAE = void> struct is_copy_constructible : std
 // Specialization for types that appear to be copy constructible but also look like stl containers
 // (we specifically check for: has `value_type` and `reference` with `reference = value_type&`): if
 // so, copy constructability depends on whether the value_type is copy constructible.
-template <typename Container> struct is_copy_constructible<Container, enable_if_t<
-        std::is_copy_constructible<Container>::value &&
-        std::is_same<typename Container::value_type &, typename Container::reference>::value
-    >> : std::is_copy_constructible<typename Container::value_type> {};
+template <typename Container> struct is_copy_constructible<Container, enable_if_t<all_of<
+        std::is_copy_constructible<Container>,
+        std::is_same<typename Container::value_type &, typename Container::reference>,
+        // Avoid infinite recursion
+        negation<std::is_same<Container, typename Container::value_type>>
+    >::value>> : is_copy_constructible<typename Container::value_type> {};
+
+// Likewise for std::pair
+// (after C++17 it is mandatory that the copy constructor not exist when the two types aren't themselves
+// copy constructible, but this can not be relied upon when T1 or T2 are themselves containers).
+template <typename T1, typename T2> struct is_copy_constructible<std::pair<T1, T2>>
+    : all_of<is_copy_constructible<T1>, is_copy_constructible<T2>> {};
+
+// The same problems arise with std::is_copy_assignable, so we use the same workaround.
+template <typename T, typename SFINAE = void> struct is_copy_assignable : std::is_copy_assignable<T> {};
+template <typename Container> struct is_copy_assignable<Container, enable_if_t<all_of<
+        std::is_copy_assignable<Container>,
+        std::is_same<typename Container::value_type &, typename Container::reference>
+    >::value>> : is_copy_assignable<typename Container::value_type> {};
+template <typename T1, typename T2> struct is_copy_assignable<std::pair<T1, T2>>
+    : all_of<is_copy_assignable<T1>, is_copy_assignable<T2>> {};
+
+NAMESPACE_END(detail)
+
+// polymorphic_type_hook<itype>::get(src, tinfo) determines whether the object pointed
+// to by `src` actually is an instance of some class derived from `itype`.
+// If so, it sets `tinfo` to point to the std::type_info representing that derived
+// type, and returns a pointer to the start of the most-derived object of that type
+// (in which `src` is a subobject; this will be the same address as `src` in most
+// single inheritance cases). If not, or if `src` is nullptr, it simply returns `src`
+// and leaves `tinfo` at its default value of nullptr.
+//
+// The default polymorphic_type_hook just returns src. A specialization for polymorphic
+// types determines the runtime type of the passed object and adjusts the this-pointer
+// appropriately via dynamic_cast<void*>. This is what enables a C++ Animal* to appear
+// to Python as a Dog (if Dog inherits from Animal, Animal is polymorphic, Dog is
+// registered with pybind11, and this Animal is in fact a Dog).
+//
+// You may specialize polymorphic_type_hook yourself for types that want to appear
+// polymorphic to Python but do not use C++ RTTI. (This is a not uncommon pattern
+// in performance-sensitive applications, used most notably in LLVM.)
+template <typename itype, typename SFINAE = void>
+struct polymorphic_type_hook
+{
+    static const void *get(const itype *src, const std::type_info*&) { return src; }
+};
+template <typename itype>
+struct polymorphic_type_hook<itype, detail::enable_if_t<std::is_polymorphic<itype>::value>>
+{
+    static const void *get(const itype *src, const std::type_info*& type) {
+        type = src ? &typeid(*src) : nullptr;
+        return dynamic_cast<const void*>(src);
+    }
+};
+
+NAMESPACE_BEGIN(detail)
 
 /// Generic type caster for objects stored on the heap
 template <typename type> class type_caster_base : public type_caster_generic {
     using itype = intrinsic_t<type>;
+
 public:
-    static PYBIND11_DESCR name() { return type_descr(_<type>()); }
+    static constexpr auto name = _<type>();
 
     type_caster_base() : type_caster_base(typeid(type)) { }
     explicit type_caster_base(const std::type_info &info) : type_caster_generic(info) { }
@@ -784,34 +871,28 @@ public:
         return cast(&src, return_value_policy::move, parent);
     }
 
-    // Returns a (pointer, type_info) pair taking care of necessary RTTI type lookup for a
-    // polymorphic type.  If the instance isn't derived, returns the non-RTTI base version.
-    template <typename T = itype, enable_if_t<std::is_polymorphic<T>::value, int> = 0>
+    // Returns a (pointer, type_info) pair taking care of necessary type lookup for a
+    // polymorphic type (using RTTI by default, but can be overridden by specializing
+    // polymorphic_type_hook). If the instance isn't derived, returns the base version.
     static std::pair<const void *, const type_info *> src_and_type(const itype *src) {
-        const void *vsrc = src;
-        auto &internals = get_internals();
         auto &cast_type = typeid(itype);
         const std::type_info *instance_type = nullptr;
-        if (vsrc) {
-            instance_type = &typeid(*src);
-            if (!same_type(cast_type, *instance_type)) {
-                // This is a base pointer to a derived type; if it is a pybind11-registered type, we
-                // can get the correct derived pointer (which may be != base pointer) by a
-                // dynamic_cast to most derived type:
-                auto it = internals.registered_types_cpp.find(std::type_index(*instance_type));
-                if (it != internals.registered_types_cpp.end())
-                    return {dynamic_cast<const void *>(src), (const type_info *) it->second};
-            }
+        const void *vsrc = polymorphic_type_hook<itype>::get(src, instance_type);
+        if (instance_type && !same_type(cast_type, *instance_type)) {
+            // This is a base pointer to a derived type. If the derived type is registered
+            // with pybind11, we want to make the full derived object available.
+            // In the typical case where itype is polymorphic, we get the correct
+            // derived pointer (which may be != base pointer) by a dynamic_cast to
+            // most derived type. If itype is not polymorphic, we won't get here
+            // except via a user-provided specialization of polymorphic_type_hook,
+            // and the user has promised that no this-pointer adjustment is
+            // required in that case, so it's OK to use static_cast.
+            if (const auto *tpi = get_type_info(*instance_type))
+                return {vsrc, tpi};
         }
         // Otherwise we have either a nullptr, an `itype` pointer, or an unknown derived pointer, so
         // don't do a cast
-        return type_caster_generic::src_and_type(vsrc, cast_type, instance_type);
-    }
-
-    // Non-polymorphic type, so no dynamic casting; just call the generic version directly
-    template <typename T = itype, enable_if_t<!std::is_polymorphic<T>::value, int> = 0>
-    static std::pair<const void *, const type_info *> src_and_type(const itype *src) {
-        return type_caster_generic::src_and_type(src, typeid(itype));
+        return type_caster_generic::src_and_type(src, cast_type, instance_type);
     }
 
     static handle cast(const itype *src, return_value_policy policy, handle parent) {
@@ -828,7 +909,7 @@ public:
             nullptr, nullptr, holder);
     }
 
-    template <typename T> using cast_op_type = cast_op_type<T>;
+    template <typename T> using cast_op_type = detail::cast_op_type<T>;
 
     operator itype*() { return (type *) value; }
     operator itype&() { if (!value) throw reference_cast_error(); return *((itype *) value); }
@@ -846,7 +927,7 @@ protected:
     }
 
     template <typename T, typename = enable_if_t<std::is_move_constructible<T>::value>>
-    static auto make_move_constructor(const T *x) -> decltype(new T(std::move(*(T *) x)), Constructor{}) {
+    static auto make_move_constructor(const T *x) -> decltype(new T(std::move(*const_cast<T *>(x))), Constructor{}) {
         return [](const void *arg) -> void * {
             return new T(std::move(*const_cast<T *>(reinterpret_cast<const T *>(arg))));
         };
@@ -878,7 +959,7 @@ private:
             "std::reference_wrapper<T> caster requires T to have a caster with an `T &` operator");
 public:
     bool load(handle src, bool convert) { return subcaster.load(src, convert); }
-    static PYBIND11_DESCR name() { return caster_t::name(); }
+    static constexpr auto name = caster_t::name;
     static handle cast(const std::reference_wrapper<type> &src, return_value_policy policy, handle parent) {
         // It is definitely wrong to take ownership of this pointer, so mask that rvp
         if (policy == return_value_policy::take_ownership || policy == return_value_policy::automatic)
@@ -893,19 +974,27 @@ public:
     protected: \
         type value; \
     public: \
-        static PYBIND11_DESCR name() { return type_descr(py_name); } \
-        static handle cast(const type *src, return_value_policy policy, handle parent) { \
+        static constexpr auto name = py_name; \
+        template <typename T_, enable_if_t<std::is_same<type, remove_cv_t<T_>>::value, int> = 0> \
+        static handle cast(T_ *src, return_value_policy policy, handle parent) { \
             if (!src) return none().release(); \
-            return cast(*src, policy, parent); \
+            if (policy == return_value_policy::take_ownership) { \
+                auto h = cast(std::move(*src), policy, parent); delete src; return h; \
+            } else { \
+                return cast(*src, policy, parent); \
+            } \
         } \
         operator type*() { return &value; } \
         operator type&() { return value; } \
         operator type&&() && { return std::move(value); } \
-        template <typename _T> using cast_op_type = pybind11::detail::movable_cast_op_type<_T>
+        template <typename T_> using cast_op_type = pybind11::detail::movable_cast_op_type<T_>
 
 
 template <typename CharT> using is_std_char_type = any_of<
     std::is_same<CharT, char>, /* std::string */
+#if defined(PYBIND11_HAS_U8STRING)
+    std::is_same<CharT, char8_t>, /* std::u8string */
+#endif
     std::is_same<CharT, char16_t>, /* std::u16string */
     std::is_same<CharT, char32_t>, /* std::u32string */
     std::is_same<CharT, wchar_t> /* std::wstring */
@@ -929,36 +1018,34 @@ public:
                 py_value = (py_type) PyFloat_AsDouble(src.ptr());
             else
                 return false;
-        } else if (sizeof(T) <= sizeof(long)) {
-            if (PyFloat_Check(src.ptr()))
-                return false;
-            if (std::is_signed<T>::value)
-                py_value = (py_type) PyLong_AsLong(src.ptr());
-            else
-                py_value = (py_type) PyLong_AsUnsignedLong(src.ptr());
-        } else {
-            if (PyFloat_Check(src.ptr()))
-                return false;
-            if (std::is_signed<T>::value)
-                py_value = (py_type) PYBIND11_LONG_AS_LONGLONG(src.ptr());
-            else
-                py_value = (py_type) PYBIND11_LONG_AS_UNSIGNED_LONGLONG(src.ptr());
+        } else if (PyFloat_Check(src.ptr())) {
+            return false;
+        } else if (std::is_unsigned<py_type>::value) {
+            py_value = as_unsigned<py_type>(src.ptr());
+        } else { // signed integer:
+            py_value = sizeof(T) <= sizeof(long)
+                ? (py_type) PyLong_AsLong(src.ptr())
+                : (py_type) PYBIND11_LONG_AS_LONGLONG(src.ptr());
         }
 
-        if ((py_value == (py_type) -1 && PyErr_Occurred()) ||
-            (std::is_integral<T>::value && sizeof(py_type) != sizeof(T) &&
-               (py_value < (py_type) std::numeric_limits<T>::min() ||
-                py_value > (py_type) std::numeric_limits<T>::max()))) {
+        bool py_err = py_value == (py_type) -1 && PyErr_Occurred();
+
+        // Protect std::numeric_limits::min/max with parentheses
+        if (py_err || (std::is_integral<T>::value && sizeof(py_type) != sizeof(T) &&
+                       (py_value < (py_type) (std::numeric_limits<T>::min)() ||
+                        py_value > (py_type) (std::numeric_limits<T>::max)()))) {
+            bool type_error = py_err && PyErr_ExceptionMatches(
 #if PY_VERSION_HEX < 0x03000000 && !defined(PYPY_VERSION)
-            bool type_error = PyErr_ExceptionMatches(PyExc_SystemError);
+                PyExc_SystemError
 #else
-            bool type_error = PyErr_ExceptionMatches(PyExc_TypeError);
+                PyExc_TypeError
 #endif
+            );
             PyErr_Clear();
             if (type_error && convert && PyNumber_Check(src.ptr())) {
-                auto tmp = reinterpret_borrow<object>(std::is_floating_point<T>::value
-                                                      ? PyNumber_Float(src.ptr())
-                                                      : PyNumber_Long(src.ptr()));
+                auto tmp = reinterpret_steal<object>(std::is_floating_point<T>::value
+                                                     ? PyNumber_Float(src.ptr())
+                                                     : PyNumber_Long(src.ptr()));
                 PyErr_Clear();
                 return load(tmp, false);
             }
@@ -969,20 +1056,34 @@ public:
         return true;
     }
 
-    static handle cast(T src, return_value_policy /* policy */, handle /* parent */) {
-        if (std::is_floating_point<T>::value) {
-            return PyFloat_FromDouble((double) src);
-        } else if (sizeof(T) <= sizeof(long)) {
-            if (std::is_signed<T>::value)
-                return PyLong_FromLong((long) src);
-            else
-                return PyLong_FromUnsignedLong((unsigned long) src);
-        } else {
-            if (std::is_signed<T>::value)
-                return PyLong_FromLongLong((long long) src);
-            else
-                return PyLong_FromUnsignedLongLong((unsigned long long) src);
-        }
+    template<typename U = T>
+    static typename std::enable_if<std::is_floating_point<U>::value, handle>::type
+    cast(U src, return_value_policy /* policy */, handle /* parent */) {
+        return PyFloat_FromDouble((double) src);
+    }
+
+    template<typename U = T>
+    static typename std::enable_if<!std::is_floating_point<U>::value && std::is_signed<U>::value && (sizeof(U) <= sizeof(long)), handle>::type
+    cast(U src, return_value_policy /* policy */, handle /* parent */) {
+        return PYBIND11_LONG_FROM_SIGNED((long) src);
+    }
+
+    template<typename U = T>
+    static typename std::enable_if<!std::is_floating_point<U>::value && std::is_unsigned<U>::value && (sizeof(U) <= sizeof(unsigned long)), handle>::type
+    cast(U src, return_value_policy /* policy */, handle /* parent */) {
+        return PYBIND11_LONG_FROM_UNSIGNED((unsigned long) src);
+    }
+
+    template<typename U = T>
+    static typename std::enable_if<!std::is_floating_point<U>::value && std::is_signed<U>::value && (sizeof(U) > sizeof(long)), handle>::type
+    cast(U src, return_value_policy /* policy */, handle /* parent */) {
+        return PyLong_FromLongLong((long long) src);
+    }
+
+    template<typename U = T>
+    static typename std::enable_if<!std::is_floating_point<U>::value && std::is_unsigned<U>::value && (sizeof(U) > sizeof(unsigned long)), handle>::type
+    cast(U src, return_value_policy /* policy */, handle /* parent */) {
+        return PyLong_FromUnsignedLongLong((unsigned long long) src);
     }
 
     PYBIND11_TYPE_CASTER(T, _<std::is_integral<T>::value>("int", "float"));
@@ -1041,7 +1142,7 @@ public:
 
     template <typename T> using cast_op_type = void*&;
     operator void *&() { return value; }
-    static PYBIND11_DESCR name() { return type_descr(_("capsule")); }
+    static constexpr auto name = _("capsule");
 private:
     void *value = nullptr;
 };
@@ -1050,11 +1151,39 @@ template <> class type_caster<std::nullptr_t> : public void_caster<std::nullptr_
 
 template <> class type_caster<bool> {
 public:
-    bool load(handle src, bool) {
+    bool load(handle src, bool convert) {
         if (!src) return false;
         else if (src.ptr() == Py_True) { value = true; return true; }
         else if (src.ptr() == Py_False) { value = false; return true; }
-        else return false;
+        else if (convert || !strcmp("numpy.bool_", Py_TYPE(src.ptr())->tp_name)) {
+            // (allow non-implicit conversion for numpy booleans)
+
+            Py_ssize_t res = -1;
+            if (src.is_none()) {
+                res = 0;  // None is implicitly converted to False
+            }
+            #if defined(PYPY_VERSION)
+            // On PyPy, check that "__bool__" (or "__nonzero__" on Python 2.7) attr exists
+            else if (hasattr(src, PYBIND11_BOOL_ATTR)) {
+                res = PyObject_IsTrue(src.ptr());
+            }
+            #else
+            // Alternate approach for CPython: this does the same as the above, but optimized
+            // using the CPython API so as to avoid an unneeded attribute lookup.
+            else if (auto tp_as_number = src.ptr()->ob_type->tp_as_number) {
+                if (PYBIND11_NB_BOOL(tp_as_number)) {
+                    res = (*PYBIND11_NB_BOOL(tp_as_number))(src.ptr());
+                }
+            }
+            #endif
+            if (res == 0 || res == 1) {
+                value = (bool) res;
+                return true;
+            } else {
+                PyErr_Clear();
+            }
+        }
+        return false;
     }
     static handle cast(bool src, return_value_policy /* policy */, handle /* parent */) {
         return handle(src ? Py_True : Py_False).inc_ref();
@@ -1069,6 +1198,9 @@ template <typename StringType, bool IsView = false> struct string_caster {
     // Simplify life by being able to assume standard char sizes (the standard only guarantees
     // minimums, but Python requires exact sizes)
     static_assert(!std::is_same<CharT, char>::value || sizeof(CharT) == 1, "Unsupported char size != 1");
+#if defined(PYBIND11_HAS_U8STRING)
+    static_assert(!std::is_same<CharT, char8_t>::value || sizeof(CharT) == 1, "Unsupported char8_t size != 1");
+#endif
     static_assert(!std::is_same<CharT, char16_t>::value || sizeof(CharT) == 2, "Unsupported char16_t size != 2");
     static_assert(!std::is_same<CharT, char32_t>::value || sizeof(CharT) == 4, "Unsupported char32_t size != 4");
     // wchar_t can be either 16 bits (Windows) or 32 (everywhere else)
@@ -1087,7 +1219,7 @@ template <typename StringType, bool IsView = false> struct string_caster {
 #if PY_MAJOR_VERSION >= 3
             return load_bytes(load_src);
 #else
-            if (sizeof(CharT) == 1) {
+            if (std::is_same<CharT, char>::value) {
                 return load_bytes(load_src);
             }
 
@@ -1137,7 +1269,7 @@ private:
 #else
         // PyPy seems to have multiple problems related to PyUnicode_UTF*: the UTF8 version
         // sometimes segfaults for unknown reasons, while the UTF16 and 32 versions require a
-        // non-const char * arguments, which is also a nuissance, so bypass the whole thing by just
+        // non-const char * arguments, which is also a nuisance, so bypass the whole thing by just
         // passing the encoding as a string value, which works properly:
         return PyUnicode_Decode(buffer, nbytes, UTF_N == 8 ? "utf-8" : UTF_N == 16 ? "utf-16" : "utf-32", nullptr);
 #endif
@@ -1147,7 +1279,7 @@ private:
     // without any encoding/decoding attempt).  For other C++ char sizes this is a no-op.
     // which supports loading a unicode from a str, doesn't take this path.
     template <typename C = CharT>
-    bool load_bytes(enable_if_t<sizeof(C) == 1, handle> src) {
+    bool load_bytes(enable_if_t<std::is_same<C, char>::value, handle> src) {
         if (PYBIND11_BYTES_CHECK(src.ptr())) {
             // We were passed a Python 3 raw bytes; accept it into a std::string or char*
             // without any encoding attempt.
@@ -1162,7 +1294,7 @@ private:
     }
 
     template <typename C = CharT>
-    bool load_bytes(enable_if_t<sizeof(C) != 1, handle>) { return false; }
+    bool load_bytes(enable_if_t<!std::is_same<C, char>::value, handle>) { return false; }
 };
 
 template <typename CharT, class Traits, class Allocator>
@@ -1182,6 +1314,7 @@ template <typename CharT> struct type_caster<CharT, enable_if_t<is_std_char_type
     using StringCaster = type_caster<StringType>;
     StringCaster str_caster;
     bool none = false;
+    CharT one_char = 0;
 public:
     bool load(handle src, bool convert) {
         if (!src) return false;
@@ -1209,7 +1342,7 @@ public:
     }
 
     operator CharT*() { return none ? nullptr : const_cast<CharT *>(static_cast<StringType &>(str_caster).c_str()); }
-    operator CharT() {
+    operator CharT&() {
         if (none)
             throw value_error("Cannot convert None to a character");
 
@@ -1233,7 +1366,8 @@ public:
             if (char0_bytes == str_len) {
                 // If we have a 128-255 value, we can decode it into a single char:
                 if (char0_bytes == 2 && (v0 & 0xFC) == 0xC0) { // 0x110000xx 0x10xxxxxx
-                    return static_cast<CharT>(((v0 & 3) << 6) + (static_cast<unsigned char>(value[1]) & 0x3F));
+                    one_char = static_cast<CharT>(((v0 & 3) << 6) + (static_cast<unsigned char>(value[1]) & 0x3F));
+                    return one_char;
                 }
                 // Otherwise we have a single character, but it's > U+00FF
                 throw value_error("Character code point not in range(0x100)");
@@ -1244,65 +1378,29 @@ public:
         // surrogate pair with total length 2 instantly indicates a range error (but not a "your
         // string was too long" error).
         else if (StringCaster::UTF_N == 16 && str_len == 2) {
-            char16_t v0 = static_cast<char16_t>(value[0]);
-            if (v0 >= 0xD800 && v0 < 0xE000)
+            one_char = static_cast<CharT>(value[0]);
+            if (one_char >= 0xD800 && one_char < 0xE000)
                 throw value_error("Character code point not in range(0x10000)");
         }
 
         if (str_len != 1)
             throw value_error("Expected a character, but multi-character string found");
 
-        return value[0];
+        one_char = value[0];
+        return one_char;
     }
 
-    static PYBIND11_DESCR name() { return type_descr(_(PYBIND11_STRING_NAME)); }
-    template <typename _T> using cast_op_type = remove_reference_t<pybind11::detail::cast_op_type<_T>>;
+    static constexpr auto name = _(PYBIND11_STRING_NAME);
+    template <typename _T> using cast_op_type = pybind11::detail::cast_op_type<_T>;
 };
 
-template <typename T1, typename T2> class type_caster<std::pair<T1, T2>> {
-    typedef std::pair<T1, T2> type;
+// Base implementation for std::tuple and std::pair
+template <template<typename...> class Tuple, typename... Ts> class tuple_caster {
+    using type = Tuple<Ts...>;
+    static constexpr auto size = sizeof...(Ts);
+    using indices = make_index_sequence<size>;
 public:
-    bool load(handle src, bool convert) {
-        if (!isinstance<sequence>(src))
-            return false;
-        const auto seq = reinterpret_borrow<sequence>(src);
-        if (seq.size() != 2)
-            return false;
-        return first.load(seq[0], convert) && second.load(seq[1], convert);
-    }
-
-    static handle cast(const type &src, return_value_policy policy, handle parent) {
-        auto o1 = reinterpret_steal<object>(make_caster<T1>::cast(src.first, policy, parent));
-        auto o2 = reinterpret_steal<object>(make_caster<T2>::cast(src.second, policy, parent));
-        if (!o1 || !o2)
-            return handle();
-        tuple result(2);
-        PyTuple_SET_ITEM(result.ptr(), 0, o1.release().ptr());
-        PyTuple_SET_ITEM(result.ptr(), 1, o2.release().ptr());
-        return result.release();
-    }
-
-    static PYBIND11_DESCR name() {
-        return type_descr(
-            _("Tuple[") + make_caster<T1>::name() + _(", ") + make_caster<T2>::name() + _("]")
-        );
-    }
 
-    template <typename T> using cast_op_type = type;
-
-    operator type() & { return type(cast_op<T1>(first), cast_op<T2>(second)); }
-    operator type() && { return type(cast_op<T1>(std::move(first)), cast_op<T2>(std::move(second))); }
-protected:
-    make_caster<T1> first;
-    make_caster<T2> second;
-};
-
-template <typename... Tuple> class type_caster<std::tuple<Tuple...>> {
-    using type = std::tuple<Tuple...>;
-    using indices = make_index_sequence<sizeof...(Tuple)>;
-    static constexpr auto size = sizeof...(Tuple);
-
-public:
     bool load(handle src, bool convert) {
         if (!isinstance<sequence>(src))
             return false;
@@ -1312,13 +1410,12 @@ public:
         return load_impl(seq, convert, indices{});
     }
 
-    static handle cast(const type &src, return_value_policy policy, handle parent) {
-        return cast_impl(src, policy, parent, indices{});
+    template <typename T>
+    static handle cast(T &&src, return_value_policy policy, handle parent) {
+        return cast_impl(std::forward<T>(src), policy, parent, indices{});
     }
 
-    static PYBIND11_DESCR name() {
-        return type_descr(_("Tuple[") + detail::concat(make_caster<Tuple>::name()...) + _("]"));
-    }
+    static constexpr auto name = _("Tuple[") + concat(make_caster<Ts>::name...) + _("]");
 
     template <typename T> using cast_op_type = type;
 
@@ -1327,29 +1424,30 @@ public:
 
 protected:
     template <size_t... Is>
-    type implicit_cast(index_sequence<Is...>) & { return type(cast_op<Tuple>(std::get<Is>(subcasters))...); }
+    type implicit_cast(index_sequence<Is...>) & { return type(cast_op<Ts>(std::get<Is>(subcasters))...); }
     template <size_t... Is>
-    type implicit_cast(index_sequence<Is...>) && { return type(cast_op<Tuple>(std::move(std::get<Is>(subcasters)))...); }
-
+    type implicit_cast(index_sequence<Is...>) && { return type(cast_op<Ts>(std::move(std::get<Is>(subcasters)))...); }
 
     static constexpr bool load_impl(const sequence &, bool, index_sequence<>) { return true; }
 
     template <size_t... Is>
     bool load_impl(const sequence &seq, bool convert, index_sequence<Is...>) {
+#ifdef __cpp_fold_expressions
+        if ((... || !std::get<Is>(subcasters).load(seq[Is], convert)))
+            return false;
+#else
         for (bool r : {std::get<Is>(subcasters).load(seq[Is], convert)...})
             if (!r)
                 return false;
+#endif
         return true;
     }
 
-    static handle cast_impl(const type &, return_value_policy, handle,
-                            index_sequence<>) { return tuple().release(); }
-
     /* Implementation: Convert a C++ tuple into a Python tuple */
-    template <size_t... Is>
-    static handle cast_impl(const type &src, return_value_policy policy, handle parent, index_sequence<Is...>) {
-        std::array<object, size> entries {{
-            reinterpret_steal<object>(make_caster<Tuple>::cast(std::get<Is>(src), policy, parent))...
+    template <typename T, size_t... Is>
+    static handle cast_impl(T &&src, return_value_policy policy, handle parent, index_sequence<Is...>) {
+        std::array<object, size> entries{{
+            reinterpret_steal<object>(make_caster<Ts>::cast(std::get<Is>(std::forward<T>(src)), policy, parent))...
         }};
         for (const auto &entry: entries)
             if (!entry)
@@ -1361,9 +1459,15 @@ protected:
         return result.release();
     }
 
-    std::tuple<make_caster<Tuple>...> subcasters;
+    Tuple<make_caster<Ts>...> subcasters;
 };
 
+template <typename T1, typename T2> class type_caster<std::pair<T1, T2>>
+    : public tuple_caster<std::pair, T1, T2> {};
+
+template <typename... Ts> class type_caster<std::tuple<Ts...>>
+    : public tuple_caster<std::tuple, Ts...> {};
+
 /// Helper class which abstracts away certain actions. Users can provide specializations for
 /// custom holders, but it's only necessary if the type has a non-standard interface.
 template <typename T>
@@ -1389,7 +1493,7 @@ public:
 
     explicit operator type*() { return this->value; }
     explicit operator type&() { return *(this->value); }
-    explicit operator holder_type*() { return &holder; }
+    explicit operator holder_type*() { return std::addressof(holder); }
 
     // Workaround for Intel compiler bug
     // see pybind11 issue 94
@@ -1411,10 +1515,10 @@ protected:
             throw cast_error("Unable to load a custom holder type from a default-holder instance");
     }
 
-    bool load_value(const value_and_holder &v_h) {
+    bool load_value(value_and_holder &&v_h) {
         if (v_h.holder_constructed()) {
             value = v_h.value_ptr();
-            holder = v_h.holder<holder_type>();
+            holder = v_h.template holder<holder_type>();
             return true;
         } else {
             throw cast_error("Unable to cast from non-held to held instance (T& to Holder<T>) "
@@ -1442,7 +1546,7 @@ protected:
         return false;
     }
 
-    static constexpr bool try_direct_conversions(handle) { return false; }
+    static bool try_direct_conversions(handle) { return false; }
 
 
     holder_type holder;
@@ -1459,9 +1563,9 @@ struct move_only_holder_caster {
 
     static handle cast(holder_type &&src, return_value_policy, handle) {
         auto *ptr = holder_helper<holder_type>::get(src);
-        return type_caster_base<type>::cast_holder(ptr, &src);
+        return type_caster_base<type>::cast_holder(ptr, std::addressof(src));
     }
-    static PYBIND11_DESCR name() { return type_caster_base<type>::name(); }
+    static constexpr auto name = type_caster_base<type>::name;
 };
 
 template <typename type, typename deleter>
@@ -1469,7 +1573,7 @@ class type_caster<std::unique_ptr<type, deleter>>
     : public move_only_holder_caster<type, std::unique_ptr<type, deleter>> { };
 
 template <typename type, typename holder_type>
-using type_caster_holder = conditional_t<std::is_copy_constructible<holder_type>::value,
+using type_caster_holder = conditional_t<is_copy_constructible<holder_type>::value,
                                          copyable_holder_caster<type, holder_type>,
                                          move_only_holder_caster<type, holder_type>>;
 
@@ -1492,10 +1596,10 @@ template <typename base, typename holder> struct is_holder_type :
 template <typename base, typename deleter> struct is_holder_type<base, std::unique_ptr<base, deleter>> :
     std::true_type {};
 
-template <typename T> struct handle_type_name { static PYBIND11_DESCR name() { return _<T>(); } };
-template <> struct handle_type_name<bytes> { static PYBIND11_DESCR name() { return _(PYBIND11_BYTES_NAME); } };
-template <> struct handle_type_name<args> { static PYBIND11_DESCR name() { return _("*args"); } };
-template <> struct handle_type_name<kwargs> { static PYBIND11_DESCR name() { return _("**kwargs"); } };
+template <typename T> struct handle_type_name { static constexpr auto name = _<T>(); };
+template <> struct handle_type_name<bytes> { static constexpr auto name = _(PYBIND11_BYTES_NAME); };
+template <> struct handle_type_name<args> { static constexpr auto name = _("*args"); };
+template <> struct handle_type_name<kwargs> { static constexpr auto name = _("**kwargs"); };
 
 template <typename type>
 struct pyobject_caster {
@@ -1513,7 +1617,7 @@ struct pyobject_caster {
     static handle cast(const handle &src, return_value_policy /* policy */, handle /* parent */) {
         return src.inc_ref();
     }
-    PYBIND11_TYPE_CASTER(type, handle_type_name<type>::name());
+    PYBIND11_TYPE_CASTER(type, handle_type_name<type>::name);
 };
 
 template <typename T>
@@ -1534,7 +1638,7 @@ template <typename T> using move_is_plain_type = satisfies_none_of<T,
 template <typename T, typename SFINAE = void> struct move_always : std::false_type {};
 template <typename T> struct move_always<T, enable_if_t<all_of<
     move_is_plain_type<T>,
-    negation<std::is_copy_constructible<T>>,
+    negation<is_copy_constructible<T>>,
     std::is_move_constructible<T>,
     std::is_same<decltype(std::declval<make_caster<T>>().operator T&()), T&>
 >::value>> : std::true_type {};
@@ -1553,17 +1657,23 @@ template <typename T> using move_never = none_of<move_always<T>, move_if_unrefer
 // everything else returns a reference/pointer to a local variable.
 template <typename type> using cast_is_temporary_value_reference = bool_constant<
     (std::is_reference<type>::value || std::is_pointer<type>::value) &&
-    !std::is_base_of<type_caster_generic, make_caster<type>>::value
+    !std::is_base_of<type_caster_generic, make_caster<type>>::value &&
+    !std::is_same<intrinsic_t<type>, void>::value
 >;
 
 // When a value returned from a C++ function is being cast back to Python, we almost always want to
 // force `policy = move`, regardless of the return value policy the function/method was declared
-// with.  Some classes (most notably Eigen::Ref and related) need to avoid this, and so can do so by
-// specializing this struct.
+// with.
 template <typename Return, typename SFINAE = void> struct return_value_policy_override {
+    static return_value_policy policy(return_value_policy p) { return p; }
+};
+
+template <typename Return> struct return_value_policy_override<Return,
+        detail::enable_if_t<std::is_base_of<type_caster_generic, make_caster<Return>>::value, void>> {
     static return_value_policy policy(return_value_policy p) {
-        return !std::is_lvalue_reference<Return>::value && !std::is_pointer<Return>::value
-            ? return_value_policy::move : p;
+        return !std::is_lvalue_reference<Return>::value &&
+               !std::is_pointer<Return>::value
+                   ? return_value_policy::move : p;
     }
 };
 
@@ -1574,7 +1684,7 @@ template <typename T, typename SFINAE> type_caster<T, SFINAE> &load_type(type_ca
         throw cast_error("Unable to cast Python instance to C++ type (compile in debug mode for details)");
 #else
         throw cast_error("Unable to cast Python instance of type " +
-            (std::string) str(handle.get_type()) + " to C++ type '" + type_id<T>() + "''");
+            (std::string) str(handle.get_type()) + " to C++ type '" + type_id<T>() + "'");
 #endif
     }
     return conv;
@@ -1683,6 +1793,9 @@ template <> inline void cast_safe<void>(object &&) {}
 
 NAMESPACE_END(detail)
 
+template <return_value_policy policy = return_value_policy::automatic_reference>
+tuple make_tuple() { return tuple(0); }
+
 template <return_value_policy policy = return_value_policy::automatic_reference,
           typename... Args> tuple make_tuple(Args&&... args_) {
     constexpr size_t size = sizeof...(Args);
@@ -1788,7 +1901,7 @@ struct function_record;
 
 /// Internal data associated with a single function call
 struct function_call {
-    function_call(function_record &f, handle p); // Implementation in attr.h
+    function_call(const function_record &f, handle p); // Implementation in attr.h
 
     /// The function data:
     const function_record &func;
@@ -1799,8 +1912,15 @@ struct function_call {
     /// The `convert` value the arguments should be loaded with
     std::vector<bool> args_convert;
 
+    /// Extra references for the optional `py::args` and/or `py::kwargs` arguments (which, if
+    /// present, are also in `args` but without a reference).
+    object args_ref, kwargs_ref;
+
     /// The parent, if any
     handle parent;
+
+    /// If this is a call to an initializer, this argument contains `self`
+    handle init_self;
 };
 
 
@@ -1823,7 +1943,7 @@ public:
     static constexpr bool has_kwargs = kwargs_pos < 0;
     static constexpr bool has_args = args_pos < 0;
 
-    static PYBIND11_DESCR arg_names() { return detail::concat(make_caster<Args>::name()...); }
+    static constexpr auto arg_names = concat(type_descr(make_caster<Args>::name)...);
 
     bool load_args(function_call &call) {
         return load_impl_sequence(call, indices{});
@@ -1846,14 +1966,19 @@ private:
 
     template <size_t... Is>
     bool load_impl_sequence(function_call &call, index_sequence<Is...>) {
+#ifdef __cpp_fold_expressions
+        if ((... || !std::get<Is>(argcasters).load(call.args[Is], call.args_convert[Is])))
+            return false;
+#else
         for (bool r : {std::get<Is>(argcasters).load(call.args[Is], call.args_convert[Is])...})
             if (!r)
                 return false;
+#endif
         return true;
     }
 
     template <typename Return, typename Func, size_t... Is, typename Guard>
-    Return call_impl(Func &&f, index_sequence<Is...>, Guard &&) {
+    Return call_impl(Func &&f, index_sequence<Is...>, Guard &&) && {
         return std::forward<Func>(f)(cast_op<Args>(std::move(std::get<Is>(argcasters)))...);
     }
 
@@ -2042,9 +2167,13 @@ object object_api<Derived>::call(Args &&...args) const {
 
 NAMESPACE_END(detail)
 
-#define PYBIND11_MAKE_OPAQUE(Type) \
+#define PYBIND11_MAKE_OPAQUE(...) \
     namespace pybind11 { namespace detail { \
-        template<> class type_caster<Type> : public type_caster_base<Type> { }; \
+        template<> class type_caster<__VA_ARGS__> : public type_caster_base<__VA_ARGS__> { }; \
     }}
 
-NAMESPACE_END(pybind11)
+/// Lets you pass a type containing a `,` through a macro parameter without needing a separate
+/// typedef, e.g.: `PYBIND11_OVERLOAD(PYBIND11_TYPE(ReturnType<A, B>), PYBIND11_TYPE(Parent<C, D>), f, arg)`
+#define PYBIND11_TYPE(...) __VA_ARGS__
+
+NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/src/pybind11/include/pybind11/chrono.h b/src/pybind11/include/pybind11/chrono.h
index 8a41d08..ea777e6 100644
--- a/src/pybind11/include/pybind11/chrono.h
+++ b/src/pybind11/include/pybind11/chrono.h
@@ -27,7 +27,7 @@
 #define PyDateTime_DELTA_GET_MICROSECONDS(o) (((PyDateTime_Delta*)o)->microseconds)
 #endif
 
-NAMESPACE_BEGIN(pybind11)
+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
 template <typename type> class duration_caster {
@@ -106,8 +106,11 @@ public:
         if (!PyDateTimeAPI) { PyDateTime_IMPORT; }
 
         if (!src) return false;
+
+        std::tm cal;
+        microseconds msecs;
+
         if (PyDateTime_Check(src.ptr())) {
-            std::tm cal;
             cal.tm_sec   = PyDateTime_DATE_GET_SECOND(src.ptr());
             cal.tm_min   = PyDateTime_DATE_GET_MINUTE(src.ptr());
             cal.tm_hour  = PyDateTime_DATE_GET_HOUR(src.ptr());
@@ -115,11 +118,30 @@ public:
             cal.tm_mon   = PyDateTime_GET_MONTH(src.ptr()) - 1;
             cal.tm_year  = PyDateTime_GET_YEAR(src.ptr()) - 1900;
             cal.tm_isdst = -1;
-
-            value = system_clock::from_time_t(std::mktime(&cal)) + microseconds(PyDateTime_DATE_GET_MICROSECOND(src.ptr()));
-            return true;
+            msecs        = microseconds(PyDateTime_DATE_GET_MICROSECOND(src.ptr()));
+        } else if (PyDate_Check(src.ptr())) {
+            cal.tm_sec   = 0;
+            cal.tm_min   = 0;
+            cal.tm_hour  = 0;
+            cal.tm_mday  = PyDateTime_GET_DAY(src.ptr());
+            cal.tm_mon   = PyDateTime_GET_MONTH(src.ptr()) - 1;
+            cal.tm_year  = PyDateTime_GET_YEAR(src.ptr()) - 1900;
+            cal.tm_isdst = -1;
+            msecs        = microseconds(0);
+        } else if (PyTime_Check(src.ptr())) {
+            cal.tm_sec   = PyDateTime_TIME_GET_SECOND(src.ptr());
+            cal.tm_min   = PyDateTime_TIME_GET_MINUTE(src.ptr());
+            cal.tm_hour  = PyDateTime_TIME_GET_HOUR(src.ptr());
+            cal.tm_mday  = 1;   // This date (day, month, year) = (1, 0, 70)
+            cal.tm_mon   = 0;   // represents 1-Jan-1970, which is the first
+            cal.tm_year  = 70;  // earliest available date for Python's datetime
+            cal.tm_isdst = -1;
+            msecs        = microseconds(PyDateTime_TIME_GET_MICROSECOND(src.ptr()));
         }
         else return false;
+
+        value = system_clock::from_time_t(std::mktime(&cal)) + msecs;
+        return true;
     }
 
     static handle cast(const std::chrono::time_point<std::chrono::system_clock, Duration> &src, return_value_policy /* policy */, handle /* parent */) {
@@ -128,7 +150,7 @@ public:
         // Lazy initialise the PyDateTime import
         if (!PyDateTimeAPI) { PyDateTime_IMPORT; }
 
-        std::time_t tt = system_clock::to_time_t(src);
+        std::time_t tt = system_clock::to_time_t(time_point_cast<system_clock::duration>(src));
         // this function uses static memory so it's best to copy it out asap just in case
         // otherwise other code that is using localtime may break this (not just python code)
         std::tm localtime = *std::localtime(&tt);
@@ -159,4 +181,4 @@ template <typename Rep, typename Period> class type_caster<std::chrono::duration
 };
 
 NAMESPACE_END(detail)
-NAMESPACE_END(pybind11)
+NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/src/pybind11/include/pybind11/common.h b/src/pybind11/include/pybind11/common.h
index af0a8d0..6c8a4f1 100644
--- a/src/pybind11/include/pybind11/common.h
+++ b/src/pybind11/include/pybind11/common.h
@@ -1,873 +1,2 @@
-/*
-    pybind11/common.h -- Basic macros
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#if !defined(NAMESPACE_BEGIN)
-#  define NAMESPACE_BEGIN(name) namespace name {
-#endif
-#if !defined(NAMESPACE_END)
-#  define NAMESPACE_END(name) }
-#endif
-
-#if !defined(_MSC_VER) && !defined(__INTEL_COMPILER)
-#  if __cplusplus >= 201402L
-#    define PYBIND11_CPP14
-#    if __cplusplus > 201402L /* Temporary: should be updated to >= the final C++17 value once known */
-#      define PYBIND11_CPP17
-#    endif
-#  endif
-#elif defined(_MSC_VER)
-// MSVC sets _MSVC_LANG rather than __cplusplus (supposedly until the standard is fully implemented)
-#  if _MSVC_LANG >= 201402L
-#    define PYBIND11_CPP14
-#    if _MSVC_LANG > 201402L && _MSC_VER >= 1910
-#      define PYBIND11_CPP17
-#    endif
-#  endif
-#endif
-
-// Compiler version assertions
-#if defined(__INTEL_COMPILER)
-#  if __INTEL_COMPILER < 1500
-#    error pybind11 requires Intel C++ compiler v15 or newer
-#  endif
-#elif defined(__clang__) && !defined(__apple_build_version__)
-#  if __clang_major__ < 3 || (__clang_major__ == 3 && __clang_minor__ < 3)
-#    error pybind11 requires clang 3.3 or newer
-#  endif
-#elif defined(__clang__)
-// Apple changes clang version macros to its Xcode version; the first Xcode release based on
-// (upstream) clang 3.3 was Xcode 5:
-#  if __clang_major__ < 5
-#    error pybind11 requires Xcode/clang 5.0 or newer
-#  endif
-#elif defined(__GNUG__)
-#  if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 8)
-#    error pybind11 requires gcc 4.8 or newer
-#  endif
-#elif defined(_MSC_VER)
-// Pybind hits various compiler bugs in 2015u2 and earlier, and also makes use of some stl features
-// (e.g. std::negation) added in 2015u3:
-#  if _MSC_FULL_VER < 190024210
-#    error pybind11 requires MSVC 2015 update 3 or newer
-#  endif
-#endif
-
-#if !defined(PYBIND11_EXPORT)
-#  if defined(WIN32) || defined(_WIN32)
-#    define PYBIND11_EXPORT __declspec(dllexport)
-#  else
-#    define PYBIND11_EXPORT __attribute__ ((visibility("default")))
-#  endif
-#endif
-
-#if defined(_MSC_VER)
-#  define PYBIND11_NOINLINE __declspec(noinline)
-#else
-#  define PYBIND11_NOINLINE __attribute__ ((noinline))
-#endif
-
-#if defined(PYBIND11_CPP14)
-#  define PYBIND11_DEPRECATED(reason) [[deprecated(reason)]]
-#else
-#  define PYBIND11_DEPRECATED(reason) __attribute__((deprecated(reason)))
-#endif
-
-#define PYBIND11_VERSION_MAJOR 2
-#define PYBIND11_VERSION_MINOR 2
-#define PYBIND11_VERSION_PATCH dev0
-
-/// Include Python header, disable linking to pythonX_d.lib on Windows in debug mode
-#if defined(_MSC_VER)
-#  if (PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION < 4)
-#    define HAVE_ROUND 1
-#  endif
-#  pragma warning(push)
-#  pragma warning(disable: 4510 4610 4512 4005)
-#  if defined(_DEBUG)
-#    define PYBIND11_DEBUG_MARKER
-#    undef _DEBUG
-#  endif
-#endif
-
-#include <Python.h>
-#include <frameobject.h>
-#include <pythread.h>
-
-#if defined(_WIN32) && (defined(min) || defined(max))
-#  error Macro clash with min and max -- define NOMINMAX when compiling your program on Windows
-#endif
-
-#if defined(isalnum)
-#  undef isalnum
-#  undef isalpha
-#  undef islower
-#  undef isspace
-#  undef isupper
-#  undef tolower
-#  undef toupper
-#endif
-
-#if defined(_MSC_VER)
-#  if defined(PYBIND11_DEBUG_MARKER)
-#    define _DEBUG
-#    undef PYBIND11_DEBUG_MARKER
-#  endif
-#  pragma warning(pop)
-#endif
-
-#include <cstddef>
-#include <cstring>
-#include <forward_list>
-#include <vector>
-#include <string>
-#include <stdexcept>
-#include <unordered_set>
-#include <unordered_map>
-#include <memory>
-#include <typeindex>
-#include <type_traits>
-
-#if PY_MAJOR_VERSION >= 3 /// Compatibility macros for various Python versions
-#define PYBIND11_INSTANCE_METHOD_NEW(ptr, class_) PyInstanceMethod_New(ptr)
-#define PYBIND11_INSTANCE_METHOD_CHECK PyInstanceMethod_Check
-#define PYBIND11_INSTANCE_METHOD_GET_FUNCTION PyInstanceMethod_GET_FUNCTION
-#define PYBIND11_BYTES_CHECK PyBytes_Check
-#define PYBIND11_BYTES_FROM_STRING PyBytes_FromString
-#define PYBIND11_BYTES_FROM_STRING_AND_SIZE PyBytes_FromStringAndSize
-#define PYBIND11_BYTES_AS_STRING_AND_SIZE PyBytes_AsStringAndSize
-#define PYBIND11_BYTES_AS_STRING PyBytes_AsString
-#define PYBIND11_BYTES_SIZE PyBytes_Size
-#define PYBIND11_LONG_CHECK(o) PyLong_Check(o)
-#define PYBIND11_LONG_AS_LONGLONG(o) PyLong_AsLongLong(o)
-#define PYBIND11_LONG_AS_UNSIGNED_LONGLONG(o) PyLong_AsUnsignedLongLong(o)
-#define PYBIND11_BYTES_NAME "bytes"
-#define PYBIND11_STRING_NAME "str"
-#define PYBIND11_SLICE_OBJECT PyObject
-#define PYBIND11_FROM_STRING PyUnicode_FromString
-#define PYBIND11_STR_TYPE ::pybind11::str
-#define PYBIND11_PLUGIN_IMPL(name) \
-    extern "C" PYBIND11_EXPORT PyObject *PyInit_##name()
-#else
-#define PYBIND11_INSTANCE_METHOD_NEW(ptr, class_) PyMethod_New(ptr, nullptr, class_)
-#define PYBIND11_INSTANCE_METHOD_CHECK PyMethod_Check
-#define PYBIND11_INSTANCE_METHOD_GET_FUNCTION PyMethod_GET_FUNCTION
-#define PYBIND11_BYTES_CHECK PyString_Check
-#define PYBIND11_BYTES_FROM_STRING PyString_FromString
-#define PYBIND11_BYTES_FROM_STRING_AND_SIZE PyString_FromStringAndSize
-#define PYBIND11_BYTES_AS_STRING_AND_SIZE PyString_AsStringAndSize
-#define PYBIND11_BYTES_AS_STRING PyString_AsString
-#define PYBIND11_BYTES_SIZE PyString_Size
-#define PYBIND11_LONG_CHECK(o) (PyInt_Check(o) || PyLong_Check(o))
-#define PYBIND11_LONG_AS_LONGLONG(o) (PyInt_Check(o) ? (long long) PyLong_AsLong(o) : PyLong_AsLongLong(o))
-#define PYBIND11_LONG_AS_UNSIGNED_LONGLONG(o) (PyInt_Check(o) ? (unsigned long long) PyLong_AsUnsignedLong(o) : PyLong_AsUnsignedLongLong(o))
-#define PYBIND11_BYTES_NAME "str"
-#define PYBIND11_STRING_NAME "unicode"
-#define PYBIND11_SLICE_OBJECT PySliceObject
-#define PYBIND11_FROM_STRING PyString_FromString
-#define PYBIND11_STR_TYPE ::pybind11::bytes
-#define PYBIND11_PLUGIN_IMPL(name) \
-    static PyObject *pybind11_init_wrapper();               \
-    extern "C" PYBIND11_EXPORT void init##name() {          \
-        (void)pybind11_init_wrapper();                      \
-    }                                                       \
-    PyObject *pybind11_init_wrapper()
-#endif
-
-#if PY_VERSION_HEX >= 0x03050000 && PY_VERSION_HEX < 0x03050200
-extern "C" {
-    struct _Py_atomic_address { void *value; };
-    PyAPI_DATA(_Py_atomic_address) _PyThreadState_Current;
-}
-#endif
-
-#define PYBIND11_TRY_NEXT_OVERLOAD ((PyObject *) 1) // special failure return code
-#define PYBIND11_STRINGIFY(x) #x
-#define PYBIND11_TOSTRING(x) PYBIND11_STRINGIFY(x)
-#define PYBIND11_INTERNALS_ID "__pybind11_" \
-    PYBIND11_TOSTRING(PYBIND11_VERSION_MAJOR) "_" PYBIND11_TOSTRING(PYBIND11_VERSION_MINOR) "__"
-
-/** \rst
-    ***Deprecated in favor of PYBIND11_MODULE***
-
-    This macro creates the entry point that will be invoked when the Python interpreter
-    imports a plugin library. Please create a `module` in the function body and return
-    the pointer to its underlying Python object at the end.
-
-    .. code-block:: cpp
-
-        PYBIND11_PLUGIN(example) {
-            pybind11::module m("example", "pybind11 example plugin");
-            /// Set up bindings here
-            return m.ptr();
-        }
-\endrst */
-#define PYBIND11_PLUGIN(name)                                                  \
-    PYBIND11_DEPRECATED("PYBIND11_PLUGIN is deprecated, use PYBIND11_MODULE")  \
-    static PyObject *pybind11_init();                                          \
-    PYBIND11_PLUGIN_IMPL(name) {                                               \
-        int major, minor;                                                      \
-        if (sscanf(Py_GetVersion(), "%i.%i", &major, &minor) != 2) {           \
-            PyErr_SetString(PyExc_ImportError, "Can't parse Python version."); \
-            return nullptr;                                                    \
-        } else if (major != PY_MAJOR_VERSION || minor != PY_MINOR_VERSION) {   \
-            PyErr_Format(PyExc_ImportError,                                    \
-                         "Python version mismatch: module was compiled for "   \
-                         "version %i.%i, while the interpreter is running "    \
-                         "version %i.%i.", PY_MAJOR_VERSION, PY_MINOR_VERSION, \
-                         major, minor);                                        \
-            return nullptr;                                                    \
-        }                                                                      \
-        try {                                                                  \
-            return pybind11_init();                                            \
-        } catch (pybind11::error_already_set &e) {                             \
-            e.clear();                                                         \
-            PyErr_SetString(PyExc_ImportError, e.what());                      \
-            return nullptr;                                                    \
-        } catch (const std::exception &e) {                                    \
-            PyErr_SetString(PyExc_ImportError, e.what());                      \
-            return nullptr;                                                    \
-        }                                                                      \
-    }                                                                          \
-    PyObject *pybind11_init()
-
-/** \rst
-    This macro creates the entry point that will be invoked when the Python interpreter
-    imports an extension module. The module name is given as the fist argument and it
-    should not be in quotes. The second macro argument defines a variable of type
-    `py::module` which can be used to initialize the module.
-
-    .. code-block:: cpp
-
-        PYBIND11_MODULE(example, m) {
-            m.doc() = "pybind11 example module";
-
-            // Add bindings here
-            m.def("foo", []() {
-                return "Hello, World!";
-            });
-        }
-\endrst */
-#define PYBIND11_MODULE(name, variable)                                        \
-    static void pybind11_init_##name(pybind11::module &);                      \
-    PYBIND11_PLUGIN_IMPL(name) {                                               \
-        int major, minor;                                                      \
-        if (sscanf(Py_GetVersion(), "%i.%i", &major, &minor) != 2) {           \
-            PyErr_SetString(PyExc_ImportError, "Can't parse Python version."); \
-            return nullptr;                                                    \
-        } else if (major != PY_MAJOR_VERSION || minor != PY_MINOR_VERSION) {   \
-            PyErr_Format(PyExc_ImportError,                                    \
-                         "Python version mismatch: module was compiled for "   \
-                         "version %i.%i, while the interpreter is running "    \
-                         "version %i.%i.", PY_MAJOR_VERSION, PY_MINOR_VERSION, \
-                         major, minor);                                        \
-            return nullptr;                                                    \
-        }                                                                      \
-        auto m = pybind11::module(#name);                                      \
-        try {                                                                  \
-            pybind11_init_##name(m);                                           \
-            return m.ptr();                                                    \
-        } catch (pybind11::error_already_set &e) {                             \
-            e.clear();                                                         \
-            PyErr_SetString(PyExc_ImportError, e.what());                      \
-            return nullptr;                                                    \
-        } catch (const std::exception &e) {                                    \
-            PyErr_SetString(PyExc_ImportError, e.what());                      \
-            return nullptr;                                                    \
-        }                                                                      \
-    }                                                                          \
-    void pybind11_init_##name(pybind11::module &variable)
-
-
-NAMESPACE_BEGIN(pybind11)
-
-using ssize_t = Py_ssize_t;
-using size_t  = std::size_t;
-
-/// Approach used to cast a previously unknown C++ instance into a Python object
-enum class return_value_policy : uint8_t {
-    /** This is the default return value policy, which falls back to the policy
-        return_value_policy::take_ownership when the return value is a pointer.
-        Otherwise, it uses return_value::move or return_value::copy for rvalue
-        and lvalue references, respectively. See below for a description of what
-        all of these different policies do. */
-    automatic = 0,
-
-    /** As above, but use policy return_value_policy::reference when the return
-        value is a pointer. This is the default conversion policy for function
-        arguments when calling Python functions manually from C++ code (i.e. via
-        handle::operator()). You probably won't need to use this. */
-    automatic_reference,
-
-    /** Reference an existing object (i.e. do not create a new copy) and take
-        ownership. Python will call the destructor and delete operator when the
-        object’s reference count reaches zero. Undefined behavior ensues when
-        the C++ side does the same.. */
-    take_ownership,
-
-    /** Create a new copy of the returned object, which will be owned by
-        Python. This policy is comparably safe because the lifetimes of the two
-        instances are decoupled. */
-    copy,
-
-    /** Use std::move to move the return value contents into a new instance
-        that will be owned by Python. This policy is comparably safe because the
-        lifetimes of the two instances (move source and destination) are
-        decoupled. */
-    move,
-
-    /** Reference an existing object, but do not take ownership. The C++ side
-        is responsible for managing the object’s lifetime and deallocating it
-        when it is no longer used. Warning: undefined behavior will ensue when
-        the C++ side deletes an object that is still referenced and used by
-        Python. */
-    reference,
-
-    /** This policy only applies to methods and properties. It references the
-        object without taking ownership similar to the above
-        return_value_policy::reference policy. In contrast to that policy, the
-        function or property’s implicit this argument (called the parent) is
-        considered to be the the owner of the return value (the child).
-        pybind11 then couples the lifetime of the parent to the child via a
-        reference relationship that ensures that the parent cannot be garbage
-        collected while Python is still using the child. More advanced
-        variations of this scheme are also possible using combinations of
-        return_value_policy::reference and the keep_alive call policy */
-    reference_internal
-};
-
-NAMESPACE_BEGIN(detail)
-
-inline static constexpr int log2(size_t n, int k = 0) { return (n <= 1) ? k : log2(n >> 1, k + 1); }
-
-// Returns the size as a multiple of sizeof(void *), rounded up.
-inline static constexpr size_t size_in_ptrs(size_t s) { return 1 + ((s - 1) >> log2(sizeof(void *))); }
-
-inline std::string error_string();
-
-/**
- * The space to allocate for simple layout instance holders (see below) in multiple of the size of
- * a pointer (e.g.  2 means 16 bytes on 64-bit architectures).  The default is the minimum required
- * to holder either a std::unique_ptr or std::shared_ptr (which is almost always
- * sizeof(std::shared_ptr<T>)).
- */
-constexpr size_t instance_simple_holder_in_ptrs() {
-    static_assert(sizeof(std::shared_ptr<int>) >= sizeof(std::unique_ptr<int>),
-            "pybind assumes std::shared_ptrs are at least as big as std::unique_ptrs");
-    return size_in_ptrs(sizeof(std::shared_ptr<int>));
-}
-
-// Forward declarations
-struct type_info;
-struct value_and_holder;
-
-/// The 'instance' type which needs to be standard layout (need to be able to use 'offsetof')
-struct instance {
-    PyObject_HEAD
-    /// Storage for pointers and holder; see simple_layout, below, for a description
-    union {
-        void *simple_value_holder[1 + instance_simple_holder_in_ptrs()];
-        struct {
-            void **values_and_holders;
-            bool *holder_constructed;
-        } nonsimple;
-    };
-    /// Weak references (needed for keep alive):
-    PyObject *weakrefs;
-    /// If true, the pointer is owned which means we're free to manage it with a holder.
-    bool owned : 1;
-    /**
-     * An instance has two possible value/holder layouts.
-     *
-     * Simple layout (when this flag is true), means the `simple_value_holder` is set with a pointer
-     * and the holder object governing that pointer, i.e. [val1*][holder].  This layout is applied
-     * whenever there is no python-side multiple inheritance of bound C++ types *and* the type's
-     * holder will fit in the default space (which is large enough to hold either a std::unique_ptr
-     * or std::shared_ptr).
-     *
-     * Non-simple layout applies when using custom holders that require more space than `shared_ptr`
-     * (which is typically the size of two pointers), or when multiple inheritance is used on the
-     * python side.  Non-simple layout allocates the required amount of memory to have multiple
-     * bound C++ classes as parents.  Under this layout, `nonsimple.values_and_holders` is set to a
-     * pointer to allocated space of the required space to hold a a sequence of value pointers and
-     * holders followed by a set of holder-constructed flags (1 byte each), i.e.
-     * [val1*][holder1][val2*][holder2]...[bb...]  where each [block] is rounded up to a multiple of
-     * `sizeof(void *)`.  `nonsimple.holder_constructed` is, for convenience, a pointer to the
-     * beginning of the [bb...] block (but not independently allocated).
-     */
-    bool simple_layout : 1;
-    /// For simple layout, tracks whether the holder has been constructed
-    bool simple_holder_constructed : 1;
-    /// If true, get_internals().patients has an entry for this object
-    bool has_patients : 1;
-
-    /// Initializes all of the above type/values/holders data
-    void allocate_layout();
-
-    /// Destroys/deallocates all of the above
-    void deallocate_layout();
-
-    /// Returns the value_and_holder wrapper for the given type (or the first, if `find_type`
-    /// omitted)
-    value_and_holder get_value_and_holder(const type_info *find_type = nullptr);
-};
-
-static_assert(std::is_standard_layout<instance>::value, "Internal error: `pybind11::detail::instance` is not standard layout!");
-
-struct overload_hash {
-    inline size_t operator()(const std::pair<const PyObject *, const char *>& v) const {
-        size_t value = std::hash<const void *>()(v.first);
-        value ^= std::hash<const void *>()(v.second)  + 0x9e3779b9 + (value<<6) + (value>>2);
-        return value;
-    }
-};
-
-// Python loads modules by default with dlopen with the RTLD_LOCAL flag; under libc++ and possibly
-// other stls, this means `typeid(A)` from one module won't equal `typeid(A)` from another module
-// even when `A` is the same, non-hidden-visibility type (e.g. from a common include).  Under
-// stdlibc++, this doesn't happen: equality and the type_index hash are based on the type name,
-// which works.  If not under a known-good stl, provide our own name-based hasher and equality
-// functions that use the type name.
-#if defined(__GLIBCXX__)
-inline bool same_type(const std::type_info &lhs, const std::type_info &rhs) { return lhs == rhs; }
-using type_hash = std::hash<std::type_index>;
-using type_equal_to = std::equal_to<std::type_index>;
-#else
-inline bool same_type(const std::type_info &lhs, const std::type_info &rhs) {
-    return lhs.name() == rhs.name() ||
-        std::strcmp(lhs.name(), rhs.name()) == 0;
-}
-struct type_hash {
-    size_t operator()(const std::type_index &t) const {
-        size_t hash = 5381;
-        const char *ptr = t.name();
-        while (auto c = static_cast<unsigned char>(*ptr++))
-            hash = (hash * 33) ^ c;
-        return hash;
-    }
-};
-struct type_equal_to {
-    bool operator()(const std::type_index &lhs, const std::type_index &rhs) const {
-        return lhs.name() == rhs.name() ||
-            std::strcmp(lhs.name(), rhs.name()) == 0;
-    }
-};
-#endif
-
-template <typename value_type>
-using type_map = std::unordered_map<std::type_index, value_type, type_hash, type_equal_to>;
-
-/// Internal data structure used to track registered instances and types
-struct internals {
-    type_map<void *> registered_types_cpp; // std::type_index -> type_info
-    std::unordered_map<PyTypeObject *, std::vector<type_info *>> registered_types_py; // PyTypeObject* -> base type_info(s)
-    std::unordered_multimap<const void *, instance*> registered_instances; // void * -> instance*
-    std::unordered_set<std::pair<const PyObject *, const char *>, overload_hash> inactive_overload_cache;
-    type_map<std::vector<bool (*)(PyObject *, void *&)>> direct_conversions;
-    std::unordered_map<const PyObject *, std::vector<PyObject *>> patients;
-    std::forward_list<void (*) (std::exception_ptr)> registered_exception_translators;
-    std::unordered_map<std::string, void *> shared_data; // Custom data to be shared across extensions
-    std::vector<PyObject *> loader_patient_stack; // Used by `loader_life_support`
-    PyTypeObject *static_property_type;
-    PyTypeObject *default_metaclass;
-    PyObject *instance_base;
-#if defined(WITH_THREAD)
-    decltype(PyThread_create_key()) tstate = 0; // Usually an int but a long on Cygwin64 with Python 3.x
-    PyInterpreterState *istate = nullptr;
-#endif
-};
-
-/// Return a reference to the current 'internals' information
-inline internals &get_internals();
-
-/// from __cpp_future__ import (convenient aliases from C++14/17)
-#if defined(PYBIND11_CPP14) && (!defined(_MSC_VER) || _MSC_VER >= 1910)
-using std::enable_if_t;
-using std::conditional_t;
-using std::remove_cv_t;
-using std::remove_reference_t;
-#else
-template <bool B, typename T = void> using enable_if_t = typename std::enable_if<B, T>::type;
-template <bool B, typename T, typename F> using conditional_t = typename std::conditional<B, T, F>::type;
-template <typename T> using remove_cv_t = typename std::remove_cv<T>::type;
-template <typename T> using remove_reference_t = typename std::remove_reference<T>::type;
-#endif
-
-/// Index sequences
-#if defined(PYBIND11_CPP14)
-using std::index_sequence;
-using std::make_index_sequence;
-#else
-template<size_t ...> struct index_sequence  { };
-template<size_t N, size_t ...S> struct make_index_sequence_impl : make_index_sequence_impl <N - 1, N - 1, S...> { };
-template<size_t ...S> struct make_index_sequence_impl <0, S...> { typedef index_sequence<S...> type; };
-template<size_t N> using make_index_sequence = typename make_index_sequence_impl<N>::type;
-#endif
-
-/// Make an index sequence of the indices of true arguments
-template <typename ISeq, size_t, bool...> struct select_indices_impl { using type = ISeq; };
-template <size_t... IPrev, size_t I, bool B, bool... Bs> struct select_indices_impl<index_sequence<IPrev...>, I, B, Bs...>
-    : select_indices_impl<conditional_t<B, index_sequence<IPrev..., I>, index_sequence<IPrev...>>, I + 1, Bs...> {};
-template <bool... Bs> using select_indices = typename select_indices_impl<index_sequence<>, 0, Bs...>::type;
-
-/// Backports of std::bool_constant and std::negation to accomodate older compilers
-template <bool B> using bool_constant = std::integral_constant<bool, B>;
-template <typename T> struct negation : bool_constant<!T::value> { };
-
-template <typename...> struct void_t_impl { using type = void; };
-template <typename... Ts> using void_t = typename void_t_impl<Ts...>::type;
-
-/// Compile-time all/any/none of that check the boolean value of all template types
-#ifdef __cpp_fold_expressions
-template <class... Ts> using all_of = bool_constant<(Ts::value && ...)>;
-template <class... Ts> using any_of = bool_constant<(Ts::value || ...)>;
-#elif !defined(_MSC_VER)
-template <bool...> struct bools {};
-template <class... Ts> using all_of = std::is_same<
-    bools<Ts::value..., true>,
-    bools<true, Ts::value...>>;
-template <class... Ts> using any_of = negation<all_of<negation<Ts>...>>;
-#else
-// MSVC has trouble with the above, but supports std::conjunction, which we can use instead (albeit
-// at a slight loss of compilation efficiency).
-template <class... Ts> using all_of = std::conjunction<Ts...>;
-template <class... Ts> using any_of = std::disjunction<Ts...>;
-#endif
-template <class... Ts> using none_of = negation<any_of<Ts...>>;
-
-template <class T, template<class> class... Predicates> using satisfies_all_of = all_of<Predicates<T>...>;
-template <class T, template<class> class... Predicates> using satisfies_any_of = any_of<Predicates<T>...>;
-template <class T, template<class> class... Predicates> using satisfies_none_of = none_of<Predicates<T>...>;
-
-/// Strip the class from a method type
-template <typename T> struct remove_class { };
-template <typename C, typename R, typename... A> struct remove_class<R (C::*)(A...)> { typedef R type(A...); };
-template <typename C, typename R, typename... A> struct remove_class<R (C::*)(A...) const> { typedef R type(A...); };
-
-/// Helper template to strip away type modifiers
-template <typename T> struct intrinsic_type                       { typedef T type; };
-template <typename T> struct intrinsic_type<const T>              { typedef typename intrinsic_type<T>::type type; };
-template <typename T> struct intrinsic_type<T*>                   { typedef typename intrinsic_type<T>::type type; };
-template <typename T> struct intrinsic_type<T&>                   { typedef typename intrinsic_type<T>::type type; };
-template <typename T> struct intrinsic_type<T&&>                  { typedef typename intrinsic_type<T>::type type; };
-template <typename T, size_t N> struct intrinsic_type<const T[N]> { typedef typename intrinsic_type<T>::type type; };
-template <typename T, size_t N> struct intrinsic_type<T[N]>       { typedef typename intrinsic_type<T>::type type; };
-template <typename T> using intrinsic_t = typename intrinsic_type<T>::type;
-
-/// Helper type to replace 'void' in some expressions
-struct void_type { };
-
-/// Helper template which holds a list of types
-template <typename...> struct type_list { };
-
-/// Compile-time integer sum
-#ifdef __cpp_fold_expressions
-template <typename... Ts> constexpr size_t constexpr_sum(Ts... ns) { return (0 + ... + size_t{ns}); }
-#else
-constexpr size_t constexpr_sum() { return 0; }
-template <typename T, typename... Ts>
-constexpr size_t constexpr_sum(T n, Ts... ns) { return size_t{n} + constexpr_sum(ns...); }
-#endif
-
-NAMESPACE_BEGIN(constexpr_impl)
-/// Implementation details for constexpr functions
-constexpr int first(int i) { return i; }
-template <typename T, typename... Ts>
-constexpr int first(int i, T v, Ts... vs) { return v ? i : first(i + 1, vs...); }
-
-constexpr int last(int /*i*/, int result) { return result; }
-template <typename T, typename... Ts>
-constexpr int last(int i, int result, T v, Ts... vs) { return last(i + 1, v ? i : result, vs...); }
-NAMESPACE_END(constexpr_impl)
-
-/// Return the index of the first type in Ts which satisfies Predicate<T>.  Returns sizeof...(Ts) if
-/// none match.
-template <template<typename> class Predicate, typename... Ts>
-constexpr int constexpr_first() { return constexpr_impl::first(0, Predicate<Ts>::value...); }
-
-/// Return the index of the last type in Ts which satisfies Predicate<T>, or -1 if none match.
-template <template<typename> class Predicate, typename... Ts>
-constexpr int constexpr_last() { return constexpr_impl::last(0, -1, Predicate<Ts>::value...); }
-
-/// Return the Nth element from the parameter pack
-template <size_t N, typename T, typename... Ts>
-struct pack_element { using type = typename pack_element<N - 1, Ts...>::type; };
-template <typename T, typename... Ts>
-struct pack_element<0, T, Ts...> { using type = T; };
-
-/// Return the one and only type which matches the predicate, or Default if none match.
-/// If more than one type matches the predicate, fail at compile-time.
-template <template<typename> class Predicate, typename Default, typename... Ts>
-struct exactly_one {
-    static constexpr auto found = constexpr_sum(Predicate<Ts>::value...);
-    static_assert(found <= 1, "Found more than one type matching the predicate");
-
-    static constexpr auto index = found ? constexpr_first<Predicate, Ts...>() : 0;
-    using type = conditional_t<found, typename pack_element<index, Ts...>::type, Default>;
-};
-template <template<typename> class P, typename Default>
-struct exactly_one<P, Default> { using type = Default; };
-
-template <template<typename> class Predicate, typename Default, typename... Ts>
-using exactly_one_t = typename exactly_one<Predicate, Default, Ts...>::type;
-
-/// Defer the evaluation of type T until types Us are instantiated
-template <typename T, typename... /*Us*/> struct deferred_type { using type = T; };
-template <typename T, typename... Us> using deferred_t = typename deferred_type<T, Us...>::type;
-
-template <template<typename...> class Base>
-struct is_template_base_of_impl {
-    template <typename... Us> static std::true_type check(Base<Us...> *);
-    static std::false_type check(...);
-};
-
-/// Check if a template is the base of a type. For example:
-/// `is_template_base_of<Base, T>` is true if `struct T : Base<U> {}` where U can be anything
-template <template<typename...> class Base, typename T>
-#if !defined(_MSC_VER)
-using is_template_base_of = decltype(is_template_base_of_impl<Base>::check((remove_cv_t<T>*)nullptr));
-#else // MSVC2015 has trouble with decltype in template aliases
-struct is_template_base_of : decltype(is_template_base_of_impl<Base>::check((remove_cv_t<T>*)nullptr)) { };
-#endif
-
-/// Check if T is an instantiation of the template `Class`. For example:
-/// `is_instantiation<shared_ptr, T>` is true if `T == shared_ptr<U>` where U can be anything.
-template <template<typename...> class Class, typename T>
-struct is_instantiation : std::false_type { };
-template <template<typename...> class Class, typename... Us>
-struct is_instantiation<Class, Class<Us...>> : std::true_type { };
-
-/// Check if T is std::shared_ptr<U> where U can be anything
-template <typename T> using is_shared_ptr = is_instantiation<std::shared_ptr, T>;
-
-/// Check if T looks like an input iterator
-template <typename T, typename = void> struct is_input_iterator : std::false_type {};
-template <typename T>
-struct is_input_iterator<T, void_t<decltype(*std::declval<T &>()), decltype(++std::declval<T &>())>>
-    : std::true_type {};
-
-/// Ignore that a variable is unused in compiler warnings
-inline void ignore_unused(const int *) { }
-
-/// Apply a function over each element of a parameter pack
-#ifdef __cpp_fold_expressions
-#define PYBIND11_EXPAND_SIDE_EFFECTS(PATTERN) (((PATTERN), void()), ...)
-#else
-using expand_side_effects = bool[];
-#define PYBIND11_EXPAND_SIDE_EFFECTS(PATTERN) pybind11::detail::expand_side_effects{ ((PATTERN), void(), false)..., false }
-#endif
-
-NAMESPACE_END(detail)
-
-/// Returns a named pointer that is shared among all extension modules (using the same
-/// pybind11 version) running in the current interpreter. Names starting with underscores
-/// are reserved for internal usage. Returns `nullptr` if no matching entry was found.
-inline PYBIND11_NOINLINE void* get_shared_data(const std::string& name) {
-    auto& internals = detail::get_internals();
-    auto it = internals.shared_data.find(name);
-    return it != internals.shared_data.end() ? it->second : nullptr;
-}
-
-/// Set the shared data that can be later recovered by `get_shared_data()`.
-inline PYBIND11_NOINLINE void *set_shared_data(const std::string& name, void *data) {
-    detail::get_internals().shared_data[name] = data;
-    return data;
-}
-
-/// Returns a typed reference to a shared data entry (by using `get_shared_data()`) if
-/// such entry exists. Otherwise, a new object of default-constructible type `T` is
-/// added to the shared data under the given name and a reference to it is returned.
-template<typename T> T& get_or_create_shared_data(const std::string& name) {
-    auto& internals = detail::get_internals();
-    auto it = internals.shared_data.find(name);
-    T* ptr = (T*) (it != internals.shared_data.end() ? it->second : nullptr);
-    if (!ptr) {
-        ptr = new T();
-        internals.shared_data[name] = ptr;
-    }
-    return *ptr;
-}
-
-/// Fetch and hold an error which was already set in Python
-class error_already_set : public std::runtime_error {
-public:
-    error_already_set() : std::runtime_error(detail::error_string()) {
-        PyErr_Fetch(&type, &value, &trace);
-    }
-
-    error_already_set(const error_already_set &) = delete;
-
-    error_already_set(error_already_set &&e)
-        : std::runtime_error(e.what()), type(e.type), value(e.value),
-          trace(e.trace) { e.type = e.value = e.trace = nullptr; }
-
-    inline ~error_already_set(); // implementation in pybind11.h
-
-    error_already_set& operator=(const error_already_set &) = delete;
-
-    /// Give the error back to Python
-    void restore() { PyErr_Restore(type, value, trace); type = value = trace = nullptr; }
-
-    /// Clear the held Python error state (the C++ `what()` message remains intact)
-    void clear() { restore(); PyErr_Clear(); }
-
-    /// Check if the trapped exception matches a given Python exception class
-    bool matches(PyObject *ex) const { return PyErr_GivenExceptionMatches(ex, type); }
-
-private:
-    PyObject *type, *value, *trace;
-};
-
-/// C++ bindings of builtin Python exceptions
-class builtin_exception : public std::runtime_error {
-public:
-    using std::runtime_error::runtime_error;
-    /// Set the error using the Python C API
-    virtual void set_error() const = 0;
-};
-
-#define PYBIND11_RUNTIME_EXCEPTION(name, type) \
-    class name : public builtin_exception { public: \
-        using builtin_exception::builtin_exception; \
-        name() : name("") { } \
-        void set_error() const override { PyErr_SetString(type, what()); } \
-    };
-
-PYBIND11_RUNTIME_EXCEPTION(stop_iteration, PyExc_StopIteration)
-PYBIND11_RUNTIME_EXCEPTION(index_error, PyExc_IndexError)
-PYBIND11_RUNTIME_EXCEPTION(key_error, PyExc_KeyError)
-PYBIND11_RUNTIME_EXCEPTION(value_error, PyExc_ValueError)
-PYBIND11_RUNTIME_EXCEPTION(type_error, PyExc_TypeError)
-PYBIND11_RUNTIME_EXCEPTION(cast_error, PyExc_RuntimeError) /// Thrown when pybind11::cast or handle::call fail due to a type casting error
-PYBIND11_RUNTIME_EXCEPTION(reference_cast_error, PyExc_RuntimeError) /// Used internally
-
-[[noreturn]] PYBIND11_NOINLINE inline void pybind11_fail(const char *reason) { throw std::runtime_error(reason); }
-[[noreturn]] PYBIND11_NOINLINE inline void pybind11_fail(const std::string &reason) { throw std::runtime_error(reason); }
-
-template <typename T, typename SFINAE = void> struct format_descriptor { };
-
-NAMESPACE_BEGIN(detail)
-// Returns the index of the given type in the type char array below, and in the list in numpy.h
-// The order here is: bool; 8 ints ((signed,unsigned)x(8,16,32,64)bits); float,double,long double;
-// complex float,double,long double.  Note that the long double types only participate when long
-// double is actually longer than double (it isn't under MSVC).
-// NB: not only the string below but also complex.h and numpy.h rely on this order.
-template <typename T, typename SFINAE = void> struct is_fmt_numeric { static constexpr bool value = false; };
-template <typename T> struct is_fmt_numeric<T, enable_if_t<std::is_arithmetic<T>::value>> {
-    static constexpr bool value = true;
-    static constexpr int index = std::is_same<T, bool>::value ? 0 : 1 + (
-        std::is_integral<T>::value ? detail::log2(sizeof(T))*2 + std::is_unsigned<T>::value : 8 + (
-        std::is_same<T, double>::value ? 1 : std::is_same<T, long double>::value ? 2 : 0));
-};
-NAMESPACE_END(detail)
-
-template <typename T> struct format_descriptor<T, detail::enable_if_t<std::is_arithmetic<T>::value>> {
-    static constexpr const char c = "?bBhHiIqQfdg"[detail::is_fmt_numeric<T>::index];
-    static constexpr const char value[2] = { c, '\0' };
-    static std::string format() { return std::string(1, c); }
-};
-
-template <typename T> constexpr const char format_descriptor<
-    T, detail::enable_if_t<std::is_arithmetic<T>::value>>::value[2];
-
-/// RAII wrapper that temporarily clears any Python error state
-struct error_scope {
-    PyObject *type, *value, *trace;
-    error_scope() { PyErr_Fetch(&type, &value, &trace); }
-    ~error_scope() { PyErr_Restore(type, value, trace); }
-};
-
-/// Dummy destructor wrapper that can be used to expose classes with a private destructor
-struct nodelete { template <typename T> void operator()(T*) { } };
-
-// overload_cast requires variable templates: C++14
-#if defined(PYBIND11_CPP14)
-#define PYBIND11_OVERLOAD_CAST 1
-
-NAMESPACE_BEGIN(detail)
-template <typename... Args>
-struct overload_cast_impl {
-    template <typename Return>
-    constexpr auto operator()(Return (*pf)(Args...)) const noexcept
-                              -> decltype(pf) { return pf; }
-
-    template <typename Return, typename Class>
-    constexpr auto operator()(Return (Class::*pmf)(Args...), std::false_type = {}) const noexcept
-                              -> decltype(pmf) { return pmf; }
-
-    template <typename Return, typename Class>
-    constexpr auto operator()(Return (Class::*pmf)(Args...) const, std::true_type) const noexcept
-                              -> decltype(pmf) { return pmf; }
-};
-NAMESPACE_END(detail)
-
-/// Syntax sugar for resolving overloaded function pointers:
-///  - regular: static_cast<Return (Class::*)(Arg0, Arg1, Arg2)>(&Class::func)
-///  - sweet:   overload_cast<Arg0, Arg1, Arg2>(&Class::func)
-template <typename... Args>
-static constexpr detail::overload_cast_impl<Args...> overload_cast = {};
-// MSVC 2015 only accepts this particular initialization syntax for this variable template.
-
-/// Const member function selector for overload_cast
-///  - regular: static_cast<Return (Class::*)(Arg) const>(&Class::func)
-///  - sweet:   overload_cast<Arg>(&Class::func, const_)
-static constexpr auto const_ = std::true_type{};
-
-#else // no overload_cast: providing something that static_assert-fails:
-template <typename... Args> struct overload_cast {
-    static_assert(detail::deferred_t<std::false_type, Args...>::value,
-                  "pybind11::overload_cast<...> requires compiling in C++14 mode");
-};
-#endif // overload_cast
-
-NAMESPACE_BEGIN(detail)
-
-// Adaptor for converting arbitrary container arguments into a vector; implicitly convertible from
-// any standard container (or C-style array) supporting std::begin/std::end, any singleton
-// arithmetic type (if T is arithmetic), or explicitly constructible from an iterator pair.
-template <typename T>
-class any_container {
-    std::vector<T> v;
-public:
-    any_container() = default;
-
-    // Can construct from a pair of iterators
-    template <typename It, typename = enable_if_t<is_input_iterator<It>::value>>
-    any_container(It first, It last) : v(first, last) { }
-
-    // Implicit conversion constructor from any arbitrary container type with values convertible to T
-    template <typename Container, typename = enable_if_t<std::is_convertible<decltype(*std::begin(std::declval<const Container &>())), T>::value>>
-    any_container(const Container &c) : any_container(std::begin(c), std::end(c)) { }
-
-    // initializer_list's aren't deducible, so don't get matched by the above template; we need this
-    // to explicitly allow implicit conversion from one:
-    template <typename TIn, typename = enable_if_t<std::is_convertible<TIn, T>::value>>
-    any_container(const std::initializer_list<TIn> &c) : any_container(c.begin(), c.end()) { }
-
-    // Avoid copying if given an rvalue vector of the correct type.
-    any_container(std::vector<T> &&v) : v(std::move(v)) { }
-
-    // Moves the vector out of an rvalue any_container
-    operator std::vector<T> &&() && { return std::move(v); }
-
-    // Dereferencing obtains a reference to the underlying vector
-    std::vector<T> &operator*() { return v; }
-    const std::vector<T> &operator*() const { return v; }
-
-    // -> lets you call methods on the underlying vector
-    std::vector<T> *operator->() { return &v; }
-    const std::vector<T> *operator->() const { return &v; }
-};
-
-NAMESPACE_END(detail)
-
-
-
-NAMESPACE_END(pybind11)
+#include "detail/common.h"
+#warning "Including 'common.h' is deprecated. It will be removed in v3.0. Use 'pybind11.h'."
diff --git a/src/pybind11/include/pybind11/complex.h b/src/pybind11/include/pybind11/complex.h
index 7d422e2..3f89638 100644
--- a/src/pybind11/include/pybind11/complex.h
+++ b/src/pybind11/include/pybind11/complex.h
@@ -17,7 +17,7 @@
 #  undef I
 #endif
 
-NAMESPACE_BEGIN(pybind11)
+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
 template <typename T> struct format_descriptor<std::complex<T>, detail::enable_if_t<std::is_floating_point<T>::value>> {
     static constexpr const char c = format_descriptor<T>::c;
@@ -25,9 +25,13 @@ template <typename T> struct format_descriptor<std::complex<T>, detail::enable_i
     static std::string format() { return std::string(value); }
 };
 
+#ifndef PYBIND11_CPP17
+
 template <typename T> constexpr const char format_descriptor<
     std::complex<T>, detail::enable_if_t<std::is_floating_point<T>::value>>::value[3];
 
+#endif
+
 NAMESPACE_BEGIN(detail)
 
 template <typename T> struct is_fmt_numeric<std::complex<T>, detail::enable_if_t<std::is_floating_point<T>::value>> {
@@ -58,4 +62,4 @@ public:
     PYBIND11_TYPE_CASTER(std::complex<T>, _("complex"));
 };
 NAMESPACE_END(detail)
-NAMESPACE_END(pybind11)
+NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/src/pybind11/include/pybind11/descr.h b/src/pybind11/include/pybind11/descr.h
deleted file mode 100644
index 23a099c..0000000
--- a/src/pybind11/include/pybind11/descr.h
+++ /dev/null
@@ -1,185 +0,0 @@
-/*
-    pybind11/descr.h: Helper type for concatenating type signatures
-    either at runtime (C++11) or compile time (C++14)
-
-    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
-
-    All rights reserved. Use of this source code is governed by a
-    BSD-style license that can be found in the LICENSE file.
-*/
-
-#pragma once
-
-#include "common.h"
-
-NAMESPACE_BEGIN(pybind11)
-NAMESPACE_BEGIN(detail)
-
-/* Concatenate type signatures at compile time using C++14 */
-#if defined(PYBIND11_CPP14) && !defined(_MSC_VER)
-#define PYBIND11_CONSTEXPR_DESCR
-
-template <size_t Size1, size_t Size2> class descr {
-    template <size_t Size1_, size_t Size2_> friend class descr;
-public:
-    constexpr descr(char const (&text) [Size1+1], const std::type_info * const (&types)[Size2+1])
-        : descr(text, types,
-                make_index_sequence<Size1>(),
-                make_index_sequence<Size2>()) { }
-
-    constexpr const char *text() const { return m_text; }
-    constexpr const std::type_info * const * types() const { return m_types; }
-
-    template <size_t OtherSize1, size_t OtherSize2>
-    constexpr descr<Size1 + OtherSize1, Size2 + OtherSize2> operator+(const descr<OtherSize1, OtherSize2> &other) const {
-        return concat(other,
-                      make_index_sequence<Size1>(),
-                      make_index_sequence<Size2>(),
-                      make_index_sequence<OtherSize1>(),
-                      make_index_sequence<OtherSize2>());
-    }
-
-protected:
-    template <size_t... Indices1, size_t... Indices2>
-    constexpr descr(
-        char const (&text) [Size1+1],
-        const std::type_info * const (&types) [Size2+1],
-        index_sequence<Indices1...>, index_sequence<Indices2...>)
-        : m_text{text[Indices1]..., '\0'},
-          m_types{types[Indices2]...,  nullptr } {}
-
-    template <size_t OtherSize1, size_t OtherSize2, size_t... Indices1,
-              size_t... Indices2, size_t... OtherIndices1, size_t... OtherIndices2>
-    constexpr descr<Size1 + OtherSize1, Size2 + OtherSize2>
-    concat(const descr<OtherSize1, OtherSize2> &other,
-           index_sequence<Indices1...>, index_sequence<Indices2...>,
-           index_sequence<OtherIndices1...>, index_sequence<OtherIndices2...>) const {
-        return descr<Size1 + OtherSize1, Size2 + OtherSize2>(
-            { m_text[Indices1]..., other.m_text[OtherIndices1]..., '\0' },
-            { m_types[Indices2]..., other.m_types[OtherIndices2]..., nullptr }
-        );
-    }
-
-protected:
-    char m_text[Size1 + 1];
-    const std::type_info * m_types[Size2 + 1];
-};
-
-template <size_t Size> constexpr descr<Size - 1, 0> _(char const(&text)[Size]) {
-    return descr<Size - 1, 0>(text, { nullptr });
-}
-
-template <size_t Rem, size_t... Digits> struct int_to_str : int_to_str<Rem/10, Rem%10, Digits...> { };
-template <size_t...Digits> struct int_to_str<0, Digits...> {
-    static constexpr auto digits = descr<sizeof...(Digits), 0>({ ('0' + Digits)..., '\0' }, { nullptr });
-};
-
-// Ternary description (like std::conditional)
-template <bool B, size_t Size1, size_t Size2>
-constexpr enable_if_t<B, descr<Size1 - 1, 0>> _(char const(&text1)[Size1], char const(&)[Size2]) {
-    return _(text1);
-}
-template <bool B, size_t Size1, size_t Size2>
-constexpr enable_if_t<!B, descr<Size2 - 1, 0>> _(char const(&)[Size1], char const(&text2)[Size2]) {
-    return _(text2);
-}
-template <bool B, size_t SizeA1, size_t SizeA2, size_t SizeB1, size_t SizeB2>
-constexpr enable_if_t<B, descr<SizeA1, SizeA2>> _(descr<SizeA1, SizeA2> d, descr<SizeB1, SizeB2>) { return d; }
-template <bool B, size_t SizeA1, size_t SizeA2, size_t SizeB1, size_t SizeB2>
-constexpr enable_if_t<!B, descr<SizeB1, SizeB2>> _(descr<SizeA1, SizeA2>, descr<SizeB1, SizeB2> d) { return d; }
-
-template <size_t Size> auto constexpr _() -> decltype(int_to_str<Size / 10, Size % 10>::digits) {
-    return int_to_str<Size / 10, Size % 10>::digits;
-}
-
-template <typename Type> constexpr descr<1, 1> _() {
-    return descr<1, 1>({ '%', '\0' }, { &typeid(Type), nullptr });
-}
-
-inline constexpr descr<0, 0> concat() { return _(""); }
-template <size_t Size1, size_t Size2, typename... Args> auto constexpr concat(descr<Size1, Size2> descr) { return descr; }
-template <size_t Size1, size_t Size2, typename... Args> auto constexpr concat(descr<Size1, Size2> descr, Args&&... args) { return descr + _(", ") + concat(args...); }
-template <size_t Size1, size_t Size2> auto constexpr type_descr(descr<Size1, Size2> descr) { return _("{") + descr + _("}"); }
-
-#define PYBIND11_DESCR constexpr auto
-
-#else /* Simpler C++11 implementation based on run-time memory allocation and copying */
-
-class descr {
-public:
-    PYBIND11_NOINLINE descr(const char *text, const std::type_info * const * types) {
-        size_t nChars = len(text), nTypes = len(types);
-        m_text  = new char[nChars];
-        m_types = new const std::type_info *[nTypes];
-        memcpy(m_text, text, nChars * sizeof(char));
-        memcpy(m_types, types, nTypes * sizeof(const std::type_info *));
-    }
-
-    PYBIND11_NOINLINE descr operator+(descr &&d2) && {
-        descr r;
-
-        size_t nChars1 = len(m_text),    nTypes1 = len(m_types);
-        size_t nChars2 = len(d2.m_text), nTypes2 = len(d2.m_types);
-
-        r.m_text  = new char[nChars1 + nChars2 - 1];
-        r.m_types = new const std::type_info *[nTypes1 + nTypes2 - 1];
-        memcpy(r.m_text, m_text, (nChars1-1) * sizeof(char));
-        memcpy(r.m_text + nChars1 - 1, d2.m_text, nChars2 * sizeof(char));
-        memcpy(r.m_types, m_types, (nTypes1-1) * sizeof(std::type_info *));
-        memcpy(r.m_types + nTypes1 - 1, d2.m_types, nTypes2 * sizeof(std::type_info *));
-
-        delete[] m_text;    delete[] m_types;
-        delete[] d2.m_text; delete[] d2.m_types;
-
-        return r;
-    }
-
-    char *text() { return m_text; }
-    const std::type_info * * types() { return m_types; }
-
-protected:
-    PYBIND11_NOINLINE descr() { }
-
-    template <typename T> static size_t len(const T *ptr) { // return length including null termination
-        const T *it = ptr;
-        while (*it++ != (T) 0)
-            ;
-        return static_cast<size_t>(it - ptr);
-    }
-
-    const std::type_info **m_types = nullptr;
-    char *m_text = nullptr;
-};
-
-/* The 'PYBIND11_NOINLINE inline' combinations below are intentional to get the desired linkage while producing as little object code as possible */
-
-PYBIND11_NOINLINE inline descr _(const char *text) {
-    const std::type_info *types[1] = { nullptr };
-    return descr(text, types);
-}
-
-template <bool B> PYBIND11_NOINLINE enable_if_t<B, descr> _(const char *text1, const char *) { return _(text1); }
-template <bool B> PYBIND11_NOINLINE enable_if_t<!B, descr> _(char const *, const char *text2) { return _(text2); }
-template <bool B> PYBIND11_NOINLINE enable_if_t<B, descr> _(descr d, descr) { return d; }
-template <bool B> PYBIND11_NOINLINE enable_if_t<!B, descr> _(descr, descr d) { return d; }
-
-template <typename Type> PYBIND11_NOINLINE descr _() {
-    const std::type_info *types[2] = { &typeid(Type), nullptr };
-    return descr("%", types);
-}
-
-template <size_t Size> PYBIND11_NOINLINE descr _() {
-    const std::type_info *types[1] = { nullptr };
-    return descr(std::to_string(Size).c_str(), types);
-}
-
-PYBIND11_NOINLINE inline descr concat() { return _(""); }
-PYBIND11_NOINLINE inline descr concat(descr &&d) { return d; }
-template <typename... Args> PYBIND11_NOINLINE descr concat(descr &&d, Args&&... args) { return std::move(d) + _(", ") + concat(std::forward<Args>(args)...); }
-PYBIND11_NOINLINE inline descr type_descr(descr&& d) { return _("{") + std::move(d) + _("}"); }
-
-#define PYBIND11_DESCR ::pybind11::detail::descr
-#endif
-
-NAMESPACE_END(detail)
-NAMESPACE_END(pybind11)
diff --git a/src/pybind11/include/pybind11/class_support.h b/src/pybind11/include/pybind11/detail/class.h
similarity index 85%
rename from src/pybind11/include/pybind11/class_support.h
rename to src/pybind11/include/pybind11/detail/class.h
index 2bfc5a8..edfa7de 100644
--- a/src/pybind11/include/pybind11/class_support.h
+++ b/src/pybind11/include/pybind11/detail/class.h
@@ -1,5 +1,5 @@
 /*
-    pybind11/class_support.h: Python C API implementation details for py::class_
+    pybind11/detail/class.h: Python C API implementation details for py::class_
 
     Copyright (c) 2017 Wenzel Jakob <wenzel.jakob@epfl.ch>
 
@@ -9,11 +9,26 @@
 
 #pragma once
 
-#include "attr.h"
+#include "../attr.h"
+#include "../options.h"
 
-NAMESPACE_BEGIN(pybind11)
+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
+#if PY_VERSION_HEX >= 0x03030000
+#  define PYBIND11_BUILTIN_QUALNAME
+#  define PYBIND11_SET_OLDPY_QUALNAME(obj, nameobj)
+#else
+// In pre-3.3 Python, we still set __qualname__ so that we can produce reliable function type
+// signatures; in 3.3+ this macro expands to nothing:
+#  define PYBIND11_SET_OLDPY_QUALNAME(obj, nameobj) setattr((PyObject *) obj, "__qualname__", nameobj)
+#endif
+
+inline PyTypeObject *type_incref(PyTypeObject *type) {
+    Py_INCREF(type);
+    return type;
+}
+
 #if !defined(PYPY_VERSION)
 
 /// `pybind11_static_property.__get__()`: Always pass the class instead of the instance.
@@ -43,13 +58,13 @@ inline PyTypeObject *make_static_property_type() {
         pybind11_fail("make_static_property_type(): error allocating type!");
 
     heap_type->ht_name = name_obj.inc_ref().ptr();
-#if PY_MAJOR_VERSION >= 3 && PY_MINOR_VERSION >= 3
+#ifdef PYBIND11_BUILTIN_QUALNAME
     heap_type->ht_qualname = name_obj.inc_ref().ptr();
 #endif
 
     auto type = &heap_type->ht_type;
     type->tp_name = name;
-    type->tp_base = &PyProperty_Type;
+    type->tp_base = type_incref(&PyProperty_Type);
     type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;
     type->tp_descr_get = pybind11_static_get;
     type->tp_descr_set = pybind11_static_set;
@@ -58,6 +73,7 @@ inline PyTypeObject *make_static_property_type() {
         pybind11_fail("make_static_property_type(): failure in PyType_Ready()!");
 
     setattr((PyObject *) type, "__module__", str("pybind11_builtins"));
+    PYBIND11_SET_OLDPY_QUALNAME(type, name_obj);
 
     return type;
 }
@@ -156,13 +172,13 @@ inline PyTypeObject* make_default_metaclass() {
         pybind11_fail("make_default_metaclass(): error allocating metaclass!");
 
     heap_type->ht_name = name_obj.inc_ref().ptr();
-#if PY_MAJOR_VERSION >= 3 && PY_MINOR_VERSION >= 3
+#ifdef PYBIND11_BUILTIN_QUALNAME
     heap_type->ht_qualname = name_obj.inc_ref().ptr();
 #endif
 
     auto type = &heap_type->ht_type;
     type->tp_name = name;
-    type->tp_base = &PyType_Type;
+    type->tp_base = type_incref(&PyType_Type);
     type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;
 
     type->tp_setattro = pybind11_meta_setattro;
@@ -174,6 +190,7 @@ inline PyTypeObject* make_default_metaclass() {
         pybind11_fail("make_default_metaclass(): failure in PyType_Ready()!");
 
     setattr((PyObject *) type, "__module__", str("pybind11_builtins"));
+    PYBIND11_SET_OLDPY_QUALNAME(type, name_obj);
 
     return type;
 }
@@ -227,12 +244,10 @@ inline bool deregister_instance(instance *self, void *valptr, const type_info *t
     return ret;
 }
 
-/// Instance creation function for all pybind11 types. It only allocates space for the C++ object
-/// (or multiple objects, for Python-side inheritance from multiple pybind11 types), but doesn't
-/// call the constructor -- an `__init__` function must do that.  If allocating value, the instance
-/// is registered; otherwise register_instance will need to be called once the value has been
-/// assigned.
-inline PyObject *make_new_instance(PyTypeObject *type, bool allocate_value /*= true (in cast.h)*/) {
+/// Instance creation function for all pybind11 types. It allocates the internal instance layout for
+/// holding C++ objects and holders.  Allocation is done lazily (the first time the instance is cast
+/// to a reference or pointer), and initialization is done by an `__init__` function.
+inline PyObject *make_new_instance(PyTypeObject *type) {
 #if defined(PYPY_VERSION)
     // PyPy gets tp_basicsize wrong (issue 2482) under multiple inheritance when the first inherited
     // object is a a plain Python type (i.e. not derived from an extension type).  Fix it.
@@ -247,14 +262,6 @@ inline PyObject *make_new_instance(PyTypeObject *type, bool allocate_value /*= t
     inst->allocate_layout();
 
     inst->owned = true;
-    // Allocate (if requested) the value pointers; otherwise leave them as nullptr
-    if (allocate_value) {
-        for (auto &v_h : values_and_holders(inst)) {
-            void *&vptr = v_h.value_ptr();
-            vptr = v_h.type->operator_new(v_h.type->type_size);
-            register_instance(inst, vptr, v_h.type);
-        }
-    }
 
     return self;
 }
@@ -311,11 +318,14 @@ inline void clear_instance(PyObject *self) {
     // Deallocate any values/holders, if present:
     for (auto &v_h : values_and_holders(instance)) {
         if (v_h) {
-            if (instance->owned || v_h.holder_constructed())
-                v_h.type->dealloc(v_h);
 
-            if (!deregister_instance(instance, v_h.value_ptr(), v_h.type))
+            // We have to deregister before we call dealloc because, for virtual MI types, we still
+            // need to be able to get the parent pointers.
+            if (v_h.instance_registered() && !deregister_instance(instance, v_h.value_ptr(), v_h.type))
                 pybind11_fail("pybind11_object_dealloc(): Tried to deallocate unregistered instance!");
+
+            if (instance->owned || v_h.holder_constructed())
+                v_h.type->dealloc(v_h);
         }
     }
     // Deallocate the value/holder layout internals:
@@ -336,7 +346,23 @@ inline void clear_instance(PyObject *self) {
 /// to destroy the C++ object itself, while the rest is Python bookkeeping.
 extern "C" inline void pybind11_object_dealloc(PyObject *self) {
     clear_instance(self);
-    Py_TYPE(self)->tp_free(self);
+
+    auto type = Py_TYPE(self);
+    type->tp_free(self);
+
+#if PY_VERSION_HEX < 0x03080000
+    // `type->tp_dealloc != pybind11_object_dealloc` means that we're being called
+    // as part of a derived type's dealloc, in which case we're not allowed to decref
+    // the type here. For cross-module compatibility, we shouldn't compare directly
+    // with `pybind11_object_dealloc`, but with the common one stashed in internals.
+    auto pybind11_object_type = (PyTypeObject *) get_internals().instance_base;
+    if (type->tp_dealloc == pybind11_object_type->tp_dealloc)
+        Py_DECREF(type);
+#else
+    // This was not needed before Python 3.8 (Python issue 35810)
+    // https://github.com/pybind/pybind11/issues/1946
+    Py_DECREF(type);
+#endif
 }
 
 /** Create the type which can be used as a common base for all classes.  This is
@@ -355,13 +381,13 @@ inline PyObject *make_object_base_type(PyTypeObject *metaclass) {
         pybind11_fail("make_object_base_type(): error allocating type!");
 
     heap_type->ht_name = name_obj.inc_ref().ptr();
-#if PY_MAJOR_VERSION >= 3 && PY_MINOR_VERSION >= 3
+#ifdef PYBIND11_BUILTIN_QUALNAME
     heap_type->ht_qualname = name_obj.inc_ref().ptr();
 #endif
 
     auto type = &heap_type->ht_type;
     type->tp_name = name;
-    type->tp_base = &PyBaseObject_Type;
+    type->tp_base = type_incref(&PyBaseObject_Type);
     type->tp_basicsize = static_cast<ssize_t>(sizeof(instance));
     type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;
 
@@ -376,6 +402,7 @@ inline PyObject *make_object_base_type(PyTypeObject *metaclass) {
         pybind11_fail("PyType_Ready failed in make_object_base_type():" + error_string());
 
     setattr((PyObject *) type, "__module__", str("pybind11_builtins"));
+    PYBIND11_SET_OLDPY_QUALNAME(type, name_obj);
 
     assert(!PyType_HasFeature(type, Py_TPFLAGS_HAVE_GC));
     return (PyObject *) heap_type;
@@ -448,7 +475,7 @@ extern "C" inline int pybind11_getbuffer(PyObject *obj, Py_buffer *view, int fla
         if (tinfo && tinfo->get_buffer)
             break;
     }
-    if (view == nullptr || obj == nullptr || !tinfo || !tinfo->get_buffer) {
+    if (view == nullptr || !tinfo || !tinfo->get_buffer) {
         if (view)
             view->obj = nullptr;
         PyErr_SetString(PyExc_BufferError, "pybind11_getbuffer(): Internal error");
@@ -464,6 +491,13 @@ extern "C" inline int pybind11_getbuffer(PyObject *obj, Py_buffer *view, int fla
     view->len = view->itemsize;
     for (auto s : info->shape)
         view->len *= s;
+    view->readonly = info->readonly;
+    if ((flags & PyBUF_WRITABLE) == PyBUF_WRITABLE && info->readonly) {
+        if (view)
+            view->obj = nullptr;
+        PyErr_SetString(PyExc_BufferError, "Writable buffer requested for readonly storage");
+        return -1;
+    }
     if ((flags & PyBUF_FORMAT) == PyBUF_FORMAT)
         view->format = const_cast<char *>(info->format.c_str());
     if ((flags & PyBUF_STRIDES) == PyBUF_STRIDES) {
@@ -496,13 +530,15 @@ inline void enable_buffer_protocol(PyHeapTypeObject *heap_type) {
 inline PyObject* make_new_python_type(const type_record &rec) {
     auto name = reinterpret_steal<object>(PYBIND11_FROM_STRING(rec.name));
 
-#if PY_MAJOR_VERSION >= 3 && PY_MINOR_VERSION >= 3
-    auto ht_qualname = name;
-    if (rec.scope && hasattr(rec.scope, "__qualname__")) {
-        ht_qualname = reinterpret_steal<object>(
+    auto qualname = name;
+    if (rec.scope && !PyModule_Check(rec.scope.ptr()) && hasattr(rec.scope, "__qualname__")) {
+#if PY_MAJOR_VERSION >= 3
+        qualname = reinterpret_steal<object>(
             PyUnicode_FromFormat("%U.%U", rec.scope.attr("__qualname__").ptr(), name.ptr()));
-    }
+#else
+        qualname = str(rec.scope.attr("__qualname__").cast<std::string>() + "." + rec.name);
 #endif
+    }
 
     object module;
     if (rec.scope) {
@@ -512,12 +548,11 @@ inline PyObject* make_new_python_type(const type_record &rec) {
             module = rec.scope.attr("__name__");
     }
 
+    auto full_name = c_str(
 #if !defined(PYPY_VERSION)
-    const auto full_name = module ? str(module).cast<std::string>() + "." + rec.name
-                                  : std::string(rec.name);
-#else
-    const auto full_name = std::string(rec.name);
+        module ? str(module).cast<std::string>() + "." + rec.name :
 #endif
+        rec.name);
 
     char *tp_doc = nullptr;
     if (rec.doc && options::show_user_defined_docstrings()) {
@@ -545,14 +580,14 @@ inline PyObject* make_new_python_type(const type_record &rec) {
         pybind11_fail(std::string(rec.name) + ": Unable to create type object!");
 
     heap_type->ht_name = name.release().ptr();
-#if PY_MAJOR_VERSION >= 3 && PY_MINOR_VERSION >= 3
-    heap_type->ht_qualname = ht_qualname.release().ptr();
+#ifdef PYBIND11_BUILTIN_QUALNAME
+    heap_type->ht_qualname = qualname.inc_ref().ptr();
 #endif
 
     auto type = &heap_type->ht_type;
-    type->tp_name = strdup(full_name.c_str());
+    type->tp_name = full_name;
     type->tp_doc = tp_doc;
-    type->tp_base = (PyTypeObject *) handle(base).inc_ref().ptr();
+    type->tp_base = type_incref((PyTypeObject *)base);
     type->tp_basicsize = static_cast<ssize_t>(sizeof(instance));
     if (bases.size() > 0)
         type->tp_bases = bases.release().ptr();
@@ -564,6 +599,9 @@ inline PyObject* make_new_python_type(const type_record &rec) {
     type->tp_as_number = &heap_type->as_number;
     type->tp_as_sequence = &heap_type->as_sequence;
     type->tp_as_mapping = &heap_type->as_mapping;
+#if PY_VERSION_HEX >= 0x03050000
+    type->tp_as_async = &heap_type->as_async;
+#endif
 
     /* Flags */
     type->tp_flags |= Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;
@@ -586,12 +624,16 @@ inline PyObject* make_new_python_type(const type_record &rec) {
     /* Register type with the parent scope */
     if (rec.scope)
         setattr(rec.scope, rec.name, (PyObject *) type);
+    else
+        Py_INCREF(type); // Keep it alive forever (reference leak)
 
     if (module) // Needed by pydoc
         setattr((PyObject *) type, "__module__", module);
 
+    PYBIND11_SET_OLDPY_QUALNAME(type, qualname);
+
     return (PyObject *) type;
 }
 
 NAMESPACE_END(detail)
-NAMESPACE_END(pybind11)
+NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/src/pybind11/include/pybind11/detail/common.h b/src/pybind11/include/pybind11/detail/common.h
new file mode 100644
index 0000000..e53f502
--- /dev/null
+++ b/src/pybind11/include/pybind11/detail/common.h
@@ -0,0 +1,820 @@
+/*
+    pybind11/detail/common.h -- Basic macros
+
+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
+
+    All rights reserved. Use of this source code is governed by a
+    BSD-style license that can be found in the LICENSE file.
+*/
+
+#pragma once
+
+#if !defined(NAMESPACE_BEGIN)
+#  define NAMESPACE_BEGIN(name) namespace name {
+#endif
+#if !defined(NAMESPACE_END)
+#  define NAMESPACE_END(name) }
+#endif
+
+// Robust support for some features and loading modules compiled against different pybind versions
+// requires forcing hidden visibility on pybind code, so we enforce this by setting the attribute on
+// the main `pybind11` namespace.
+#if !defined(PYBIND11_NAMESPACE)
+#  ifdef __GNUG__
+#    define PYBIND11_NAMESPACE pybind11 __attribute__((visibility("hidden")))
+#  else
+#    define PYBIND11_NAMESPACE pybind11
+#  endif
+#endif
+
+#if !(defined(_MSC_VER) && __cplusplus == 199711L) && !defined(__INTEL_COMPILER)
+#  if __cplusplus >= 201402L
+#    define PYBIND11_CPP14
+#    if __cplusplus >= 201703L
+#      define PYBIND11_CPP17
+#    endif
+#  endif
+#elif defined(_MSC_VER) && __cplusplus == 199711L
+// MSVC sets _MSVC_LANG rather than __cplusplus (supposedly until the standard is fully implemented)
+// Unless you use the /Zc:__cplusplus flag on Visual Studio 2017 15.7 Preview 3 or newer
+#  if _MSVC_LANG >= 201402L
+#    define PYBIND11_CPP14
+#    if _MSVC_LANG > 201402L && _MSC_VER >= 1910
+#      define PYBIND11_CPP17
+#    endif
+#  endif
+#endif
+
+// Compiler version assertions
+#if defined(__INTEL_COMPILER)
+#  if __INTEL_COMPILER < 1700
+#    error pybind11 requires Intel C++ compiler v17 or newer
+#  endif
+#elif defined(__clang__) && !defined(__apple_build_version__)
+#  if __clang_major__ < 3 || (__clang_major__ == 3 && __clang_minor__ < 3)
+#    error pybind11 requires clang 3.3 or newer
+#  endif
+#elif defined(__clang__)
+// Apple changes clang version macros to its Xcode version; the first Xcode release based on
+// (upstream) clang 3.3 was Xcode 5:
+#  if __clang_major__ < 5
+#    error pybind11 requires Xcode/clang 5.0 or newer
+#  endif
+#elif defined(__GNUG__)
+#  if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 8)
+#    error pybind11 requires gcc 4.8 or newer
+#  endif
+#elif defined(_MSC_VER)
+// Pybind hits various compiler bugs in 2015u2 and earlier, and also makes use of some stl features
+// (e.g. std::negation) added in 2015u3:
+#  if _MSC_FULL_VER < 190024210
+#    error pybind11 requires MSVC 2015 update 3 or newer
+#  endif
+#endif
+
+#if !defined(PYBIND11_EXPORT)
+#  if defined(WIN32) || defined(_WIN32)
+#    define PYBIND11_EXPORT __declspec(dllexport)
+#  else
+#    define PYBIND11_EXPORT __attribute__ ((visibility("default")))
+#  endif
+#endif
+
+#if defined(_MSC_VER)
+#  define PYBIND11_NOINLINE __declspec(noinline)
+#else
+#  define PYBIND11_NOINLINE __attribute__ ((noinline))
+#endif
+
+#if defined(PYBIND11_CPP14)
+#  define PYBIND11_DEPRECATED(reason) [[deprecated(reason)]]
+#else
+#  define PYBIND11_DEPRECATED(reason) __attribute__((deprecated(reason)))
+#endif
+
+#define PYBIND11_VERSION_MAJOR 2
+#define PYBIND11_VERSION_MINOR 5
+#define PYBIND11_VERSION_PATCH 0
+
+/// Include Python header, disable linking to pythonX_d.lib on Windows in debug mode
+#if defined(_MSC_VER)
+#  if (PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION < 4)
+#    define HAVE_ROUND 1
+#  endif
+#  pragma warning(push)
+#  pragma warning(disable: 4510 4610 4512 4005)
+#  if defined(_DEBUG) && !defined(Py_DEBUG)
+#    define PYBIND11_DEBUG_MARKER
+#    undef _DEBUG
+#  endif
+#endif
+
+#include <Python.h>
+#include <frameobject.h>
+#include <pythread.h>
+
+/* Python #defines overrides on all sorts of core functions, which
+   tends to weak havok in C++ codebases that expect these to work
+   like regular functions (potentially with several overloads) */
+#if defined(isalnum)
+#  undef isalnum
+#  undef isalpha
+#  undef islower
+#  undef isspace
+#  undef isupper
+#  undef tolower
+#  undef toupper
+#endif
+
+#if defined(copysign)
+#  undef copysign
+#endif
+
+#if defined(_MSC_VER)
+#  if defined(PYBIND11_DEBUG_MARKER)
+#    define _DEBUG
+#    undef PYBIND11_DEBUG_MARKER
+#  endif
+#  pragma warning(pop)
+#endif
+
+#include <cstddef>
+#include <cstring>
+#include <forward_list>
+#include <vector>
+#include <string>
+#include <stdexcept>
+#include <unordered_set>
+#include <unordered_map>
+#include <memory>
+#include <typeindex>
+#include <type_traits>
+
+#if PY_MAJOR_VERSION >= 3 /// Compatibility macros for various Python versions
+#define PYBIND11_INSTANCE_METHOD_NEW(ptr, class_) PyInstanceMethod_New(ptr)
+#define PYBIND11_INSTANCE_METHOD_CHECK PyInstanceMethod_Check
+#define PYBIND11_INSTANCE_METHOD_GET_FUNCTION PyInstanceMethod_GET_FUNCTION
+#define PYBIND11_BYTES_CHECK PyBytes_Check
+#define PYBIND11_BYTES_FROM_STRING PyBytes_FromString
+#define PYBIND11_BYTES_FROM_STRING_AND_SIZE PyBytes_FromStringAndSize
+#define PYBIND11_BYTES_AS_STRING_AND_SIZE PyBytes_AsStringAndSize
+#define PYBIND11_BYTES_AS_STRING PyBytes_AsString
+#define PYBIND11_BYTES_SIZE PyBytes_Size
+#define PYBIND11_LONG_CHECK(o) PyLong_Check(o)
+#define PYBIND11_LONG_AS_LONGLONG(o) PyLong_AsLongLong(o)
+#define PYBIND11_LONG_FROM_SIGNED(o) PyLong_FromSsize_t((ssize_t) o)
+#define PYBIND11_LONG_FROM_UNSIGNED(o) PyLong_FromSize_t((size_t) o)
+#define PYBIND11_BYTES_NAME "bytes"
+#define PYBIND11_STRING_NAME "str"
+#define PYBIND11_SLICE_OBJECT PyObject
+#define PYBIND11_FROM_STRING PyUnicode_FromString
+#define PYBIND11_STR_TYPE ::pybind11::str
+#define PYBIND11_BOOL_ATTR "__bool__"
+#define PYBIND11_NB_BOOL(ptr) ((ptr)->nb_bool)
+// Providing a separate declaration to make Clang's -Wmissing-prototypes happy
+#define PYBIND11_PLUGIN_IMPL(name) \
+    extern "C" PYBIND11_EXPORT PyObject *PyInit_##name();   \
+    extern "C" PYBIND11_EXPORT PyObject *PyInit_##name()
+
+#else
+#define PYBIND11_INSTANCE_METHOD_NEW(ptr, class_) PyMethod_New(ptr, nullptr, class_)
+#define PYBIND11_INSTANCE_METHOD_CHECK PyMethod_Check
+#define PYBIND11_INSTANCE_METHOD_GET_FUNCTION PyMethod_GET_FUNCTION
+#define PYBIND11_BYTES_CHECK PyString_Check
+#define PYBIND11_BYTES_FROM_STRING PyString_FromString
+#define PYBIND11_BYTES_FROM_STRING_AND_SIZE PyString_FromStringAndSize
+#define PYBIND11_BYTES_AS_STRING_AND_SIZE PyString_AsStringAndSize
+#define PYBIND11_BYTES_AS_STRING PyString_AsString
+#define PYBIND11_BYTES_SIZE PyString_Size
+#define PYBIND11_LONG_CHECK(o) (PyInt_Check(o) || PyLong_Check(o))
+#define PYBIND11_LONG_AS_LONGLONG(o) (PyInt_Check(o) ? (long long) PyLong_AsLong(o) : PyLong_AsLongLong(o))
+#define PYBIND11_LONG_FROM_SIGNED(o) PyInt_FromSsize_t((ssize_t) o) // Returns long if needed.
+#define PYBIND11_LONG_FROM_UNSIGNED(o) PyInt_FromSize_t((size_t) o) // Returns long if needed.
+#define PYBIND11_BYTES_NAME "str"
+#define PYBIND11_STRING_NAME "unicode"
+#define PYBIND11_SLICE_OBJECT PySliceObject
+#define PYBIND11_FROM_STRING PyString_FromString
+#define PYBIND11_STR_TYPE ::pybind11::bytes
+#define PYBIND11_BOOL_ATTR "__nonzero__"
+#define PYBIND11_NB_BOOL(ptr) ((ptr)->nb_nonzero)
+// Providing a separate PyInit decl to make Clang's -Wmissing-prototypes happy
+#define PYBIND11_PLUGIN_IMPL(name) \
+    static PyObject *pybind11_init_wrapper();               \
+    extern "C" PYBIND11_EXPORT void init##name();           \
+    extern "C" PYBIND11_EXPORT void init##name() {          \
+        (void)pybind11_init_wrapper();                      \
+    }                                                       \
+    PyObject *pybind11_init_wrapper()
+#endif
+
+#if PY_VERSION_HEX >= 0x03050000 && PY_VERSION_HEX < 0x03050200
+extern "C" {
+    struct _Py_atomic_address { void *value; };
+    PyAPI_DATA(_Py_atomic_address) _PyThreadState_Current;
+}
+#endif
+
+#define PYBIND11_TRY_NEXT_OVERLOAD ((PyObject *) 1) // special failure return code
+#define PYBIND11_STRINGIFY(x) #x
+#define PYBIND11_TOSTRING(x) PYBIND11_STRINGIFY(x)
+#define PYBIND11_CONCAT(first, second) first##second
+#define PYBIND11_ENSURE_INTERNALS_READY \
+    pybind11::detail::get_internals();
+
+#define PYBIND11_CHECK_PYTHON_VERSION \
+    {                                                                          \
+        const char *compiled_ver = PYBIND11_TOSTRING(PY_MAJOR_VERSION)         \
+            "." PYBIND11_TOSTRING(PY_MINOR_VERSION);                           \
+        const char *runtime_ver = Py_GetVersion();                             \
+        size_t len = std::strlen(compiled_ver);                                \
+        if (std::strncmp(runtime_ver, compiled_ver, len) != 0                  \
+                || (runtime_ver[len] >= '0' && runtime_ver[len] <= '9')) {     \
+            PyErr_Format(PyExc_ImportError,                                    \
+                "Python version mismatch: module was compiled for Python %s, " \
+                "but the interpreter version is incompatible: %s.",            \
+                compiled_ver, runtime_ver);                                    \
+            return nullptr;                                                    \
+        }                                                                      \
+    }
+
+#define PYBIND11_CATCH_INIT_EXCEPTIONS \
+        catch (pybind11::error_already_set &e) {                               \
+            PyErr_SetString(PyExc_ImportError, e.what());                      \
+            return nullptr;                                                    \
+        } catch (const std::exception &e) {                                    \
+            PyErr_SetString(PyExc_ImportError, e.what());                      \
+            return nullptr;                                                    \
+        }                                                                      \
+
+/** \rst
+    ***Deprecated in favor of PYBIND11_MODULE***
+
+    This macro creates the entry point that will be invoked when the Python interpreter
+    imports a plugin library. Please create a `module` in the function body and return
+    the pointer to its underlying Python object at the end.
+
+    .. code-block:: cpp
+
+        PYBIND11_PLUGIN(example) {
+            pybind11::module m("example", "pybind11 example plugin");
+            /// Set up bindings here
+            return m.ptr();
+        }
+\endrst */
+#define PYBIND11_PLUGIN(name)                                                  \
+    PYBIND11_DEPRECATED("PYBIND11_PLUGIN is deprecated, use PYBIND11_MODULE")  \
+    static PyObject *pybind11_init();                                          \
+    PYBIND11_PLUGIN_IMPL(name) {                                               \
+        PYBIND11_CHECK_PYTHON_VERSION                                          \
+        PYBIND11_ENSURE_INTERNALS_READY                                        \
+        try {                                                                  \
+            return pybind11_init();                                            \
+        } PYBIND11_CATCH_INIT_EXCEPTIONS                                       \
+    }                                                                          \
+    PyObject *pybind11_init()
+
+/** \rst
+    This macro creates the entry point that will be invoked when the Python interpreter
+    imports an extension module. The module name is given as the fist argument and it
+    should not be in quotes. The second macro argument defines a variable of type
+    `py::module` which can be used to initialize the module.
+
+    .. code-block:: cpp
+
+        PYBIND11_MODULE(example, m) {
+            m.doc() = "pybind11 example module";
+
+            // Add bindings here
+            m.def("foo", []() {
+                return "Hello, World!";
+            });
+        }
+\endrst */
+#define PYBIND11_MODULE(name, variable)                                        \
+    static void PYBIND11_CONCAT(pybind11_init_, name)(pybind11::module &);     \
+    PYBIND11_PLUGIN_IMPL(name) {                                               \
+        PYBIND11_CHECK_PYTHON_VERSION                                          \
+        PYBIND11_ENSURE_INTERNALS_READY                                        \
+        auto m = pybind11::module(PYBIND11_TOSTRING(name));                    \
+        try {                                                                  \
+            PYBIND11_CONCAT(pybind11_init_, name)(m);                          \
+            return m.ptr();                                                    \
+        } PYBIND11_CATCH_INIT_EXCEPTIONS                                       \
+    }                                                                          \
+    void PYBIND11_CONCAT(pybind11_init_, name)(pybind11::module &variable)
+
+
+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+
+using ssize_t = Py_ssize_t;
+using size_t  = std::size_t;
+
+/// Approach used to cast a previously unknown C++ instance into a Python object
+enum class return_value_policy : uint8_t {
+    /** This is the default return value policy, which falls back to the policy
+        return_value_policy::take_ownership when the return value is a pointer.
+        Otherwise, it uses return_value::move or return_value::copy for rvalue
+        and lvalue references, respectively. See below for a description of what
+        all of these different policies do. */
+    automatic = 0,
+
+    /** As above, but use policy return_value_policy::reference when the return
+        value is a pointer. This is the default conversion policy for function
+        arguments when calling Python functions manually from C++ code (i.e. via
+        handle::operator()). You probably won't need to use this. */
+    automatic_reference,
+
+    /** Reference an existing object (i.e. do not create a new copy) and take
+        ownership. Python will call the destructor and delete operator when the
+        object’s reference count reaches zero. Undefined behavior ensues when
+        the C++ side does the same.. */
+    take_ownership,
+
+    /** Create a new copy of the returned object, which will be owned by
+        Python. This policy is comparably safe because the lifetimes of the two
+        instances are decoupled. */
+    copy,
+
+    /** Use std::move to move the return value contents into a new instance
+        that will be owned by Python. This policy is comparably safe because the
+        lifetimes of the two instances (move source and destination) are
+        decoupled. */
+    move,
+
+    /** Reference an existing object, but do not take ownership. The C++ side
+        is responsible for managing the object’s lifetime and deallocating it
+        when it is no longer used. Warning: undefined behavior will ensue when
+        the C++ side deletes an object that is still referenced and used by
+        Python. */
+    reference,
+
+    /** This policy only applies to methods and properties. It references the
+        object without taking ownership similar to the above
+        return_value_policy::reference policy. In contrast to that policy, the
+        function or property’s implicit this argument (called the parent) is
+        considered to be the the owner of the return value (the child).
+        pybind11 then couples the lifetime of the parent to the child via a
+        reference relationship that ensures that the parent cannot be garbage
+        collected while Python is still using the child. More advanced
+        variations of this scheme are also possible using combinations of
+        return_value_policy::reference and the keep_alive call policy */
+    reference_internal
+};
+
+NAMESPACE_BEGIN(detail)
+
+inline static constexpr int log2(size_t n, int k = 0) { return (n <= 1) ? k : log2(n >> 1, k + 1); }
+
+// Returns the size as a multiple of sizeof(void *), rounded up.
+inline static constexpr size_t size_in_ptrs(size_t s) { return 1 + ((s - 1) >> log2(sizeof(void *))); }
+
+/**
+ * The space to allocate for simple layout instance holders (see below) in multiple of the size of
+ * a pointer (e.g.  2 means 16 bytes on 64-bit architectures).  The default is the minimum required
+ * to holder either a std::unique_ptr or std::shared_ptr (which is almost always
+ * sizeof(std::shared_ptr<T>)).
+ */
+constexpr size_t instance_simple_holder_in_ptrs() {
+    static_assert(sizeof(std::shared_ptr<int>) >= sizeof(std::unique_ptr<int>),
+            "pybind assumes std::shared_ptrs are at least as big as std::unique_ptrs");
+    return size_in_ptrs(sizeof(std::shared_ptr<int>));
+}
+
+// Forward declarations
+struct type_info;
+struct value_and_holder;
+
+struct nonsimple_values_and_holders {
+    void **values_and_holders;
+    uint8_t *status;
+};
+
+/// The 'instance' type which needs to be standard layout (need to be able to use 'offsetof')
+struct instance {
+    PyObject_HEAD
+    /// Storage for pointers and holder; see simple_layout, below, for a description
+    union {
+        void *simple_value_holder[1 + instance_simple_holder_in_ptrs()];
+        nonsimple_values_and_holders nonsimple;
+    };
+    /// Weak references
+    PyObject *weakrefs;
+    /// If true, the pointer is owned which means we're free to manage it with a holder.
+    bool owned : 1;
+    /**
+     * An instance has two possible value/holder layouts.
+     *
+     * Simple layout (when this flag is true), means the `simple_value_holder` is set with a pointer
+     * and the holder object governing that pointer, i.e. [val1*][holder].  This layout is applied
+     * whenever there is no python-side multiple inheritance of bound C++ types *and* the type's
+     * holder will fit in the default space (which is large enough to hold either a std::unique_ptr
+     * or std::shared_ptr).
+     *
+     * Non-simple layout applies when using custom holders that require more space than `shared_ptr`
+     * (which is typically the size of two pointers), or when multiple inheritance is used on the
+     * python side.  Non-simple layout allocates the required amount of memory to have multiple
+     * bound C++ classes as parents.  Under this layout, `nonsimple.values_and_holders` is set to a
+     * pointer to allocated space of the required space to hold a sequence of value pointers and
+     * holders followed `status`, a set of bit flags (1 byte each), i.e.
+     * [val1*][holder1][val2*][holder2]...[bb...]  where each [block] is rounded up to a multiple of
+     * `sizeof(void *)`.  `nonsimple.status` is, for convenience, a pointer to the
+     * beginning of the [bb...] block (but not independently allocated).
+     *
+     * Status bits indicate whether the associated holder is constructed (&
+     * status_holder_constructed) and whether the value pointer is registered (&
+     * status_instance_registered) in `registered_instances`.
+     */
+    bool simple_layout : 1;
+    /// For simple layout, tracks whether the holder has been constructed
+    bool simple_holder_constructed : 1;
+    /// For simple layout, tracks whether the instance is registered in `registered_instances`
+    bool simple_instance_registered : 1;
+    /// If true, get_internals().patients has an entry for this object
+    bool has_patients : 1;
+
+    /// Initializes all of the above type/values/holders data (but not the instance values themselves)
+    void allocate_layout();
+
+    /// Destroys/deallocates all of the above
+    void deallocate_layout();
+
+    /// Returns the value_and_holder wrapper for the given type (or the first, if `find_type`
+    /// omitted).  Returns a default-constructed (with `.inst = nullptr`) object on failure if
+    /// `throw_if_missing` is false.
+    value_and_holder get_value_and_holder(const type_info *find_type = nullptr, bool throw_if_missing = true);
+
+    /// Bit values for the non-simple status flags
+    static constexpr uint8_t status_holder_constructed  = 1;
+    static constexpr uint8_t status_instance_registered = 2;
+};
+
+static_assert(std::is_standard_layout<instance>::value, "Internal error: `pybind11::detail::instance` is not standard layout!");
+
+/// from __cpp_future__ import (convenient aliases from C++14/17)
+#if defined(PYBIND11_CPP14) && (!defined(_MSC_VER) || _MSC_VER >= 1910)
+using std::enable_if_t;
+using std::conditional_t;
+using std::remove_cv_t;
+using std::remove_reference_t;
+#else
+template <bool B, typename T = void> using enable_if_t = typename std::enable_if<B, T>::type;
+template <bool B, typename T, typename F> using conditional_t = typename std::conditional<B, T, F>::type;
+template <typename T> using remove_cv_t = typename std::remove_cv<T>::type;
+template <typename T> using remove_reference_t = typename std::remove_reference<T>::type;
+#endif
+
+/// Index sequences
+#if defined(PYBIND11_CPP14)
+using std::index_sequence;
+using std::make_index_sequence;
+#else
+template<size_t ...> struct index_sequence  { };
+template<size_t N, size_t ...S> struct make_index_sequence_impl : make_index_sequence_impl <N - 1, N - 1, S...> { };
+template<size_t ...S> struct make_index_sequence_impl <0, S...> { typedef index_sequence<S...> type; };
+template<size_t N> using make_index_sequence = typename make_index_sequence_impl<N>::type;
+#endif
+
+/// Make an index sequence of the indices of true arguments
+template <typename ISeq, size_t, bool...> struct select_indices_impl { using type = ISeq; };
+template <size_t... IPrev, size_t I, bool B, bool... Bs> struct select_indices_impl<index_sequence<IPrev...>, I, B, Bs...>
+    : select_indices_impl<conditional_t<B, index_sequence<IPrev..., I>, index_sequence<IPrev...>>, I + 1, Bs...> {};
+template <bool... Bs> using select_indices = typename select_indices_impl<index_sequence<>, 0, Bs...>::type;
+
+/// Backports of std::bool_constant and std::negation to accommodate older compilers
+template <bool B> using bool_constant = std::integral_constant<bool, B>;
+template <typename T> struct negation : bool_constant<!T::value> { };
+
+template <typename...> struct void_t_impl { using type = void; };
+template <typename... Ts> using void_t = typename void_t_impl<Ts...>::type;
+
+/// Compile-time all/any/none of that check the boolean value of all template types
+#if defined(__cpp_fold_expressions) && !(defined(_MSC_VER) && (_MSC_VER < 1916))
+template <class... Ts> using all_of = bool_constant<(Ts::value && ...)>;
+template <class... Ts> using any_of = bool_constant<(Ts::value || ...)>;
+#elif !defined(_MSC_VER)
+template <bool...> struct bools {};
+template <class... Ts> using all_of = std::is_same<
+    bools<Ts::value..., true>,
+    bools<true, Ts::value...>>;
+template <class... Ts> using any_of = negation<all_of<negation<Ts>...>>;
+#else
+// MSVC has trouble with the above, but supports std::conjunction, which we can use instead (albeit
+// at a slight loss of compilation efficiency).
+template <class... Ts> using all_of = std::conjunction<Ts...>;
+template <class... Ts> using any_of = std::disjunction<Ts...>;
+#endif
+template <class... Ts> using none_of = negation<any_of<Ts...>>;
+
+template <class T, template<class> class... Predicates> using satisfies_all_of = all_of<Predicates<T>...>;
+template <class T, template<class> class... Predicates> using satisfies_any_of = any_of<Predicates<T>...>;
+template <class T, template<class> class... Predicates> using satisfies_none_of = none_of<Predicates<T>...>;
+
+/// Strip the class from a method type
+template <typename T> struct remove_class { };
+template <typename C, typename R, typename... A> struct remove_class<R (C::*)(A...)> { typedef R type(A...); };
+template <typename C, typename R, typename... A> struct remove_class<R (C::*)(A...) const> { typedef R type(A...); };
+
+/// Helper template to strip away type modifiers
+template <typename T> struct intrinsic_type                       { typedef T type; };
+template <typename T> struct intrinsic_type<const T>              { typedef typename intrinsic_type<T>::type type; };
+template <typename T> struct intrinsic_type<T*>                   { typedef typename intrinsic_type<T>::type type; };
+template <typename T> struct intrinsic_type<T&>                   { typedef typename intrinsic_type<T>::type type; };
+template <typename T> struct intrinsic_type<T&&>                  { typedef typename intrinsic_type<T>::type type; };
+template <typename T, size_t N> struct intrinsic_type<const T[N]> { typedef typename intrinsic_type<T>::type type; };
+template <typename T, size_t N> struct intrinsic_type<T[N]>       { typedef typename intrinsic_type<T>::type type; };
+template <typename T> using intrinsic_t = typename intrinsic_type<T>::type;
+
+/// Helper type to replace 'void' in some expressions
+struct void_type { };
+
+/// Helper template which holds a list of types
+template <typename...> struct type_list { };
+
+/// Compile-time integer sum
+#ifdef __cpp_fold_expressions
+template <typename... Ts> constexpr size_t constexpr_sum(Ts... ns) { return (0 + ... + size_t{ns}); }
+#else
+constexpr size_t constexpr_sum() { return 0; }
+template <typename T, typename... Ts>
+constexpr size_t constexpr_sum(T n, Ts... ns) { return size_t{n} + constexpr_sum(ns...); }
+#endif
+
+NAMESPACE_BEGIN(constexpr_impl)
+/// Implementation details for constexpr functions
+constexpr int first(int i) { return i; }
+template <typename T, typename... Ts>
+constexpr int first(int i, T v, Ts... vs) { return v ? i : first(i + 1, vs...); }
+
+constexpr int last(int /*i*/, int result) { return result; }
+template <typename T, typename... Ts>
+constexpr int last(int i, int result, T v, Ts... vs) { return last(i + 1, v ? i : result, vs...); }
+NAMESPACE_END(constexpr_impl)
+
+/// Return the index of the first type in Ts which satisfies Predicate<T>.  Returns sizeof...(Ts) if
+/// none match.
+template <template<typename> class Predicate, typename... Ts>
+constexpr int constexpr_first() { return constexpr_impl::first(0, Predicate<Ts>::value...); }
+
+/// Return the index of the last type in Ts which satisfies Predicate<T>, or -1 if none match.
+template <template<typename> class Predicate, typename... Ts>
+constexpr int constexpr_last() { return constexpr_impl::last(0, -1, Predicate<Ts>::value...); }
+
+/// Return the Nth element from the parameter pack
+template <size_t N, typename T, typename... Ts>
+struct pack_element { using type = typename pack_element<N - 1, Ts...>::type; };
+template <typename T, typename... Ts>
+struct pack_element<0, T, Ts...> { using type = T; };
+
+/// Return the one and only type which matches the predicate, or Default if none match.
+/// If more than one type matches the predicate, fail at compile-time.
+template <template<typename> class Predicate, typename Default, typename... Ts>
+struct exactly_one {
+    static constexpr auto found = constexpr_sum(Predicate<Ts>::value...);
+    static_assert(found <= 1, "Found more than one type matching the predicate");
+
+    static constexpr auto index = found ? constexpr_first<Predicate, Ts...>() : 0;
+    using type = conditional_t<found, typename pack_element<index, Ts...>::type, Default>;
+};
+template <template<typename> class P, typename Default>
+struct exactly_one<P, Default> { using type = Default; };
+
+template <template<typename> class Predicate, typename Default, typename... Ts>
+using exactly_one_t = typename exactly_one<Predicate, Default, Ts...>::type;
+
+/// Defer the evaluation of type T until types Us are instantiated
+template <typename T, typename... /*Us*/> struct deferred_type { using type = T; };
+template <typename T, typename... Us> using deferred_t = typename deferred_type<T, Us...>::type;
+
+/// Like is_base_of, but requires a strict base (i.e. `is_strict_base_of<T, T>::value == false`,
+/// unlike `std::is_base_of`)
+template <typename Base, typename Derived> using is_strict_base_of = bool_constant<
+    std::is_base_of<Base, Derived>::value && !std::is_same<Base, Derived>::value>;
+
+/// Like is_base_of, but also requires that the base type is accessible (i.e. that a Derived pointer
+/// can be converted to a Base pointer)
+template <typename Base, typename Derived> using is_accessible_base_of = bool_constant<
+    std::is_base_of<Base, Derived>::value && std::is_convertible<Derived *, Base *>::value>;
+
+template <template<typename...> class Base>
+struct is_template_base_of_impl {
+    template <typename... Us> static std::true_type check(Base<Us...> *);
+    static std::false_type check(...);
+};
+
+/// Check if a template is the base of a type. For example:
+/// `is_template_base_of<Base, T>` is true if `struct T : Base<U> {}` where U can be anything
+template <template<typename...> class Base, typename T>
+#if !defined(_MSC_VER)
+using is_template_base_of = decltype(is_template_base_of_impl<Base>::check((intrinsic_t<T>*)nullptr));
+#else // MSVC2015 has trouble with decltype in template aliases
+struct is_template_base_of : decltype(is_template_base_of_impl<Base>::check((intrinsic_t<T>*)nullptr)) { };
+#endif
+
+/// Check if T is an instantiation of the template `Class`. For example:
+/// `is_instantiation<shared_ptr, T>` is true if `T == shared_ptr<U>` where U can be anything.
+template <template<typename...> class Class, typename T>
+struct is_instantiation : std::false_type { };
+template <template<typename...> class Class, typename... Us>
+struct is_instantiation<Class, Class<Us...>> : std::true_type { };
+
+/// Check if T is std::shared_ptr<U> where U can be anything
+template <typename T> using is_shared_ptr = is_instantiation<std::shared_ptr, T>;
+
+/// Check if T looks like an input iterator
+template <typename T, typename = void> struct is_input_iterator : std::false_type {};
+template <typename T>
+struct is_input_iterator<T, void_t<decltype(*std::declval<T &>()), decltype(++std::declval<T &>())>>
+    : std::true_type {};
+
+template <typename T> using is_function_pointer = bool_constant<
+    std::is_pointer<T>::value && std::is_function<typename std::remove_pointer<T>::type>::value>;
+
+template <typename F> struct strip_function_object {
+    using type = typename remove_class<decltype(&F::operator())>::type;
+};
+
+// Extracts the function signature from a function, function pointer or lambda.
+template <typename Function, typename F = remove_reference_t<Function>>
+using function_signature_t = conditional_t<
+    std::is_function<F>::value,
+    F,
+    typename conditional_t<
+        std::is_pointer<F>::value || std::is_member_pointer<F>::value,
+        std::remove_pointer<F>,
+        strip_function_object<F>
+    >::type
+>;
+
+/// Returns true if the type looks like a lambda: that is, isn't a function, pointer or member
+/// pointer.  Note that this can catch all sorts of other things, too; this is intended to be used
+/// in a place where passing a lambda makes sense.
+template <typename T> using is_lambda = satisfies_none_of<remove_reference_t<T>,
+        std::is_function, std::is_pointer, std::is_member_pointer>;
+
+/// Ignore that a variable is unused in compiler warnings
+inline void ignore_unused(const int *) { }
+
+/// Apply a function over each element of a parameter pack
+#ifdef __cpp_fold_expressions
+#define PYBIND11_EXPAND_SIDE_EFFECTS(PATTERN) (((PATTERN), void()), ...)
+#else
+using expand_side_effects = bool[];
+#define PYBIND11_EXPAND_SIDE_EFFECTS(PATTERN) pybind11::detail::expand_side_effects{ ((PATTERN), void(), false)..., false }
+#endif
+
+NAMESPACE_END(detail)
+
+/// C++ bindings of builtin Python exceptions
+class builtin_exception : public std::runtime_error {
+public:
+    using std::runtime_error::runtime_error;
+    /// Set the error using the Python C API
+    virtual void set_error() const = 0;
+};
+
+#define PYBIND11_RUNTIME_EXCEPTION(name, type) \
+    class name : public builtin_exception { public: \
+        using builtin_exception::builtin_exception; \
+        name() : name("") { } \
+        void set_error() const override { PyErr_SetString(type, what()); } \
+    };
+
+PYBIND11_RUNTIME_EXCEPTION(stop_iteration, PyExc_StopIteration)
+PYBIND11_RUNTIME_EXCEPTION(index_error, PyExc_IndexError)
+PYBIND11_RUNTIME_EXCEPTION(key_error, PyExc_KeyError)
+PYBIND11_RUNTIME_EXCEPTION(value_error, PyExc_ValueError)
+PYBIND11_RUNTIME_EXCEPTION(type_error, PyExc_TypeError)
+PYBIND11_RUNTIME_EXCEPTION(buffer_error, PyExc_BufferError)
+PYBIND11_RUNTIME_EXCEPTION(import_error, PyExc_ImportError)
+PYBIND11_RUNTIME_EXCEPTION(cast_error, PyExc_RuntimeError) /// Thrown when pybind11::cast or handle::call fail due to a type casting error
+PYBIND11_RUNTIME_EXCEPTION(reference_cast_error, PyExc_RuntimeError) /// Used internally
+
+[[noreturn]] PYBIND11_NOINLINE inline void pybind11_fail(const char *reason) { throw std::runtime_error(reason); }
+[[noreturn]] PYBIND11_NOINLINE inline void pybind11_fail(const std::string &reason) { throw std::runtime_error(reason); }
+
+template <typename T, typename SFINAE = void> struct format_descriptor { };
+
+NAMESPACE_BEGIN(detail)
+// Returns the index of the given type in the type char array below, and in the list in numpy.h
+// The order here is: bool; 8 ints ((signed,unsigned)x(8,16,32,64)bits); float,double,long double;
+// complex float,double,long double.  Note that the long double types only participate when long
+// double is actually longer than double (it isn't under MSVC).
+// NB: not only the string below but also complex.h and numpy.h rely on this order.
+template <typename T, typename SFINAE = void> struct is_fmt_numeric { static constexpr bool value = false; };
+template <typename T> struct is_fmt_numeric<T, enable_if_t<std::is_arithmetic<T>::value>> {
+    static constexpr bool value = true;
+    static constexpr int index = std::is_same<T, bool>::value ? 0 : 1 + (
+        std::is_integral<T>::value ? detail::log2(sizeof(T))*2 + std::is_unsigned<T>::value : 8 + (
+        std::is_same<T, double>::value ? 1 : std::is_same<T, long double>::value ? 2 : 0));
+};
+NAMESPACE_END(detail)
+
+template <typename T> struct format_descriptor<T, detail::enable_if_t<std::is_arithmetic<T>::value>> {
+    static constexpr const char c = "?bBhHiIqQfdg"[detail::is_fmt_numeric<T>::index];
+    static constexpr const char value[2] = { c, '\0' };
+    static std::string format() { return std::string(1, c); }
+};
+
+#if !defined(PYBIND11_CPP17)
+
+template <typename T> constexpr const char format_descriptor<
+    T, detail::enable_if_t<std::is_arithmetic<T>::value>>::value[2];
+
+#endif
+
+/// RAII wrapper that temporarily clears any Python error state
+struct error_scope {
+    PyObject *type, *value, *trace;
+    error_scope() { PyErr_Fetch(&type, &value, &trace); }
+    ~error_scope() { PyErr_Restore(type, value, trace); }
+};
+
+/// Dummy destructor wrapper that can be used to expose classes with a private destructor
+struct nodelete { template <typename T> void operator()(T*) { } };
+
+NAMESPACE_BEGIN(detail)
+template <typename... Args>
+struct overload_cast_impl {
+    constexpr overload_cast_impl() {} // MSVC 2015 needs this
+
+    template <typename Return>
+    constexpr auto operator()(Return (*pf)(Args...)) const noexcept
+                              -> decltype(pf) { return pf; }
+
+    template <typename Return, typename Class>
+    constexpr auto operator()(Return (Class::*pmf)(Args...), std::false_type = {}) const noexcept
+                              -> decltype(pmf) { return pmf; }
+
+    template <typename Return, typename Class>
+    constexpr auto operator()(Return (Class::*pmf)(Args...) const, std::true_type) const noexcept
+                              -> decltype(pmf) { return pmf; }
+};
+NAMESPACE_END(detail)
+
+// overload_cast requires variable templates: C++14
+#if defined(PYBIND11_CPP14)
+#define PYBIND11_OVERLOAD_CAST 1
+/// Syntax sugar for resolving overloaded function pointers:
+///  - regular: static_cast<Return (Class::*)(Arg0, Arg1, Arg2)>(&Class::func)
+///  - sweet:   overload_cast<Arg0, Arg1, Arg2>(&Class::func)
+template <typename... Args>
+static constexpr detail::overload_cast_impl<Args...> overload_cast = {};
+// MSVC 2015 only accepts this particular initialization syntax for this variable template.
+#endif
+
+/// Const member function selector for overload_cast
+///  - regular: static_cast<Return (Class::*)(Arg) const>(&Class::func)
+///  - sweet:   overload_cast<Arg>(&Class::func, const_)
+static constexpr auto const_ = std::true_type{};
+
+#if !defined(PYBIND11_CPP14) // no overload_cast: providing something that static_assert-fails:
+template <typename... Args> struct overload_cast {
+    static_assert(detail::deferred_t<std::false_type, Args...>::value,
+                  "pybind11::overload_cast<...> requires compiling in C++14 mode");
+};
+#endif // overload_cast
+
+NAMESPACE_BEGIN(detail)
+
+// Adaptor for converting arbitrary container arguments into a vector; implicitly convertible from
+// any standard container (or C-style array) supporting std::begin/std::end, any singleton
+// arithmetic type (if T is arithmetic), or explicitly constructible from an iterator pair.
+template <typename T>
+class any_container {
+    std::vector<T> v;
+public:
+    any_container() = default;
+
+    // Can construct from a pair of iterators
+    template <typename It, typename = enable_if_t<is_input_iterator<It>::value>>
+    any_container(It first, It last) : v(first, last) { }
+
+    // Implicit conversion constructor from any arbitrary container type with values convertible to T
+    template <typename Container, typename = enable_if_t<std::is_convertible<decltype(*std::begin(std::declval<const Container &>())), T>::value>>
+    any_container(const Container &c) : any_container(std::begin(c), std::end(c)) { }
+
+    // initializer_list's aren't deducible, so don't get matched by the above template; we need this
+    // to explicitly allow implicit conversion from one:
+    template <typename TIn, typename = enable_if_t<std::is_convertible<TIn, T>::value>>
+    any_container(const std::initializer_list<TIn> &c) : any_container(c.begin(), c.end()) { }
+
+    // Avoid copying if given an rvalue vector of the correct type.
+    any_container(std::vector<T> &&v) : v(std::move(v)) { }
+
+    // Moves the vector out of an rvalue any_container
+    operator std::vector<T> &&() && { return std::move(v); }
+
+    // Dereferencing obtains a reference to the underlying vector
+    std::vector<T> &operator*() { return v; }
+    const std::vector<T> &operator*() const { return v; }
+
+    // -> lets you call methods on the underlying vector
+    std::vector<T> *operator->() { return &v; }
+    const std::vector<T> *operator->() const { return &v; }
+};
+
+NAMESPACE_END(detail)
+
+
+
+NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/src/pybind11/include/pybind11/detail/descr.h b/src/pybind11/include/pybind11/detail/descr.h
new file mode 100644
index 0000000..8d404e5
--- /dev/null
+++ b/src/pybind11/include/pybind11/detail/descr.h
@@ -0,0 +1,100 @@
+/*
+    pybind11/detail/descr.h: Helper type for concatenating type signatures at compile time
+
+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
+
+    All rights reserved. Use of this source code is governed by a
+    BSD-style license that can be found in the LICENSE file.
+*/
+
+#pragma once
+
+#include "common.h"
+
+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+NAMESPACE_BEGIN(detail)
+
+#if !defined(_MSC_VER)
+#  define PYBIND11_DESCR_CONSTEXPR static constexpr
+#else
+#  define PYBIND11_DESCR_CONSTEXPR const
+#endif
+
+/* Concatenate type signatures at compile time */
+template <size_t N, typename... Ts>
+struct descr {
+    char text[N + 1];
+
+    constexpr descr() : text{'\0'} { }
+    constexpr descr(char const (&s)[N+1]) : descr(s, make_index_sequence<N>()) { }
+
+    template <size_t... Is>
+    constexpr descr(char const (&s)[N+1], index_sequence<Is...>) : text{s[Is]..., '\0'} { }
+
+    template <typename... Chars>
+    constexpr descr(char c, Chars... cs) : text{c, static_cast<char>(cs)..., '\0'} { }
+
+    static constexpr std::array<const std::type_info *, sizeof...(Ts) + 1> types() {
+        return {{&typeid(Ts)..., nullptr}};
+    }
+};
+
+template <size_t N1, size_t N2, typename... Ts1, typename... Ts2, size_t... Is1, size_t... Is2>
+constexpr descr<N1 + N2, Ts1..., Ts2...> plus_impl(const descr<N1, Ts1...> &a, const descr<N2, Ts2...> &b,
+                                                   index_sequence<Is1...>, index_sequence<Is2...>) {
+    return {a.text[Is1]..., b.text[Is2]...};
+}
+
+template <size_t N1, size_t N2, typename... Ts1, typename... Ts2>
+constexpr descr<N1 + N2, Ts1..., Ts2...> operator+(const descr<N1, Ts1...> &a, const descr<N2, Ts2...> &b) {
+    return plus_impl(a, b, make_index_sequence<N1>(), make_index_sequence<N2>());
+}
+
+template <size_t N>
+constexpr descr<N - 1> _(char const(&text)[N]) { return descr<N - 1>(text); }
+constexpr descr<0> _(char const(&)[1]) { return {}; }
+
+template <size_t Rem, size_t... Digits> struct int_to_str : int_to_str<Rem/10, Rem%10, Digits...> { };
+template <size_t...Digits> struct int_to_str<0, Digits...> {
+    static constexpr auto digits = descr<sizeof...(Digits)>(('0' + Digits)...);
+};
+
+// Ternary description (like std::conditional)
+template <bool B, size_t N1, size_t N2>
+constexpr enable_if_t<B, descr<N1 - 1>> _(char const(&text1)[N1], char const(&)[N2]) {
+    return _(text1);
+}
+template <bool B, size_t N1, size_t N2>
+constexpr enable_if_t<!B, descr<N2 - 1>> _(char const(&)[N1], char const(&text2)[N2]) {
+    return _(text2);
+}
+
+template <bool B, typename T1, typename T2>
+constexpr enable_if_t<B, T1> _(const T1 &d, const T2 &) { return d; }
+template <bool B, typename T1, typename T2>
+constexpr enable_if_t<!B, T2> _(const T1 &, const T2 &d) { return d; }
+
+template <size_t Size> auto constexpr _() -> decltype(int_to_str<Size / 10, Size % 10>::digits) {
+    return int_to_str<Size / 10, Size % 10>::digits;
+}
+
+template <typename Type> constexpr descr<1, Type> _() { return {'%'}; }
+
+constexpr descr<0> concat() { return {}; }
+
+template <size_t N, typename... Ts>
+constexpr descr<N, Ts...> concat(const descr<N, Ts...> &descr) { return descr; }
+
+template <size_t N, typename... Ts, typename... Args>
+constexpr auto concat(const descr<N, Ts...> &d, const Args &...args)
+    -> decltype(std::declval<descr<N + 2, Ts...>>() + concat(args...)) {
+    return d + _(", ") + concat(args...);
+}
+
+template <size_t N, typename... Ts>
+constexpr descr<N + 2, Ts...> type_descr(const descr<N, Ts...> &descr) {
+    return _("{") + descr + _("}");
+}
+
+NAMESPACE_END(detail)
+NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/src/pybind11/include/pybind11/detail/init.h b/src/pybind11/include/pybind11/detail/init.h
new file mode 100644
index 0000000..acfe00b
--- /dev/null
+++ b/src/pybind11/include/pybind11/detail/init.h
@@ -0,0 +1,335 @@
+/*
+    pybind11/detail/init.h: init factory function implementation and support code.
+
+    Copyright (c) 2017 Jason Rhinelander <jason@imaginary.ca>
+
+    All rights reserved. Use of this source code is governed by a
+    BSD-style license that can be found in the LICENSE file.
+*/
+
+#pragma once
+
+#include "class.h"
+
+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+NAMESPACE_BEGIN(detail)
+
+template <>
+class type_caster<value_and_holder> {
+public:
+    bool load(handle h, bool) {
+        value = reinterpret_cast<value_and_holder *>(h.ptr());
+        return true;
+    }
+
+    template <typename> using cast_op_type = value_and_holder &;
+    operator value_and_holder &() { return *value; }
+    static constexpr auto name = _<value_and_holder>();
+
+private:
+    value_and_holder *value = nullptr;
+};
+
+NAMESPACE_BEGIN(initimpl)
+
+inline void no_nullptr(void *ptr) {
+    if (!ptr) throw type_error("pybind11::init(): factory function returned nullptr");
+}
+
+// Implementing functions for all forms of py::init<...> and py::init(...)
+template <typename Class> using Cpp = typename Class::type;
+template <typename Class> using Alias = typename Class::type_alias;
+template <typename Class> using Holder = typename Class::holder_type;
+
+template <typename Class> using is_alias_constructible = std::is_constructible<Alias<Class>, Cpp<Class> &&>;
+
+// Takes a Cpp pointer and returns true if it actually is a polymorphic Alias instance.
+template <typename Class, enable_if_t<Class::has_alias, int> = 0>
+bool is_alias(Cpp<Class> *ptr) {
+    return dynamic_cast<Alias<Class> *>(ptr) != nullptr;
+}
+// Failing fallback version of the above for a no-alias class (always returns false)
+template <typename /*Class*/>
+constexpr bool is_alias(void *) { return false; }
+
+// Constructs and returns a new object; if the given arguments don't map to a constructor, we fall
+// back to brace aggregate initiailization so that for aggregate initialization can be used with
+// py::init, e.g.  `py::init<int, int>` to initialize a `struct T { int a; int b; }`.  For
+// non-aggregate types, we need to use an ordinary T(...) constructor (invoking as `T{...}` usually
+// works, but will not do the expected thing when `T` has an `initializer_list<T>` constructor).
+template <typename Class, typename... Args, detail::enable_if_t<std::is_constructible<Class, Args...>::value, int> = 0>
+inline Class *construct_or_initialize(Args &&...args) { return new Class(std::forward<Args>(args)...); }
+template <typename Class, typename... Args, detail::enable_if_t<!std::is_constructible<Class, Args...>::value, int> = 0>
+inline Class *construct_or_initialize(Args &&...args) { return new Class{std::forward<Args>(args)...}; }
+
+// Attempts to constructs an alias using a `Alias(Cpp &&)` constructor.  This allows types with
+// an alias to provide only a single Cpp factory function as long as the Alias can be
+// constructed from an rvalue reference of the base Cpp type.  This means that Alias classes
+// can, when appropriate, simply define a `Alias(Cpp &&)` constructor rather than needing to
+// inherit all the base class constructors.
+template <typename Class>
+void construct_alias_from_cpp(std::true_type /*is_alias_constructible*/,
+                              value_and_holder &v_h, Cpp<Class> &&base) {
+    v_h.value_ptr() = new Alias<Class>(std::move(base));
+}
+template <typename Class>
+[[noreturn]] void construct_alias_from_cpp(std::false_type /*!is_alias_constructible*/,
+                                           value_and_holder &, Cpp<Class> &&) {
+    throw type_error("pybind11::init(): unable to convert returned instance to required "
+                     "alias class: no `Alias<Class>(Class &&)` constructor available");
+}
+
+// Error-generating fallback for factories that don't match one of the below construction
+// mechanisms.
+template <typename Class>
+void construct(...) {
+    static_assert(!std::is_same<Class, Class>::value /* always false */,
+            "pybind11::init(): init function must return a compatible pointer, "
+            "holder, or value");
+}
+
+// Pointer return v1: the factory function returns a class pointer for a registered class.
+// If we don't need an alias (because this class doesn't have one, or because the final type is
+// inherited on the Python side) we can simply take over ownership.  Otherwise we need to try to
+// construct an Alias from the returned base instance.
+template <typename Class>
+void construct(value_and_holder &v_h, Cpp<Class> *ptr, bool need_alias) {
+    no_nullptr(ptr);
+    if (Class::has_alias && need_alias && !is_alias<Class>(ptr)) {
+        // We're going to try to construct an alias by moving the cpp type.  Whether or not
+        // that succeeds, we still need to destroy the original cpp pointer (either the
+        // moved away leftover, if the alias construction works, or the value itself if we
+        // throw an error), but we can't just call `delete ptr`: it might have a special
+        // deleter, or might be shared_from_this.  So we construct a holder around it as if
+        // it was a normal instance, then steal the holder away into a local variable; thus
+        // the holder and destruction happens when we leave the C++ scope, and the holder
+        // class gets to handle the destruction however it likes.
+        v_h.value_ptr() = ptr;
+        v_h.set_instance_registered(true); // To prevent init_instance from registering it
+        v_h.type->init_instance(v_h.inst, nullptr); // Set up the holder
+        Holder<Class> temp_holder(std::move(v_h.holder<Holder<Class>>())); // Steal the holder
+        v_h.type->dealloc(v_h); // Destroys the moved-out holder remains, resets value ptr to null
+        v_h.set_instance_registered(false);
+
+        construct_alias_from_cpp<Class>(is_alias_constructible<Class>{}, v_h, std::move(*ptr));
+    } else {
+        // Otherwise the type isn't inherited, so we don't need an Alias
+        v_h.value_ptr() = ptr;
+    }
+}
+
+// Pointer return v2: a factory that always returns an alias instance ptr.  We simply take over
+// ownership of the pointer.
+template <typename Class, enable_if_t<Class::has_alias, int> = 0>
+void construct(value_and_holder &v_h, Alias<Class> *alias_ptr, bool) {
+    no_nullptr(alias_ptr);
+    v_h.value_ptr() = static_cast<Cpp<Class> *>(alias_ptr);
+}
+
+// Holder return: copy its pointer, and move or copy the returned holder into the new instance's
+// holder.  This also handles types like std::shared_ptr<T> and std::unique_ptr<T> where T is a
+// derived type (through those holder's implicit conversion from derived class holder constructors).
+template <typename Class>
+void construct(value_and_holder &v_h, Holder<Class> holder, bool need_alias) {
+    auto *ptr = holder_helper<Holder<Class>>::get(holder);
+    // If we need an alias, check that the held pointer is actually an alias instance
+    if (Class::has_alias && need_alias && !is_alias<Class>(ptr))
+        throw type_error("pybind11::init(): construction failed: returned holder-wrapped instance "
+                         "is not an alias instance");
+
+    v_h.value_ptr() = ptr;
+    v_h.type->init_instance(v_h.inst, &holder);
+}
+
+// return-by-value version 1: returning a cpp class by value.  If the class has an alias and an
+// alias is required the alias must have an `Alias(Cpp &&)` constructor so that we can construct
+// the alias from the base when needed (i.e. because of Python-side inheritance).  When we don't
+// need it, we simply move-construct the cpp value into a new instance.
+template <typename Class>
+void construct(value_and_holder &v_h, Cpp<Class> &&result, bool need_alias) {
+    static_assert(std::is_move_constructible<Cpp<Class>>::value,
+        "pybind11::init() return-by-value factory function requires a movable class");
+    if (Class::has_alias && need_alias)
+        construct_alias_from_cpp<Class>(is_alias_constructible<Class>{}, v_h, std::move(result));
+    else
+        v_h.value_ptr() = new Cpp<Class>(std::move(result));
+}
+
+// return-by-value version 2: returning a value of the alias type itself.  We move-construct an
+// Alias instance (even if no the python-side inheritance is involved).  The is intended for
+// cases where Alias initialization is always desired.
+template <typename Class>
+void construct(value_and_holder &v_h, Alias<Class> &&result, bool) {
+    static_assert(std::is_move_constructible<Alias<Class>>::value,
+        "pybind11::init() return-by-alias-value factory function requires a movable alias class");
+    v_h.value_ptr() = new Alias<Class>(std::move(result));
+}
+
+// Implementing class for py::init<...>()
+template <typename... Args>
+struct constructor {
+    template <typename Class, typename... Extra, enable_if_t<!Class::has_alias, int> = 0>
+    static void execute(Class &cl, const Extra&... extra) {
+        cl.def("__init__", [](value_and_holder &v_h, Args... args) {
+            v_h.value_ptr() = construct_or_initialize<Cpp<Class>>(std::forward<Args>(args)...);
+        }, is_new_style_constructor(), extra...);
+    }
+
+    template <typename Class, typename... Extra,
+              enable_if_t<Class::has_alias &&
+                          std::is_constructible<Cpp<Class>, Args...>::value, int> = 0>
+    static void execute(Class &cl, const Extra&... extra) {
+        cl.def("__init__", [](value_and_holder &v_h, Args... args) {
+            if (Py_TYPE(v_h.inst) == v_h.type->type)
+                v_h.value_ptr() = construct_or_initialize<Cpp<Class>>(std::forward<Args>(args)...);
+            else
+                v_h.value_ptr() = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);
+        }, is_new_style_constructor(), extra...);
+    }
+
+    template <typename Class, typename... Extra,
+              enable_if_t<Class::has_alias &&
+                          !std::is_constructible<Cpp<Class>, Args...>::value, int> = 0>
+    static void execute(Class &cl, const Extra&... extra) {
+        cl.def("__init__", [](value_and_holder &v_h, Args... args) {
+            v_h.value_ptr() = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);
+        }, is_new_style_constructor(), extra...);
+    }
+};
+
+// Implementing class for py::init_alias<...>()
+template <typename... Args> struct alias_constructor {
+    template <typename Class, typename... Extra,
+              enable_if_t<Class::has_alias && std::is_constructible<Alias<Class>, Args...>::value, int> = 0>
+    static void execute(Class &cl, const Extra&... extra) {
+        cl.def("__init__", [](value_and_holder &v_h, Args... args) {
+            v_h.value_ptr() = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);
+        }, is_new_style_constructor(), extra...);
+    }
+};
+
+// Implementation class for py::init(Func) and py::init(Func, AliasFunc)
+template <typename CFunc, typename AFunc = void_type (*)(),
+          typename = function_signature_t<CFunc>, typename = function_signature_t<AFunc>>
+struct factory;
+
+// Specialization for py::init(Func)
+template <typename Func, typename Return, typename... Args>
+struct factory<Func, void_type (*)(), Return(Args...)> {
+    remove_reference_t<Func> class_factory;
+
+    factory(Func &&f) : class_factory(std::forward<Func>(f)) { }
+
+    // The given class either has no alias or has no separate alias factory;
+    // this always constructs the class itself.  If the class is registered with an alias
+    // type and an alias instance is needed (i.e. because the final type is a Python class
+    // inheriting from the C++ type) the returned value needs to either already be an alias
+    // instance, or the alias needs to be constructible from a `Class &&` argument.
+    template <typename Class, typename... Extra>
+    void execute(Class &cl, const Extra &...extra) && {
+        #if defined(PYBIND11_CPP14)
+        cl.def("__init__", [func = std::move(class_factory)]
+        #else
+        auto &func = class_factory;
+        cl.def("__init__", [func]
+        #endif
+        (value_and_holder &v_h, Args... args) {
+            construct<Class>(v_h, func(std::forward<Args>(args)...),
+                             Py_TYPE(v_h.inst) != v_h.type->type);
+        }, is_new_style_constructor(), extra...);
+    }
+};
+
+// Specialization for py::init(Func, AliasFunc)
+template <typename CFunc, typename AFunc,
+          typename CReturn, typename... CArgs, typename AReturn, typename... AArgs>
+struct factory<CFunc, AFunc, CReturn(CArgs...), AReturn(AArgs...)> {
+    static_assert(sizeof...(CArgs) == sizeof...(AArgs),
+                  "pybind11::init(class_factory, alias_factory): class and alias factories "
+                  "must have identical argument signatures");
+    static_assert(all_of<std::is_same<CArgs, AArgs>...>::value,
+                  "pybind11::init(class_factory, alias_factory): class and alias factories "
+                  "must have identical argument signatures");
+
+    remove_reference_t<CFunc> class_factory;
+    remove_reference_t<AFunc> alias_factory;
+
+    factory(CFunc &&c, AFunc &&a)
+        : class_factory(std::forward<CFunc>(c)), alias_factory(std::forward<AFunc>(a)) { }
+
+    // The class factory is called when the `self` type passed to `__init__` is the direct
+    // class (i.e. not inherited), the alias factory when `self` is a Python-side subtype.
+    template <typename Class, typename... Extra>
+    void execute(Class &cl, const Extra&... extra) && {
+        static_assert(Class::has_alias, "The two-argument version of `py::init()` can "
+                                        "only be used if the class has an alias");
+        #if defined(PYBIND11_CPP14)
+        cl.def("__init__", [class_func = std::move(class_factory), alias_func = std::move(alias_factory)]
+        #else
+        auto &class_func = class_factory;
+        auto &alias_func = alias_factory;
+        cl.def("__init__", [class_func, alias_func]
+        #endif
+        (value_and_holder &v_h, CArgs... args) {
+            if (Py_TYPE(v_h.inst) == v_h.type->type)
+                // If the instance type equals the registered type we don't have inheritance, so
+                // don't need the alias and can construct using the class function:
+                construct<Class>(v_h, class_func(std::forward<CArgs>(args)...), false);
+            else
+                construct<Class>(v_h, alias_func(std::forward<CArgs>(args)...), true);
+        }, is_new_style_constructor(), extra...);
+    }
+};
+
+/// Set just the C++ state. Same as `__init__`.
+template <typename Class, typename T>
+void setstate(value_and_holder &v_h, T &&result, bool need_alias) {
+    construct<Class>(v_h, std::forward<T>(result), need_alias);
+}
+
+/// Set both the C++ and Python states
+template <typename Class, typename T, typename O,
+          enable_if_t<std::is_convertible<O, handle>::value, int> = 0>
+void setstate(value_and_holder &v_h, std::pair<T, O> &&result, bool need_alias) {
+    construct<Class>(v_h, std::move(result.first), need_alias);
+    setattr((PyObject *) v_h.inst, "__dict__", result.second);
+}
+
+/// Implementation for py::pickle(GetState, SetState)
+template <typename Get, typename Set,
+          typename = function_signature_t<Get>, typename = function_signature_t<Set>>
+struct pickle_factory;
+
+template <typename Get, typename Set,
+          typename RetState, typename Self, typename NewInstance, typename ArgState>
+struct pickle_factory<Get, Set, RetState(Self), NewInstance(ArgState)> {
+    static_assert(std::is_same<intrinsic_t<RetState>, intrinsic_t<ArgState>>::value,
+                  "The type returned by `__getstate__` must be the same "
+                  "as the argument accepted by `__setstate__`");
+
+    remove_reference_t<Get> get;
+    remove_reference_t<Set> set;
+
+    pickle_factory(Get get, Set set)
+        : get(std::forward<Get>(get)), set(std::forward<Set>(set)) { }
+
+    template <typename Class, typename... Extra>
+    void execute(Class &cl, const Extra &...extra) && {
+        cl.def("__getstate__", std::move(get));
+
+#if defined(PYBIND11_CPP14)
+        cl.def("__setstate__", [func = std::move(set)]
+#else
+        auto &func = set;
+        cl.def("__setstate__", [func]
+#endif
+        (value_and_holder &v_h, ArgState state) {
+            setstate<Class>(v_h, func(std::forward<ArgState>(state)),
+                            Py_TYPE(v_h.inst) != v_h.type->type);
+        }, is_new_style_constructor(), extra...);
+    }
+};
+
+NAMESPACE_END(initimpl)
+NAMESPACE_END(detail)
+NAMESPACE_END(pybind11)
diff --git a/src/pybind11/include/pybind11/detail/internals.h b/src/pybind11/include/pybind11/detail/internals.h
new file mode 100644
index 0000000..6224dfb
--- /dev/null
+++ b/src/pybind11/include/pybind11/detail/internals.h
@@ -0,0 +1,349 @@
+/*
+    pybind11/detail/internals.h: Internal data structure and related functions
+
+    Copyright (c) 2017 Wenzel Jakob <wenzel.jakob@epfl.ch>
+
+    All rights reserved. Use of this source code is governed by a
+    BSD-style license that can be found in the LICENSE file.
+*/
+
+#pragma once
+
+#include "../pytypes.h"
+
+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+NAMESPACE_BEGIN(detail)
+// Forward declarations
+inline PyTypeObject *make_static_property_type();
+inline PyTypeObject *make_default_metaclass();
+inline PyObject *make_object_base_type(PyTypeObject *metaclass);
+
+// The old Python Thread Local Storage (TLS) API is deprecated in Python 3.7 in favor of the new
+// Thread Specific Storage (TSS) API.
+#if PY_VERSION_HEX >= 0x03070000
+#    define PYBIND11_TLS_KEY_INIT(var) Py_tss_t *var = nullptr
+#    define PYBIND11_TLS_GET_VALUE(key) PyThread_tss_get((key))
+#    define PYBIND11_TLS_REPLACE_VALUE(key, value) PyThread_tss_set((key), (value))
+#    define PYBIND11_TLS_DELETE_VALUE(key) PyThread_tss_set((key), nullptr)
+#    define PYBIND11_TLS_FREE(key) PyThread_tss_free(key)
+#else
+    // Usually an int but a long on Cygwin64 with Python 3.x
+#    define PYBIND11_TLS_KEY_INIT(var) decltype(PyThread_create_key()) var = 0
+#    define PYBIND11_TLS_GET_VALUE(key) PyThread_get_key_value((key))
+#    if PY_MAJOR_VERSION < 3
+#        define PYBIND11_TLS_DELETE_VALUE(key)                               \
+             PyThread_delete_key_value(key)
+#        define PYBIND11_TLS_REPLACE_VALUE(key, value)                       \
+             do {                                                            \
+                 PyThread_delete_key_value((key));                           \
+                 PyThread_set_key_value((key), (value));                     \
+             } while (false)
+#    else
+#        define PYBIND11_TLS_DELETE_VALUE(key)                               \
+             PyThread_set_key_value((key), nullptr)
+#        define PYBIND11_TLS_REPLACE_VALUE(key, value)                       \
+             PyThread_set_key_value((key), (value))
+#    endif
+#    define PYBIND11_TLS_FREE(key) (void)key
+#endif
+
+// Python loads modules by default with dlopen with the RTLD_LOCAL flag; under libc++ and possibly
+// other STLs, this means `typeid(A)` from one module won't equal `typeid(A)` from another module
+// even when `A` is the same, non-hidden-visibility type (e.g. from a common include).  Under
+// libstdc++, this doesn't happen: equality and the type_index hash are based on the type name,
+// which works.  If not under a known-good stl, provide our own name-based hash and equality
+// functions that use the type name.
+#if defined(__GLIBCXX__)
+inline bool same_type(const std::type_info &lhs, const std::type_info &rhs) { return lhs == rhs; }
+using type_hash = std::hash<std::type_index>;
+using type_equal_to = std::equal_to<std::type_index>;
+#else
+inline bool same_type(const std::type_info &lhs, const std::type_info &rhs) {
+    return lhs.name() == rhs.name() || std::strcmp(lhs.name(), rhs.name()) == 0;
+}
+
+struct type_hash {
+    size_t operator()(const std::type_index &t) const {
+        size_t hash = 5381;
+        const char *ptr = t.name();
+        while (auto c = static_cast<unsigned char>(*ptr++))
+            hash = (hash * 33) ^ c;
+        return hash;
+    }
+};
+
+struct type_equal_to {
+    bool operator()(const std::type_index &lhs, const std::type_index &rhs) const {
+        return lhs.name() == rhs.name() || std::strcmp(lhs.name(), rhs.name()) == 0;
+    }
+};
+#endif
+
+template <typename value_type>
+using type_map = std::unordered_map<std::type_index, value_type, type_hash, type_equal_to>;
+
+struct overload_hash {
+    inline size_t operator()(const std::pair<const PyObject *, const char *>& v) const {
+        size_t value = std::hash<const void *>()(v.first);
+        value ^= std::hash<const void *>()(v.second)  + 0x9e3779b9 + (value<<6) + (value>>2);
+        return value;
+    }
+};
+
+/// Internal data structure used to track registered instances and types.
+/// Whenever binary incompatible changes are made to this structure,
+/// `PYBIND11_INTERNALS_VERSION` must be incremented.
+struct internals {
+    type_map<type_info *> registered_types_cpp; // std::type_index -> pybind11's type information
+    std::unordered_map<PyTypeObject *, std::vector<type_info *>> registered_types_py; // PyTypeObject* -> base type_info(s)
+    std::unordered_multimap<const void *, instance*> registered_instances; // void * -> instance*
+    std::unordered_set<std::pair<const PyObject *, const char *>, overload_hash> inactive_overload_cache;
+    type_map<std::vector<bool (*)(PyObject *, void *&)>> direct_conversions;
+    std::unordered_map<const PyObject *, std::vector<PyObject *>> patients;
+    std::forward_list<void (*) (std::exception_ptr)> registered_exception_translators;
+    std::unordered_map<std::string, void *> shared_data; // Custom data to be shared across extensions
+    std::vector<PyObject *> loader_patient_stack; // Used by `loader_life_support`
+    std::forward_list<std::string> static_strings; // Stores the std::strings backing detail::c_str()
+    PyTypeObject *static_property_type;
+    PyTypeObject *default_metaclass;
+    PyObject *instance_base;
+#if defined(WITH_THREAD)
+    PYBIND11_TLS_KEY_INIT(tstate);
+    PyInterpreterState *istate = nullptr;
+    ~internals() {
+        // This destructor is called *after* Py_Finalize() in finalize_interpreter().
+        // That *SHOULD BE* fine. The following details what happens whe PyThread_tss_free is called.
+        // PYBIND11_TLS_FREE is PyThread_tss_free on python 3.7+. On older python, it does nothing.
+        // PyThread_tss_free calls PyThread_tss_delete and PyMem_RawFree.
+        // PyThread_tss_delete just calls TlsFree (on Windows) or pthread_key_delete (on *NIX). Neither
+        // of those have anything to do with CPython internals.
+        // PyMem_RawFree *requires* that the `tstate` be allocated with the CPython allocator.
+        PYBIND11_TLS_FREE(tstate);
+    }
+#endif
+};
+
+/// Additional type information which does not fit into the PyTypeObject.
+/// Changes to this struct also require bumping `PYBIND11_INTERNALS_VERSION`.
+struct type_info {
+    PyTypeObject *type;
+    const std::type_info *cpptype;
+    size_t type_size, type_align, holder_size_in_ptrs;
+    void *(*operator_new)(size_t);
+    void (*init_instance)(instance *, const void *);
+    void (*dealloc)(value_and_holder &v_h);
+    std::vector<PyObject *(*)(PyObject *, PyTypeObject *)> implicit_conversions;
+    std::vector<std::pair<const std::type_info *, void *(*)(void *)>> implicit_casts;
+    std::vector<bool (*)(PyObject *, void *&)> *direct_conversions;
+    buffer_info *(*get_buffer)(PyObject *, void *) = nullptr;
+    void *get_buffer_data = nullptr;
+    void *(*module_local_load)(PyObject *, const type_info *) = nullptr;
+    /* A simple type never occurs as a (direct or indirect) parent
+     * of a class that makes use of multiple inheritance */
+    bool simple_type : 1;
+    /* True if there is no multiple inheritance in this type's inheritance tree */
+    bool simple_ancestors : 1;
+    /* for base vs derived holder_type checks */
+    bool default_holder : 1;
+    /* true if this is a type registered with py::module_local */
+    bool module_local : 1;
+};
+
+/// Tracks the `internals` and `type_info` ABI version independent of the main library version
+#define PYBIND11_INTERNALS_VERSION 4
+
+/// On MSVC, debug and release builds are not ABI-compatible!
+#if defined(_MSC_VER) && defined(_DEBUG)
+#   define PYBIND11_BUILD_TYPE "_debug"
+#else
+#   define PYBIND11_BUILD_TYPE ""
+#endif
+
+/// Let's assume that different compilers are ABI-incompatible.
+#if defined(_MSC_VER)
+#   define PYBIND11_COMPILER_TYPE "_msvc"
+#elif defined(__INTEL_COMPILER)
+#   define PYBIND11_COMPILER_TYPE "_icc"
+#elif defined(__clang__)
+#   define PYBIND11_COMPILER_TYPE "_clang"
+#elif defined(__PGI)
+#   define PYBIND11_COMPILER_TYPE "_pgi"
+#elif defined(__MINGW32__)
+#   define PYBIND11_COMPILER_TYPE "_mingw"
+#elif defined(__CYGWIN__)
+#   define PYBIND11_COMPILER_TYPE "_gcc_cygwin"
+#elif defined(__GNUC__)
+#   define PYBIND11_COMPILER_TYPE "_gcc"
+#else
+#   define PYBIND11_COMPILER_TYPE "_unknown"
+#endif
+
+#if defined(_LIBCPP_VERSION)
+#  define PYBIND11_STDLIB "_libcpp"
+#elif defined(__GLIBCXX__) || defined(__GLIBCPP__)
+#  define PYBIND11_STDLIB "_libstdcpp"
+#else
+#  define PYBIND11_STDLIB ""
+#endif
+
+/// On Linux/OSX, changes in __GXX_ABI_VERSION__ indicate ABI incompatibility.
+#if defined(__GXX_ABI_VERSION)
+#  define PYBIND11_BUILD_ABI "_cxxabi" PYBIND11_TOSTRING(__GXX_ABI_VERSION)
+#else
+#  define PYBIND11_BUILD_ABI ""
+#endif
+
+#if defined(WITH_THREAD)
+#  define PYBIND11_INTERNALS_KIND ""
+#else
+#  define PYBIND11_INTERNALS_KIND "_without_thread"
+#endif
+
+#define PYBIND11_INTERNALS_ID "__pybind11_internals_v" \
+    PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION) PYBIND11_INTERNALS_KIND PYBIND11_COMPILER_TYPE PYBIND11_STDLIB PYBIND11_BUILD_ABI PYBIND11_BUILD_TYPE "__"
+
+#define PYBIND11_MODULE_LOCAL_ID "__pybind11_module_local_v" \
+    PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION) PYBIND11_INTERNALS_KIND PYBIND11_COMPILER_TYPE PYBIND11_STDLIB PYBIND11_BUILD_ABI PYBIND11_BUILD_TYPE "__"
+
+/// Each module locally stores a pointer to the `internals` data. The data
+/// itself is shared among modules with the same `PYBIND11_INTERNALS_ID`.
+inline internals **&get_internals_pp() {
+    static internals **internals_pp = nullptr;
+    return internals_pp;
+}
+
+inline void translate_exception(std::exception_ptr p) {
+    try {
+        if (p) std::rethrow_exception(p);
+    } catch (error_already_set &e)           { e.restore();                                    return;
+    } catch (const builtin_exception &e)     { e.set_error();                                  return;
+    } catch (const std::bad_alloc &e)        { PyErr_SetString(PyExc_MemoryError,   e.what()); return;
+    } catch (const std::domain_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return;
+    } catch (const std::invalid_argument &e) { PyErr_SetString(PyExc_ValueError,    e.what()); return;
+    } catch (const std::length_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return;
+    } catch (const std::out_of_range &e)     { PyErr_SetString(PyExc_IndexError,    e.what()); return;
+    } catch (const std::range_error &e)      { PyErr_SetString(PyExc_ValueError,    e.what()); return;
+    } catch (const std::overflow_error &e)   { PyErr_SetString(PyExc_OverflowError, e.what()); return;
+    } catch (const std::exception &e)        { PyErr_SetString(PyExc_RuntimeError,  e.what()); return;
+    } catch (...) {
+        PyErr_SetString(PyExc_RuntimeError, "Caught an unknown exception!");
+        return;
+    }
+}
+
+#if !defined(__GLIBCXX__)
+inline void translate_local_exception(std::exception_ptr p) {
+    try {
+        if (p) std::rethrow_exception(p);
+    } catch (error_already_set &e)       { e.restore();   return;
+    } catch (const builtin_exception &e) { e.set_error(); return;
+    }
+}
+#endif
+
+/// Return a reference to the current `internals` data
+PYBIND11_NOINLINE inline internals &get_internals() {
+    auto **&internals_pp = get_internals_pp();
+    if (internals_pp && *internals_pp)
+        return **internals_pp;
+
+    // Ensure that the GIL is held since we will need to make Python calls.
+    // Cannot use py::gil_scoped_acquire here since that constructor calls get_internals.
+    struct gil_scoped_acquire_local {
+        gil_scoped_acquire_local() : state (PyGILState_Ensure()) {}
+        ~gil_scoped_acquire_local() { PyGILState_Release(state); }
+        const PyGILState_STATE state;
+    } gil;
+
+    constexpr auto *id = PYBIND11_INTERNALS_ID;
+    auto builtins = handle(PyEval_GetBuiltins());
+    if (builtins.contains(id) && isinstance<capsule>(builtins[id])) {
+        internals_pp = static_cast<internals **>(capsule(builtins[id]));
+
+        // We loaded builtins through python's builtins, which means that our `error_already_set`
+        // and `builtin_exception` may be different local classes than the ones set up in the
+        // initial exception translator, below, so add another for our local exception classes.
+        //
+        // libstdc++ doesn't require this (types there are identified only by name)
+#if !defined(__GLIBCXX__)
+        (*internals_pp)->registered_exception_translators.push_front(&translate_local_exception);
+#endif
+    } else {
+        if (!internals_pp) internals_pp = new internals*();
+        auto *&internals_ptr = *internals_pp;
+        internals_ptr = new internals();
+#if defined(WITH_THREAD)
+        PyEval_InitThreads();
+        PyThreadState *tstate = PyThreadState_Get();
+        #if PY_VERSION_HEX >= 0x03070000
+            internals_ptr->tstate = PyThread_tss_alloc();
+            if (!internals_ptr->tstate || PyThread_tss_create(internals_ptr->tstate))
+                pybind11_fail("get_internals: could not successfully initialize the TSS key!");
+            PyThread_tss_set(internals_ptr->tstate, tstate);
+        #else
+            internals_ptr->tstate = PyThread_create_key();
+            if (internals_ptr->tstate == -1)
+                pybind11_fail("get_internals: could not successfully initialize the TLS key!");
+            PyThread_set_key_value(internals_ptr->tstate, tstate);
+        #endif
+        internals_ptr->istate = tstate->interp;
+#endif
+        builtins[id] = capsule(internals_pp);
+        internals_ptr->registered_exception_translators.push_front(&translate_exception);
+        internals_ptr->static_property_type = make_static_property_type();
+        internals_ptr->default_metaclass = make_default_metaclass();
+        internals_ptr->instance_base = make_object_base_type(internals_ptr->default_metaclass);
+    }
+    return **internals_pp;
+}
+
+/// Works like `internals.registered_types_cpp`, but for module-local registered types:
+inline type_map<type_info *> &registered_local_types_cpp() {
+    static type_map<type_info *> locals{};
+    return locals;
+}
+
+/// Constructs a std::string with the given arguments, stores it in `internals`, and returns its
+/// `c_str()`.  Such strings objects have a long storage duration -- the internal strings are only
+/// cleared when the program exits or after interpreter shutdown (when embedding), and so are
+/// suitable for c-style strings needed by Python internals (such as PyTypeObject's tp_name).
+template <typename... Args>
+const char *c_str(Args &&...args) {
+    auto &strings = get_internals().static_strings;
+    strings.emplace_front(std::forward<Args>(args)...);
+    return strings.front().c_str();
+}
+
+NAMESPACE_END(detail)
+
+/// Returns a named pointer that is shared among all extension modules (using the same
+/// pybind11 version) running in the current interpreter. Names starting with underscores
+/// are reserved for internal usage. Returns `nullptr` if no matching entry was found.
+inline PYBIND11_NOINLINE void *get_shared_data(const std::string &name) {
+    auto &internals = detail::get_internals();
+    auto it = internals.shared_data.find(name);
+    return it != internals.shared_data.end() ? it->second : nullptr;
+}
+
+/// Set the shared data that can be later recovered by `get_shared_data()`.
+inline PYBIND11_NOINLINE void *set_shared_data(const std::string &name, void *data) {
+    detail::get_internals().shared_data[name] = data;
+    return data;
+}
+
+/// Returns a typed reference to a shared data entry (by using `get_shared_data()`) if
+/// such entry exists. Otherwise, a new object of default-constructible type `T` is
+/// added to the shared data under the given name and a reference to it is returned.
+template<typename T>
+T &get_or_create_shared_data(const std::string &name) {
+    auto &internals = detail::get_internals();
+    auto it = internals.shared_data.find(name);
+    T *ptr = (T *) (it != internals.shared_data.end() ? it->second : nullptr);
+    if (!ptr) {
+        ptr = new T();
+        internals.shared_data[name] = ptr;
+    }
+    return *ptr;
+}
+
+NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/src/pybind11/include/pybind11/typeid.h b/src/pybind11/include/pybind11/detail/typeid.h
similarity index 88%
rename from src/pybind11/include/pybind11/typeid.h
rename to src/pybind11/include/pybind11/detail/typeid.h
index c903fb1..9c8a4fc 100644
--- a/src/pybind11/include/pybind11/typeid.h
+++ b/src/pybind11/include/pybind11/detail/typeid.h
@@ -1,5 +1,5 @@
 /*
-    pybind11/typeid.h: Compiler-independent access to type identifiers
+    pybind11/detail/typeid.h: Compiler-independent access to type identifiers
 
     Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
 
@@ -16,7 +16,9 @@
 #include <cxxabi.h>
 #endif
 
-NAMESPACE_BEGIN(pybind11)
+#include "common.h"
+
+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 /// Erase all occurrences of a substring
 inline void erase_all(std::string &string, const std::string &search) {
@@ -50,4 +52,4 @@ template <typename T> static std::string type_id() {
     return name;
 }
 
-NAMESPACE_END(pybind11)
+NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/src/pybind11/include/pybind11/eigen.h b/src/pybind11/include/pybind11/eigen.h
index fc07051..d963d96 100644
--- a/src/pybind11/include/pybind11/eigen.h
+++ b/src/pybind11/include/pybind11/eigen.h
@@ -17,25 +17,31 @@
 #  pragma GCC diagnostic push
 #  pragma GCC diagnostic ignored "-Wconversion"
 #  pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+#  ifdef __clang__
+//   Eigen generates a bunch of implicit-copy-constructor-is-deprecated warnings with -Wdeprecated
+//   under Clang, so disable that warning here:
+#    pragma GCC diagnostic ignored "-Wdeprecated"
+#  endif
 #  if __GNUC__ >= 7
 #    pragma GCC diagnostic ignored "-Wint-in-bool-context"
 #  endif
 #endif
 
-#include <Eigen/Core>
-#include <Eigen/SparseCore>
-
 #if defined(_MSC_VER)
 #  pragma warning(push)
 #  pragma warning(disable: 4127) // warning C4127: Conditional expression is constant
+#  pragma warning(disable: 4996) // warning C4996: std::unary_negate is deprecated in C++17
 #endif
 
+#include <Eigen/Core>
+#include <Eigen/SparseCore>
+
 // Eigen prior to 3.2.7 doesn't have proper move constructors--but worse, some classes get implicit
 // move constructors that break things.  We could detect this an explicitly copy, but an extra copy
 // of matrices seems highly undesirable.
 static_assert(EIGEN_VERSION_AT_LEAST(3,2,7), "Eigen support in pybind11 requires Eigen >= 3.2.7");
 
-NAMESPACE_BEGIN(pybind11)
+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
 // Provide a convenience alias for easier pass-by-ref usage with fully dynamic strides:
 using EigenDStride = Eigen::Stride<Eigen::Dynamic, Eigen::Dynamic>;
@@ -180,28 +186,26 @@ template <typename Type_> struct EigenProps {
         }
     }
 
-    static PYBIND11_DESCR descriptor() {
-        constexpr bool show_writeable = is_eigen_dense_map<Type>::value && is_eigen_mutable_map<Type>::value;
-        constexpr bool show_order = is_eigen_dense_map<Type>::value;
-        constexpr bool show_c_contiguous = show_order && requires_row_major;
-        constexpr bool show_f_contiguous = !show_c_contiguous && show_order && requires_col_major;
-
-        return type_descr(_("numpy.ndarray[") + npy_format_descriptor<Scalar>::name() +
-            _("[")  + _<fixed_rows>(_<(size_t) rows>(), _("m")) +
-            _(", ") + _<fixed_cols>(_<(size_t) cols>(), _("n")) +
-            _("]") +
-            // For a reference type (e.g. Ref<MatrixXd>) we have other constraints that might need to be
-            // satisfied: writeable=True (for a mutable reference), and, depending on the map's stride
-            // options, possibly f_contiguous or c_contiguous.  We include them in the descriptor output
-            // to provide some hint as to why a TypeError is occurring (otherwise it can be confusing to
-            // see that a function accepts a 'numpy.ndarray[float64[3,2]]' and an error message that you
-            // *gave* a numpy.ndarray of the right type and dimensions.
-            _<show_writeable>(", flags.writeable", "") +
-            _<show_c_contiguous>(", flags.c_contiguous", "") +
-            _<show_f_contiguous>(", flags.f_contiguous", "") +
-            _("]")
-        );
-    }
+    static constexpr bool show_writeable = is_eigen_dense_map<Type>::value && is_eigen_mutable_map<Type>::value;
+    static constexpr bool show_order = is_eigen_dense_map<Type>::value;
+    static constexpr bool show_c_contiguous = show_order && requires_row_major;
+    static constexpr bool show_f_contiguous = !show_c_contiguous && show_order && requires_col_major;
+
+    static constexpr auto descriptor =
+        _("numpy.ndarray[") + npy_format_descriptor<Scalar>::name +
+        _("[")  + _<fixed_rows>(_<(size_t) rows>(), _("m")) +
+        _(", ") + _<fixed_cols>(_<(size_t) cols>(), _("n")) +
+        _("]") +
+        // For a reference type (e.g. Ref<MatrixXd>) we have other constraints that might need to be
+        // satisfied: writeable=True (for a mutable reference), and, depending on the map's stride
+        // options, possibly f_contiguous or c_contiguous.  We include them in the descriptor output
+        // to provide some hint as to why a TypeError is occurring (otherwise it can be confusing to
+        // see that a function accepts a 'numpy.ndarray[float64[3,2]]' and an error message that you
+        // *gave* a numpy.ndarray of the right type and dimensions.
+        _<show_writeable>(", flags.writeable", "") +
+        _<show_c_contiguous>(", flags.c_contiguous", "") +
+        _<show_f_contiguous>(", flags.f_contiguous", "") +
+        _("]");
 };
 
 // Casts an Eigen type to numpy array.  If given a base, the numpy array references the src data,
@@ -272,6 +276,7 @@ struct type_caster<Type, enable_if_t<is_eigen_dense_plain<Type>::value>> {
         value = Type(fits.rows, fits.cols);
         auto ref = reinterpret_steal<array>(eigen_ref_array<props>(value));
         if (dims == 1) ref = ref.squeeze();
+        else if (ref.ndim() == 1) buf = buf.squeeze();
 
         int result = detail::npy_api::get().PyArray_CopyInto_(ref.ptr(), buf.ptr());
 
@@ -337,7 +342,7 @@ public:
         return cast_impl(src, policy, parent);
     }
 
-    static PYBIND11_DESCR name() { return props::descriptor(); }
+    static constexpr auto name = props::descriptor;
 
     operator Type*() { return &value; }
     operator Type&() { return value; }
@@ -348,14 +353,6 @@ private:
     Type value;
 };
 
-// Eigen Ref/Map classes have slightly different policy requirements, meaning we don't want to force
-// `move` when a Ref/Map rvalue is returned; we treat Ref<> sort of like a pointer (we care about
-// the underlying data, not the outer shell).
-template <typename Return>
-struct return_value_policy_override<Return, enable_if_t<is_eigen_dense_map<Return>::value>> {
-    static return_value_policy policy(return_value_policy p) { return p; }
-};
-
 // Base class for casting reference/map/block/etc. objects back to python.
 template <typename MapType> struct eigen_map_caster {
 private:
@@ -385,7 +382,7 @@ public:
         }
     }
 
-    static PYBIND11_DESCR name() { return props::descriptor(); }
+    static constexpr auto name = props::descriptor;
 
     // Explicitly delete these: support python -> C++ conversion on these (i.e. these can be return
     // types but not bound arguments).  We still provide them (with an explicitly delete) so that
@@ -530,7 +527,7 @@ public:
     }
     static handle cast(const Type *src, return_value_policy policy, handle parent) { return cast(*src, policy, parent); }
 
-    static PYBIND11_DESCR name() { return props::descriptor(); }
+    static constexpr auto name = props::descriptor;
 
     // Explicitly delete these: support python -> C++ conversion on these (i.e. these can be return
     // types but not bound arguments).  We still provide them (with an explicitly delete) so that
@@ -597,11 +594,11 @@ struct type_caster<Type, enable_if_t<is_eigen_sparse<Type>::value>> {
     }
 
     PYBIND11_TYPE_CASTER(Type, _<(Type::IsRowMajor) != 0>("scipy.sparse.csr_matrix[", "scipy.sparse.csc_matrix[")
-            + npy_format_descriptor<Scalar>::name() + _("]"));
+            + npy_format_descriptor<Scalar>::name + _("]"));
 };
 
 NAMESPACE_END(detail)
-NAMESPACE_END(pybind11)
+NAMESPACE_END(PYBIND11_NAMESPACE)
 
 #if defined(__GNUG__) || defined(__clang__)
 #  pragma GCC diagnostic pop
diff --git a/src/pybind11/include/pybind11/embed.h b/src/pybind11/include/pybind11/embed.h
index a3f6a4e..f814c78 100644
--- a/src/pybind11/include/pybind11/embed.h
+++ b/src/pybind11/include/pybind11/embed.h
@@ -18,11 +18,13 @@
 
 #if PY_MAJOR_VERSION >= 3
 #  define PYBIND11_EMBEDDED_MODULE_IMPL(name)            \
+      extern "C" PyObject *pybind11_init_impl_##name();  \
       extern "C" PyObject *pybind11_init_impl_##name() { \
           return pybind11_init_wrapper_##name();         \
       }
 #else
 #  define PYBIND11_EMBEDDED_MODULE_IMPL(name)            \
+      extern "C" void pybind11_init_impl_##name();       \
       extern "C" void pybind11_init_impl_##name() {      \
           pybind11_init_wrapper_##name();                \
       }
@@ -44,14 +46,13 @@
         }
  \endrst */
 #define PYBIND11_EMBEDDED_MODULE(name, variable)                              \
-    static void pybind11_init_##name(pybind11::module &);                     \
-    static PyObject *pybind11_init_wrapper_##name() {                         \
-        auto m = pybind11::module(#name);                                     \
+    static void PYBIND11_CONCAT(pybind11_init_, name)(pybind11::module &);    \
+    static PyObject PYBIND11_CONCAT(*pybind11_init_wrapper_, name)() {        \
+        auto m = pybind11::module(PYBIND11_TOSTRING(name));                   \
         try {                                                                 \
-            pybind11_init_##name(m);                                          \
+            PYBIND11_CONCAT(pybind11_init_, name)(m);                         \
             return m.ptr();                                                   \
         } catch (pybind11::error_already_set &e) {                            \
-            e.clear();                                                        \
             PyErr_SetString(PyExc_ImportError, e.what());                     \
             return nullptr;                                                   \
         } catch (const std::exception &e) {                                   \
@@ -60,11 +61,12 @@
         }                                                                     \
     }                                                                         \
     PYBIND11_EMBEDDED_MODULE_IMPL(name)                                       \
-    pybind11::detail::embedded_module name(#name, pybind11_init_impl_##name); \
-    void pybind11_init_##name(pybind11::module &variable)
+    pybind11::detail::embedded_module name(PYBIND11_TOSTRING(name),           \
+                               PYBIND11_CONCAT(pybind11_init_impl_, name));   \
+    void PYBIND11_CONCAT(pybind11_init_, name)(pybind11::module &variable)
 
 
-NAMESPACE_BEGIN(pybind11)
+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
 /// Python 2.7/3.x compatible version of `PyImport_AppendInittab` and error checks.
@@ -90,8 +92,14 @@ NAMESPACE_END(detail)
     Initialize the Python interpreter. No other pybind11 or CPython API functions can be
     called before this is done; with the exception of `PYBIND11_EMBEDDED_MODULE`. The
     optional parameter can be used to skip the registration of signal handlers (see the
-    Python documentation for details). Calling this function again after the interpreter
+    `Python documentation`_ for details). Calling this function again after the interpreter
     has already been initialized is a fatal error.
+
+    If initializing the Python interpreter fails, then the program is terminated.  (This
+    is controlled by the CPython runtime and is an exception to pybind11's normal behavior
+    of throwing exceptions on errors.)
+
+    .. _Python documentation: https://docs.python.org/3/c-api/init.html#c.Py_InitializeEx
  \endrst */
 inline void initialize_interpreter(bool init_signal_handlers = true) {
     if (Py_IsInitialized())
@@ -100,8 +108,7 @@ inline void initialize_interpreter(bool init_signal_handlers = true) {
     Py_InitializeEx(init_signal_handlers ? 1 : 0);
 
     // Make .py files in the working directory available by default
-    auto sys_path = reinterpret_borrow<list>(module::import("sys").attr("path"));
-    sys_path.append(".");
+    module::import("sys").attr("path").cast<list>().append(".");
 }
 
 /** \rst
@@ -146,7 +153,7 @@ inline void finalize_interpreter() {
     // Get the internals pointer (without creating it if it doesn't exist).  It's possible for the
     // internals to be created during Py_Finalize() (e.g. if a py::capsule calls `get_internals()`
     // during destruction), so we get the pointer-pointer here and check it after Py_Finalize().
-    detail::internals **internals_ptr_ptr = &detail::get_internals_ptr();
+    detail::internals **internals_ptr_ptr = detail::get_internals_pp();
     // It could also be stashed in builtins, so look there too:
     if (builtins.contains(id) && isinstance<capsule>(builtins[id]))
         internals_ptr_ptr = capsule(builtins[id]);
@@ -192,4 +199,4 @@ private:
     bool is_valid = true;
 };
 
-NAMESPACE_END(pybind11)
+NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/src/pybind11/include/pybind11/eval.h b/src/pybind11/include/pybind11/eval.h
index 165003b..ea85ba1 100644
--- a/src/pybind11/include/pybind11/eval.h
+++ b/src/pybind11/include/pybind11/eval.h
@@ -13,7 +13,7 @@
 
 #include "pybind11.h"
 
-NAMESPACE_BEGIN(pybind11)
+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
 enum eval_mode {
     /// Evaluate a string containing an isolated expression
@@ -114,4 +114,4 @@ object eval_file(str fname, object global = globals(), object local = object())
     return reinterpret_steal<object>(result);
 }
 
-NAMESPACE_END(pybind11)
+NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/src/pybind11/include/pybind11/functional.h b/src/pybind11/include/pybind11/functional.h
index fdb6b33..f8bda64 100644
--- a/src/pybind11/include/pybind11/functional.h
+++ b/src/pybind11/include/pybind11/functional.h
@@ -12,7 +12,7 @@
 #include "pybind11.h"
 #include <functional>
 
-NAMESPACE_BEGIN(pybind11)
+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
 template <typename Return, typename... Args>
@@ -54,12 +54,30 @@ public:
             }
         }
 
-        value = [func](Args... args) -> Return {
-            gil_scoped_acquire acq;
-            object retval(func(std::forward<Args>(args)...));
-            /* Visual studio 2015 parser issue: need parentheses around this expression */
-            return (retval.template cast<Return>());
+        // ensure GIL is held during functor destruction
+        struct func_handle {
+            function f;
+            func_handle(function&& f_) : f(std::move(f_)) {}
+            func_handle(const func_handle&) = default;
+            ~func_handle() {
+                gil_scoped_acquire acq;
+                function kill_f(std::move(f));
+            }
         };
+
+        // to emulate 'move initialization capture' in C++11
+        struct func_wrapper {
+            func_handle hfunc;
+            func_wrapper(func_handle&& hf): hfunc(std::move(hf)) {}
+            Return operator()(Args... args) const {
+                gil_scoped_acquire acq;
+                object retval(hfunc.f(std::forward<Args>(args)...));
+                /* Visual studio 2015 parser issue: need parentheses around this expression */
+                return (retval.template cast<Return>());
+            }
+        };
+
+        value = func_wrapper(func_handle(std::move(func)));
         return true;
     }
 
@@ -75,11 +93,9 @@ public:
             return cpp_function(std::forward<Func>(f_), policy).release();
     }
 
-    PYBIND11_TYPE_CASTER(type, _("Callable[[") +
-            argument_loader<Args...>::arg_names() + _("], ") +
-            make_caster<retval_type>::name() +
-            _("]"));
+    PYBIND11_TYPE_CASTER(type, _("Callable[[") + concat(make_caster<Args>::name...) + _("], ")
+                               + make_caster<retval_type>::name + _("]"));
 };
 
 NAMESPACE_END(detail)
-NAMESPACE_END(pybind11)
+NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/src/pybind11/include/pybind11/iostream.h b/src/pybind11/include/pybind11/iostream.h
new file mode 100644
index 0000000..c43b7c9
--- /dev/null
+++ b/src/pybind11/include/pybind11/iostream.h
@@ -0,0 +1,209 @@
+/*
+    pybind11/iostream.h -- Tools to assist with redirecting cout and cerr to Python
+
+    Copyright (c) 2017 Henry F. Schreiner
+
+    All rights reserved. Use of this source code is governed by a
+    BSD-style license that can be found in the LICENSE file.
+*/
+
+#pragma once
+
+#include "pybind11.h"
+
+#include <streambuf>
+#include <ostream>
+#include <string>
+#include <memory>
+#include <iostream>
+
+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+NAMESPACE_BEGIN(detail)
+
+// Buffer that writes to Python instead of C++
+class pythonbuf : public std::streambuf {
+private:
+    using traits_type = std::streambuf::traits_type;
+
+    const size_t buf_size;
+    std::unique_ptr<char[]> d_buffer;
+    object pywrite;
+    object pyflush;
+
+    int overflow(int c) {
+        if (!traits_type::eq_int_type(c, traits_type::eof())) {
+            *pptr() = traits_type::to_char_type(c);
+            pbump(1);
+        }
+        return sync() == 0 ? traits_type::not_eof(c) : traits_type::eof();
+    }
+
+    int sync() {
+        if (pbase() != pptr()) {
+            // This subtraction cannot be negative, so dropping the sign
+            str line(pbase(), static_cast<size_t>(pptr() - pbase()));
+
+            {
+                gil_scoped_acquire tmp;
+                pywrite(line);
+                pyflush();
+            }
+
+            setp(pbase(), epptr());
+        }
+        return 0;
+    }
+
+public:
+
+    pythonbuf(object pyostream, size_t buffer_size = 1024)
+        : buf_size(buffer_size),
+          d_buffer(new char[buf_size]),
+          pywrite(pyostream.attr("write")),
+          pyflush(pyostream.attr("flush")) {
+        setp(d_buffer.get(), d_buffer.get() + buf_size - 1);
+    }
+
+    pythonbuf(pythonbuf&&) = default;
+
+    /// Sync before destroy
+    ~pythonbuf() {
+        sync();
+    }
+};
+
+NAMESPACE_END(detail)
+
+
+/** \rst
+    This a move-only guard that redirects output.
+
+    .. code-block:: cpp
+
+        #include <pybind11/iostream.h>
+
+        ...
+
+        {
+            py::scoped_ostream_redirect output;
+            std::cout << "Hello, World!"; // Python stdout
+        } // <-- return std::cout to normal
+
+    You can explicitly pass the c++ stream and the python object,
+    for example to guard stderr instead.
+
+    .. code-block:: cpp
+
+        {
+            py::scoped_ostream_redirect output{std::cerr, py::module::import("sys").attr("stderr")};
+            std::cerr << "Hello, World!";
+        }
+ \endrst */
+class scoped_ostream_redirect {
+protected:
+    std::streambuf *old;
+    std::ostream &costream;
+    detail::pythonbuf buffer;
+
+public:
+    scoped_ostream_redirect(
+            std::ostream &costream = std::cout,
+            object pyostream = module::import("sys").attr("stdout"))
+        : costream(costream), buffer(pyostream) {
+        old = costream.rdbuf(&buffer);
+    }
+
+    ~scoped_ostream_redirect() {
+        costream.rdbuf(old);
+    }
+
+    scoped_ostream_redirect(const scoped_ostream_redirect &) = delete;
+    scoped_ostream_redirect(scoped_ostream_redirect &&other) = default;
+    scoped_ostream_redirect &operator=(const scoped_ostream_redirect &) = delete;
+    scoped_ostream_redirect &operator=(scoped_ostream_redirect &&) = delete;
+};
+
+
+/** \rst
+    Like `scoped_ostream_redirect`, but redirects cerr by default. This class
+    is provided primary to make ``py::call_guard`` easier to make.
+
+    .. code-block:: cpp
+
+     m.def("noisy_func", &noisy_func,
+           py::call_guard<scoped_ostream_redirect,
+                          scoped_estream_redirect>());
+
+\endrst */
+class scoped_estream_redirect : public scoped_ostream_redirect {
+public:
+    scoped_estream_redirect(
+            std::ostream &costream = std::cerr,
+            object pyostream = module::import("sys").attr("stderr"))
+        : scoped_ostream_redirect(costream,pyostream) {}
+};
+
+
+NAMESPACE_BEGIN(detail)
+
+// Class to redirect output as a context manager. C++ backend.
+class OstreamRedirect {
+    bool do_stdout_;
+    bool do_stderr_;
+    std::unique_ptr<scoped_ostream_redirect> redirect_stdout;
+    std::unique_ptr<scoped_estream_redirect> redirect_stderr;
+
+public:
+    OstreamRedirect(bool do_stdout = true, bool do_stderr = true)
+        : do_stdout_(do_stdout), do_stderr_(do_stderr) {}
+
+    void enter() {
+        if (do_stdout_)
+            redirect_stdout.reset(new scoped_ostream_redirect());
+        if (do_stderr_)
+            redirect_stderr.reset(new scoped_estream_redirect());
+    }
+
+    void exit() {
+        redirect_stdout.reset();
+        redirect_stderr.reset();
+    }
+};
+
+NAMESPACE_END(detail)
+
+/** \rst
+    This is a helper function to add a C++ redirect context manager to Python
+    instead of using a C++ guard. To use it, add the following to your binding code:
+
+    .. code-block:: cpp
+
+        #include <pybind11/iostream.h>
+
+        ...
+
+        py::add_ostream_redirect(m, "ostream_redirect");
+
+    You now have a Python context manager that redirects your output:
+
+    .. code-block:: python
+
+        with m.ostream_redirect():
+            m.print_to_cout_function()
+
+    This manager can optionally be told which streams to operate on:
+
+    .. code-block:: python
+
+        with m.ostream_redirect(stdout=true, stderr=true):
+            m.noisy_function_with_error_printing()
+
+ \endrst */
+inline class_<detail::OstreamRedirect> add_ostream_redirect(module m, std::string name = "ostream_redirect") {
+    return class_<detail::OstreamRedirect>(m, name.c_str(), module_local())
+        .def(init<bool,bool>(), arg("stdout")=true, arg("stderr")=true)
+        .def("__enter__", &detail::OstreamRedirect::enter)
+        .def("__exit__", [](detail::OstreamRedirect &self_, args) { self_.exit(); });
+}
+
+NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/src/pybind11/include/pybind11/numpy.h b/src/pybind11/include/pybind11/numpy.h
index 388e212..ba41a22 100644
--- a/src/pybind11/include/pybind11/numpy.h
+++ b/src/pybind11/include/pybind11/numpy.h
@@ -14,13 +14,14 @@
 #include <numeric>
 #include <algorithm>
 #include <array>
+#include <cstdint>
 #include <cstdlib>
 #include <cstring>
 #include <sstream>
 #include <string>
-#include <initializer_list>
 #include <functional>
 #include <utility>
+#include <vector>
 #include <typeindex>
 
 #if defined(_MSC_VER)
@@ -34,7 +35,7 @@
    upon the library user. */
 static_assert(sizeof(ssize_t) == sizeof(Py_intptr_t), "ssize_t != Py_intptr_t");
 
-NAMESPACE_BEGIN(pybind11)
+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
 class array; // Forward declaration
 
@@ -108,6 +109,18 @@ inline numpy_internals& get_numpy_internals() {
     return *ptr;
 }
 
+template <typename T> struct same_size {
+    template <typename U> using as = bool_constant<sizeof(T) == sizeof(U)>;
+};
+
+template <typename Concrete> constexpr int platform_lookup() { return -1; }
+
+// Lookup a type according to its size, and return a value corresponding to the NumPy typenum.
+template <typename Concrete, typename T, typename... Ts, typename... Ints>
+constexpr int platform_lookup(int I, Ints... Is) {
+    return sizeof(Concrete) == sizeof(T) ? I : platform_lookup<Concrete, Ts...>(Is...);
+}
+
 struct npy_api {
     enum constants {
         NPY_ARRAY_C_CONTIGUOUS_ = 0x0001,
@@ -126,7 +139,23 @@ struct npy_api {
         NPY_FLOAT_, NPY_DOUBLE_, NPY_LONGDOUBLE_,
         NPY_CFLOAT_, NPY_CDOUBLE_, NPY_CLONGDOUBLE_,
         NPY_OBJECT_ = 17,
-        NPY_STRING_, NPY_UNICODE_, NPY_VOID_
+        NPY_STRING_, NPY_UNICODE_, NPY_VOID_,
+        // Platform-dependent normalization
+        NPY_INT8_ = NPY_BYTE_,
+        NPY_UINT8_ = NPY_UBYTE_,
+        NPY_INT16_ = NPY_SHORT_,
+        NPY_UINT16_ = NPY_USHORT_,
+        // `npy_common.h` defines the integer aliases. In order, it checks:
+        // NPY_BITSOF_LONG, NPY_BITSOF_LONGLONG, NPY_BITSOF_INT, NPY_BITSOF_SHORT, NPY_BITSOF_CHAR
+        // and assigns the alias to the first matching size, so we should check in this order.
+        NPY_INT32_ = platform_lookup<std::int32_t, long, int, short>(
+            NPY_LONG_, NPY_INT_, NPY_SHORT_),
+        NPY_UINT32_ = platform_lookup<std::uint32_t, unsigned long, unsigned int, unsigned short>(
+            NPY_ULONG_, NPY_UINT_, NPY_USHORT_),
+        NPY_INT64_ = platform_lookup<std::int64_t, long, long long, int>(
+            NPY_LONG_, NPY_LONGLONG_, NPY_INT_),
+        NPY_UINT64_ = platform_lookup<std::uint64_t, unsigned long, unsigned long long, unsigned int>(
+            NPY_ULONG_, NPY_ULONGLONG_, NPY_UINT_),
     };
 
     typedef struct {
@@ -250,7 +279,7 @@ template <typename T> struct array_info_scalar {
     typedef T type;
     static constexpr bool is_array = false;
     static constexpr bool is_empty = false;
-    static PYBIND11_DESCR extents() { return _(""); }
+    static constexpr auto extents = _("");
     static void append_extents(list& /* shape */) { }
 };
 // Computes underlying type and a comma-separated list of extents for array
@@ -269,15 +298,9 @@ template <typename T, size_t N> struct array_info<std::array<T, N>> {
         array_info<T>::append_extents(shape);
     }
 
-    template<typename T2 = T, enable_if_t<!array_info<T2>::is_array, int> = 0>
-    static PYBIND11_DESCR extents() {
-        return _<N>();
-    }
-
-    template<typename T2 = T, enable_if_t<array_info<T2>::is_array, int> = 0>
-    static PYBIND11_DESCR extents() {
-        return concat(_<N>(), array_info<T>::extents());
-    }
+    static constexpr auto extents = _<array_info<T>::is_array>(
+        concat(_<N>(), array_info<T>::extents), _<N>()
+    );
 };
 // For numpy we have special handling for arrays of characters, so we don't include
 // the size in the array extents.
@@ -288,7 +311,9 @@ template <typename T> using remove_all_extents_t = typename array_info<T>::type;
 
 template <typename T> using is_pod_struct = all_of<
     std::is_standard_layout<T>,     // since we're accessing directly in memory we need a standard layout type
-#if !defined(__GNUG__) || defined(__clang__) || __GNUC__ >= 5
+#if !defined(__GNUG__) || defined(_LIBCPP_VERSION) || defined(_GLIBCXX_USE_CXX11_ABI)
+    // _GLIBCXX_USE_CXX11_ABI indicates that we're using libstdc++ from GCC 5 or newer, independent
+    // of the actual compiler (Clang can also use libstdc++, but it always defines __GNUC__ == 4).
     std::is_trivially_copyable<T>,
 #else
     // GCC 4 doesn't implement is_trivially_copyable, so approximate it
@@ -342,7 +367,7 @@ public:
      * dimensionality, this is not checked (and so is up to the caller to use safely).
      */
     template <typename... Ix> const T &operator()(Ix... index) const {
-        static_assert(sizeof...(Ix) == Dims || Dynamic,
+        static_assert(ssize_t{sizeof...(Ix)} == Dims || Dynamic,
                 "Invalid number of indices for unchecked array reference");
         return *reinterpret_cast<const T *>(data_ + byte_offset_unsafe(strides_, ssize_t(index)...));
     }
@@ -391,7 +416,7 @@ class unchecked_mutable_reference : public unchecked_reference<T, Dims> {
 public:
     /// Mutable, unchecked access to data at the given indices.
     template <typename... Ix> T& operator()(Ix... index) {
-        static_assert(sizeof...(Ix) == Dims || Dynamic,
+        static_assert(ssize_t{sizeof...(Ix)} == Dims || Dynamic,
                 "Invalid number of indices for unchecked array reference");
         return const_cast<T &>(ConstBase::operator()(index...));
     }
@@ -444,7 +469,7 @@ public:
     /// This is essentially the same as calling numpy.dtype(args) in Python.
     static dtype from_args(object args) {
         PyObject *ptr = nullptr;
-        if (!detail::npy_api::get().PyArray_DescrConverter_(args.release().ptr(), &ptr) || !ptr)
+        if (!detail::npy_api::get().PyArray_DescrConverter_(args.ptr(), &ptr) || !ptr)
             throw error_already_set();
         return reinterpret_steal<dtype>(ptr);
     }
@@ -689,7 +714,7 @@ public:
      * care: the array must not be destroyed or reshaped for the duration of the returned object,
      * and the caller must take care not to access invalid dimensions or dimension indices.
      */
-    template <typename T, ssize_t Dims = -1> detail::unchecked_mutable_reference<T, Dims> mutable_unchecked() {
+    template <typename T, ssize_t Dims = -1> detail::unchecked_mutable_reference<T, Dims> mutable_unchecked() & {
         if (Dims >= 0 && ndim() != Dims)
             throw std::domain_error("array has incorrect number of dimensions: " + std::to_string(ndim()) +
                     "; expected " + std::to_string(Dims));
@@ -703,7 +728,7 @@ public:
      * reshaped for the duration of the returned object, and the caller must take care not to access
      * invalid dimensions or dimension indices.
      */
-    template <typename T, ssize_t Dims = -1> detail::unchecked_reference<T, Dims> unchecked() const {
+    template <typename T, ssize_t Dims = -1> detail::unchecked_reference<T, Dims> unchecked() const & {
         if (Dims >= 0 && ndim() != Dims)
             throw std::domain_error("array has incorrect number of dimensions: " + std::to_string(ndim()) +
                     "; expected " + std::to_string(Dims));
@@ -762,8 +787,9 @@ protected:
     static std::vector<ssize_t> c_strides(const std::vector<ssize_t> &shape, ssize_t itemsize) {
         auto ndim = shape.size();
         std::vector<ssize_t> strides(ndim, itemsize);
-        for (size_t i = ndim - 1; i > 0; --i)
-            strides[i - 1] = strides[i] * shape[i];
+        if (ndim > 0)
+            for (size_t i = ndim - 1; i > 0; --i)
+                strides[i - 1] = strides[i] * shape[i];
         return strides;
     }
 
@@ -858,14 +884,14 @@ public:
 
     // Reference to element at a given index
     template<typename... Ix> const T& at(Ix... index) const {
-        if (sizeof...(index) != ndim())
+        if ((ssize_t) sizeof...(index) != ndim())
             fail_dim_check(sizeof...(index), "index dimension mismatch");
         return *(static_cast<const T*>(array::data()) + byte_offset(ssize_t(index)...) / itemsize());
     }
 
     // Mutable reference to element at a given index
     template<typename... Ix> T& mutable_at(Ix... index) {
-        if (sizeof...(index) != ndim())
+        if ((ssize_t) sizeof...(index) != ndim())
             fail_dim_check(sizeof...(index), "index dimension mismatch");
         return *(static_cast<T*>(array::mutable_data()) + byte_offset(ssize_t(index)...) / itemsize());
     }
@@ -876,7 +902,7 @@ public:
      * care: the array must not be destroyed or reshaped for the duration of the returned object,
      * and the caller must take care not to access invalid dimensions or dimension indices.
      */
-    template <ssize_t Dims = -1> detail::unchecked_mutable_reference<T, Dims> mutable_unchecked() {
+    template <ssize_t Dims = -1> detail::unchecked_mutable_reference<T, Dims> mutable_unchecked() & {
         return array::mutable_unchecked<T, Dims>();
     }
 
@@ -887,7 +913,7 @@ public:
      * for the duration of the returned object, and the caller must take care not to access invalid
      * dimensions or dimension indices.
      */
-    template <ssize_t Dims = -1> detail::unchecked_reference<T, Dims> unchecked() const {
+    template <ssize_t Dims = -1> detail::unchecked_reference<T, Dims> unchecked() const & {
         return array::unchecked<T, Dims>();
     }
 
@@ -944,9 +970,9 @@ struct format_descriptor<T, detail::enable_if_t<std::is_enum<T>::value>> {
 template <typename T>
 struct format_descriptor<T, detail::enable_if_t<detail::array_info<T>::is_array>> {
     static std::string format() {
-        using detail::_;
-        PYBIND11_DESCR extents = _("(") + detail::array_info<T>::extents() + _(")");
-        return extents.text() + format_descriptor<detail::remove_all_extents_t<T>>::format();
+        using namespace detail;
+        static constexpr auto extents = _("(") + array_info<T>::extents + _(")");
+        return extents.text + format_descriptor<remove_all_extents_t<T>>::format();
     }
 };
 
@@ -965,7 +991,7 @@ struct pyobject_caster<array_t<T, ExtraFlags>> {
     static handle cast(const handle &src, return_value_policy /* policy */, handle /* parent */) {
         return src.inc_ref();
     }
-    PYBIND11_TYPE_CASTER(type, handle_type_name<type>::name());
+    PYBIND11_TYPE_CASTER(type, handle_type_name<type>::name);
 };
 
 template <typename T>
@@ -975,13 +1001,40 @@ struct compare_buffer_info<T, detail::enable_if_t<detail::is_pod_struct<T>::valu
     }
 };
 
-template <typename T> struct npy_format_descriptor<T, enable_if_t<satisfies_any_of<T, std::is_arithmetic, is_complex>::value>> {
+template <typename T, typename = void>
+struct npy_format_descriptor_name;
+
+template <typename T>
+struct npy_format_descriptor_name<T, enable_if_t<std::is_integral<T>::value>> {
+    static constexpr auto name = _<std::is_same<T, bool>::value>(
+        _("bool"), _<std::is_signed<T>::value>("int", "uint") + _<sizeof(T)*8>()
+    );
+};
+
+template <typename T>
+struct npy_format_descriptor_name<T, enable_if_t<std::is_floating_point<T>::value>> {
+    static constexpr auto name = _<std::is_same<T, float>::value || std::is_same<T, double>::value>(
+        _("float") + _<sizeof(T)*8>(), _("longdouble")
+    );
+};
+
+template <typename T>
+struct npy_format_descriptor_name<T, enable_if_t<is_complex<T>::value>> {
+    static constexpr auto name = _<std::is_same<typename T::value_type, float>::value
+                                   || std::is_same<typename T::value_type, double>::value>(
+        _("complex") + _<sizeof(typename T::value_type)*16>(), _("longcomplex")
+    );
+};
+
+template <typename T>
+struct npy_format_descriptor<T, enable_if_t<satisfies_any_of<T, std::is_arithmetic, is_complex>::value>>
+    : npy_format_descriptor_name<T> {
 private:
     // NB: the order here must match the one in common.h
     constexpr static const int values[15] = {
         npy_api::NPY_BOOL_,
-        npy_api::NPY_BYTE_,   npy_api::NPY_UBYTE_,   npy_api::NPY_SHORT_,    npy_api::NPY_USHORT_,
-        npy_api::NPY_INT_,    npy_api::NPY_UINT_,    npy_api::NPY_LONGLONG_, npy_api::NPY_ULONGLONG_,
+        npy_api::NPY_BYTE_,   npy_api::NPY_UBYTE_,   npy_api::NPY_INT16_,    npy_api::NPY_UINT16_,
+        npy_api::NPY_INT32_,  npy_api::NPY_UINT32_,  npy_api::NPY_INT64_,    npy_api::NPY_UINT64_,
         npy_api::NPY_FLOAT_,  npy_api::NPY_DOUBLE_,  npy_api::NPY_LONGDOUBLE_,
         npy_api::NPY_CFLOAT_, npy_api::NPY_CDOUBLE_, npy_api::NPY_CLONGDOUBLE_
     };
@@ -991,28 +1044,13 @@ public:
 
     static pybind11::dtype dtype() {
         if (auto ptr = npy_api::get().PyArray_DescrFromType_(value))
-            return reinterpret_borrow<pybind11::dtype>(ptr);
+            return reinterpret_steal<pybind11::dtype>(ptr);
         pybind11_fail("Unsupported buffer format!");
     }
-    template <typename T2 = T, enable_if_t<std::is_integral<T2>::value, int> = 0>
-    static PYBIND11_DESCR name() {
-        return _<std::is_same<T, bool>::value>(_("bool"),
-            _<std::is_signed<T>::value>("int", "uint") + _<sizeof(T)*8>());
-    }
-    template <typename T2 = T, enable_if_t<std::is_floating_point<T2>::value, int> = 0>
-    static PYBIND11_DESCR name() {
-        return _<std::is_same<T, float>::value || std::is_same<T, double>::value>(
-                _("float") + _<sizeof(T)*8>(), _("longdouble"));
-    }
-    template <typename T2 = T, enable_if_t<is_complex<T2>::value, int> = 0>
-    static PYBIND11_DESCR name() {
-        return _<std::is_same<typename T2::value_type, float>::value || std::is_same<typename T2::value_type, double>::value>(
-                _("complex") + _<sizeof(typename T2::value_type)*16>(), _("longcomplex"));
-    }
 };
 
 #define PYBIND11_DECL_CHAR_FMT \
-    static PYBIND11_DESCR name() { return _("S") + _<N>(); } \
+    static constexpr auto name = _("S") + _<N>(); \
     static pybind11::dtype dtype() { return pybind11::dtype(std::string("S") + std::to_string(N)); }
 template <size_t N> struct npy_format_descriptor<char[N]> { PYBIND11_DECL_CHAR_FMT };
 template <size_t N> struct npy_format_descriptor<std::array<char, N>> { PYBIND11_DECL_CHAR_FMT };
@@ -1024,7 +1062,7 @@ private:
 public:
     static_assert(!array_info<T>::is_empty, "Zero-sized arrays are not supported");
 
-    static PYBIND11_DESCR name() { return _("(") + array_info<T>::extents() + _(")") + base_descr::name(); }
+    static constexpr auto name = _("(") + array_info<T>::extents + _(")") + base_descr::name;
     static pybind11::dtype dtype() {
         list shape;
         array_info<T>::append_extents(shape);
@@ -1036,7 +1074,7 @@ template<typename T> struct npy_format_descriptor<T, enable_if_t<std::is_enum<T>
 private:
     using base_descr = npy_format_descriptor<typename std::underlying_type<T>::type>;
 public:
-    static PYBIND11_DESCR name() { return base_descr::name(); }
+    static constexpr auto name = base_descr::name;
     static pybind11::dtype dtype() { return base_descr::dtype(); }
 };
 
@@ -1049,7 +1087,7 @@ struct field_descriptor {
 };
 
 inline PYBIND11_NOINLINE void register_structured_dtype(
-    const std::initializer_list<field_descriptor>& fields,
+    any_container<field_descriptor> fields,
     const std::type_info& tinfo, ssize_t itemsize,
     bool (*direct_converter)(PyObject *, void *&)) {
 
@@ -1057,8 +1095,14 @@ inline PYBIND11_NOINLINE void register_structured_dtype(
     if (numpy_internals.get_type_info(tinfo, false))
         pybind11_fail("NumPy: dtype is already registered");
 
+    // Use ordered fields because order matters as of NumPy 1.14:
+    // https://docs.scipy.org/doc/numpy/release.html#multiple-field-indexing-assignment-of-structured-arrays
+    std::vector<field_descriptor> ordered_fields(std::move(fields));
+    std::sort(ordered_fields.begin(), ordered_fields.end(),
+        [](const field_descriptor &a, const field_descriptor &b) { return a.offset < b.offset; });
+
     list names, formats, offsets;
-    for (auto field : fields) {
+    for (auto& field : ordered_fields) {
         if (!field.descr)
             pybind11_fail(std::string("NumPy: unsupported field dtype: `") +
                             field.name + "` @ " + tinfo.name());
@@ -1075,9 +1119,6 @@ inline PYBIND11_NOINLINE void register_structured_dtype(
     // - https://github.com/numpy/numpy/pull/7798
     // Because of this, we won't use numpy's logic to generate buffer format
     // strings and will just do it ourselves.
-    std::vector<field_descriptor> ordered_fields(fields);
-    std::sort(ordered_fields.begin(), ordered_fields.end(),
-        [](const field_descriptor &a, const field_descriptor &b) { return a.offset < b.offset; });
     ssize_t offset = 0;
     std::ostringstream oss;
     // mark the structure as unaligned with '^', because numpy and C++ don't
@@ -1111,7 +1152,7 @@ inline PYBIND11_NOINLINE void register_structured_dtype(
 template <typename T, typename SFINAE> struct npy_format_descriptor {
     static_assert(is_pod_struct<T>::value, "Attempt to use a non-POD or unimplemented POD type as a numpy dtype");
 
-    static PYBIND11_DESCR name() { return make_caster<T>::name(); }
+    static constexpr auto name = make_caster<T>::name;
 
     static pybind11::dtype dtype() {
         return reinterpret_borrow<pybind11::dtype>(dtype_ptr());
@@ -1122,8 +1163,8 @@ template <typename T, typename SFINAE> struct npy_format_descriptor {
         return format_str;
     }
 
-    static void register_dtype(const std::initializer_list<field_descriptor>& fields) {
-        register_structured_dtype(fields, typeid(typename std::remove_cv<T>::type),
+    static void register_dtype(any_container<field_descriptor> fields) {
+        register_structured_dtype(std::move(fields), typeid(typename std::remove_cv<T>::type),
                                   sizeof(T), &direct_converter);
     }
 
@@ -1196,7 +1237,8 @@ private:
 
 #define PYBIND11_NUMPY_DTYPE(Type, ...) \
     ::pybind11::detail::npy_format_descriptor<Type>::register_dtype \
-        ({PYBIND11_MAP_LIST (PYBIND11_FIELD_DESCRIPTOR, Type, __VA_ARGS__)})
+        (::std::vector<::pybind11::detail::field_descriptor> \
+         {PYBIND11_MAP_LIST (PYBIND11_FIELD_DESCRIPTOR, Type, __VA_ARGS__)})
 
 #ifdef _MSC_VER
 #define PYBIND11_MAP2_LIST_NEXT1(test, next) \
@@ -1217,7 +1259,8 @@ private:
 
 #define PYBIND11_NUMPY_DTYPE_EX(Type, ...) \
     ::pybind11::detail::npy_format_descriptor<Type>::register_dtype \
-        ({PYBIND11_MAP2_LIST (PYBIND11_FIELD_DESCRIPTOR_EX, Type, __VA_ARGS__)})
+        (::std::vector<::pybind11::detail::field_descriptor> \
+         {PYBIND11_MAP2_LIST (PYBIND11_FIELD_DESCRIPTOR_EX, Type, __VA_ARGS__)})
 
 #endif // __CLION_IDE__
 
@@ -1455,7 +1498,10 @@ public:
 private:
     remove_reference_t<Func> f;
 
-    template <size_t Index> using param_n_t = typename pack_element<Index, typename vectorize_arg<Args>::call_type...>::type;
+    // Internal compiler error in MSVC 19.16.27025.1 (Visual Studio 2017 15.9.4), when compiling with "/permissive-" flag
+    // when arg_call_types is manually inlined.
+    using arg_call_types = std::tuple<typename vectorize_arg<Args>::call_type...>;
+    template <size_t Index> using param_n_t = typename std::tuple_element<Index, arg_call_types>::type;
 
     // Runs a vectorized function given arguments tuple and three index sequences:
     //     - Index is the full set of 0 ... (N-1) argument indices;
@@ -1495,7 +1541,7 @@ private:
         if (trivial == broadcast_trivial::f_trivial) result = array_t<Return, array::f_style>(shape);
         else result = array_t<Return>(shape);
 
-        if (size == 0) return result;
+        if (size == 0) return std::move(result);
 
         /* Call the function */
         if (trivial == broadcast_trivial::non_trivial)
@@ -1503,7 +1549,7 @@ private:
         else
             apply_trivial(buffers, params, result.mutable_data(), size, i_seq, vi_seq, bi_seq);
 
-        return result;
+        return std::move(result);
     }
 
     template <size_t... Index, size_t... VIndex, size_t... BIndex>
@@ -1556,9 +1602,7 @@ vectorize_extractor(const Func &f, Return (*) (Args ...)) {
 }
 
 template <typename T, int Flags> struct handle_type_name<array_t<T, Flags>> {
-    static PYBIND11_DESCR name() {
-        return _("numpy.ndarray[") + npy_format_descriptor<T>::name() + _("]");
-    }
+    static constexpr auto name = _("numpy.ndarray[") + npy_format_descriptor<T>::name + _("]");
 };
 
 NAMESPACE_END(detail)
@@ -1571,10 +1615,10 @@ vectorize(Return (*f) (Args ...)) {
 }
 
 // lambda vectorizer:
-template <typename Func, typename FuncType = typename detail::remove_class<decltype(&detail::remove_reference_t<Func>::operator())>::type>
+template <typename Func, detail::enable_if_t<detail::is_lambda<Func>::value, int> = 0>
 auto vectorize(Func &&f) -> decltype(
-        detail::vectorize_extractor(std::forward<Func>(f), (FuncType *) nullptr)) {
-    return detail::vectorize_extractor(std::forward<Func>(f), (FuncType *) nullptr);
+        detail::vectorize_extractor(std::forward<Func>(f), (detail::function_signature_t<Func> *) nullptr)) {
+    return detail::vectorize_extractor(std::forward<Func>(f), (detail::function_signature_t<Func> *) nullptr);
 }
 
 // Vectorize a class method (non-const):
@@ -1584,14 +1628,14 @@ Helper vectorize(Return (Class::*f)(Args...)) {
     return Helper(std::mem_fn(f));
 }
 
-// Vectorize a class method (non-const):
+// Vectorize a class method (const):
 template <typename Return, typename Class, typename... Args,
           typename Helper = detail::vectorize_helper<decltype(std::mem_fn(std::declval<Return (Class::*)(Args...) const>())), Return, const Class *, Args...>>
 Helper vectorize(Return (Class::*f)(Args...) const) {
     return Helper(std::mem_fn(f));
 }
 
-NAMESPACE_END(pybind11)
+NAMESPACE_END(PYBIND11_NAMESPACE)
 
 #if defined(_MSC_VER)
 #pragma warning(pop)
diff --git a/src/pybind11/include/pybind11/operators.h b/src/pybind11/include/pybind11/operators.h
index 562987b..b3dd62c 100644
--- a/src/pybind11/include/pybind11/operators.h
+++ b/src/pybind11/include/pybind11/operators.h
@@ -18,7 +18,7 @@
 #  pragma warning(disable: 4127) // warning C4127: Conditional expression is constant
 #endif
 
-NAMESPACE_BEGIN(pybind11)
+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
 /// Enumeration with all supported operator types
@@ -28,7 +28,7 @@ enum op_id : int {
     op_int, op_long, op_float, op_str, op_cmp, op_gt, op_ge, op_lt, op_le,
     op_eq, op_ne, op_iadd, op_isub, op_imul, op_idiv, op_imod, op_ilshift,
     op_irshift, op_iand, op_ixor, op_ior, op_complex, op_bool, op_nonzero,
-    op_repr, op_truediv, op_itruediv
+    op_repr, op_truediv, op_itruediv, op_hash
 };
 
 enum op_type : int {
@@ -148,6 +148,7 @@ PYBIND11_INPLACE_OPERATOR(ior,      operator|=,   l |= r)
 PYBIND11_UNARY_OPERATOR(neg,        operator-,    -l)
 PYBIND11_UNARY_OPERATOR(pos,        operator+,    +l)
 PYBIND11_UNARY_OPERATOR(abs,        abs,          std::abs(l))
+PYBIND11_UNARY_OPERATOR(hash,       hash,         std::hash<L>()(l))
 PYBIND11_UNARY_OPERATOR(invert,     operator~,    (~l))
 PYBIND11_UNARY_OPERATOR(bool,       operator!,    !!l)
 PYBIND11_UNARY_OPERATOR(int,        int_,         (int) l)
@@ -160,7 +161,7 @@ NAMESPACE_END(detail)
 
 using detail::self;
 
-NAMESPACE_END(pybind11)
+NAMESPACE_END(PYBIND11_NAMESPACE)
 
 #if defined(_MSC_VER)
 #  pragma warning(pop)
diff --git a/src/pybind11/include/pybind11/options.h b/src/pybind11/include/pybind11/options.h
index 3105551..cc1e1f6 100644
--- a/src/pybind11/include/pybind11/options.h
+++ b/src/pybind11/include/pybind11/options.h
@@ -9,9 +9,9 @@
 
 #pragma once
 
-#include "common.h"
+#include "detail/common.h"
 
-NAMESPACE_BEGIN(pybind11)
+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
 class options {
 public:
@@ -62,4 +62,4 @@ private:
     state previous_state;
 };
 
-NAMESPACE_END(pybind11)
+NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/src/pybind11/include/pybind11/pybind11.h b/src/pybind11/include/pybind11/pybind11.h
index e922903..d95d61f 100644
--- a/src/pybind11/include/pybind11/pybind11.h
+++ b/src/pybind11/include/pybind11/pybind11.h
@@ -10,7 +10,17 @@
 
 #pragma once
 
-#if defined(_MSC_VER)
+#if defined(__INTEL_COMPILER)
+#  pragma warning push
+#  pragma warning disable 68    // integer conversion resulted in a change of sign
+#  pragma warning disable 186   // pointless comparison of unsigned integer with zero
+#  pragma warning disable 878   // incompatible exception specifications
+#  pragma warning disable 1334  // the "template" keyword used for syntactic disambiguation may only be used within a template
+#  pragma warning disable 1682  // implicit conversion of a 64-bit integral type to a smaller integral type (potential portability problem)
+#  pragma warning disable 1786  // function "strdup" was declared deprecated
+#  pragma warning disable 1875  // offsetof applied to non-POD (Plain Old Data) types is nonstandard
+#  pragma warning disable 2196  // warning #2196: routine is both "inline" and "noinline"
+#elif defined(_MSC_VER)
 #  pragma warning(push)
 #  pragma warning(disable: 4100) // warning C4100: Unreferenced formal parameter
 #  pragma warning(disable: 4127) // warning C4127: Conditional expression is constant
@@ -19,11 +29,6 @@
 #  pragma warning(disable: 4996) // warning C4996: The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name
 #  pragma warning(disable: 4702) // warning C4702: unreachable code
 #  pragma warning(disable: 4522) // warning C4522: multiple assignment operators specified
-#elif defined(__INTEL_COMPILER)
-#  pragma warning(push)
-#  pragma warning(disable: 186)   // pointless comparison of unsigned integer with zero
-#  pragma warning(disable: 1334)  // the "template" keyword used for syntactic disambiguation may only be used within a template
-#  pragma warning(disable: 2196)  // warning #2196: routine is both "inline" and "noinline"
 #elif defined(__GNUG__) && !defined(__clang__)
 #  pragma GCC diagnostic push
 #  pragma GCC diagnostic ignored "-Wunused-but-set-parameter"
@@ -38,14 +43,20 @@
 
 #include "attr.h"
 #include "options.h"
-#include "class_support.h"
+#include "detail/class.h"
+#include "detail/init.h"
+
+#if defined(__GNUG__) && !defined(__clang__)
+#  include <cxxabi.h>
+#endif
 
-NAMESPACE_BEGIN(pybind11)
+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
 /// Wraps an arbitrary C++ function/method/lambda function/.. into a callable Python object
 class cpp_function : public function {
 public:
     cpp_function() { }
+    cpp_function(std::nullptr_t) { }
 
     /// Construct a cpp_function from a vanilla function pointer
     template <typename Return, typename... Args, typename... Extra>
@@ -54,16 +65,11 @@ public:
     }
 
     /// Construct a cpp_function from a lambda function (possibly with internal state)
-    template <typename Func, typename... Extra, typename = detail::enable_if_t<
-        detail::satisfies_none_of<
-            detail::remove_reference_t<Func>,
-            std::is_function, std::is_pointer, std::is_member_pointer
-        >::value>
-    >
+    template <typename Func, typename... Extra,
+              typename = detail::enable_if_t<detail::is_lambda<Func>::value>>
     cpp_function(Func &&f, const Extra&... extra) {
-        using FuncType = typename detail::remove_class<decltype(&detail::remove_reference_t<Func>::operator())>::type;
         initialize(std::forward<Func>(f),
-                   (FuncType *) nullptr, extra...);
+                   (detail::function_signature_t<Func> *) nullptr, extra...);
     }
 
     /// Construct a cpp_function from a class method (non-const)
@@ -92,8 +98,8 @@ protected:
     /// Special internal constructor for functors, lambda functions, etc.
     template <typename Func, typename Return, typename... Args, typename... Extra>
     void initialize(Func &&f, Return (*)(Args...), const Extra&... extra) {
-
-        struct capture { detail::remove_reference_t<Func> f; };
+        using namespace detail;
+        struct capture { remove_reference_t<Func> f; };
 
         /* Store the function including any extra state it might have (e.g. a lambda capture object) */
         auto rec = make_function_record();
@@ -112,23 +118,23 @@ protected:
 #  pragma GCC diagnostic pop
 #endif
             if (!std::is_trivially_destructible<Func>::value)
-                rec->free_data = [](detail::function_record *r) { ((capture *) &r->data)->~capture(); };
+                rec->free_data = [](function_record *r) { ((capture *) &r->data)->~capture(); };
         } else {
             rec->data[0] = new capture { std::forward<Func>(f) };
-            rec->free_data = [](detail::function_record *r) { delete ((capture *) r->data[0]); };
+            rec->free_data = [](function_record *r) { delete ((capture *) r->data[0]); };
         }
 
         /* Type casters for the function arguments and return value */
-        using cast_in = detail::argument_loader<Args...>;
-        using cast_out = detail::make_caster<
-            detail::conditional_t<std::is_void<Return>::value, detail::void_type, Return>
+        using cast_in = argument_loader<Args...>;
+        using cast_out = make_caster<
+            conditional_t<std::is_void<Return>::value, void_type, Return>
         >;
 
-        static_assert(detail::expected_num_args<Extra...>(sizeof...(Args), cast_in::has_args, cast_in::has_kwargs),
+        static_assert(expected_num_args<Extra...>(sizeof...(Args), cast_in::has_args, cast_in::has_kwargs),
                       "The number of argument annotations does not match the number of function arguments");
 
         /* Dispatch code which converts function arguments and performs the actual function call */
-        rec->impl = [](detail::function_call &call) -> handle {
+        rec->impl = [](function_call &call) -> handle {
             cast_in args_converter;
 
             /* Try to cast the function arguments into the C++ domain */
@@ -136,7 +142,7 @@ protected:
                 return PYBIND11_TRY_NEXT_OVERLOAD;
 
             /* Invoke call policy pre-call hook */
-            detail::process_attributes<Extra...>::precall(call);
+            process_attributes<Extra...>::precall(call);
 
             /* Get a pointer to the capture object */
             auto data = (sizeof(capture) <= sizeof(call.func.data)
@@ -144,30 +150,30 @@ protected:
             capture *cap = const_cast<capture *>(reinterpret_cast<const capture *>(data));
 
             /* Override policy for rvalues -- usually to enforce rvp::move on an rvalue */
-            const auto policy = detail::return_value_policy_override<Return>::policy(call.func.policy);
+            return_value_policy policy = return_value_policy_override<Return>::policy(call.func.policy);
 
             /* Function scope guard -- defaults to the compile-to-nothing `void_type` */
-            using Guard = detail::extract_guard_t<Extra...>;
+            using Guard = extract_guard_t<Extra...>;
 
             /* Perform the function call */
             handle result = cast_out::cast(
                 std::move(args_converter).template call<Return, Guard>(cap->f), policy, call.parent);
 
             /* Invoke call policy post-call hook */
-            detail::process_attributes<Extra...>::postcall(call, result);
+            process_attributes<Extra...>::postcall(call, result);
 
             return result;
         };
 
         /* Process any user-provided function attributes */
-        detail::process_attributes<Extra...>::init(extra..., rec);
+        process_attributes<Extra...>::init(extra..., rec);
 
         /* Generate a readable signature describing the function's arguments and return value types */
-        using detail::descr; using detail::_;
-        PYBIND11_DESCR signature = _("(") + cast_in::arg_names() + _(") -> ") + cast_out::name();
+        static constexpr auto signature = _("(") + cast_in::arg_names + _(") -> ") + cast_out::name;
+        PYBIND11_DESCR_CONSTEXPR auto types = decltype(signature)::types();
 
         /* Register the function with Python from generic (non-templated) code */
-        initialize_generic(rec, signature.text(), signature.types(), sizeof...(Args));
+        initialize_generic(rec, signature.text, types.data(), sizeof...(Args));
 
         if (cast_in::has_args) rec->has_args = true;
         if (cast_in::has_kwargs) rec->has_kwargs = true;
@@ -199,47 +205,63 @@ protected:
                 a.descr = strdup(a.value.attr("__repr__")().cast<std::string>().c_str());
         }
 
+        rec->is_constructor = !strcmp(rec->name, "__init__") || !strcmp(rec->name, "__setstate__");
+
+#if !defined(NDEBUG) && !defined(PYBIND11_DISABLE_NEW_STYLE_INIT_WARNING)
+        if (rec->is_constructor && !rec->is_new_style_constructor) {
+            const auto class_name = std::string(((PyTypeObject *) rec->scope.ptr())->tp_name);
+            const auto func_name = std::string(rec->name);
+            PyErr_WarnEx(
+                PyExc_FutureWarning,
+                ("pybind11-bound class '" + class_name + "' is using an old-style "
+                 "placement-new '" + func_name + "' which has been deprecated. See "
+                 "the upgrade guide in pybind11's docs. This message is only visible "
+                 "when compiled in debug mode.").c_str(), 0
+            );
+        }
+#endif
+
         /* Generate a proper function signature */
         std::string signature;
-        size_t type_depth = 0, char_index = 0, type_index = 0, arg_index = 0;
-        while (true) {
-            char c = text[char_index++];
-            if (c == '\0')
-                break;
+        size_t type_index = 0, arg_index = 0;
+        for (auto *pc = text; *pc != '\0'; ++pc) {
+            const auto c = *pc;
 
             if (c == '{') {
-                // Write arg name for everything except *args, **kwargs and return type.
-                if (type_depth == 0 && text[char_index] != '*' && arg_index < args) {
-                    if (!rec->args.empty() && rec->args[arg_index].name) {
-                        signature += rec->args[arg_index].name;
-                    } else if (arg_index == 0 && rec->is_method) {
-                        signature += "self";
-                    } else {
-                        signature += "arg" + std::to_string(arg_index - (rec->is_method ? 1 : 0));
-                    }
-                    signature += ": ";
+                // Write arg name for everything except *args and **kwargs.
+                if (*(pc + 1) == '*')
+                    continue;
+
+                if (arg_index < rec->args.size() && rec->args[arg_index].name) {
+                    signature += rec->args[arg_index].name;
+                } else if (arg_index == 0 && rec->is_method) {
+                    signature += "self";
+                } else {
+                    signature += "arg" + std::to_string(arg_index - (rec->is_method ? 1 : 0));
                 }
-                ++type_depth;
+                signature += ": ";
             } else if (c == '}') {
-                --type_depth;
-                if (type_depth == 0) {
-                    if (arg_index < rec->args.size() && rec->args[arg_index].descr) {
-                        signature += "=";
-                        signature += rec->args[arg_index].descr;
-                    }
-                    arg_index++;
+                // Write default value if available.
+                if (arg_index < rec->args.size() && rec->args[arg_index].descr) {
+                    signature += " = ";
+                    signature += rec->args[arg_index].descr;
                 }
+                arg_index++;
             } else if (c == '%') {
                 const std::type_info *t = types[type_index++];
                 if (!t)
                     pybind11_fail("Internal error while parsing type signature (1)");
                 if (auto tinfo = detail::get_type_info(*t)) {
-#if defined(PYPY_VERSION)
-                    signature += handle((PyObject *) tinfo->type)
-                                     .attr("__module__")
-                                     .cast<std::string>() + ".";
-#endif
-                    signature += tinfo->type->tp_name;
+                    handle th((PyObject *) tinfo->type);
+                    signature +=
+                        th.attr("__module__").cast<std::string>() + "." +
+                        th.attr("__qualname__").cast<std::string>(); // Python 3.3+, but we backport it to earlier versions
+                } else if (rec->is_new_style_constructor && arg_index == 0) {
+                    // A new-style `__init__` takes `self` as `value_and_holder`.
+                    // Rewrite it to the proper class type.
+                    signature +=
+                        rec->scope.attr("__module__").cast<std::string>() + "." +
+                        rec->scope.attr("__qualname__").cast<std::string>();
                 } else {
                     std::string tname(t->name());
                     detail::clean_type_id(tname);
@@ -249,14 +271,9 @@ protected:
                 signature += c;
             }
         }
-        if (type_depth != 0 || types[type_index] != nullptr)
+        if (arg_index != args || types[type_index] != nullptr)
             pybind11_fail("Internal error while parsing type signature (2)");
 
-        #if !defined(PYBIND11_CONSTEXPR_DESCR)
-            delete[] types;
-            delete[] text;
-        #endif
-
 #if PY_MAJOR_VERSION < 3
         if (strcmp(rec->name, "__next__") == 0) {
             std::free(rec->name);
@@ -268,7 +285,6 @@ protected:
 #endif
         rec->signature = strdup(signature.c_str());
         rec->args.shrink_to_fit();
-        rec->is_constructor = !strcmp(rec->name, "__init__") || !strcmp(rec->name, "__setstate__");
         rec->nargs = (std::uint16_t) args;
 
         if (rec->sibling && PYBIND11_INSTANCE_METHOD_CHECK(rec->sibling.ptr()))
@@ -295,7 +311,7 @@ protected:
             rec->def = new PyMethodDef();
             std::memset(rec->def, 0, sizeof(PyMethodDef));
             rec->def->ml_name = rec->name;
-            rec->def->ml_meth = reinterpret_cast<PyCFunction>(*dispatcher);
+            rec->def->ml_meth = reinterpret_cast<PyCFunction>(reinterpret_cast<void (*) (void)>(*dispatcher));
             rec->def->ml_flags = METH_VARARGS | METH_KEYWORDS;
 
             capsule rec_capsule(rec, [](void *ptr) {
@@ -409,8 +425,8 @@ protected:
         using namespace detail;
 
         /* Iterator over the list of potentially admissible overloads */
-        function_record *overloads = (function_record *) PyCapsule_GetPointer(self, nullptr),
-                        *it = overloads;
+        const function_record *overloads = (function_record *) PyCapsule_GetPointer(self, nullptr),
+                              *it = overloads;
 
         /* Need to know how many arguments + keyword arguments there are to pick the right overload */
         const size_t n_args_in = (size_t) PyTuple_GET_SIZE(args_in);
@@ -418,6 +434,23 @@ protected:
         handle parent = n_args_in > 0 ? PyTuple_GET_ITEM(args_in, 0) : nullptr,
                result = PYBIND11_TRY_NEXT_OVERLOAD;
 
+        auto self_value_and_holder = value_and_holder();
+        if (overloads->is_constructor) {
+            const auto tinfo = get_type_info((PyTypeObject *) overloads->scope.ptr());
+            const auto pi = reinterpret_cast<instance *>(parent.ptr());
+            self_value_and_holder = pi->get_value_and_holder(tinfo, false);
+
+            if (!self_value_and_holder.type || !self_value_and_holder.inst) {
+                PyErr_SetString(PyExc_TypeError, "__init__(self, ...) called with invalid `self` argument");
+                return nullptr;
+            }
+
+            // If this value is already registered it must mean __init__ is invoked multiple times;
+            // we really can't support that in C++, so just ignore the second __init__.
+            if (self_value_and_holder.instance_registered())
+                return none().release().ptr();
+        }
+
         try {
             // We do this in two passes: in the first pass, we load arguments with `convert=false`;
             // in the second, we allow conversion (except for arguments with an explicit
@@ -449,7 +482,7 @@ protected:
                    result other than PYBIND11_TRY_NEXT_OVERLOAD.
                  */
 
-                function_record &func = *it;
+                const function_record &func = *it;
                 size_t pos_args = func.nargs;    // Number of positional arguments that we need
                 if (func.has_args) --pos_args;   // (but don't count py::args
                 if (func.has_kwargs) --pos_args; //  or py::kwargs)
@@ -462,13 +495,26 @@ protected:
 
                 function_call call(func, parent);
 
-                size_t args_to_copy = std::min(pos_args, n_args_in);
+                size_t args_to_copy = (std::min)(pos_args, n_args_in); // Protect std::min with parentheses
                 size_t args_copied = 0;
 
+                // 0. Inject new-style `self` argument
+                if (func.is_new_style_constructor) {
+                    // The `value` may have been preallocated by an old-style `__init__`
+                    // if it was a preceding candidate for overload resolution.
+                    if (self_value_and_holder)
+                        self_value_and_holder.type->dealloc(self_value_and_holder);
+
+                    call.init_self = PyTuple_GET_ITEM(args_in, 0);
+                    call.args.push_back(reinterpret_cast<PyObject *>(&self_value_and_holder));
+                    call.args_convert.push_back(false);
+                    ++args_copied;
+                }
+
                 // 1. Copy any position arguments given.
                 bool bad_arg = false;
                 for (; args_copied < args_to_copy; ++args_copied) {
-                    argument_record *arg_rec = args_copied < func.args.size() ? &func.args[args_copied] : nullptr;
+                    const argument_record *arg_rec = args_copied < func.args.size() ? &func.args[args_copied] : nullptr;
                     if (kwargs_in && arg_rec && arg_rec->name && PyDict_GetItemString(kwargs_in, arg_rec->name)) {
                         bad_arg = true;
                         break;
@@ -527,8 +573,8 @@ protected:
                     continue; // Unconsumed kwargs, but no py::kwargs argument to accept them
 
                 // 4a. If we have a py::args argument, create a new tuple with leftovers
-                tuple extra_args;
                 if (func.has_args) {
+                    tuple extra_args;
                     if (args_to_copy == 0) {
                         // We didn't copy out any position arguments from the args_in tuple, so we
                         // can reuse it directly without copying:
@@ -539,12 +585,12 @@ protected:
                         size_t args_size = n_args_in - args_copied;
                         extra_args = tuple(args_size);
                         for (size_t i = 0; i < args_size; ++i) {
-                            handle item = PyTuple_GET_ITEM(args_in, args_copied + i);
-                            extra_args[i] = item.inc_ref().ptr();
+                            extra_args[i] = PyTuple_GET_ITEM(args_in, args_copied + i);
                         }
                     }
                     call.args.push_back(extra_args);
                     call.args_convert.push_back(false);
+                    call.args_ref = std::move(extra_args);
                 }
 
                 // 4b. If we have a py::kwargs, pass on any remaining kwargs
@@ -553,6 +599,7 @@ protected:
                         kwargs = dict(); // If we didn't get one, send an empty one
                     call.args.push_back(kwargs);
                     call.args_convert.push_back(false);
+                    call.kwargs_ref = std::move(kwargs);
                 }
 
                 // 5. Put everything in a vector.  Not technically step 5, we've been building it
@@ -608,13 +655,22 @@ protected:
                         result = PYBIND11_TRY_NEXT_OVERLOAD;
                     }
 
-                    if (result.ptr() != PYBIND11_TRY_NEXT_OVERLOAD)
+                    if (result.ptr() != PYBIND11_TRY_NEXT_OVERLOAD) {
+                        // The error reporting logic below expects 'it' to be valid, as it would be
+                        // if we'd encountered this failure in the first-pass loop.
+                        if (!result)
+                            it = &call.func;
                         break;
+                    }
                 }
             }
         } catch (error_already_set &e) {
             e.restore();
             return nullptr;
+#if defined(__GNUG__) && !defined(__clang__)
+        } catch ( abi::__forced_unwind& ) {
+            throw;
+#endif
         } catch (...) {
             /* When an exception is caught, give each registered exception
                translator a chance to translate it to a Python exception
@@ -642,6 +698,16 @@ protected:
             return nullptr;
         }
 
+        auto append_note_if_missing_header_is_suspected = [](std::string &msg) {
+            if (msg.find("std::") != std::string::npos) {
+                msg += "\n\n"
+                       "Did you forget to `#include <pybind11/stl.h>`? Or <pybind11/complex.h>,\n"
+                       "<pybind11/functional.h>, <pybind11/chrono.h>, etc. Some automatic\n"
+                       "conversions are optional and require extra headers to be included\n"
+                       "when compiling your pybind11 module.";
+            }
+        };
+
         if (result.ptr() == PYBIND11_TRY_NEXT_OVERLOAD) {
             if (overloads->is_operator)
                 return handle(Py_NotImplemented).inc_ref().ptr();
@@ -651,7 +717,7 @@ protected:
                 " arguments. The following argument types are supported:\n";
 
             int ctr = 0;
-            for (function_record *it2 = overloads; it2 != nullptr; it2 = it2->next) {
+            for (const function_record *it2 = overloads; it2 != nullptr; it2 = it2->next) {
                 msg += "    "+ std::to_string(++ctr) + ". ";
 
                 bool wrote_sig = false;
@@ -699,18 +765,20 @@ protected:
                 }
             }
 
+            append_note_if_missing_header_is_suspected(msg);
             PyErr_SetString(PyExc_TypeError, msg.c_str());
             return nullptr;
         } else if (!result) {
             std::string msg = "Unable to convert function return value to a "
                               "Python type! The signature was\n\t";
             msg += it->signature;
+            append_note_if_missing_header_is_suspected(msg);
             PyErr_SetString(PyExc_TypeError, msg.c_str());
             return nullptr;
         } else {
-            if (overloads->is_constructor) {
-                auto tinfo = get_type_info((PyTypeObject *) overloads->scope.ptr());
-                tinfo->init_holder(reinterpret_cast<instance *>(parent.ptr()), nullptr);
+            if (overloads->is_constructor && !self_value_and_holder.holder_constructed()) {
+                auto *pi = reinterpret_cast<instance *>(parent.ptr());
+                self_value_and_holder.type->init_instance(pi, nullptr);
             }
             return result.ptr();
         }
@@ -784,6 +852,14 @@ public:
         return reinterpret_steal<module>(obj);
     }
 
+    /// Reload the module or throws `error_already_set`.
+    void reload() {
+        PyObject *obj = PyImport_ReloadModule(ptr());
+        if (!obj)
+            throw error_already_set();
+        *this = reinterpret_steal<module>(obj);
+    }
+
     // Adds an object to the module using the given name.  Throws if an object with the given name
     // already exists.
     //
@@ -818,7 +894,7 @@ protected:
             pybind11_fail("generic_type: cannot initialize type \"" + std::string(rec.name) +
                           "\": an object with that name is already defined");
 
-        if (get_type_info(*rec.type))
+        if (rec.module_local ? get_local_type_info(*rec.type) : get_global_type_info(*rec.type))
             pybind11_fail("generic_type: type \"" + std::string(rec.name) +
                           "\" is already registered!");
 
@@ -829,18 +905,23 @@ protected:
         tinfo->type = (PyTypeObject *) m_ptr;
         tinfo->cpptype = rec.type;
         tinfo->type_size = rec.type_size;
+        tinfo->type_align = rec.type_align;
         tinfo->operator_new = rec.operator_new;
         tinfo->holder_size_in_ptrs = size_in_ptrs(rec.holder_size);
-        tinfo->init_holder = rec.init_holder;
+        tinfo->init_instance = rec.init_instance;
         tinfo->dealloc = rec.dealloc;
         tinfo->simple_type = true;
         tinfo->simple_ancestors = true;
+        tinfo->default_holder = rec.default_holder;
+        tinfo->module_local = rec.module_local;
 
         auto &internals = get_internals();
         auto tindex = std::type_index(*rec.type);
         tinfo->direct_conversions = &internals.direct_conversions[tindex];
-        tinfo->default_holder = rec.default_holder;
-        internals.registered_types_cpp[tindex] = tinfo;
+        if (rec.module_local)
+            registered_local_types_cpp()[tindex] = tinfo;
+        else
+            internals.registered_types_cpp[tindex] = tinfo;
         internals.registered_types_py[(PyTypeObject *) m_ptr] = { tinfo };
 
         if (rec.bases.size() > 1 || rec.multiple_inheritance) {
@@ -851,6 +932,12 @@ protected:
             auto parent_tinfo = get_type_info((PyTypeObject *) rec.bases[0].ptr());
             tinfo->simple_ancestors = parent_tinfo->simple_ancestors;
         }
+
+        if (rec.module_local) {
+            // Stash the local typeinfo and loader so that external modules can access it.
+            tinfo->module_local_load = &type_caster_generic::local_load;
+            setattr(m_ptr, PYBIND11_MODULE_LOCAL_ID, capsule(tinfo));
+        }
     }
 
     /// Helper function which tags all parents of a type using mult. inheritance
@@ -881,18 +968,18 @@ protected:
         tinfo->get_buffer_data = get_buffer_data;
     }
 
+    // rec_func must be set for either fget or fset.
     void def_property_static_impl(const char *name,
                                   handle fget, handle fset,
-                                  detail::function_record *rec_fget) {
-        const auto is_static = !(rec_fget->is_method && rec_fget->scope);
-        const auto has_doc = rec_fget->doc && pybind11::options::show_user_defined_docstrings();
-
+                                  detail::function_record *rec_func) {
+        const auto is_static = rec_func && !(rec_func->is_method && rec_func->scope);
+        const auto has_doc = rec_func && rec_func->doc && pybind11::options::show_user_defined_docstrings();
         auto property = handle((PyObject *) (is_static ? get_internals().static_property_type
                                                        : &PyProperty_Type));
         attr(name) = property(fget.ptr() ? fget : none(),
                               fset.ptr() ? fset : none(),
                               /*deleter*/none(),
-                              pybind11::str(has_doc ? rec_fget->doc : ""));
+                              pybind11::str(has_doc ? rec_func->doc : ""));
     }
 };
 
@@ -902,19 +989,63 @@ void set_operator_new(type_record *r) { r->operator_new = &T::operator new; }
 
 template <typename> void set_operator_new(...) { }
 
+template <typename T, typename SFINAE = void> struct has_operator_delete : std::false_type { };
+template <typename T> struct has_operator_delete<T, void_t<decltype(static_cast<void (*)(void *)>(T::operator delete))>>
+    : std::true_type { };
+template <typename T, typename SFINAE = void> struct has_operator_delete_size : std::false_type { };
+template <typename T> struct has_operator_delete_size<T, void_t<decltype(static_cast<void (*)(void *, size_t)>(T::operator delete))>>
+    : std::true_type { };
 /// Call class-specific delete if it exists or global otherwise. Can also be an overload set.
-template <typename T, typename = void_t<decltype(static_cast<void (*)(void *)>(T::operator delete))>>
-void call_operator_delete(T *p) { T::operator delete(p); }
-
-inline void call_operator_delete(void *p) { ::operator delete(p); }
+template <typename T, enable_if_t<has_operator_delete<T>::value, int> = 0>
+void call_operator_delete(T *p, size_t, size_t) { T::operator delete(p); }
+template <typename T, enable_if_t<!has_operator_delete<T>::value && has_operator_delete_size<T>::value, int> = 0>
+void call_operator_delete(T *p, size_t s, size_t) { T::operator delete(p, s); }
+
+inline void call_operator_delete(void *p, size_t s, size_t a) {
+    (void)s; (void)a;
+    #if defined(__cpp_aligned_new) && (!defined(_MSC_VER) || _MSC_VER >= 1912)
+        if (a > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
+            #ifdef __cpp_sized_deallocation
+                ::operator delete(p, s, std::align_val_t(a));
+            #else
+                ::operator delete(p, std::align_val_t(a));
+            #endif
+            return;
+        }
+    #endif
+    #ifdef __cpp_sized_deallocation
+        ::operator delete(p, s);
+    #else
+        ::operator delete(p);
+    #endif
+}
 
 NAMESPACE_END(detail)
 
+/// Given a pointer to a member function, cast it to its `Derived` version.
+/// Forward everything else unchanged.
+template <typename /*Derived*/, typename F>
+auto method_adaptor(F &&f) -> decltype(std::forward<F>(f)) { return std::forward<F>(f); }
+
+template <typename Derived, typename Return, typename Class, typename... Args>
+auto method_adaptor(Return (Class::*pmf)(Args...)) -> Return (Derived::*)(Args...) {
+    static_assert(detail::is_accessible_base_of<Class, Derived>::value,
+        "Cannot bind an inaccessible base class method; use a lambda definition instead");
+    return pmf;
+}
+
+template <typename Derived, typename Return, typename Class, typename... Args>
+auto method_adaptor(Return (Class::*pmf)(Args...) const) -> Return (Derived::*)(Args...) const {
+    static_assert(detail::is_accessible_base_of<Class, Derived>::value,
+        "Cannot bind an inaccessible base class method; use a lambda definition instead");
+    return pmf;
+}
+
 template <typename type_, typename... options>
 class class_ : public detail::generic_type {
     template <typename T> using is_holder = detail::is_holder_type<type_, T>;
-    template <typename T> using is_subtype = detail::bool_constant<std::is_base_of<type_, T>::value && !std::is_same<T, type_>::value>;
-    template <typename T> using is_base = detail::bool_constant<std::is_base_of<T, type_>::value && !std::is_same<T, type_>::value>;
+    template <typename T> using is_subtype = detail::is_strict_base_of<type_, T>;
+    template <typename T> using is_base = detail::is_strict_base_of<T, type_>;
     // struct instead of using here to help MSVC:
     template <typename T> struct is_valid_class_option :
         detail::any_of<is_holder<T>, is_subtype<T>, is_base<T>> {};
@@ -928,6 +1059,9 @@ public:
     static_assert(detail::all_of<is_valid_class_option<options>...>::value,
             "Unknown/invalid class_ template parameters provided");
 
+    static_assert(!has_alias || std::is_polymorphic<type>::value,
+            "Cannot use an alias class with a non-polymorphic type");
+
     PYBIND11_OBJECT(class_, generic_type, PyType_Check)
 
     template <typename... Extra>
@@ -947,10 +1081,11 @@ public:
         record.name = name;
         record.type = &typeid(type);
         record.type_size = sizeof(conditional_t<has_alias, type_alias, type>);
+        record.type_align = alignof(conditional_t<has_alias, type_alias, type>&);
         record.holder_size = sizeof(holder_type);
-        record.init_holder = init_holder;
+        record.init_instance = init_instance;
         record.dealloc = dealloc;
-        record.default_holder = std::is_same<holder_type, std::unique_ptr<type>>::value;
+        record.default_holder = detail::is_instantiation<std::unique_ptr, holder_type>::value;
 
         set_operator_new<type>(&record);
 
@@ -963,7 +1098,7 @@ public:
         generic_type::initialize(record);
 
         if (has_alias) {
-            auto &instances = get_internals().registered_types_cpp;
+            auto &instances = record.module_local ? registered_local_types_cpp() : get_internals().registered_types_cpp;
             instances[std::type_index(typeid(type_alias))] = instances[std::type_index(typeid(type))];
         }
     }
@@ -980,7 +1115,7 @@ public:
 
     template <typename Func, typename... Extra>
     class_ &def(const char *name_, Func&& f, const Extra&... extra) {
-        cpp_function cf(std::forward<Func>(f), name(name_), is_method(*this),
+        cpp_function cf(method_adaptor<type>(std::forward<Func>(f)), name(name_), is_method(*this),
                         sibling(getattr(*this, name_, none())), extra...);
         attr(cf.name()) = cf;
         return *this;
@@ -992,7 +1127,7 @@ public:
                 "def_static(...) called with a non-static member function pointer");
         cpp_function cf(std::forward<Func>(f), name(name_), scope(*this),
                         sibling(getattr(*this, name_, none())), extra...);
-        attr(cf.name()) = cf;
+        attr(cf.name()) = staticmethod(cf);
         return *this;
     }
 
@@ -1009,17 +1144,29 @@ public:
     }
 
     template <typename... Args, typename... Extra>
-    class_ &def(const detail::init<Args...> &init, const Extra&... extra) {
+    class_ &def(const detail::initimpl::constructor<Args...> &init, const Extra&... extra) {
         init.execute(*this, extra...);
         return *this;
     }
 
     template <typename... Args, typename... Extra>
-    class_ &def(const detail::init_alias<Args...> &init, const Extra&... extra) {
+    class_ &def(const detail::initimpl::alias_constructor<Args...> &init, const Extra&... extra) {
         init.execute(*this, extra...);
         return *this;
     }
 
+    template <typename... Args, typename... Extra>
+    class_ &def(detail::initimpl::factory<Args...> &&init, const Extra&... extra) {
+        std::move(init).execute(*this, extra...);
+        return *this;
+    }
+
+    template <typename... Args, typename... Extra>
+    class_ &def(detail::initimpl::pickle_factory<Args...> &&pf, const Extra &...extra) {
+        std::move(pf).execute(*this, extra...);
+        return *this;
+    }
+
     template <typename Func> class_& def_buffer(Func &&func) {
         struct capture { Func func; };
         capture *ptr = new capture { std::forward<Func>(func) };
@@ -1044,15 +1191,17 @@ public:
 
     template <typename C, typename D, typename... Extra>
     class_ &def_readwrite(const char *name, D C::*pm, const Extra&... extra) {
-        cpp_function fget([pm](const C &c) -> const D &{ return c.*pm; }, is_method(*this)),
-                     fset([pm](C &c, const D &value) { c.*pm = value; }, is_method(*this));
+        static_assert(std::is_same<C, type>::value || std::is_base_of<C, type>::value, "def_readwrite() requires a class member (or base class member)");
+        cpp_function fget([pm](const type &c) -> const D &{ return c.*pm; }, is_method(*this)),
+                     fset([pm](type &c, const D &value) { c.*pm = value; }, is_method(*this));
         def_property(name, fget, fset, return_value_policy::reference_internal, extra...);
         return *this;
     }
 
     template <typename C, typename D, typename... Extra>
     class_ &def_readonly(const char *name, const D C::*pm, const Extra& ...extra) {
-        cpp_function fget([pm](const C &c) -> const D &{ return c.*pm; }, is_method(*this));
+        static_assert(std::is_same<C, type>::value || std::is_base_of<C, type>::value, "def_readonly() requires a class member (or base class member)");
+        cpp_function fget([pm](const type &c) -> const D &{ return c.*pm; }, is_method(*this));
         def_property_readonly(name, fget, return_value_policy::reference_internal, extra...);
         return *this;
     }
@@ -1075,13 +1224,14 @@ public:
     /// Uses return_value_policy::reference_internal by default
     template <typename Getter, typename... Extra>
     class_ &def_property_readonly(const char *name, const Getter &fget, const Extra& ...extra) {
-        return def_property_readonly(name, cpp_function(fget), return_value_policy::reference_internal, extra...);
+        return def_property_readonly(name, cpp_function(method_adaptor<type>(fget)),
+                                     return_value_policy::reference_internal, extra...);
     }
 
     /// Uses cpp_function's return_value_policy by default
     template <typename... Extra>
     class_ &def_property_readonly(const char *name, const cpp_function &fget, const Extra& ...extra) {
-        return def_property(name, fget, cpp_function(), extra...);
+        return def_property(name, fget, nullptr, extra...);
     }
 
     /// Uses return_value_policy::reference by default
@@ -1093,13 +1243,18 @@ public:
     /// Uses cpp_function's return_value_policy by default
     template <typename... Extra>
     class_ &def_property_readonly_static(const char *name, const cpp_function &fget, const Extra& ...extra) {
-        return def_property_static(name, fget, cpp_function(), extra...);
+        return def_property_static(name, fget, nullptr, extra...);
     }
 
     /// Uses return_value_policy::reference_internal by default
+    template <typename Getter, typename Setter, typename... Extra>
+    class_ &def_property(const char *name, const Getter &fget, const Setter &fset, const Extra& ...extra) {
+        return def_property(name, fget, cpp_function(method_adaptor<type>(fset)), extra...);
+    }
     template <typename Getter, typename... Extra>
     class_ &def_property(const char *name, const Getter &fget, const cpp_function &fset, const Extra& ...extra) {
-        return def_property(name, cpp_function(fget), fset, return_value_policy::reference_internal, extra...);
+        return def_property(name, cpp_function(method_adaptor<type>(fget)), fset,
+                            return_value_policy::reference_internal, extra...);
     }
 
     /// Uses cpp_function's return_value_policy by default
@@ -1117,79 +1272,99 @@ public:
     /// Uses cpp_function's return_value_policy by default
     template <typename... Extra>
     class_ &def_property_static(const char *name, const cpp_function &fget, const cpp_function &fset, const Extra& ...extra) {
+        static_assert( 0 == detail::constexpr_sum(std::is_base_of<arg, Extra>::value...),
+                      "Argument annotations are not allowed for properties");
         auto rec_fget = get_function_record(fget), rec_fset = get_function_record(fset);
-        char *doc_prev = rec_fget->doc; /* 'extra' field may include a property-specific documentation string */
-        detail::process_attributes<Extra...>::init(extra..., rec_fget);
-        if (rec_fget->doc && rec_fget->doc != doc_prev) {
-            free(doc_prev);
-            rec_fget->doc = strdup(rec_fget->doc);
+        auto *rec_active = rec_fget;
+        if (rec_fget) {
+           char *doc_prev = rec_fget->doc; /* 'extra' field may include a property-specific documentation string */
+           detail::process_attributes<Extra...>::init(extra..., rec_fget);
+           if (rec_fget->doc && rec_fget->doc != doc_prev) {
+              free(doc_prev);
+              rec_fget->doc = strdup(rec_fget->doc);
+           }
         }
         if (rec_fset) {
-            doc_prev = rec_fset->doc;
+            char *doc_prev = rec_fset->doc;
             detail::process_attributes<Extra...>::init(extra..., rec_fset);
             if (rec_fset->doc && rec_fset->doc != doc_prev) {
                 free(doc_prev);
                 rec_fset->doc = strdup(rec_fset->doc);
             }
+            if (! rec_active) rec_active = rec_fset;
         }
-        def_property_static_impl(name, fget, fset, rec_fget);
+        def_property_static_impl(name, fget, fset, rec_active);
         return *this;
     }
 
 private:
     /// Initialize holder object, variant 1: object derives from enable_shared_from_this
     template <typename T>
-    static void init_holder_helper(detail::instance *inst, detail::value_and_holder &v_h,
+    static void init_holder(detail::instance *inst, detail::value_and_holder &v_h,
             const holder_type * /* unused */, const std::enable_shared_from_this<T> * /* dummy */) {
         try {
             auto sh = std::dynamic_pointer_cast<typename holder_type::element_type>(
                     v_h.value_ptr<type>()->shared_from_this());
             if (sh) {
-                new (&v_h.holder<holder_type>()) holder_type(std::move(sh));
+                new (std::addressof(v_h.holder<holder_type>())) holder_type(std::move(sh));
                 v_h.set_holder_constructed();
             }
         } catch (const std::bad_weak_ptr &) {}
 
         if (!v_h.holder_constructed() && inst->owned) {
-            new (&v_h.holder<holder_type>()) holder_type(v_h.value_ptr<type>());
+            new (std::addressof(v_h.holder<holder_type>())) holder_type(v_h.value_ptr<type>());
             v_h.set_holder_constructed();
         }
     }
 
     static void init_holder_from_existing(const detail::value_and_holder &v_h,
             const holder_type *holder_ptr, std::true_type /*is_copy_constructible*/) {
-        new (&v_h.holder<holder_type>()) holder_type(*reinterpret_cast<const holder_type *>(holder_ptr));
+        new (std::addressof(v_h.holder<holder_type>())) holder_type(*reinterpret_cast<const holder_type *>(holder_ptr));
     }
 
     static void init_holder_from_existing(const detail::value_and_holder &v_h,
             const holder_type *holder_ptr, std::false_type /*is_copy_constructible*/) {
-        new (&v_h.holder<holder_type>()) holder_type(std::move(*const_cast<holder_type *>(holder_ptr)));
+        new (std::addressof(v_h.holder<holder_type>())) holder_type(std::move(*const_cast<holder_type *>(holder_ptr)));
     }
 
     /// Initialize holder object, variant 2: try to construct from existing holder object, if possible
-    static void init_holder_helper(detail::instance *inst, detail::value_and_holder &v_h,
+    static void init_holder(detail::instance *inst, detail::value_and_holder &v_h,
             const holder_type *holder_ptr, const void * /* dummy -- not enable_shared_from_this<T>) */) {
         if (holder_ptr) {
             init_holder_from_existing(v_h, holder_ptr, std::is_copy_constructible<holder_type>());
             v_h.set_holder_constructed();
         } else if (inst->owned || detail::always_construct_holder<holder_type>::value) {
-            new (&v_h.holder<holder_type>()) holder_type(v_h.value_ptr<type>());
+            new (std::addressof(v_h.holder<holder_type>())) holder_type(v_h.value_ptr<type>());
             v_h.set_holder_constructed();
         }
     }
 
-    /// Initialize holder object of an instance, possibly given a pointer to an existing holder
-    static void init_holder(detail::instance *inst, const void *holder_ptr) {
+    /// Performs instance initialization including constructing a holder and registering the known
+    /// instance.  Should be called as soon as the `type` value_ptr is set for an instance.  Takes an
+    /// optional pointer to an existing holder to use; if not specified and the instance is
+    /// `.owned`, a new holder will be constructed to manage the value pointer.
+    static void init_instance(detail::instance *inst, const void *holder_ptr) {
         auto v_h = inst->get_value_and_holder(detail::get_type_info(typeid(type)));
-        init_holder_helper(inst, v_h, (const holder_type *) holder_ptr, v_h.value_ptr<type>());
+        if (!v_h.instance_registered()) {
+            register_instance(inst, v_h.value_ptr(), v_h.type);
+            v_h.set_instance_registered();
+        }
+        init_holder(inst, v_h, (const holder_type *) holder_ptr, v_h.value_ptr<type>());
     }
 
     /// Deallocates an instance; via holder, if constructed; otherwise via operator delete.
-    static void dealloc(const detail::value_and_holder &v_h) {
-        if (v_h.holder_constructed())
+    static void dealloc(detail::value_and_holder &v_h) {
+        if (v_h.holder_constructed()) {
             v_h.holder<holder_type>().~holder_type();
-        else
-            detail::call_operator_delete(v_h.value_ptr<type>());
+            v_h.set_holder_constructed(false);
+        }
+        else {
+            detail::call_operator_delete(v_h.value_ptr<type>(),
+                v_h.type->type_size,
+                v_h.type->type_align
+            );
+        }
+        v_h.value_ptr() = nullptr;
     }
 
     static detail::function_record *get_function_record(handle h) {
@@ -1199,134 +1374,232 @@ private:
     }
 };
 
+/// Binds an existing constructor taking arguments Args...
+template <typename... Args> detail::initimpl::constructor<Args...> init() { return {}; }
+/// Like `init<Args...>()`, but the instance is always constructed through the alias class (even
+/// when not inheriting on the Python side).
+template <typename... Args> detail::initimpl::alias_constructor<Args...> init_alias() { return {}; }
+
+/// Binds a factory function as a constructor
+template <typename Func, typename Ret = detail::initimpl::factory<Func>>
+Ret init(Func &&f) { return {std::forward<Func>(f)}; }
+
+/// Dual-argument factory function: the first function is called when no alias is needed, the second
+/// when an alias is needed (i.e. due to python-side inheritance).  Arguments must be identical.
+template <typename CFunc, typename AFunc, typename Ret = detail::initimpl::factory<CFunc, AFunc>>
+Ret init(CFunc &&c, AFunc &&a) {
+    return {std::forward<CFunc>(c), std::forward<AFunc>(a)};
+}
+
+/// Binds pickling functions `__getstate__` and `__setstate__` and ensures that the type
+/// returned by `__getstate__` is the same as the argument accepted by `__setstate__`.
+template <typename GetState, typename SetState>
+detail::initimpl::pickle_factory<GetState, SetState> pickle(GetState &&g, SetState &&s) {
+    return {std::forward<GetState>(g), std::forward<SetState>(s)};
+}
+
+NAMESPACE_BEGIN(detail)
+struct enum_base {
+    enum_base(handle base, handle parent) : m_base(base), m_parent(parent) { }
+
+    PYBIND11_NOINLINE void init(bool is_arithmetic, bool is_convertible) {
+        m_base.attr("__entries") = dict();
+        auto property = handle((PyObject *) &PyProperty_Type);
+        auto static_property = handle((PyObject *) get_internals().static_property_type);
+
+        m_base.attr("__repr__") = cpp_function(
+            [](handle arg) -> str {
+                handle type = arg.get_type();
+                object type_name = type.attr("__name__");
+                dict entries = type.attr("__entries");
+                for (const auto &kv : entries) {
+                    object other = kv.second[int_(0)];
+                    if (other.equal(arg))
+                        return pybind11::str("{}.{}").format(type_name, kv.first);
+                }
+                return pybind11::str("{}.???").format(type_name);
+            }, is_method(m_base)
+        );
+
+        m_base.attr("name") = property(cpp_function(
+            [](handle arg) -> str {
+                dict entries = arg.get_type().attr("__entries");
+                for (const auto &kv : entries) {
+                    if (handle(kv.second[int_(0)]).equal(arg))
+                        return pybind11::str(kv.first);
+                }
+                return "???";
+            }, is_method(m_base)
+        ));
+
+        m_base.attr("__doc__") = static_property(cpp_function(
+            [](handle arg) -> std::string {
+                std::string docstring;
+                dict entries = arg.attr("__entries");
+                if (((PyTypeObject *) arg.ptr())->tp_doc)
+                    docstring += std::string(((PyTypeObject *) arg.ptr())->tp_doc) + "\n\n";
+                docstring += "Members:";
+                for (const auto &kv : entries) {
+                    auto key = std::string(pybind11::str(kv.first));
+                    auto comment = kv.second[int_(1)];
+                    docstring += "\n\n  " + key;
+                    if (!comment.is_none())
+                        docstring += " : " + (std::string) pybind11::str(comment);
+                }
+                return docstring;
+            }
+        ), none(), none(), "");
+
+        m_base.attr("__members__") = static_property(cpp_function(
+            [](handle arg) -> dict {
+                dict entries = arg.attr("__entries"), m;
+                for (const auto &kv : entries)
+                    m[kv.first] = kv.second[int_(0)];
+                return m;
+            }), none(), none(), ""
+        );
+
+        #define PYBIND11_ENUM_OP_STRICT(op, expr, strict_behavior)                     \
+            m_base.attr(op) = cpp_function(                                            \
+                [](object a, object b) {                                               \
+                    if (!a.get_type().is(b.get_type()))                                \
+                        strict_behavior;                                               \
+                    return expr;                                                       \
+                },                                                                     \
+                is_method(m_base))
+
+        #define PYBIND11_ENUM_OP_CONV(op, expr)                                        \
+            m_base.attr(op) = cpp_function(                                            \
+                [](object a_, object b_) {                                             \
+                    int_ a(a_), b(b_);                                                 \
+                    return expr;                                                       \
+                },                                                                     \
+                is_method(m_base))
+
+        #define PYBIND11_ENUM_OP_CONV_LHS(op, expr)                                    \
+            m_base.attr(op) = cpp_function(                                            \
+                [](object a_, object b) {                                              \
+                    int_ a(a_);                                                        \
+                    return expr;                                                       \
+                },                                                                     \
+                is_method(m_base))
+
+        if (is_convertible) {
+            PYBIND11_ENUM_OP_CONV_LHS("__eq__", !b.is_none() &&  a.equal(b));
+            PYBIND11_ENUM_OP_CONV_LHS("__ne__",  b.is_none() || !a.equal(b));
+
+            if (is_arithmetic) {
+                PYBIND11_ENUM_OP_CONV("__lt__",   a <  b);
+                PYBIND11_ENUM_OP_CONV("__gt__",   a >  b);
+                PYBIND11_ENUM_OP_CONV("__le__",   a <= b);
+                PYBIND11_ENUM_OP_CONV("__ge__",   a >= b);
+                PYBIND11_ENUM_OP_CONV("__and__",  a &  b);
+                PYBIND11_ENUM_OP_CONV("__rand__", a &  b);
+                PYBIND11_ENUM_OP_CONV("__or__",   a |  b);
+                PYBIND11_ENUM_OP_CONV("__ror__",  a |  b);
+                PYBIND11_ENUM_OP_CONV("__xor__",  a ^  b);
+                PYBIND11_ENUM_OP_CONV("__rxor__", a ^  b);
+                m_base.attr("__invert__") = cpp_function(
+                    [](object arg) { return ~(int_(arg)); }, is_method(m_base));
+            }
+        } else {
+            PYBIND11_ENUM_OP_STRICT("__eq__",  int_(a).equal(int_(b)), return false);
+            PYBIND11_ENUM_OP_STRICT("__ne__", !int_(a).equal(int_(b)), return true);
+
+            if (is_arithmetic) {
+                #define PYBIND11_THROW throw type_error("Expected an enumeration of matching type!");
+                PYBIND11_ENUM_OP_STRICT("__lt__", int_(a) <  int_(b), PYBIND11_THROW);
+                PYBIND11_ENUM_OP_STRICT("__gt__", int_(a) >  int_(b), PYBIND11_THROW);
+                PYBIND11_ENUM_OP_STRICT("__le__", int_(a) <= int_(b), PYBIND11_THROW);
+                PYBIND11_ENUM_OP_STRICT("__ge__", int_(a) >= int_(b), PYBIND11_THROW);
+                #undef PYBIND11_THROW
+            }
+        }
+
+        #undef PYBIND11_ENUM_OP_CONV_LHS
+        #undef PYBIND11_ENUM_OP_CONV
+        #undef PYBIND11_ENUM_OP_STRICT
+
+        object getstate = cpp_function(
+            [](object arg) { return int_(arg); }, is_method(m_base));
+
+        m_base.attr("__getstate__") = getstate;
+        m_base.attr("__hash__") = getstate;
+    }
+
+    PYBIND11_NOINLINE void value(char const* name_, object value, const char *doc = nullptr) {
+        dict entries = m_base.attr("__entries");
+        str name(name_);
+        if (entries.contains(name)) {
+            std::string type_name = (std::string) str(m_base.attr("__name__"));
+            throw value_error(type_name + ": element \"" + std::string(name_) + "\" already exists!");
+        }
+
+        entries[name] = std::make_pair(value, doc);
+        m_base.attr(name) = value;
+    }
+
+    PYBIND11_NOINLINE void export_values() {
+        dict entries = m_base.attr("__entries");
+        for (const auto &kv : entries)
+            m_parent.attr(kv.first) = kv.second[int_(0)];
+    }
+
+    handle m_base;
+    handle m_parent;
+};
+
+NAMESPACE_END(detail)
+
 /// Binds C++ enumerations and enumeration classes to Python
 template <typename Type> class enum_ : public class_<Type> {
 public:
-    using class_<Type>::def;
-    using class_<Type>::def_property_readonly_static;
+    using Base = class_<Type>;
+    using Base::def;
+    using Base::attr;
+    using Base::def_property_readonly;
+    using Base::def_property_readonly_static;
     using Scalar = typename std::underlying_type<Type>::type;
 
     template <typename... Extra>
     enum_(const handle &scope, const char *name, const Extra&... extra)
-      : class_<Type>(scope, name, extra...), m_entries(), m_parent(scope) {
-
+      : class_<Type>(scope, name, extra...), m_base(*this, scope) {
         constexpr bool is_arithmetic = detail::any_of<std::is_same<arithmetic, Extra>...>::value;
+        constexpr bool is_convertible = std::is_convertible<Type, Scalar>::value;
+        m_base.init(is_arithmetic, is_convertible);
 
-        auto m_entries_ptr = m_entries.inc_ref().ptr();
-        def("__repr__", [name, m_entries_ptr](Type value) -> pybind11::str {
-            for (const auto &kv : reinterpret_borrow<dict>(m_entries_ptr)) {
-                if (pybind11::cast<Type>(kv.second) == value)
-                    return pybind11::str("{}.{}").format(name, kv.first);
-            }
-            return pybind11::str("{}.???").format(name);
-        });
-        def_property_readonly_static("__members__", [m_entries_ptr](object /* self */) {
-            dict m;
-            for (const auto &kv : reinterpret_borrow<dict>(m_entries_ptr))
-                m[kv.first] = kv.second;
-            return m;
-        }, return_value_policy::copy);
-        def("__init__", [](Type& value, Scalar i) { value = (Type)i; });
+        def(init([](Scalar i) { return static_cast<Type>(i); }));
         def("__int__", [](Type value) { return (Scalar) value; });
         #if PY_MAJOR_VERSION < 3
             def("__long__", [](Type value) { return (Scalar) value; });
         #endif
-        def("__eq__", [](const Type &value, Type *value2) { return value2 && value == *value2; });
-        def("__ne__", [](const Type &value, Type *value2) { return !value2 || value != *value2; });
-        if (is_arithmetic) {
-            def("__lt__", [](const Type &value, Type *value2) { return value2 && value < *value2; });
-            def("__gt__", [](const Type &value, Type *value2) { return value2 && value > *value2; });
-            def("__le__", [](const Type &value, Type *value2) { return value2 && value <= *value2; });
-            def("__ge__", [](const Type &value, Type *value2) { return value2 && value >= *value2; });
-        }
-        if (std::is_convertible<Type, Scalar>::value) {
-            // Don't provide comparison with the underlying type if the enum isn't convertible,
-            // i.e. if Type is a scoped enum, mirroring the C++ behaviour.  (NB: we explicitly
-            // convert Type to Scalar below anyway because this needs to compile).
-            def("__eq__", [](const Type &value, Scalar value2) { return (Scalar) value == value2; });
-            def("__ne__", [](const Type &value, Scalar value2) { return (Scalar) value != value2; });
-            if (is_arithmetic) {
-                def("__lt__", [](const Type &value, Scalar value2) { return (Scalar) value < value2; });
-                def("__gt__", [](const Type &value, Scalar value2) { return (Scalar) value > value2; });
-                def("__le__", [](const Type &value, Scalar value2) { return (Scalar) value <= value2; });
-                def("__ge__", [](const Type &value, Scalar value2) { return (Scalar) value >= value2; });
-                def("__invert__", [](const Type &value) { return ~((Scalar) value); });
-                def("__and__", [](const Type &value, Scalar value2) { return (Scalar) value & value2; });
-                def("__or__", [](const Type &value, Scalar value2) { return (Scalar) value | value2; });
-                def("__xor__", [](const Type &value, Scalar value2) { return (Scalar) value ^ value2; });
-                def("__rand__", [](const Type &value, Scalar value2) { return (Scalar) value & value2; });
-                def("__ror__", [](const Type &value, Scalar value2) { return (Scalar) value | value2; });
-                def("__rxor__", [](const Type &value, Scalar value2) { return (Scalar) value ^ value2; });
-                def("__and__", [](const Type &value, const Type &value2) { return (Scalar) value & (Scalar) value2; });
-                def("__or__", [](const Type &value, const Type &value2) { return (Scalar) value | (Scalar) value2; });
-                def("__xor__", [](const Type &value, const Type &value2) { return (Scalar) value ^ (Scalar) value2; });
-            }
-        }
-        def("__hash__", [](const Type &value) { return (Scalar) value; });
-        // Pickling and unpickling -- needed for use with the 'multiprocessing' module
-        def("__getstate__", [](const Type &value) { return pybind11::make_tuple((Scalar) value); });
-        def("__setstate__", [](Type &p, tuple t) { new (&p) Type((Type) t[0].cast<Scalar>()); });
+        #if PY_MAJOR_VERSION > 3 || (PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION >= 8)
+            def("__index__", [](Type value) { return (Scalar) value; });
+        #endif
+
+        cpp_function setstate(
+            [](Type &value, Scalar arg) { value = static_cast<Type>(arg); },
+            is_method(*this));
+        attr("__setstate__") = setstate;
     }
 
     /// Export enumeration entries into the parent scope
     enum_& export_values() {
-        for (const auto &kv : m_entries)
-            m_parent.attr(kv.first) = kv.second;
+        m_base.export_values();
         return *this;
     }
 
     /// Add an enumeration entry
-    enum_& value(char const* name, Type value) {
-        auto v = pybind11::cast(value, return_value_policy::copy);
-        this->attr(name) = v;
-        m_entries[pybind11::str(name)] = v;
+    enum_& value(char const* name, Type value, const char *doc = nullptr) {
+        m_base.value(name, pybind11::cast(value, return_value_policy::copy), doc);
         return *this;
     }
 
 private:
-    dict m_entries;
-    handle m_parent;
+    detail::enum_base m_base;
 };
 
 NAMESPACE_BEGIN(detail)
-template <typename... Args> struct init {
-    template <typename Class, typename... Extra, enable_if_t<!Class::has_alias, int> = 0>
-    static void execute(Class &cl, const Extra&... extra) {
-        using Base = typename Class::type;
-        /// Function which calls a specific C++ in-place constructor
-        cl.def("__init__", [](Base *self_, Args... args) { new (self_) Base(args...); }, extra...);
-    }
-
-    template <typename Class, typename... Extra,
-              enable_if_t<Class::has_alias &&
-                          std::is_constructible<typename Class::type, Args...>::value, int> = 0>
-    static void execute(Class &cl, const Extra&... extra) {
-        using Base = typename Class::type;
-        using Alias = typename Class::type_alias;
-        handle cl_type = cl;
-        cl.def("__init__", [cl_type](handle self_, Args... args) {
-                if (self_.get_type().is(cl_type))
-                    new (self_.cast<Base *>()) Base(args...);
-                else
-                    new (self_.cast<Alias *>()) Alias(args...);
-            }, extra...);
-    }
-
-    template <typename Class, typename... Extra,
-              enable_if_t<Class::has_alias &&
-                          !std::is_constructible<typename Class::type, Args...>::value, int> = 0>
-    static void execute(Class &cl, const Extra&... extra) {
-        init_alias<Args...>::execute(cl, extra...);
-    }
-};
-template <typename... Args> struct init_alias {
-    template <typename Class, typename... Extra,
-              enable_if_t<Class::has_alias && std::is_constructible<typename Class::type_alias, Args...>::value, int> = 0>
-    static void execute(Class &cl, const Extra&... extra) {
-        using Alias = typename Class::type_alias;
-        cl.def("__init__", [](Alias *self_, Args... args) { new (self_) Alias(args...); }, extra...);
-    }
-};
 
 
 inline void keep_alive_impl(handle nurse, handle patient) {
@@ -1357,15 +1630,22 @@ inline void keep_alive_impl(handle nurse, handle patient) {
 }
 
 PYBIND11_NOINLINE inline void keep_alive_impl(size_t Nurse, size_t Patient, function_call &call, handle ret) {
-    keep_alive_impl(
-        Nurse   == 0 ? ret : Nurse   <= call.args.size() ? call.args[Nurse   - 1] : handle(),
-        Patient == 0 ? ret : Patient <= call.args.size() ? call.args[Patient - 1] : handle()
-    );
+    auto get_arg = [&](size_t n) {
+        if (n == 0)
+            return ret;
+        else if (n == 1 && call.init_self)
+            return call.init_self;
+        else if (n <= call.args.size())
+            return call.args[n - 1];
+        return handle();
+    };
+
+    keep_alive_impl(get_arg(Nurse), get_arg(Patient));
 }
 
 inline std::pair<decltype(internals::registered_types_py)::iterator, bool> all_type_info_get_cache(PyTypeObject *type) {
     auto res = get_internals().registered_types_py
-#ifdef z__cpp_lib_unordered_map_try_emplace
+#ifdef __cpp_lib_unordered_map_try_emplace
         .try_emplace(type);
 #else
         .emplace(type, std::vector<detail::type_info *>());
@@ -1391,9 +1671,6 @@ struct iterator_state {
 
 NAMESPACE_END(detail)
 
-template <typename... Args> detail::init<Args...> init() { return detail::init<Args...>(); }
-template <typename... Args> detail::init_alias<Args...> init_alias() { return detail::init_alias<Args...>(); }
-
 /// Makes a python iterator from a first and past-the-end C++ InputIterator.
 template <return_value_policy Policy = return_value_policy::reference_internal,
           typename Iterator,
@@ -1404,7 +1681,7 @@ iterator make_iterator(Iterator first, Sentinel last, Extra &&... extra) {
     typedef detail::iterator_state<Iterator, Sentinel, false, Policy> state;
 
     if (!detail::get_type_info(typeid(state), false)) {
-        class_<state>(handle(), "iterator")
+        class_<state>(handle(), "iterator", pybind11::module_local())
             .def("__iter__", [](state &s) -> state& { return s; })
             .def("__next__", [](state &s) -> ValueType {
                 if (!s.first_or_done)
@@ -1433,7 +1710,7 @@ iterator make_key_iterator(Iterator first, Sentinel last, Extra &&... extra) {
     typedef detail::iterator_state<Iterator, Sentinel, true, Policy> state;
 
     if (!detail::get_type_info(typeid(state), false)) {
-        class_<state>(handle(), "iterator")
+        class_<state>(handle(), "iterator", pybind11::module_local())
             .def("__iter__", [](state &s) -> state& { return s; })
             .def("__next__", [](state &s) -> KeyType {
                 if (!s.first_or_done)
@@ -1466,7 +1743,16 @@ template <return_value_policy Policy = return_value_policy::reference_internal,
 }
 
 template <typename InputType, typename OutputType> void implicitly_convertible() {
+    struct set_flag {
+        bool &flag;
+        set_flag(bool &flag) : flag(flag) { flag = true; }
+        ~set_flag() { flag = false; }
+    };
     auto implicit_caster = [](PyObject *obj, PyTypeObject *type) -> PyObject * {
+        static bool currently_used = false;
+        if (currently_used) // implicit conversions are non-reentrant
+            return nullptr;
+        set_flag flag_helper(currently_used);
         if (!detail::make_caster<InputType>().load(obj, false))
             return nullptr;
         tuple args(1);
@@ -1499,6 +1785,7 @@ void register_exception_translator(ExceptionTranslator&& translator) {
 template <typename type>
 class exception : public object {
 public:
+    exception() = default;
     exception(handle scope, const char *name, PyObject *base = PyExc_Exception) {
         std::string full_name = scope.attr("__name__").cast<std::string>() +
                                 std::string(".") + name;
@@ -1515,6 +1802,14 @@ public:
     }
 };
 
+NAMESPACE_BEGIN(detail)
+// Returns a reference to a function-local static exception object used in the simple
+// register_exception approach below.  (It would be simpler to have the static local variable
+// directly in register_exception, but that makes clang <3.5 segfault - issue #1349).
+template <typename CppException>
+exception<CppException> &get_exception_object() { static exception<CppException> ex; return ex; }
+NAMESPACE_END(detail)
+
 /**
  * Registers a Python exception in `m` of the given `name` and installs an exception translator to
  * translate the C++ exception to the created Python exception using the exceptions what() method.
@@ -1525,13 +1820,15 @@ template <typename CppException>
 exception<CppException> &register_exception(handle scope,
                                             const char *name,
                                             PyObject *base = PyExc_Exception) {
-    static exception<CppException> ex(scope, name, base);
+    auto &ex = detail::get_exception_object<CppException>();
+    if (!ex) ex = exception<CppException>(scope, name, base);
+
     register_exception_translator([](std::exception_ptr p) {
         if (!p) return;
         try {
             std::rethrow_exception(p);
         } catch (const CppException &e) {
-            ex(e.what());
+            detail::get_exception_object<CppException>()(e.what());
         }
     });
     return ex;
@@ -1604,7 +1901,16 @@ class gil_scoped_acquire {
 public:
     PYBIND11_NOINLINE gil_scoped_acquire() {
         auto const &internals = detail::get_internals();
-        tstate = (PyThreadState *) PyThread_get_key_value(internals.tstate);
+        tstate = (PyThreadState *) PYBIND11_TLS_GET_VALUE(internals.tstate);
+
+        if (!tstate) {
+            /* Check if the GIL was acquired using the PyGILState_* API instead (e.g. if
+               calling from a Python thread). Since we use a different key, this ensures
+               we don't create a new thread state and deadlock in PyEval_AcquireThread
+               below. Note we don't save this state with internals.tstate, since we don't
+               create it we would fail to clear it (its reference count should be > 0). */
+            tstate = PyGILState_GetThisThreadState();
+        }
 
         if (!tstate) {
             tstate = PyThreadState_New(internals.istate);
@@ -1613,10 +1919,7 @@ public:
                     pybind11_fail("scoped_acquire: could not create thread state!");
             #endif
             tstate->gilstate_counter = 0;
-            #if PY_MAJOR_VERSION < 3
-                PyThread_delete_key_value(internals.tstate);
-            #endif
-            PyThread_set_key_value(internals.tstate, tstate);
+            PYBIND11_TLS_REPLACE_VALUE(internals.tstate, tstate);
         } else {
             release = detail::get_thread_state_unchecked() != tstate;
         }
@@ -1655,7 +1958,7 @@ public:
             #endif
             PyThreadState_Clear(tstate);
             PyThreadState_DeleteCurrent();
-            PyThread_delete_key_value(detail::get_internals().tstate);
+            PYBIND11_TLS_DELETE_VALUE(detail::get_internals().tstate);
             release = false;
         }
     }
@@ -1680,11 +1983,7 @@ public:
         tstate = PyEval_SaveThread();
         if (disassoc) {
             auto key = internals.tstate;
-            #if PY_MAJOR_VERSION < 3
-                PyThread_delete_key_value(key);
-            #else
-                PyThread_set_key_value(key, nullptr);
-            #endif
+            PYBIND11_TLS_DELETE_VALUE(key);
         }
     }
     ~gil_scoped_release() {
@@ -1693,10 +1992,7 @@ public:
         PyEval_RestoreThread(tstate);
         if (disassoc) {
             auto key = detail::get_internals().tstate;
-            #if PY_MAJOR_VERSION < 3
-                PyThread_delete_key_value(key);
-            #endif
-            PyThread_set_key_value(key, tstate);
+            PYBIND11_TLS_REPLACE_VALUE(key, tstate);
         }
     }
 private:
@@ -1723,9 +2019,12 @@ class gil_scoped_release { };
 #endif
 
 error_already_set::~error_already_set() {
-    if (value) {
+    if (m_type) {
         gil_scoped_acquire gil;
-        clear();
+        error_scope scope;
+        m_type.release().dec_ref();
+        m_value.release().dec_ref();
+        m_trace.release().dec_ref();
     }
 }
 
@@ -1786,6 +2085,14 @@ inline function get_type_overload(const void *this_ptr, const detail::type_info
     return overload;
 }
 
+/** \rst
+  Try to retrieve a python method by the provided name from the instance pointed to by the this_ptr.
+
+  :this_ptr: The pointer to the object the overload should be retrieved for. This should be the first
+                   non-trampoline class encountered in the inheritance chain.
+  :name: The name of the overloaded Python method to retrieve.
+  :return: The Python method by this name from the object or an empty function wrapper.
+ \endrst */
 template <class T> function get_overload(const T *this_ptr, const char *name) {
     auto tinfo = detail::get_type_info(typeid(T));
     return tinfo ? get_type_overload(this_ptr, tinfo, name) : function();
@@ -1804,26 +2111,73 @@ template <class T> function get_overload(const T *this_ptr, const char *name) {
         } \
     }
 
+/** \rst
+    Macro to populate the virtual method in the trampoline class. This macro tries to look up a method named 'fn'
+    from the Python side, deals with the :ref:`gil` and necessary argument conversions to call this method and return
+    the appropriate type. See :ref:`overriding_virtuals` for more information. This macro should be used when the method
+    name in C is not the same as the method name in Python. For example with `__str__`.
+
+    .. code-block:: cpp
+
+      std::string toString() override {
+        PYBIND11_OVERLOAD_NAME(
+            std::string, // Return type (ret_type)
+            Animal,      // Parent class (cname)
+            toString,    // Name of function in C++ (name)
+            "__str__",   // Name of method in Python (fn)
+        );
+      }
+\endrst */
 #define PYBIND11_OVERLOAD_NAME(ret_type, cname, name, fn, ...) \
-    PYBIND11_OVERLOAD_INT(ret_type, cname, name, __VA_ARGS__) \
+    PYBIND11_OVERLOAD_INT(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), name, __VA_ARGS__) \
     return cname::fn(__VA_ARGS__)
 
+/** \rst
+    Macro for pure virtual functions, this function is identical to :c:macro:`PYBIND11_OVERLOAD_NAME`, except that it
+    throws if no overload can be found.
+\endrst */
 #define PYBIND11_OVERLOAD_PURE_NAME(ret_type, cname, name, fn, ...) \
-    PYBIND11_OVERLOAD_INT(ret_type, cname, name, __VA_ARGS__) \
-    pybind11::pybind11_fail("Tried to call pure virtual function \"" #cname "::" name "\"");
-
+    PYBIND11_OVERLOAD_INT(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), name, __VA_ARGS__) \
+    pybind11::pybind11_fail("Tried to call pure virtual function \"" PYBIND11_STRINGIFY(cname) "::" name "\"");
+
+/** \rst
+    Macro to populate the virtual method in the trampoline class. This macro tries to look up the method
+    from the Python side, deals with the :ref:`gil` and necessary argument conversions to call this method and return
+    the appropriate type. This macro should be used if the method name in C and in Python are identical.
+    See :ref:`overriding_virtuals` for more information.
+
+    .. code-block:: cpp
+
+      class PyAnimal : public Animal {
+      public:
+          // Inherit the constructors
+          using Animal::Animal;
+
+          // Trampoline (need one for each virtual function)
+          std::string go(int n_times) override {
+              PYBIND11_OVERLOAD_PURE(
+                  std::string, // Return type (ret_type)
+                  Animal,      // Parent class (cname)
+                  go,          // Name of function in C++ (must match Python name) (fn)
+                  n_times      // Argument(s) (...)
+              );
+          }
+      };
+\endrst */
 #define PYBIND11_OVERLOAD(ret_type, cname, fn, ...) \
-    PYBIND11_OVERLOAD_NAME(ret_type, cname, #fn, fn, __VA_ARGS__)
+    PYBIND11_OVERLOAD_NAME(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), #fn, fn, __VA_ARGS__)
 
+/** \rst
+    Macro for pure virtual functions, this function is identical to :c:macro:`PYBIND11_OVERLOAD`, except that it throws
+    if no overload can be found.
+\endrst */
 #define PYBIND11_OVERLOAD_PURE(ret_type, cname, fn, ...) \
-    PYBIND11_OVERLOAD_PURE_NAME(ret_type, cname, #fn, fn, __VA_ARGS__)
+    PYBIND11_OVERLOAD_PURE_NAME(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), #fn, fn, __VA_ARGS__)
 
-NAMESPACE_END(pybind11)
+NAMESPACE_END(PYBIND11_NAMESPACE)
 
-#if defined(_MSC_VER)
+#if defined(_MSC_VER) && !defined(__INTEL_COMPILER)
 #  pragma warning(pop)
-#elif defined(__INTEL_COMPILER)
-/* Leave ignored warnings on */
 #elif defined(__GNUG__) && !defined(__clang__)
 #  pragma GCC diagnostic pop
 #endif
diff --git a/src/pybind11/include/pybind11/pytypes.h b/src/pybind11/include/pybind11/pytypes.h
index a5aff66..4003d69 100644
--- a/src/pybind11/include/pybind11/pytypes.h
+++ b/src/pybind11/include/pybind11/pytypes.h
@@ -1,5 +1,5 @@
 /*
-    pybind11/typeid.h: Convenience wrapper classes for basic Python types
+    pybind11/pytypes.h: Convenience wrapper classes for basic Python types
 
     Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
 
@@ -9,12 +9,12 @@
 
 #pragma once
 
-#include "common.h"
+#include "detail/common.h"
 #include "buffer_info.h"
 #include <utility>
 #include <type_traits>
 
-NAMESPACE_BEGIN(pybind11)
+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
 /* A few forward declarations */
 class handle; class object;
@@ -114,6 +114,35 @@ public:
     bool is(object_api const& other) const { return derived().ptr() == other.derived().ptr(); }
     /// Equivalent to ``obj is None`` in Python.
     bool is_none() const { return derived().ptr() == Py_None; }
+    /// Equivalent to obj == other in Python
+    bool equal(object_api const &other) const      { return rich_compare(other, Py_EQ); }
+    bool not_equal(object_api const &other) const  { return rich_compare(other, Py_NE); }
+    bool operator<(object_api const &other) const  { return rich_compare(other, Py_LT); }
+    bool operator<=(object_api const &other) const { return rich_compare(other, Py_LE); }
+    bool operator>(object_api const &other) const  { return rich_compare(other, Py_GT); }
+    bool operator>=(object_api const &other) const { return rich_compare(other, Py_GE); }
+
+    object operator-() const;
+    object operator~() const;
+    object operator+(object_api const &other) const;
+    object operator+=(object_api const &other) const;
+    object operator-(object_api const &other) const;
+    object operator-=(object_api const &other) const;
+    object operator*(object_api const &other) const;
+    object operator*=(object_api const &other) const;
+    object operator/(object_api const &other) const;
+    object operator/=(object_api const &other) const;
+    object operator|(object_api const &other) const;
+    object operator|=(object_api const &other) const;
+    object operator&(object_api const &other) const;
+    object operator&=(object_api const &other) const;
+    object operator^(object_api const &other) const;
+    object operator^=(object_api const &other) const;
+    object operator<<(object_api const &other) const;
+    object operator<<=(object_api const &other) const;
+    object operator>>(object_api const &other) const;
+    object operator>>=(object_api const &other) const;
+
     PYBIND11_DEPRECATED("Use py::str(obj) instead")
     pybind11::str str() const;
 
@@ -124,6 +153,9 @@ public:
     int ref_count() const { return static_cast<int>(Py_REFCNT(derived().ptr())); }
     /// Return a handle to the Python type object underlying the instance
     handle get_type() const;
+
+private:
+    bool rich_compare(object_api const &other, int value) const;
 };
 
 NAMESPACE_END(detail)
@@ -279,6 +311,49 @@ template <typename T> T reinterpret_borrow(handle h) { return {h, object::borrow
 \endrst */
 template <typename T> T reinterpret_steal(handle h) { return {h, object::stolen_t{}}; }
 
+NAMESPACE_BEGIN(detail)
+inline std::string error_string();
+NAMESPACE_END(detail)
+
+/// Fetch and hold an error which was already set in Python.  An instance of this is typically
+/// thrown to propagate python-side errors back through C++ which can either be caught manually or
+/// else falls back to the function dispatcher (which then raises the captured error back to
+/// python).
+class error_already_set : public std::runtime_error {
+public:
+    /// Constructs a new exception from the current Python error indicator, if any.  The current
+    /// Python error indicator will be cleared.
+    error_already_set() : std::runtime_error(detail::error_string()) {
+        PyErr_Fetch(&m_type.ptr(), &m_value.ptr(), &m_trace.ptr());
+    }
+
+    error_already_set(const error_already_set &) = default;
+    error_already_set(error_already_set &&) = default;
+
+    inline ~error_already_set();
+
+    /// Give the currently-held error back to Python, if any.  If there is currently a Python error
+    /// already set it is cleared first.  After this call, the current object no longer stores the
+    /// error variables (but the `.what()` string is still available).
+    void restore() { PyErr_Restore(m_type.release().ptr(), m_value.release().ptr(), m_trace.release().ptr()); }
+
+    // Does nothing; provided for backwards compatibility.
+    PYBIND11_DEPRECATED("Use of error_already_set.clear() is deprecated")
+    void clear() {}
+
+    /// Check if the currently trapped error type matches the given Python exception class (or a
+    /// subclass thereof).  May also be passed a tuple to search for any exception class matches in
+    /// the given tuple.
+    bool matches(handle exc) const { return PyErr_GivenExceptionMatches(m_type.ptr(), exc.ptr()); }
+
+    const object& type() const { return m_type; }
+    const object& value() const { return m_value; }
+    const object& trace() const { return m_trace; }
+
+private:
+    object m_type, m_value, m_trace;
+};
+
 /** \defgroup python_builtins _
     Unless stated otherwise, the following C++ functions behave the same
     as their Python counterparts.
@@ -317,6 +392,14 @@ inline bool hasattr(handle obj, const char *name) {
     return PyObject_HasAttrString(obj.ptr(), name) == 1;
 }
 
+inline void delattr(handle obj, handle name) {
+    if (PyObject_DelAttr(obj.ptr(), name.ptr()) != 0) { throw error_already_set(); }
+}
+
+inline void delattr(handle obj, const char *name) {
+    if (PyObject_DelAttrString(obj.ptr(), name) != 0) { throw error_already_set(); }
+}
+
 inline object getattr(handle obj, handle name) {
     PyObject *result = PyObject_GetAttr(obj.ptr(), name.ptr());
     if (!result) { throw error_already_set(); }
@@ -354,6 +437,13 @@ inline void setattr(handle obj, handle name, handle value) {
 inline void setattr(handle obj, const char *name, handle value) {
     if (PyObject_SetAttrString(obj.ptr(), name, value.ptr()) != 0) { throw error_already_set(); }
 }
+
+inline ssize_t hash(handle obj) {
+    auto h = PyObject_Hash(obj.ptr());
+    if (h == -1) { throw error_already_set(); }
+    return h;
+}
+
 /// @} python_builtins
 
 NAMESPACE_BEGIN(detail)
@@ -381,15 +471,14 @@ object object_or_cast(T &&o);
 // Match a PyObject*, which we want to convert directly to handle via its converting constructor
 inline handle object_or_cast(PyObject *ptr) { return ptr; }
 
-
 template <typename Policy>
 class accessor : public object_api<accessor<Policy>> {
     using key_type = typename Policy::key_type;
 
 public:
     accessor(handle obj, key_type key) : obj(obj), key(std::move(key)) { }
-    accessor(const accessor &a) = default;
-    accessor(accessor &&a) = default;
+    accessor(const accessor &) = default;
+    accessor(accessor &&) = default;
 
     // accessor overload required to override default assignment operator (templates are not allowed
     // to replace default compiler-generated assignments).
@@ -619,7 +708,7 @@ protected:
 
 private:
     handle obj;
-    PyObject *key, *value;
+    PyObject *key = nullptr, *value = nullptr;
     ssize_t pos = -1;
 };
 NAMESPACE_END(iterator_policies)
@@ -647,9 +736,14 @@ inline bool PyIterable_Check(PyObject *obj) {
 }
 
 inline bool PyNone_Check(PyObject *o) { return o == Py_None; }
+#if PY_MAJOR_VERSION >= 3
+inline bool PyEllipsis_Check(PyObject *o) { return o == Py_Ellipsis; }
+#endif
 
 inline bool PyUnicode_Check_Permissive(PyObject *o) { return PyUnicode_Check(o) || PYBIND11_BYTES_CHECK(o); }
 
+inline bool PyStaticMethod_Check(PyObject *o) { return o->ob_type == &PyStaticMethod_Type; }
+
 class kwargs_proxy : public handle {
 public:
     explicit kwargs_proxy(handle h) : handle(h) { }
@@ -695,7 +789,14 @@ NAMESPACE_END(detail)
 #define PYBIND11_OBJECT_CVT(Name, Parent, CheckFun, ConvertFun) \
     PYBIND11_OBJECT_COMMON(Name, Parent, CheckFun) \
     /* This is deliberately not 'explicit' to allow implicit conversion from object: */ \
-    Name(const object &o) : Parent(ConvertFun(o.ptr()), stolen_t{}) { if (!m_ptr) throw error_already_set(); }
+    Name(const object &o) \
+    : Parent(check_(o) ? o.inc_ref().ptr() : ConvertFun(o.ptr()), stolen_t{}) \
+    { if (!m_ptr) throw error_already_set(); } \
+    Name(object &&o) \
+    : Parent(check_(o) ? o.release().ptr() : ConvertFun(o.ptr()), stolen_t{}) \
+    { if (!m_ptr) throw error_already_set(); } \
+    template <typename Policy_> \
+    Name(const ::pybind11::detail::accessor<Policy_> &a) : Name(object(a)) { }
 
 #define PYBIND11_OBJECT(Name, Parent, CheckFun) \
     PYBIND11_OBJECT_COMMON(Name, Parent, CheckFun) \
@@ -914,6 +1015,14 @@ public:
     none() : object(Py_None, borrowed_t{}) { }
 };
 
+#if PY_MAJOR_VERSION >= 3
+class ellipsis : public object {
+public:
+    PYBIND11_OBJECT(ellipsis, object, detail::PyEllipsis_Check)
+    ellipsis() : object(Py_Ellipsis, borrowed_t{}) { }
+};
+#endif
+
 class bool_ : public object {
 public:
     PYBIND11_OBJECT_CVT(bool_, object, PyBool_Check, raw_bool)
@@ -931,6 +1040,28 @@ private:
     }
 };
 
+NAMESPACE_BEGIN(detail)
+// Converts a value to the given unsigned type.  If an error occurs, you get back (Unsigned) -1;
+// otherwise you get back the unsigned long or unsigned long long value cast to (Unsigned).
+// (The distinction is critically important when casting a returned -1 error value to some other
+// unsigned type: (A)-1 != (B)-1 when A and B are unsigned types of different sizes).
+template <typename Unsigned>
+Unsigned as_unsigned(PyObject *o) {
+    if (sizeof(Unsigned) <= sizeof(unsigned long)
+#if PY_VERSION_HEX < 0x03000000
+            || PyInt_Check(o)
+#endif
+    ) {
+        unsigned long v = PyLong_AsUnsignedLong(o);
+        return v == (unsigned long) -1 && PyErr_Occurred() ? (Unsigned) -1 : (Unsigned) v;
+    }
+    else {
+        unsigned long long v = PyLong_AsUnsignedLongLong(o);
+        return v == (unsigned long long) -1 && PyErr_Occurred() ? (Unsigned) -1 : (Unsigned) v;
+    }
+}
+NAMESPACE_END(detail)
+
 class int_ : public object {
 public:
     PYBIND11_OBJECT_CVT(int_, object, PYBIND11_LONG_CHECK, PyNumber_Long)
@@ -956,17 +1087,11 @@ public:
     template <typename T,
               detail::enable_if_t<std::is_integral<T>::value, int> = 0>
     operator T() const {
-        if (sizeof(T) <= sizeof(long)) {
-            if (std::is_signed<T>::value)
-                return (T) PyLong_AsLong(m_ptr);
-            else
-                return (T) PyLong_AsUnsignedLong(m_ptr);
-        } else {
-            if (std::is_signed<T>::value)
-                return (T) PYBIND11_LONG_AS_LONGLONG(m_ptr);
-            else
-                return (T) PYBIND11_LONG_AS_UNSIGNED_LONGLONG(m_ptr);
-        }
+        return std::is_unsigned<T>::value
+            ? detail::as_unsigned<T>(m_ptr)
+            : sizeof(T) <= sizeof(long)
+              ? (T) PyLong_AsLong(m_ptr)
+              : (T) PYBIND11_LONG_AS_LONGLONG(m_ptr);
     }
 };
 
@@ -1008,6 +1133,13 @@ public:
                                     (ssize_t *) stop, (ssize_t *) step,
                                     (ssize_t *) slicelength) == 0;
     }
+    bool compute(ssize_t length, ssize_t *start, ssize_t *stop, ssize_t *step,
+      ssize_t *slicelength) const {
+      return PySlice_GetIndicesEx((PYBIND11_SLICE_OBJECT *) m_ptr,
+          length, start,
+          stop, step,
+          slicelength) == 0;
+    }
 };
 
 class capsule : public object {
@@ -1070,7 +1202,9 @@ public:
         if (!m_ptr) pybind11_fail("Could not allocate tuple object!");
     }
     size_t size() const { return (size_t) PyTuple_Size(m_ptr); }
+    bool empty() const { return size() == 0; }
     detail::tuple_accessor operator[](size_t index) const { return {*this, index}; }
+    detail::item_accessor operator[](handle h) const { return object::operator[](h); }
     detail::tuple_iterator begin() const { return {*this, 0}; }
     detail::tuple_iterator end() const { return {*this, PyTuple_GET_SIZE(m_ptr)}; }
 };
@@ -1088,11 +1222,13 @@ public:
     explicit dict(Args &&...args) : dict(collector(std::forward<Args>(args)...).kwargs()) { }
 
     size_t size() const { return (size_t) PyDict_Size(m_ptr); }
+    bool empty() const { return size() == 0; }
     detail::dict_iterator begin() const { return {*this, 0}; }
     detail::dict_iterator end() const { return {}; }
     void clear() const { PyDict_Clear(ptr()); }
-    bool contains(handle key) const { return PyDict_Contains(ptr(), key.ptr()) == 1; }
-    bool contains(const char *key) const { return PyDict_Contains(ptr(), pybind11::str(key).ptr()) == 1; }
+    template <typename T> bool contains(T &&key) const {
+        return PyDict_Contains(m_ptr, detail::object_or_cast(std::forward<T>(key)).ptr()) == 1;
+    }
 
 private:
     /// Call the `dict` Python type -- always returns a new reference
@@ -1107,7 +1243,9 @@ class sequence : public object {
 public:
     PYBIND11_OBJECT_DEFAULT(sequence, object, PySequence_Check)
     size_t size() const { return (size_t) PySequence_Size(m_ptr); }
+    bool empty() const { return size() == 0; }
     detail::sequence_accessor operator[](size_t index) const { return {*this, index}; }
+    detail::item_accessor operator[](handle h) const { return object::operator[](h); }
     detail::sequence_iterator begin() const { return {*this, 0}; }
     detail::sequence_iterator end() const { return {*this, PySequence_Size(m_ptr)}; }
 };
@@ -1119,12 +1257,18 @@ public:
         if (!m_ptr) pybind11_fail("Could not allocate list object!");
     }
     size_t size() const { return (size_t) PyList_Size(m_ptr); }
+    bool empty() const { return size() == 0; }
     detail::list_accessor operator[](size_t index) const { return {*this, index}; }
+    detail::item_accessor operator[](handle h) const { return object::operator[](h); }
     detail::list_iterator begin() const { return {*this, 0}; }
     detail::list_iterator end() const { return {*this, PyList_GET_SIZE(m_ptr)}; }
     template <typename T> void append(T &&val) const {
         PyList_Append(m_ptr, detail::object_or_cast(std::forward<T>(val)).ptr());
     }
+    template <typename T> void insert(size_t index, T &&val) const {
+        PyList_Insert(m_ptr, static_cast<ssize_t>(index),
+            detail::object_or_cast(std::forward<T>(val)).ptr());
+    }
 };
 
 class args : public tuple { PYBIND11_OBJECT_DEFAULT(args, tuple, PyTuple_Check) };
@@ -1137,10 +1281,14 @@ public:
         if (!m_ptr) pybind11_fail("Could not allocate set object!");
     }
     size_t size() const { return (size_t) PySet_Size(m_ptr); }
+    bool empty() const { return size() == 0; }
     template <typename T> bool add(T &&val) const {
         return PySet_Add(m_ptr, detail::object_or_cast(std::forward<T>(val)).ptr()) == 0;
     }
     void clear() const { PySet_Clear(m_ptr); }
+    template <typename T> bool contains(T &&val) const {
+        return PySet_Contains(m_ptr, detail::object_or_cast(std::forward<T>(val)).ptr()) == 1;
+    }
 };
 
 class function : public object {
@@ -1155,11 +1303,16 @@ public:
     bool is_cpp_function() const { return (bool) cpp_function(); }
 };
 
+class staticmethod : public object {
+public:
+    PYBIND11_OBJECT_CVT(staticmethod, object, detail::PyStaticMethod_Check, PyStaticMethod_New)
+};
+
 class buffer : public object {
 public:
     PYBIND11_OBJECT_DEFAULT(buffer, object, PyObject_CheckBuffer)
 
-    buffer_info request(bool writable = false) {
+    buffer_info request(bool writable = false) const {
         int flags = PyBUF_STRIDES | PyBUF_FORMAT;
         if (writable) flags |= PyBUF_WRITABLE;
         Py_buffer *view = new Py_buffer();
@@ -1192,7 +1345,7 @@ public:
         buf.strides = py_strides.data();
         buf.shape = py_shape.data();
         buf.suboffsets = nullptr;
-        buf.readonly = false;
+        buf.readonly = info.readonly;
         buf.internal = nullptr;
 
         m_ptr = PyMemoryView_FromBuffer(&buf);
@@ -1213,6 +1366,21 @@ inline size_t len(handle h) {
     return (size_t) result;
 }
 
+inline size_t len_hint(handle h) {
+#if PY_VERSION_HEX >= 0x03040000
+    ssize_t result = PyObject_LengthHint(h.ptr(), 0);
+#else
+    ssize_t result = PyObject_Length(h.ptr());
+#endif
+    if (result < 0) {
+        // Sometimes a length can't be determined at all (eg generators)
+        // In which case simply return 0
+        PyErr_Clear();
+        return 0;
+    }
+    return (size_t) result;
+}
+
 inline str repr(handle h) {
     PyObject *str_value = PyObject_Repr(h.ptr());
     if (!str_value) throw error_already_set();
@@ -1262,5 +1430,55 @@ str_attr_accessor object_api<D>::doc() const { return attr("__doc__"); }
 template <typename D>
 handle object_api<D>::get_type() const { return (PyObject *) Py_TYPE(derived().ptr()); }
 
+template <typename D>
+bool object_api<D>::rich_compare(object_api const &other, int value) const {
+    int rv = PyObject_RichCompareBool(derived().ptr(), other.derived().ptr(), value);
+    if (rv == -1)
+        throw error_already_set();
+    return rv == 1;
+}
+
+#define PYBIND11_MATH_OPERATOR_UNARY(op, fn)                                   \
+    template <typename D> object object_api<D>::op() const {                   \
+        object result = reinterpret_steal<object>(fn(derived().ptr()));        \
+        if (!result.ptr())                                                     \
+            throw error_already_set();                                         \
+        return result;                                                         \
+    }
+
+#define PYBIND11_MATH_OPERATOR_BINARY(op, fn)                                  \
+    template <typename D>                                                      \
+    object object_api<D>::op(object_api const &other) const {                  \
+        object result = reinterpret_steal<object>(                             \
+            fn(derived().ptr(), other.derived().ptr()));                       \
+        if (!result.ptr())                                                     \
+            throw error_already_set();                                         \
+        return result;                                                         \
+    }
+
+PYBIND11_MATH_OPERATOR_UNARY (operator~,   PyNumber_Invert)
+PYBIND11_MATH_OPERATOR_UNARY (operator-,   PyNumber_Negative)
+PYBIND11_MATH_OPERATOR_BINARY(operator+,   PyNumber_Add)
+PYBIND11_MATH_OPERATOR_BINARY(operator+=,  PyNumber_InPlaceAdd)
+PYBIND11_MATH_OPERATOR_BINARY(operator-,   PyNumber_Subtract)
+PYBIND11_MATH_OPERATOR_BINARY(operator-=,  PyNumber_InPlaceSubtract)
+PYBIND11_MATH_OPERATOR_BINARY(operator*,   PyNumber_Multiply)
+PYBIND11_MATH_OPERATOR_BINARY(operator*=,  PyNumber_InPlaceMultiply)
+PYBIND11_MATH_OPERATOR_BINARY(operator/,   PyNumber_TrueDivide)
+PYBIND11_MATH_OPERATOR_BINARY(operator/=,  PyNumber_InPlaceTrueDivide)
+PYBIND11_MATH_OPERATOR_BINARY(operator|,   PyNumber_Or)
+PYBIND11_MATH_OPERATOR_BINARY(operator|=,  PyNumber_InPlaceOr)
+PYBIND11_MATH_OPERATOR_BINARY(operator&,   PyNumber_And)
+PYBIND11_MATH_OPERATOR_BINARY(operator&=,  PyNumber_InPlaceAnd)
+PYBIND11_MATH_OPERATOR_BINARY(operator^,   PyNumber_Xor)
+PYBIND11_MATH_OPERATOR_BINARY(operator^=,  PyNumber_InPlaceXor)
+PYBIND11_MATH_OPERATOR_BINARY(operator<<,  PyNumber_Lshift)
+PYBIND11_MATH_OPERATOR_BINARY(operator<<=, PyNumber_InPlaceLshift)
+PYBIND11_MATH_OPERATOR_BINARY(operator>>,  PyNumber_Rshift)
+PYBIND11_MATH_OPERATOR_BINARY(operator>>=, PyNumber_InPlaceRshift)
+
+#undef PYBIND11_MATH_OPERATOR_UNARY
+#undef PYBIND11_MATH_OPERATOR_BINARY
+
 NAMESPACE_END(detail)
-NAMESPACE_END(pybind11)
+NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/src/pybind11/include/pybind11/stl.h b/src/pybind11/include/pybind11/stl.h
index 535eb49..32f8d29 100644
--- a/src/pybind11/include/pybind11/stl.h
+++ b/src/pybind11/include/pybind11/stl.h
@@ -16,6 +16,7 @@
 #include <unordered_map>
 #include <iostream>
 #include <list>
+#include <deque>
 #include <valarray>
 
 #if defined(_MSC_VER)
@@ -30,7 +31,8 @@
 #    define PYBIND11_HAS_OPTIONAL 1
 #  endif
 // std::experimental::optional (but not allowed in c++11 mode)
-#  if defined(PYBIND11_CPP14) && __has_include(<experimental/optional>)
+#  if defined(PYBIND11_CPP14) && (__has_include(<experimental/optional>) && \
+                                 !__has_include(<optional>))
 #    include <experimental/optional>
 #    define PYBIND11_HAS_EXP_OPTIONAL 1
 #  endif
@@ -46,9 +48,22 @@
 #  define PYBIND11_HAS_VARIANT 1
 #endif
 
-NAMESPACE_BEGIN(pybind11)
+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
+/// Extracts an const lvalue reference or rvalue reference for U based on the type of T (e.g. for
+/// forwarding a container element).  Typically used indirect via forwarded_type(), below.
+template <typename T, typename U>
+using forwarded_type = conditional_t<
+    std::is_lvalue_reference<T>::value, remove_reference_t<U> &, remove_reference_t<U> &&>;
+
+/// Forwards a value U as rvalue or lvalue according to whether T is rvalue or lvalue; typically
+/// used for forwarding a container's elements.
+template <typename T, typename U>
+forwarded_type<T, U> forward_like(U &&u) {
+    return std::forward<detail::forwarded_type<T, U>>(std::forward<U>(u));
+}
+
 template <typename Type, typename Key> struct set_caster {
     using type = Type;
     using key_conv = make_caster<Key>;
@@ -67,17 +82,20 @@ template <typename Type, typename Key> struct set_caster {
         return true;
     }
 
-    static handle cast(const type &src, return_value_policy policy, handle parent) {
+    template <typename T>
+    static handle cast(T &&src, return_value_policy policy, handle parent) {
+        if (!std::is_lvalue_reference<T>::value)
+            policy = return_value_policy_override<Key>::policy(policy);
         pybind11::set s;
-        for (auto const &value: src) {
-            auto value_ = reinterpret_steal<object>(key_conv::cast(value, policy, parent));
+        for (auto &&value : src) {
+            auto value_ = reinterpret_steal<object>(key_conv::cast(forward_like<T>(value), policy, parent));
             if (!value_ || !s.add(value_))
                 return handle();
         }
         return s.release();
     }
 
-    PYBIND11_TYPE_CASTER(type, _("Set[") + key_conv::name() + _("]"));
+    PYBIND11_TYPE_CASTER(type, _("Set[") + key_conv::name + _("]"));
 };
 
 template <typename Type, typename Key, typename Value> struct map_caster {
@@ -100,11 +118,18 @@ template <typename Type, typename Key, typename Value> struct map_caster {
         return true;
     }
 
-    static handle cast(const Type &src, return_value_policy policy, handle parent) {
+    template <typename T>
+    static handle cast(T &&src, return_value_policy policy, handle parent) {
         dict d;
-        for (auto const &kv: src) {
-            auto key = reinterpret_steal<object>(key_conv::cast(kv.first, policy, parent));
-            auto value = reinterpret_steal<object>(value_conv::cast(kv.second, policy, parent));
+        return_value_policy policy_key = policy;
+        return_value_policy policy_value = policy;
+        if (!std::is_lvalue_reference<T>::value) {
+            policy_key = return_value_policy_override<Key>::policy(policy_key);
+            policy_value = return_value_policy_override<Value>::policy(policy_value);
+        }
+        for (auto &&kv : src) {
+            auto key = reinterpret_steal<object>(key_conv::cast(forward_like<T>(kv.first), policy_key, parent));
+            auto value = reinterpret_steal<object>(value_conv::cast(forward_like<T>(kv.second), policy_value, parent));
             if (!key || !value)
                 return handle();
             d[key] = value;
@@ -112,14 +137,14 @@ template <typename Type, typename Key, typename Value> struct map_caster {
         return d.release();
     }
 
-    PYBIND11_TYPE_CASTER(Type, _("Dict[") + key_conv::name() + _(", ") + value_conv::name() + _("]"));
+    PYBIND11_TYPE_CASTER(Type, _("Dict[") + key_conv::name + _(", ") + value_conv::name + _("]"));
 };
 
 template <typename Type, typename Value> struct list_caster {
     using value_conv = make_caster<Value>;
 
     bool load(handle src, bool convert) {
-        if (!isinstance<sequence>(src))
+        if (!isinstance<sequence>(src) || isinstance<str>(src))
             return false;
         auto s = reinterpret_borrow<sequence>(src);
         value.clear();
@@ -140,11 +165,14 @@ private:
     void reserve_maybe(sequence, void *) { }
 
 public:
-    static handle cast(const Type &src, return_value_policy policy, handle parent) {
+    template <typename T>
+    static handle cast(T &&src, return_value_policy policy, handle parent) {
+        if (!std::is_lvalue_reference<T>::value)
+            policy = return_value_policy_override<Value>::policy(policy);
         list l(src.size());
         size_t index = 0;
-        for (auto const &value: src) {
-            auto value_ = reinterpret_steal<object>(value_conv::cast(value, policy, parent));
+        for (auto &&value : src) {
+            auto value_ = reinterpret_steal<object>(value_conv::cast(forward_like<T>(value), policy, parent));
             if (!value_)
                 return handle();
             PyList_SET_ITEM(l.ptr(), (ssize_t) index++, value_.release().ptr()); // steals a reference
@@ -152,12 +180,15 @@ public:
         return l.release();
     }
 
-    PYBIND11_TYPE_CASTER(Type, _("List[") + value_conv::name() + _("]"));
+    PYBIND11_TYPE_CASTER(Type, _("List[") + value_conv::name + _("]"));
 };
 
 template <typename Type, typename Alloc> struct type_caster<std::vector<Type, Alloc>>
  : list_caster<std::vector<Type, Alloc>, Type> { };
 
+template <typename Type, typename Alloc> struct type_caster<std::deque<Type, Alloc>>
+ : list_caster<std::deque<Type, Alloc>, Type> { };
+
 template <typename Type, typename Alloc> struct type_caster<std::list<Type, Alloc>>
  : list_caster<std::list<Type, Alloc>, Type> { };
 
@@ -178,9 +209,9 @@ private:
 
 public:
     bool load(handle src, bool convert) {
-        if (!isinstance<list>(src))
+        if (!isinstance<sequence>(src))
             return false;
-        auto l = reinterpret_borrow<list>(src);
+        auto l = reinterpret_borrow<sequence>(src);
         if (!require_size(l.size()))
             return false;
         size_t ctr = 0;
@@ -193,11 +224,12 @@ public:
         return true;
     }
 
-    static handle cast(const ArrayType &src, return_value_policy policy, handle parent) {
+    template <typename T>
+    static handle cast(T &&src, return_value_policy policy, handle parent) {
         list l(src.size());
         size_t index = 0;
-        for (auto const &value: src) {
-            auto value_ = reinterpret_steal<object>(value_conv::cast(value, policy, parent));
+        for (auto &&value : src) {
+            auto value_ = reinterpret_steal<object>(value_conv::cast(forward_like<T>(value), policy, parent));
             if (!value_)
                 return handle();
             PyList_SET_ITEM(l.ptr(), (ssize_t) index++, value_.release().ptr()); // steals a reference
@@ -205,7 +237,7 @@ public:
         return l.release();
     }
 
-    PYBIND11_TYPE_CASTER(ArrayType, _("List[") + value_conv::name() + _<Resizable>(_(""), _("[") + _<Size>() + _("]")) + _("]"));
+    PYBIND11_TYPE_CASTER(ArrayType, _("List[") + value_conv::name + _<Resizable>(_(""), _("[") + _<Size>() + _("]")) + _("]"));
 };
 
 template <typename Type, size_t Size> struct type_caster<std::array<Type, Size>>
@@ -230,10 +262,12 @@ template <typename Key, typename Value, typename Hash, typename Equal, typename
 template<typename T> struct optional_caster {
     using value_conv = make_caster<typename T::value_type>;
 
-    static handle cast(const T& src, return_value_policy policy, handle parent) {
+    template <typename T_>
+    static handle cast(T_ &&src, return_value_policy policy, handle parent) {
         if (!src)
             return none().inc_ref();
-        return value_conv::cast(*src, policy, parent);
+        policy = return_value_policy_override<typename T::value_type>::policy(policy);
+        return value_conv::cast(*std::forward<T_>(src), policy, parent);
     }
 
     bool load(handle src, bool convert) {
@@ -250,7 +284,7 @@ template<typename T> struct optional_caster {
         return true;
     }
 
-    PYBIND11_TYPE_CASTER(T, _("Optional[") + value_conv::name() + _("]"));
+    PYBIND11_TYPE_CASTER(T, _("Optional[") + value_conv::name + _("]"));
 };
 
 #if PYBIND11_HAS_OPTIONAL
@@ -274,8 +308,10 @@ struct variant_caster_visitor {
     return_value_policy policy;
     handle parent;
 
+    using result_type = handle; // required by boost::variant in C++11
+
     template <typename T>
-    handle operator()(T &&src) const {
+    result_type operator()(T &&src) const {
         return make_caster<T>::cast(std::forward<T>(src), policy, parent);
     }
 };
@@ -328,13 +364,14 @@ struct variant_caster<V<Ts...>> {
     }
 
     using Type = V<Ts...>;
-    PYBIND11_TYPE_CASTER(Type, _("Union[") + detail::concat(make_caster<Ts>::name()...) + _("]"));
+    PYBIND11_TYPE_CASTER(Type, _("Union[") + detail::concat(make_caster<Ts>::name...) + _("]"));
 };
 
 #if PYBIND11_HAS_VARIANT
 template <typename... Ts>
 struct type_caster<std::variant<Ts...>> : variant_caster<std::variant<Ts...>> { };
 #endif
+
 NAMESPACE_END(detail)
 
 inline std::ostream &operator<<(std::ostream &os, const handle &obj) {
@@ -342,7 +379,7 @@ inline std::ostream &operator<<(std::ostream &os, const handle &obj) {
     return os;
 }
 
-NAMESPACE_END(pybind11)
+NAMESPACE_END(PYBIND11_NAMESPACE)
 
 #if defined(_MSC_VER)
 #pragma warning(pop)
diff --git a/src/pybind11/include/pybind11/stl_bind.h b/src/pybind11/include/pybind11/stl_bind.h
index 9411747..da233ec 100644
--- a/src/pybind11/include/pybind11/stl_bind.h
+++ b/src/pybind11/include/pybind11/stl_bind.h
@@ -9,13 +9,13 @@
 
 #pragma once
 
-#include "common.h"
+#include "detail/common.h"
 #include "operators.h"
 
 #include <algorithm>
 #include <sstream>
 
-NAMESPACE_BEGIN(pybind11)
+NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
 /* SFINAE helper class used by 'is_comparable */
@@ -66,10 +66,7 @@ template <typename, typename, typename... Args> void vector_if_insertion_operato
 template <typename, typename, typename... Args> void vector_modifiers(const Args &...) { }
 
 template<typename Vector, typename Class_>
-void vector_if_copy_constructible(enable_if_t<
-    std::is_copy_constructible<Vector>::value &&
-    std::is_copy_constructible<typename Vector::value_type>::value, Class_> &cl) {
-
+void vector_if_copy_constructible(enable_if_t<is_copy_constructible<Vector>::value, Class_> &cl) {
     cl.def(init<const Vector &>(), "Copy constructor");
 }
 
@@ -113,27 +110,38 @@ void vector_if_equal_operator(enable_if_t<is_comparable<Vector>::value, Class_>
 // (Technically, some of these (pop and __delitem__) don't actually require copyability, but it seems
 // silly to allow deletion but not insertion, so include them here too.)
 template <typename Vector, typename Class_>
-void vector_modifiers(enable_if_t<std::is_copy_constructible<typename Vector::value_type>::value, Class_> &cl) {
+void vector_modifiers(enable_if_t<is_copy_constructible<typename Vector::value_type>::value, Class_> &cl) {
     using T = typename Vector::value_type;
     using SizeType = typename Vector::size_type;
     using DiffType = typename Vector::difference_type;
 
+    auto wrap_i = [](DiffType i, SizeType n) {
+        if (i < 0)
+            i += n;
+        if (i < 0 || (SizeType)i >= n)
+            throw index_error();
+        return i;
+    };
+
     cl.def("append",
            [](Vector &v, const T &value) { v.push_back(value); },
            arg("x"),
            "Add an item to the end of the list");
 
-    cl.def("__init__", [](Vector &v, iterable it) {
-        new (&v) Vector();
-        try {
-            v.reserve(len(it));
-            for (handle h : it)
-               v.push_back(h.cast<T>());
-        } catch (...) {
-            v.~Vector();
-            throw;
-        }
-    });
+    cl.def(init([](iterable it) {
+        auto v = std::unique_ptr<Vector>(new Vector());
+        v->reserve(len_hint(it));
+        for (handle h : it)
+           v->push_back(h.cast<T>());
+        return v.release();
+    }));
+
+    cl.def("clear",
+        [](Vector &v) {
+            v.clear();
+        },
+        "Clear the contents"
+    );
 
     cl.def("extend",
        [](Vector &v, const Vector &src) {
@@ -143,11 +151,36 @@ void vector_modifiers(enable_if_t<std::is_copy_constructible<typename Vector::va
        "Extend the list by appending all the items in the given list"
     );
 
+    cl.def("extend",
+       [](Vector &v, iterable it) {
+           const size_t old_size = v.size();
+           v.reserve(old_size + len_hint(it));
+           try {
+               for (handle h : it) {
+                   v.push_back(h.cast<T>());
+               }
+           } catch (const cast_error &) {
+               v.erase(v.begin() + static_cast<typename Vector::difference_type>(old_size), v.end());
+               try {
+                   v.shrink_to_fit();
+               } catch (const std::exception &) {
+                   // Do nothing
+               }
+               throw;
+           }
+       },
+       arg("L"),
+       "Extend the list by appending all the items in the given list"
+    );
+
     cl.def("insert",
-        [](Vector &v, SizeType i, const T &x) {
-            if (i > v.size())
+        [](Vector &v, DiffType i, const T &x) {
+            // Can't use wrap_i; i == v.size() is OK
+            if (i < 0)
+                i += v.size();
+            if (i < 0 || (SizeType)i > v.size())
                 throw index_error();
-            v.insert(v.begin() + (DiffType) i, x);
+            v.insert(v.begin() + i, x);
         },
         arg("i") , arg("x"),
         "Insert an item at a given position."
@@ -165,11 +198,10 @@ void vector_modifiers(enable_if_t<std::is_copy_constructible<typename Vector::va
     );
 
     cl.def("pop",
-        [](Vector &v, SizeType i) {
-            if (i >= v.size())
-                throw index_error();
-            T t = v[i];
-            v.erase(v.begin() + (DiffType) i);
+        [wrap_i](Vector &v, DiffType i) {
+            i = wrap_i(i, v.size());
+            T t = v[(SizeType) i];
+            v.erase(v.begin() + i);
             return t;
         },
         arg("i"),
@@ -177,10 +209,9 @@ void vector_modifiers(enable_if_t<std::is_copy_constructible<typename Vector::va
     );
 
     cl.def("__setitem__",
-        [](Vector &v, SizeType i, const T &t) {
-            if (i >= v.size())
-                throw index_error();
-            v[i] = t;
+        [wrap_i](Vector &v, DiffType i, const T &t) {
+            i = wrap_i(i, v.size());
+            v[(SizeType)i] = t;
         }
     );
 
@@ -223,10 +254,9 @@ void vector_modifiers(enable_if_t<std::is_copy_constructible<typename Vector::va
     );
 
     cl.def("__delitem__",
-        [](Vector &v, SizeType i) {
-            if (i >= v.size())
-                throw index_error();
-            v.erase(v.begin() + DiffType(i));
+        [wrap_i](Vector &v, DiffType i) {
+            i = wrap_i(i, v.size());
+            v.erase(v.begin() + i);
         },
         "Delete the list elements at index ``i``"
     );
@@ -262,13 +292,21 @@ template <typename Vector, typename Class_>
 void vector_accessor(enable_if_t<!vector_needs_copy<Vector>::value, Class_> &cl) {
     using T = typename Vector::value_type;
     using SizeType = typename Vector::size_type;
+    using DiffType = typename Vector::difference_type;
     using ItType   = typename Vector::iterator;
 
+    auto wrap_i = [](DiffType i, SizeType n) {
+        if (i < 0)
+            i += n;
+        if (i < 0 || (SizeType)i >= n)
+            throw index_error();
+        return i;
+    };
+
     cl.def("__getitem__",
-        [](Vector &v, SizeType i) -> T & {
-            if (i >= v.size())
-                throw index_error();
-            return v[i];
+        [wrap_i](Vector &v, DiffType i) -> T & {
+            i = wrap_i(i, v.size());
+            return v[(SizeType)i];
         },
         return_value_policy::reference_internal // ref + keepalive
     );
@@ -288,12 +326,15 @@ template <typename Vector, typename Class_>
 void vector_accessor(enable_if_t<vector_needs_copy<Vector>::value, Class_> &cl) {
     using T = typename Vector::value_type;
     using SizeType = typename Vector::size_type;
+    using DiffType = typename Vector::difference_type;
     using ItType   = typename Vector::iterator;
     cl.def("__getitem__",
-        [](const Vector &v, SizeType i) -> T {
-            if (i >= v.size())
+        [](const Vector &v, DiffType i) -> T {
+            if (i < 0 && (i += v.size()) < 0)
                 throw index_error();
-            return v[i];
+            if ((SizeType)i >= v.size())
+                throw index_error();
+            return v[(SizeType)i];
         }
     );
 
@@ -349,20 +390,22 @@ vector_buffer(Class_& cl) {
         return buffer_info(v.data(), static_cast<ssize_t>(sizeof(T)), format_descriptor<T>::format(), 1, {v.size()}, {sizeof(T)});
     });
 
-    cl.def("__init__", [](Vector& vec, buffer buf) {
+    cl.def(init([](buffer buf) {
         auto info = buf.request();
         if (info.ndim != 1 || info.strides[0] % static_cast<ssize_t>(sizeof(T)))
             throw type_error("Only valid 1D buffers can be copied to a vector");
         if (!detail::compare_buffer_info<T>::compare(info) || (ssize_t) sizeof(T) != info.itemsize)
             throw type_error("Format mismatch (Python: " + info.format + " C++: " + format_descriptor<T>::format() + ")");
-        new (&vec) Vector();
-        vec.reserve((size_t) info.shape[0]);
+
+        auto vec = std::unique_ptr<Vector>(new Vector());
+        vec->reserve((size_t) info.shape[0]);
         T *p = static_cast<T*>(info.ptr);
         ssize_t step = info.strides[0] / static_cast<ssize_t>(sizeof(T));
         T *end = p + info.shape[0] * step;
         for (; p != end; p += step)
-            vec.push_back(*p);
-    });
+            vec->push_back(*p);
+        return vec.release();
+    }));
 
     return;
 }
@@ -376,10 +419,16 @@ NAMESPACE_END(detail)
 // std::vector
 //
 template <typename Vector, typename holder_type = std::unique_ptr<Vector>, typename... Args>
-class_<Vector, holder_type> bind_vector(module &m, std::string const &name, Args&&... args) {
+class_<Vector, holder_type> bind_vector(handle scope, std::string const &name, Args&&... args) {
     using Class_ = class_<Vector, holder_type>;
 
-    Class_ cl(m, name.c_str(), std::forward<Args>(args)...);
+    // If the value_type is unregistered (e.g. a converting type) or is itself registered
+    // module-local then make the vector binding module-local as well:
+    using vtype = typename Vector::value_type;
+    auto vtype_info = detail::get_type_info(typeid(vtype));
+    bool local = !vtype_info || vtype_info->module_local;
+
+    Class_ cl(scope, name.c_str(), pybind11::module_local(local), std::forward<Args>(args)...);
 
     // Declare the buffer interface if a buffer_protocol() is passed in
     detail::vector_buffer<Vector, Class_, Args...>(cl);
@@ -470,7 +519,7 @@ template <typename, typename, typename... Args> void map_assignment(const Args &
 
 // Map assignment when copy-assignable: just copy the value
 template <typename Map, typename Class_>
-void map_assignment(enable_if_t<std::is_copy_assignable<typename Map::mapped_type>::value, Class_> &cl) {
+void map_assignment(enable_if_t<is_copy_assignable<typename Map::mapped_type>::value, Class_> &cl) {
     using KeyType = typename Map::key_type;
     using MappedType = typename Map::mapped_type;
 
@@ -486,8 +535,8 @@ void map_assignment(enable_if_t<std::is_copy_assignable<typename Map::mapped_typ
 // Not copy-assignable, but still copy-constructible: we can update the value by erasing and reinserting
 template<typename Map, typename Class_>
 void map_assignment(enable_if_t<
-        !std::is_copy_assignable<typename Map::mapped_type>::value &&
-        std::is_copy_constructible<typename Map::mapped_type>::value,
+        !is_copy_assignable<typename Map::mapped_type>::value &&
+        is_copy_constructible<typename Map::mapped_type>::value,
         Class_> &cl) {
     using KeyType = typename Map::key_type;
     using MappedType = typename Map::mapped_type;
@@ -531,12 +580,22 @@ template <typename Map, typename Class_> auto map_if_insertion_operator(Class_ &
 NAMESPACE_END(detail)
 
 template <typename Map, typename holder_type = std::unique_ptr<Map>, typename... Args>
-class_<Map, holder_type> bind_map(module &m, const std::string &name, Args&&... args) {
+class_<Map, holder_type> bind_map(handle scope, const std::string &name, Args&&... args) {
     using KeyType = typename Map::key_type;
     using MappedType = typename Map::mapped_type;
     using Class_ = class_<Map, holder_type>;
 
-    Class_ cl(m, name.c_str(), std::forward<Args>(args)...);
+    // If either type is a non-module-local bound type then make the map binding non-local as well;
+    // otherwise (e.g. both types are either module-local or converting) the map will be
+    // module-local.
+    auto tinfo = detail::get_type_info(typeid(MappedType));
+    bool local = !tinfo || tinfo->module_local;
+    if (local) {
+        tinfo = detail::get_type_info(typeid(KeyType));
+        local = !tinfo || tinfo->module_local;
+    }
+
+    Class_ cl(scope, name.c_str(), pybind11::module_local(local), std::forward<Args>(args)...);
 
     cl.def(init<>());
 
@@ -568,6 +627,15 @@ class_<Map, holder_type> bind_map(module &m, const std::string &name, Args&&...
         return_value_policy::reference_internal // ref + keepalive
     );
 
+    cl.def("__contains__",
+        [](Map &m, const KeyType &k) -> bool {
+            auto it = m.find(k);
+            if (it == m.end())
+              return false;
+           return true;
+        }
+    );
+
     // Assignment provided only if the type is copyable
     detail::map_assignment<Map, Class_>(cl);
 
@@ -576,7 +644,7 @@ class_<Map, holder_type> bind_map(module &m, const std::string &name, Args&&...
                auto it = m.find(k);
                if (it == m.end())
                    throw key_error();
-               return m.erase(it);
+               m.erase(it);
            }
     );
 
@@ -585,4 +653,4 @@ class_<Map, holder_type> bind_map(module &m, const std::string &name, Args&&...
     return cl;
 }
 
-NAMESPACE_END(pybind11)
+NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/src/pybind11/pybind11/__init__.py b/src/pybind11/pybind11/__init__.py
index a765692..4b1de3e 100644
--- a/src/pybind11/pybind11/__init__.py
+++ b/src/pybind11/pybind11/__init__.py
@@ -1,11 +1,12 @@
 from ._version import version_info, __version__  # noqa: F401 imported but unused
 
 
-def get_include(*args, **kwargs):
+def get_include(user=False):
     import os
-    try:
-        from pip import locations
-        return os.path.dirname(
-            locations.distutils_scheme('pybind11', *args, **kwargs)['headers'])
-    except ImportError:
-        return 'include'
+    d = os.path.dirname(__file__)
+    if os.path.exists(os.path.join(d, "include")):
+        # Package is installed
+        return os.path.join(d, "include")
+    else:
+        # Package is from a source directory
+        return os.path.join(os.path.dirname(d), "include")
diff --git a/src/pybind11/pybind11/__main__.py b/src/pybind11/pybind11/__main__.py
index c3832d7..89b263a 100644
--- a/src/pybind11/pybind11/__main__.py
+++ b/src/pybind11/pybind11/__main__.py
@@ -8,12 +8,17 @@ from . import get_include
 
 
 def print_includes():
-    dirs = [sysconfig.get_path('include')]
-    if sysconfig.get_path('platinclude') not in dirs:
-        dirs.append(sysconfig.get_path('platinclude'))
-    if get_include() not in dirs:
-        dirs.append(get_include())
-    print(' '.join('-I' + d for d in dirs))
+    dirs = [sysconfig.get_path('include'),
+            sysconfig.get_path('platinclude'),
+            get_include()]
+
+    # Make unique but preserve order
+    unique_dirs = []
+    for d in dirs:
+        if d not in unique_dirs:
+            unique_dirs.append(d)
+
+    print(' '.join('-I' + d for d in unique_dirs))
 
 
 def main():
diff --git a/src/pybind11/pybind11/_version.py b/src/pybind11/pybind11/_version.py
index 73445e7..8d5aa5c 100644
--- a/src/pybind11/pybind11/_version.py
+++ b/src/pybind11/pybind11/_version.py
@@ -1,2 +1,2 @@
-version_info = (2, 2, 'dev0')
+version_info = (2, 5, 0)
 __version__ = '.'.join(map(str, version_info))
diff --git a/src/pybind11/setup.cfg b/src/pybind11/setup.cfg
index 9e5e88d..002f38d 100644
--- a/src/pybind11/setup.cfg
+++ b/src/pybind11/setup.cfg
@@ -6,5 +6,7 @@ max-line-length = 99
 show_source = True
 exclude = .git, __pycache__, build, dist, docs, tools, venv
 ignore =
-    # required for pretty matrix formating: multiple spaces after `,` and `[`
-    E201, E241
+    # required for pretty matrix formatting: multiple spaces after `,` and `[`
+    E201, E241, W504,
+    # camelcase 'cPickle' imported as lowercase 'pickle'
+    N813
diff --git a/src/pybind11/setup.py b/src/pybind11/setup.py
index f1eac9c..473ea1e 100644
--- a/src/pybind11/setup.py
+++ b/src/pybind11/setup.py
@@ -3,36 +3,70 @@
 # Setup script for PyPI; use CMakeFile.txt to build extension modules
 
 from setuptools import setup
+from distutils.command.install_headers import install_headers
+from distutils.command.build_py import build_py
 from pybind11 import __version__
 import os
 
+package_data = [
+    'include/pybind11/detail/class.h',
+    'include/pybind11/detail/common.h',
+    'include/pybind11/detail/descr.h',
+    'include/pybind11/detail/init.h',
+    'include/pybind11/detail/internals.h',
+    'include/pybind11/detail/typeid.h',
+    'include/pybind11/attr.h',
+    'include/pybind11/buffer_info.h',
+    'include/pybind11/cast.h',
+    'include/pybind11/chrono.h',
+    'include/pybind11/common.h',
+    'include/pybind11/complex.h',
+    'include/pybind11/eigen.h',
+    'include/pybind11/embed.h',
+    'include/pybind11/eval.h',
+    'include/pybind11/functional.h',
+    'include/pybind11/iostream.h',
+    'include/pybind11/numpy.h',
+    'include/pybind11/operators.h',
+    'include/pybind11/options.h',
+    'include/pybind11/pybind11.h',
+    'include/pybind11/pytypes.h',
+    'include/pybind11/stl.h',
+    'include/pybind11/stl_bind.h',
+]
+
 # Prevent installation of pybind11 headers by setting
 # PYBIND11_USE_CMAKE.
 if os.environ.get('PYBIND11_USE_CMAKE'):
     headers = []
 else:
-    headers = [
-        'include/pybind11/attr.h',
-        'include/pybind11/buffer_info.h',
-        'include/pybind11/cast.h',
-        'include/pybind11/chrono.h',
-        'include/pybind11/class_support.h',
-        'include/pybind11/common.h',
-        'include/pybind11/complex.h',
-        'include/pybind11/descr.h',
-        'include/pybind11/eigen.h',
-        'include/pybind11/embed.h',
-        'include/pybind11/eval.h',
-        'include/pybind11/functional.h',
-        'include/pybind11/numpy.h',
-        'include/pybind11/operators.h',
-        'include/pybind11/options.h',
-        'include/pybind11/pybind11.h',
-        'include/pybind11/pytypes.h',
-        'include/pybind11/stl.h',
-        'include/pybind11/stl_bind.h',
-        'include/pybind11/typeid.h'
-    ]
+    headers = package_data
+
+
+class InstallHeaders(install_headers):
+    """Use custom header installer because the default one flattens subdirectories"""
+    def run(self):
+        if not self.distribution.headers:
+            return
+
+        for header in self.distribution.headers:
+            subdir = os.path.dirname(os.path.relpath(header, 'include/pybind11'))
+            install_dir = os.path.join(self.install_dir, subdir)
+            self.mkpath(install_dir)
+
+            (out, _) = self.copy_file(header, install_dir)
+            self.outfiles.append(out)
+
+
+# Install the headers inside the package as well
+class BuildPy(build_py):
+    def build_package_data(self):
+        build_py.build_package_data(self)
+        for header in package_data:
+            target = os.path.join(self.build_lib, 'pybind11', header)
+            self.mkpath(os.path.dirname(target))
+            self.copy_file(header, target, preserve_mode=False)
+
 
 setup(
     name='pybind11',
@@ -40,11 +74,13 @@ setup(
     description='Seamless operability between C++11 and Python',
     author='Wenzel Jakob',
     author_email='wenzel.jakob@epfl.ch',
-    url='https://github.com/wjakob/pybind11',
-    download_url='https://github.com/wjakob/pybind11/tarball/v' + __version__,
+    url='https://github.com/pybind/pybind11',
+    download_url='https://github.com/pybind/pybind11/tarball/v' + __version__,
     packages=['pybind11'],
     license='BSD',
     headers=headers,
+    zip_safe=False,
+    cmdclass=dict(install_headers=InstallHeaders, build_py=BuildPy),
     classifiers=[
         'Development Status :: 5 - Production/Stable',
         'Intended Audience :: Developers',
diff --git a/src/pybind11/tests/CMakeLists.txt b/src/pybind11/tests/CMakeLists.txt
index 945753f..765c47a 100644
--- a/src/pybind11/tests/CMakeLists.txt
+++ b/src/pybind11/tests/CMakeLists.txt
@@ -12,7 +12,7 @@ option(PYBIND11_WERROR  "Report all warnings as errors"  OFF)
 if (CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
     # We're being loaded directly, i.e. not via add_subdirectory, so make this
     # work as its own project and load the pybind11Config to get the tools we need
-    project(pybind11_tests)
+    project(pybind11_tests CXX)
 
     find_package(pybind11 REQUIRED CONFIG)
 endif()
@@ -26,6 +26,7 @@ endif()
 
 # Full set of test files (you can override these; see below)
 set(PYBIND11_TEST_FILES
+  test_async.cpp
   test_buffers.cpp
   test_builtin_casters.cpp
   test_call_policies.cpp
@@ -39,7 +40,11 @@ set(PYBIND11_TEST_FILES
   test_enum.cpp
   test_eval.cpp
   test_exceptions.cpp
+  test_factory_constructors.cpp
+  test_gil_scoped.cpp
+  test_iostream.cpp
   test_kwargs_and_defaults.cpp
+  test_local_bindings.cpp
   test_methods_and_attributes.cpp
   test_modules.cpp
   test_multiple_inheritance.cpp
@@ -54,6 +59,8 @@ set(PYBIND11_TEST_FILES
   test_smart_ptr.cpp
   test_stl.cpp
   test_stl_binders.cpp
+  test_tagbased_polymorphic.cpp
+  test_union.cpp
   test_virtual_functions.cpp
 )
 
@@ -65,8 +72,29 @@ if (PYBIND11_TEST_OVERRIDE)
   set(PYBIND11_TEST_FILES ${PYBIND11_TEST_OVERRIDE})
 endif()
 
+# Skip test_async for Python < 3.5
+list(FIND PYBIND11_TEST_FILES test_async.cpp PYBIND11_TEST_FILES_ASYNC_I)
+if((PYBIND11_TEST_FILES_ASYNC_I GREATER -1) AND ("${PYTHON_VERSION_MAJOR}.${PYTHON_VERSION_MINOR}" VERSION_LESS 3.5))
+  message(STATUS "Skipping test_async because Python version ${PYTHON_VERSION_MAJOR}.${PYTHON_VERSION_MINOR} < 3.5")
+  list(REMOVE_AT PYBIND11_TEST_FILES ${PYBIND11_TEST_FILES_ASYNC_I})
+endif()
+
 string(REPLACE ".cpp" ".py" PYBIND11_PYTEST_FILES "${PYBIND11_TEST_FILES}")
 
+# Contains the set of test files that require pybind11_cross_module_tests to be
+# built; if none of these are built (i.e. because TEST_OVERRIDE is used and
+# doesn't include them) the second module doesn't get built.
+set(PYBIND11_CROSS_MODULE_TESTS
+  test_exceptions.py
+  test_local_bindings.py
+  test_stl.py
+  test_stl_binders.py
+)
+
+set(PYBIND11_CROSS_MODULE_GIL_TESTS
+  test_gil_scoped.py
+)
+
 # Check if Eigen is available; if not, remove from PYBIND11_TEST_FILES (but
 # keep it in PYBIND11_PYTEST_FILES, so that we get the "eigen is not installed"
 # skip message).
@@ -76,7 +104,7 @@ if(PYBIND11_TEST_FILES_EIGEN_I GREATER -1)
   # Eigen 3.3.1+ exports a cmake 3.0+ target for handling dependency requirements, but also
   # produces a fatal error if loaded from a pre-3.0 cmake.
   if (NOT CMAKE_VERSION VERSION_LESS 3.0)
-    find_package(Eigen3 QUIET CONFIG)
+    find_package(Eigen3 3.2.7 QUIET CONFIG)
     if (EIGEN3_FOUND)
       if (EIGEN3_VERSION_STRING AND NOT EIGEN3_VERSION_STRING VERSION_LESS 3.3.1)
         set(PYBIND11_EIGEN_VIA_TARGET 1)
@@ -86,7 +114,7 @@ if(PYBIND11_TEST_FILES_EIGEN_I GREATER -1)
   if (NOT EIGEN3_FOUND)
     # Couldn't load via target, so fall back to allowing module mode finding, which will pick up
     # tools/FindEigen3.cmake
-    find_package(Eigen3 QUIET)
+    find_package(Eigen3 3.2.7 QUIET)
   endif()
 
   if(EIGEN3_FOUND)
@@ -103,53 +131,83 @@ if(PYBIND11_TEST_FILES_EIGEN_I GREATER -1)
   endif()
 endif()
 
+# Optional dependency for some tests (boost::variant is only supported with version >= 1.56)
+find_package(Boost 1.56)
+
 # Compile with compiler warnings turned on
 function(pybind11_enable_warnings target_name)
   if(MSVC)
     target_compile_options(${target_name} PRIVATE /W4)
-  else()
-      target_compile_options(${target_name} PRIVATE -Wall -Wextra -Wconversion -Wcast-qual)
+  elseif(CMAKE_CXX_COMPILER_ID MATCHES "(GNU|Intel|Clang)")
+      target_compile_options(${target_name} PRIVATE -Wall -Wextra -Wconversion -Wcast-qual -Wdeprecated)
   endif()
 
   if(PYBIND11_WERROR)
     if(MSVC)
       target_compile_options(${target_name} PRIVATE /WX)
-    else()
+    elseif(CMAKE_CXX_COMPILER_ID MATCHES "(GNU|Intel|Clang)")
       target_compile_options(${target_name} PRIVATE -Werror)
     endif()
   endif()
 endfunction()
 
+set(test_targets pybind11_tests)
 
-# Create the binding library
-pybind11_add_module(pybind11_tests THIN_LTO pybind11_tests.cpp
-  ${PYBIND11_TEST_FILES} ${PYBIND11_HEADERS})
+# Build pybind11_cross_module_tests if any test_whatever.py are being built that require it
+foreach(t ${PYBIND11_CROSS_MODULE_TESTS})
+  list(FIND PYBIND11_PYTEST_FILES ${t} i)
+  if (i GREATER -1)
+    list(APPEND test_targets pybind11_cross_module_tests)
+    break()
+  endif()
+endforeach()
 
-pybind11_enable_warnings(pybind11_tests)
+foreach(t ${PYBIND11_CROSS_MODULE_GIL_TESTS})
+  list(FIND PYBIND11_PYTEST_FILES ${t} i)
+  if (i GREATER -1)
+    list(APPEND test_targets cross_module_gil_utils)
+    break()
+  endif()
+endforeach()
 
-if(MSVC)
-  target_compile_options(pybind11_tests PRIVATE /utf-8)
-endif()
+set(testdir ${CMAKE_CURRENT_SOURCE_DIR})
+foreach(target ${test_targets})
+  set(test_files ${PYBIND11_TEST_FILES})
+  if(NOT target STREQUAL "pybind11_tests")
+    set(test_files "")
+  endif()
 
-if(EIGEN3_FOUND)
-  if (PYBIND11_EIGEN_VIA_TARGET)
-    target_link_libraries(pybind11_tests PRIVATE Eigen3::Eigen)
-  else()
-    target_include_directories(pybind11_tests PRIVATE ${EIGEN3_INCLUDE_DIR})
+  # Create the binding library
+  pybind11_add_module(${target} THIN_LTO ${target}.cpp ${test_files} ${PYBIND11_HEADERS})
+  pybind11_enable_warnings(${target})
+
+  if(MSVC)
+    target_compile_options(${target} PRIVATE /utf-8)
   endif()
-  target_compile_definitions(pybind11_tests PRIVATE -DPYBIND11_TEST_EIGEN)
-endif()
 
-set(testdir ${CMAKE_CURRENT_SOURCE_DIR})
+  if(EIGEN3_FOUND)
+    if (PYBIND11_EIGEN_VIA_TARGET)
+      target_link_libraries(${target} PRIVATE Eigen3::Eigen)
+    else()
+      target_include_directories(${target} PRIVATE ${EIGEN3_INCLUDE_DIR})
+    endif()
+    target_compile_definitions(${target} PRIVATE -DPYBIND11_TEST_EIGEN)
+  endif()
 
-# Always write the output file directly into the 'tests' directory (even on MSVC)
-if(NOT CMAKE_LIBRARY_OUTPUT_DIRECTORY)
-  set_target_properties(pybind11_tests PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${testdir})
-  foreach(config ${CMAKE_CONFIGURATION_TYPES})
-    string(TOUPPER ${config} config)
-    set_target_properties(pybind11_tests PROPERTIES LIBRARY_OUTPUT_DIRECTORY_${config} ${testdir})
-  endforeach()
-endif()
+  if(Boost_FOUND)
+    target_include_directories(${target} PRIVATE ${Boost_INCLUDE_DIRS})
+    target_compile_definitions(${target} PRIVATE -DPYBIND11_TEST_BOOST)
+  endif()
+
+  # Always write the output file directly into the 'tests' directory (even on MSVC)
+  if(NOT CMAKE_LIBRARY_OUTPUT_DIRECTORY)
+    set_target_properties(${target} PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${testdir})
+    foreach(config ${CMAKE_CONFIGURATION_TYPES})
+      string(TOUPPER ${config} config)
+      set_target_properties(${target} PROPERTIES LIBRARY_OUTPUT_DIRECTORY_${config} ${testdir})
+    endforeach()
+  endif()
+endforeach()
 
 # Make sure pytest is found or produce a fatal error
 if(NOT PYBIND11_PYTEST_FOUND)
@@ -173,7 +231,7 @@ endif()
 
 # A single command to compile and run the tests
 add_custom_target(pytest COMMAND ${PYTHON_EXECUTABLE} -m pytest ${PYBIND11_PYTEST_FILES}
-                  DEPENDS pybind11_tests WORKING_DIRECTORY ${testdir} ${PYBIND11_USES_TERMINAL})
+                  DEPENDS ${test_targets} WORKING_DIRECTORY ${testdir} ${PYBIND11_USES_TERMINAL})
 
 if(PYBIND11_TEST_OVERRIDE)
   add_custom_command(TARGET pytest POST_BUILD
@@ -189,7 +247,7 @@ if (NOT PROJECT_NAME STREQUAL "pybind11")
   return()
 endif()
 
-# Add a post-build comment to show the .so size and, if a previous size, compare it:
+# Add a post-build comment to show the primary test suite .so size and, if a previous size, compare it:
 add_custom_command(TARGET pybind11_tests POST_BUILD
   COMMAND ${PYTHON_EXECUTABLE} ${PROJECT_SOURCE_DIR}/tools/libsize.py
   $<TARGET_FILE:pybind11_tests> ${CMAKE_CURRENT_BINARY_DIR}/sosize-$<TARGET_FILE_NAME:pybind11_tests>.txt)
diff --git a/src/pybind11/tests/conftest.py b/src/pybind11/tests/conftest.py
index 5b08004..57f681c 100644
--- a/src/pybind11/tests/conftest.py
+++ b/src/pybind11/tests/conftest.py
@@ -17,6 +17,11 @@ _unicode_marker = re.compile(r'u(\'[^\']*\')')
 _long_marker = re.compile(r'([0-9])L')
 _hexadecimal = re.compile(r'0x[0-9a-fA-F]+')
 
+# test_async.py requires support for async and await
+collect_ignore = []
+if sys.version_info[:2] < (3, 5):
+    collect_ignore.append("test_async.py")
+
 
 def _strip_and_dedent(s):
     """For triple-quote strings"""
@@ -75,7 +80,7 @@ class Capture(object):
         self.capfd.readouterr()
         return self
 
-    def __exit__(self, *_):
+    def __exit__(self, *args):
         self.out, self.err = self.capfd.readouterr()
 
     def __eq__(self, other):
@@ -185,7 +190,7 @@ def gc_collect():
     gc.collect()
 
 
-def pytest_namespace():
+def pytest_configure():
     """Add import suppression and test requirements to `pytest` namespace"""
     try:
         import numpy as np
@@ -196,23 +201,23 @@ def pytest_namespace():
     except ImportError:
         scipy = None
     try:
-        from pybind11_tests import have_eigen
+        from pybind11_tests.eigen import have_eigen
     except ImportError:
         have_eigen = False
     pypy = platform.python_implementation() == "PyPy"
 
     skipif = pytest.mark.skipif
-    return {
-        'suppress': suppress,
-        'requires_numpy': skipif(not np, reason="numpy is not installed"),
-        'requires_scipy': skipif(not np, reason="scipy is not installed"),
-        'requires_eigen_and_numpy': skipif(not have_eigen or not np,
-                                           reason="eigen and/or numpy are not installed"),
-        'requires_eigen_and_scipy': skipif(not have_eigen or not scipy,
-                                           reason="eigen and/or scipy are not installed"),
-        'unsupported_on_pypy': skipif(pypy, reason="unsupported on PyPy"),
-        'gc_collect': gc_collect
-    }
+    pytest.suppress = suppress
+    pytest.requires_numpy = skipif(not np, reason="numpy is not installed")
+    pytest.requires_scipy = skipif(not np, reason="scipy is not installed")
+    pytest.requires_eigen_and_numpy = skipif(not have_eigen or not np,
+                                             reason="eigen and/or numpy are not installed")
+    pytest.requires_eigen_and_scipy = skipif(
+        not have_eigen or not scipy, reason="eigen and/or scipy are not installed")
+    pytest.unsupported_on_pypy = skipif(pypy, reason="unsupported on PyPy")
+    pytest.unsupported_on_py2 = skipif(sys.version_info.major < 3,
+                                       reason="unsupported on Python 2.x")
+    pytest.gc_collect = gc_collect
 
 
 def _test_import_pybind11():
diff --git a/src/pybind11/tests/constructor_stats.h b/src/pybind11/tests/constructor_stats.h
index babded0..431e5ac 100644
--- a/src/pybind11/tests/constructor_stats.h
+++ b/src/pybind11/tests/constructor_stats.h
@@ -180,7 +180,7 @@ public:
                 }
             }
         }
-        catch (std::out_of_range) {}
+        catch (const std::out_of_range&) {}
         if (!t1) throw std::runtime_error("Unknown class passed to ConstructorStats::get()");
         auto &cs1 = get(*t1);
         // If we have both a t1 and t2 match, one is probably the trampoline class; return whichever
diff --git a/src/pybind11/tests/cross_module_gil_utils.cpp b/src/pybind11/tests/cross_module_gil_utils.cpp
new file mode 100644
index 0000000..07db9f6
--- /dev/null
+++ b/src/pybind11/tests/cross_module_gil_utils.cpp
@@ -0,0 +1,73 @@
+/*
+    tests/cross_module_gil_utils.cpp -- tools for acquiring GIL from a different module
+
+    Copyright (c) 2019 Google LLC
+
+    All rights reserved. Use of this source code is governed by a
+    BSD-style license that can be found in the LICENSE file.
+*/
+#include <pybind11/pybind11.h>
+#include <cstdint>
+
+// This file mimics a DSO that makes pybind11 calls but does not define a
+// PYBIND11_MODULE. The purpose is to test that such a DSO can create a
+// py::gil_scoped_acquire when the running thread is in a GIL-released state.
+//
+// Note that we define a Python module here for convenience, but in general
+// this need not be the case. The typical scenario would be a DSO that implements
+// shared logic used internally by multiple pybind11 modules.
+
+namespace {
+
+namespace py = pybind11;
+void gil_acquire() { py::gil_scoped_acquire gil; }
+
+constexpr char kModuleName[] = "cross_module_gil_utils";
+
+#if PY_MAJOR_VERSION >= 3
+struct PyModuleDef moduledef = {
+    PyModuleDef_HEAD_INIT,
+    kModuleName,
+    NULL,
+    0,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL
+};
+#else
+PyMethodDef module_methods[] = {
+    {NULL, NULL, 0, NULL}
+};
+#endif
+
+}  // namespace
+
+extern "C" PYBIND11_EXPORT
+#if PY_MAJOR_VERSION >= 3
+PyObject* PyInit_cross_module_gil_utils()
+#else
+void initcross_module_gil_utils()
+#endif
+{
+
+    PyObject* m =
+#if PY_MAJOR_VERSION >= 3
+        PyModule_Create(&moduledef);
+#else
+        Py_InitModule(kModuleName, module_methods);
+#endif
+
+    if (m != NULL) {
+        static_assert(
+            sizeof(&gil_acquire) == sizeof(void*),
+            "Function pointer must have the same size as void*");
+        PyModule_AddObject(m, "gil_acquire_funcaddr",
+                           PyLong_FromVoidPtr(reinterpret_cast<void*>(&gil_acquire)));
+    }
+
+#if PY_MAJOR_VERSION >= 3
+    return m;
+#endif
+}
diff --git a/src/pybind11/tests/local_bindings.h b/src/pybind11/tests/local_bindings.h
new file mode 100644
index 0000000..b6afb80
--- /dev/null
+++ b/src/pybind11/tests/local_bindings.h
@@ -0,0 +1,64 @@
+#pragma once
+#include "pybind11_tests.h"
+
+/// Simple class used to test py::local:
+template <int> class LocalBase {
+public:
+    LocalBase(int i) : i(i) { }
+    int i = -1;
+};
+
+/// Registered with py::module_local in both main and secondary modules:
+using LocalType = LocalBase<0>;
+/// Registered without py::module_local in both modules:
+using NonLocalType = LocalBase<1>;
+/// A second non-local type (for stl_bind tests):
+using NonLocal2 = LocalBase<2>;
+/// Tests within-module, different-compilation-unit local definition conflict:
+using LocalExternal = LocalBase<3>;
+/// Mixed: registered local first, then global
+using MixedLocalGlobal = LocalBase<4>;
+/// Mixed: global first, then local
+using MixedGlobalLocal = LocalBase<5>;
+
+/// Registered with py::module_local only in the secondary module:
+using ExternalType1 = LocalBase<6>;
+using ExternalType2 = LocalBase<7>;
+
+using LocalVec = std::vector<LocalType>;
+using LocalVec2 = std::vector<NonLocal2>;
+using LocalMap = std::unordered_map<std::string, LocalType>;
+using NonLocalVec = std::vector<NonLocalType>;
+using NonLocalVec2 = std::vector<NonLocal2>;
+using NonLocalMap = std::unordered_map<std::string, NonLocalType>;
+using NonLocalMap2 = std::unordered_map<std::string, uint8_t>;
+
+PYBIND11_MAKE_OPAQUE(LocalVec);
+PYBIND11_MAKE_OPAQUE(LocalVec2);
+PYBIND11_MAKE_OPAQUE(LocalMap);
+PYBIND11_MAKE_OPAQUE(NonLocalVec);
+//PYBIND11_MAKE_OPAQUE(NonLocalVec2); // same type as LocalVec2
+PYBIND11_MAKE_OPAQUE(NonLocalMap);
+PYBIND11_MAKE_OPAQUE(NonLocalMap2);
+
+
+// Simple bindings (used with the above):
+template <typename T, int Adjust = 0, typename... Args>
+py::class_<T> bind_local(Args && ...args) {
+    return py::class_<T>(std::forward<Args>(args)...)
+        .def(py::init<int>())
+        .def("get", [](T &i) { return i.i + Adjust; });
+};
+
+// Simulate a foreign library base class (to match the example in the docs):
+namespace pets {
+class Pet {
+public:
+    Pet(std::string name) : name_(name) {}
+    std::string name_;
+    const std::string &name() { return name_; }
+};
+}
+
+struct MixGL { int i; MixGL(int i) : i{i} {} };
+struct MixGL2 { int i; MixGL2(int i) : i{i} {} };
diff --git a/src/pybind11/tests/pybind11_cross_module_tests.cpp b/src/pybind11/tests/pybind11_cross_module_tests.cpp
new file mode 100644
index 0000000..f705e31
--- /dev/null
+++ b/src/pybind11/tests/pybind11_cross_module_tests.cpp
@@ -0,0 +1,123 @@
+/*
+    tests/pybind11_cross_module_tests.cpp -- contains tests that require multiple modules
+
+    Copyright (c) 2017 Jason Rhinelander <jason@imaginary.ca>
+
+    All rights reserved. Use of this source code is governed by a
+    BSD-style license that can be found in the LICENSE file.
+*/
+
+#include "pybind11_tests.h"
+#include "local_bindings.h"
+#include <pybind11/stl_bind.h>
+#include <numeric>
+
+PYBIND11_MODULE(pybind11_cross_module_tests, m) {
+    m.doc() = "pybind11 cross-module test module";
+
+    // test_local_bindings.py tests:
+    //
+    // Definitions here are tested by importing both this module and the
+    // relevant pybind11_tests submodule from a test_whatever.py
+
+    // test_load_external
+    bind_local<ExternalType1>(m, "ExternalType1", py::module_local());
+    bind_local<ExternalType2>(m, "ExternalType2", py::module_local());
+
+    // test_exceptions.py
+    m.def("raise_runtime_error", []() { PyErr_SetString(PyExc_RuntimeError, "My runtime error"); throw py::error_already_set(); });
+    m.def("raise_value_error", []() { PyErr_SetString(PyExc_ValueError, "My value error"); throw py::error_already_set(); });
+    m.def("throw_pybind_value_error", []() { throw py::value_error("pybind11 value error"); });
+    m.def("throw_pybind_type_error", []() { throw py::type_error("pybind11 type error"); });
+    m.def("throw_stop_iteration", []() { throw py::stop_iteration(); });
+
+    // test_local_bindings.py
+    // Local to both:
+    bind_local<LocalType, 1>(m, "LocalType", py::module_local())
+        .def("get2", [](LocalType &t) { return t.i + 2; })
+        ;
+
+    // Can only be called with our python type:
+    m.def("local_value", [](LocalType &l) { return l.i; });
+
+    // test_nonlocal_failure
+    // This registration will fail (global registration when LocalFail is already registered
+    // globally in the main test module):
+    m.def("register_nonlocal", [m]() {
+        bind_local<NonLocalType, 0>(m, "NonLocalType");
+    });
+
+    // test_stl_bind_local
+    // stl_bind.h binders defaults to py::module_local if the types are local or converting:
+    py::bind_vector<LocalVec>(m, "LocalVec");
+    py::bind_map<LocalMap>(m, "LocalMap");
+
+    // test_stl_bind_global
+    // and global if the type (or one of the types, for the map) is global (so these will fail,
+    // assuming pybind11_tests is already loaded):
+    m.def("register_nonlocal_vec", [m]() {
+        py::bind_vector<NonLocalVec>(m, "NonLocalVec");
+    });
+    m.def("register_nonlocal_map", [m]() {
+        py::bind_map<NonLocalMap>(m, "NonLocalMap");
+    });
+    // The default can, however, be overridden to global using `py::module_local()` or
+    // `py::module_local(false)`.
+    // Explicitly made local:
+    py::bind_vector<NonLocalVec2>(m, "NonLocalVec2", py::module_local());
+    // Explicitly made global (and so will fail to bind):
+    m.def("register_nonlocal_map2", [m]() {
+        py::bind_map<NonLocalMap2>(m, "NonLocalMap2", py::module_local(false));
+    });
+
+    // test_mixed_local_global
+    // We try this both with the global type registered first and vice versa (the order shouldn't
+    // matter).
+    m.def("register_mixed_global_local", [m]() {
+        bind_local<MixedGlobalLocal, 200>(m, "MixedGlobalLocal", py::module_local());
+    });
+    m.def("register_mixed_local_global", [m]() {
+        bind_local<MixedLocalGlobal, 2000>(m, "MixedLocalGlobal", py::module_local(false));
+    });
+    m.def("get_mixed_gl", [](int i) { return MixedGlobalLocal(i); });
+    m.def("get_mixed_lg", [](int i) { return MixedLocalGlobal(i); });
+
+    // test_internal_locals_differ
+    m.def("local_cpp_types_addr", []() { return (uintptr_t) &py::detail::registered_local_types_cpp(); });
+
+    // test_stl_caster_vs_stl_bind
+    py::bind_vector<std::vector<int>>(m, "VectorInt");
+
+    m.def("load_vector_via_binding", [](std::vector<int> &v) {
+        return std::accumulate(v.begin(), v.end(), 0);
+    });
+
+    // test_cross_module_calls
+    m.def("return_self", [](LocalVec *v) { return v; });
+    m.def("return_copy", [](const LocalVec &v) { return LocalVec(v); });
+
+    class Dog : public pets::Pet { public: Dog(std::string name) : Pet(name) {}; };
+    py::class_<pets::Pet>(m, "Pet", py::module_local())
+        .def("name", &pets::Pet::name);
+    // Binding for local extending class:
+    py::class_<Dog, pets::Pet>(m, "Dog")
+        .def(py::init<std::string>());
+    m.def("pet_name", [](pets::Pet &p) { return p.name(); });
+
+    py::class_<MixGL>(m, "MixGL", py::module_local()).def(py::init<int>());
+    m.def("get_gl_value", [](MixGL &o) { return o.i + 100; });
+
+    py::class_<MixGL2>(m, "MixGL2", py::module_local()).def(py::init<int>());
+
+    // test_vector_bool
+    // We can't test both stl.h and stl_bind.h conversions of `std::vector<bool>` within
+    // the same module (it would be an ODR violation). Therefore `bind_vector` of `bool`
+    // is defined here and tested in `test_stl_binders.py`.
+    py::bind_vector<std::vector<bool>>(m, "VectorBool");
+
+    // test_missing_header_message
+    // The main module already includes stl.h, but we need to test the error message
+    // which appears when this header is missing.
+    m.def("missing_header_arg", [](std::vector<float>) { });
+    m.def("missing_header_return", []() { return std::vector<float>(); });
+}
diff --git a/src/pybind11/tests/pybind11_tests.cpp b/src/pybind11/tests/pybind11_tests.cpp
index 81fe8bf..bc7d2c3 100644
--- a/src/pybind11/tests/pybind11_tests.cpp
+++ b/src/pybind11/tests/pybind11_tests.cpp
@@ -77,7 +77,8 @@ PYBIND11_MODULE(pybind11_tests, m) {
         .def(py::init<>())
         .def(py::init<int>())
         .def("get_value", &UserType::value, "Get value using a method")
-        .def_property_readonly("value", &UserType::value, "Get value using a property")
+        .def("set_value", &UserType::set, "Set value using a method")
+        .def_property("value", &UserType::value, &UserType::set, "Get/set value using a property")
         .def("__repr__", [](const UserType& u) { return "UserType({})"_s.format(u.value()); });
 
     py::class_<IncType, UserType>(m, "IncType")
diff --git a/src/pybind11/tests/pybind11_tests.h b/src/pybind11/tests/pybind11_tests.h
index dd8d159..90963a5 100644
--- a/src/pybind11/tests/pybind11_tests.h
+++ b/src/pybind11/tests/pybind11_tests.h
@@ -1,6 +1,11 @@
 #pragma once
 #include <pybind11/pybind11.h>
 
+#if defined(_MSC_VER) && _MSC_VER < 1910
+// We get some really long type names here which causes MSVC 2015 to emit warnings
+#  pragma warning(disable: 4503) // warning C4503: decorated name length exceeded, name was truncated
+#endif
+
 namespace py = pybind11;
 using namespace pybind11::literals;
 
@@ -28,6 +33,7 @@ public:
     UserType(int i) : i(i) { }
 
     int value() const { return i; }
+    void set(int set) { i = set; }
 
 private:
     int i = -1;
@@ -43,3 +49,17 @@ public:
     IncType &operator=(const IncType &) = delete;
     IncType &operator=(IncType &&) = delete;
 };
+
+/// Custom cast-only type that casts to a string "rvalue" or "lvalue" depending on the cast context.
+/// Used to test recursive casters (e.g. std::tuple, stl containers).
+struct RValueCaster {};
+NAMESPACE_BEGIN(pybind11)
+NAMESPACE_BEGIN(detail)
+template<> class type_caster<RValueCaster> {
+public:
+    PYBIND11_TYPE_CASTER(RValueCaster, _("RValueCaster"));
+    static handle cast(RValueCaster &&, return_value_policy, handle) { return py::str("rvalue").release(); }
+    static handle cast(const RValueCaster &, return_value_policy, handle) { return py::str("lvalue").release(); }
+};
+NAMESPACE_END(detail)
+NAMESPACE_END(pybind11)
diff --git a/src/pybind11/tests/pytest.ini b/src/pybind11/tests/pytest.ini
index 1e44f0a..f209964 100644
--- a/src/pybind11/tests/pytest.ini
+++ b/src/pybind11/tests/pytest.ini
@@ -13,3 +13,4 @@ filterwarnings =
     ignore::ImportWarning
     # bogus numpy ABI warning (see numpy/#432)
     ignore:.*numpy.dtype size changed.*:RuntimeWarning
+    ignore:.*numpy.ufunc size changed.*:RuntimeWarning
diff --git a/src/pybind11/tests/test_async.cpp b/src/pybind11/tests/test_async.cpp
new file mode 100644
index 0000000..f0ad0d5
--- /dev/null
+++ b/src/pybind11/tests/test_async.cpp
@@ -0,0 +1,26 @@
+/*
+    tests/test_async.cpp -- __await__ support
+
+    Copyright (c) 2019 Google Inc.
+
+    All rights reserved. Use of this source code is governed by a
+    BSD-style license that can be found in the LICENSE file.
+*/
+
+#include "pybind11_tests.h"
+
+TEST_SUBMODULE(async_module, m) {
+    struct DoesNotSupportAsync {};
+    py::class_<DoesNotSupportAsync>(m, "DoesNotSupportAsync")
+        .def(py::init<>());
+    struct SupportsAsync {};
+    py::class_<SupportsAsync>(m, "SupportsAsync")
+        .def(py::init<>())
+        .def("__await__", [](const SupportsAsync& self) -> py::object {
+            static_cast<void>(self);
+            py::object loop = py::module::import("asyncio.events").attr("get_event_loop")();
+            py::object f = loop.attr("create_future")();
+            f.attr("set_result")(5);
+            return f.attr("__await__")();
+        });
+}
diff --git a/src/pybind11/tests/test_async.py b/src/pybind11/tests/test_async.py
new file mode 100644
index 0000000..e1c959d
--- /dev/null
+++ b/src/pybind11/tests/test_async.py
@@ -0,0 +1,23 @@
+import asyncio
+import pytest
+from pybind11_tests import async_module as m
+
+
+@pytest.fixture
+def event_loop():
+    loop = asyncio.new_event_loop()
+    yield loop
+    loop.close()
+
+
+async def get_await_result(x):
+    return await x
+
+
+def test_await(event_loop):
+    assert 5 == event_loop.run_until_complete(get_await_result(m.SupportsAsync()))
+
+
+def test_await_missing(event_loop):
+    with pytest.raises(TypeError):
+        event_loop.run_until_complete(get_await_result(m.DoesNotSupportAsync()))
diff --git a/src/pybind11/tests/test_buffers.cpp b/src/pybind11/tests/test_buffers.cpp
index 9e92e5d..1bc67ff 100644
--- a/src/pybind11/tests/test_buffers.cpp
+++ b/src/pybind11/tests/test_buffers.cpp
@@ -10,113 +10,83 @@
 #include "pybind11_tests.h"
 #include "constructor_stats.h"
 
-class Matrix {
-public:
-    Matrix(ssize_t rows, ssize_t cols) : m_rows(rows), m_cols(cols) {
-        print_created(this, std::to_string(m_rows) + "x" + std::to_string(m_cols) + " matrix");
-        m_data = new float[(size_t) (rows*cols)];
-        memset(m_data, 0, sizeof(float) * (size_t) (rows * cols));
-    }
-
-    Matrix(const Matrix &s) : m_rows(s.m_rows), m_cols(s.m_cols) {
-        print_copy_created(this, std::to_string(m_rows) + "x" + std::to_string(m_cols) + " matrix");
-        m_data = new float[(size_t) (m_rows * m_cols)];
-        memcpy(m_data, s.m_data, sizeof(float) * (size_t) (m_rows * m_cols));
-    }
-
-    Matrix(Matrix &&s) : m_rows(s.m_rows), m_cols(s.m_cols), m_data(s.m_data) {
-        print_move_created(this);
-        s.m_rows = 0;
-        s.m_cols = 0;
-        s.m_data = nullptr;
-    }
-
-    ~Matrix() {
-        print_destroyed(this, std::to_string(m_rows) + "x" + std::to_string(m_cols) + " matrix");
-        delete[] m_data;
-    }
-
-    Matrix &operator=(const Matrix &s) {
-        print_copy_assigned(this, std::to_string(m_rows) + "x" + std::to_string(m_cols) + " matrix");
-        delete[] m_data;
-        m_rows = s.m_rows;
-        m_cols = s.m_cols;
-        m_data = new float[(size_t) (m_rows * m_cols)];
-        memcpy(m_data, s.m_data, sizeof(float) * (size_t) (m_rows * m_cols));
-        return *this;
-    }
-
-    Matrix &operator=(Matrix &&s) {
-        print_move_assigned(this, std::to_string(m_rows) + "x" + std::to_string(m_cols) + " matrix");
-        if (&s != this) {
-            delete[] m_data;
-            m_rows = s.m_rows; m_cols = s.m_cols; m_data = s.m_data;
-            s.m_rows = 0; s.m_cols = 0; s.m_data = nullptr;
+TEST_SUBMODULE(buffers, m) {
+    // test_from_python / test_to_python:
+    class Matrix {
+    public:
+        Matrix(ssize_t rows, ssize_t cols) : m_rows(rows), m_cols(cols) {
+            print_created(this, std::to_string(m_rows) + "x" + std::to_string(m_cols) + " matrix");
+            m_data = new float[(size_t) (rows*cols)];
+            memset(m_data, 0, sizeof(float) * (size_t) (rows * cols));
         }
-        return *this;
-    }
-
-    float operator()(ssize_t i, ssize_t j) const {
-        return m_data[(size_t) (i*m_cols + j)];
-    }
-
-    float &operator()(ssize_t i, ssize_t j) {
-        return m_data[(size_t) (i*m_cols + j)];
-    }
-
-    float *data() { return m_data; }
-
-    ssize_t rows() const { return m_rows; }
-    ssize_t cols() const { return m_cols; }
-private:
-    ssize_t m_rows;
-    ssize_t m_cols;
-    float *m_data;
-};
 
-class SquareMatrix : public Matrix {
-public:
-    SquareMatrix(ssize_t n) : Matrix(n, n) { }
-};
-
-struct PTMFBuffer {
-    int32_t value = 0;
-
-    py::buffer_info get_buffer_info() {
-        return py::buffer_info(&value, sizeof(value),
-                               py::format_descriptor<int32_t>::format(), 1);
-    }
-};
+        Matrix(const Matrix &s) : m_rows(s.m_rows), m_cols(s.m_cols) {
+            print_copy_created(this, std::to_string(m_rows) + "x" + std::to_string(m_cols) + " matrix");
+            m_data = new float[(size_t) (m_rows * m_cols)];
+            memcpy(m_data, s.m_data, sizeof(float) * (size_t) (m_rows * m_cols));
+        }
 
-class ConstPTMFBuffer {
-    std::unique_ptr<int32_t> value;
+        Matrix(Matrix &&s) : m_rows(s.m_rows), m_cols(s.m_cols), m_data(s.m_data) {
+            print_move_created(this);
+            s.m_rows = 0;
+            s.m_cols = 0;
+            s.m_data = nullptr;
+        }
 
-public:
-    int32_t get_value() const { return *value; }
-    void set_value(int32_t v) { *value = v; }
+        ~Matrix() {
+            print_destroyed(this, std::to_string(m_rows) + "x" + std::to_string(m_cols) + " matrix");
+            delete[] m_data;
+        }
 
-    py::buffer_info get_buffer_info() const {
-        return py::buffer_info(value.get(), sizeof(*value),
-                               py::format_descriptor<int32_t>::format(), 1);
-    }
+        Matrix &operator=(const Matrix &s) {
+            print_copy_assigned(this, std::to_string(m_rows) + "x" + std::to_string(m_cols) + " matrix");
+            delete[] m_data;
+            m_rows = s.m_rows;
+            m_cols = s.m_cols;
+            m_data = new float[(size_t) (m_rows * m_cols)];
+            memcpy(m_data, s.m_data, sizeof(float) * (size_t) (m_rows * m_cols));
+            return *this;
+        }
 
-    ConstPTMFBuffer() : value(new int32_t{0}) { };
-};
+        Matrix &operator=(Matrix &&s) {
+            print_move_assigned(this, std::to_string(m_rows) + "x" + std::to_string(m_cols) + " matrix");
+            if (&s != this) {
+                delete[] m_data;
+                m_rows = s.m_rows; m_cols = s.m_cols; m_data = s.m_data;
+                s.m_rows = 0; s.m_cols = 0; s.m_data = nullptr;
+            }
+            return *this;
+        }
 
-struct DerivedPTMFBuffer : public PTMFBuffer { };
+        float operator()(ssize_t i, ssize_t j) const {
+            return m_data[(size_t) (i*m_cols + j)];
+        }
 
-test_initializer buffers([](py::module &m) {
-    py::class_<Matrix> mtx(m, "Matrix", py::buffer_protocol());
+        float &operator()(ssize_t i, ssize_t j) {
+            return m_data[(size_t) (i*m_cols + j)];
+        }
 
-    mtx.def(py::init<ssize_t, ssize_t>())
+        float *data() { return m_data; }
+
+        ssize_t rows() const { return m_rows; }
+        ssize_t cols() const { return m_cols; }
+    private:
+        ssize_t m_rows;
+        ssize_t m_cols;
+        float *m_data;
+    };
+    py::class_<Matrix>(m, "Matrix", py::buffer_protocol())
+        .def(py::init<ssize_t, ssize_t>())
         /// Construct from a buffer
-        .def("__init__", [](Matrix &v, py::buffer b) {
+        .def(py::init([](py::buffer const b) {
             py::buffer_info info = b.request();
             if (info.format != py::format_descriptor<float>::format() || info.ndim != 2)
                 throw std::runtime_error("Incompatible buffer format!");
-            new (&v) Matrix(info.shape[0], info.shape[1]);
-            memcpy(v.data(), info.ptr, sizeof(float) * (size_t) (v.rows() * v.cols()));
-        })
+
+            auto v = new Matrix(info.shape[0], info.shape[1]);
+            memcpy(v->data(), info.ptr, sizeof(float) * (size_t) (v->rows() * v->cols()));
+            return v;
+        }))
 
        .def("rows", &Matrix::rows)
        .def("cols", &Matrix::cols)
@@ -137,30 +107,89 @@ test_initializer buffers([](py::module &m) {
             return py::buffer_info(
                 m.data(),                               /* Pointer to buffer */
                 { m.rows(), m.cols() },                 /* Buffer dimensions */
-                { sizeof(float) * size_t(m.rows()),     /* Strides (in bytes) for each index */
+                { sizeof(float) * size_t(m.cols()),     /* Strides (in bytes) for each index */
                   sizeof(float) }
             );
         })
         ;
 
+
+    // test_inherited_protocol
+    class SquareMatrix : public Matrix {
+    public:
+        SquareMatrix(ssize_t n) : Matrix(n, n) { }
+    };
     // Derived classes inherit the buffer protocol and the buffer access function
     py::class_<SquareMatrix, Matrix>(m, "SquareMatrix")
         .def(py::init<ssize_t>());
 
-    py::class_<PTMFBuffer>(m, "PTMFBuffer", py::buffer_protocol())
+
+    // test_pointer_to_member_fn
+    // Tests that passing a pointer to member to the base class works in
+    // the derived class.
+    struct Buffer {
+        int32_t value = 0;
+
+        py::buffer_info get_buffer_info() {
+            return py::buffer_info(&value, sizeof(value),
+                                   py::format_descriptor<int32_t>::format(), 1);
+        }
+    };
+    py::class_<Buffer>(m, "Buffer", py::buffer_protocol())
         .def(py::init<>())
-        .def_readwrite("value", &PTMFBuffer::value)
-        .def_buffer(&PTMFBuffer::get_buffer_info);
+        .def_readwrite("value", &Buffer::value)
+        .def_buffer(&Buffer::get_buffer_info);
+
 
-    py::class_<ConstPTMFBuffer>(m, "ConstPTMFBuffer", py::buffer_protocol())
+    class ConstBuffer {
+        std::unique_ptr<int32_t> value;
+
+    public:
+        int32_t get_value() const { return *value; }
+        void set_value(int32_t v) { *value = v; }
+
+        py::buffer_info get_buffer_info() const {
+            return py::buffer_info(value.get(), sizeof(*value),
+                                   py::format_descriptor<int32_t>::format(), 1);
+        }
+
+        ConstBuffer() : value(new int32_t{0}) { };
+    };
+    py::class_<ConstBuffer>(m, "ConstBuffer", py::buffer_protocol())
         .def(py::init<>())
-        .def_property("value", &ConstPTMFBuffer::get_value, &ConstPTMFBuffer::set_value)
-        .def_buffer(&ConstPTMFBuffer::get_buffer_info);
+        .def_property("value", &ConstBuffer::get_value, &ConstBuffer::set_value)
+        .def_buffer(&ConstBuffer::get_buffer_info);
 
-    // Tests that passing a pointer to member to the base class works in
-    // the derived class.
-    py::class_<DerivedPTMFBuffer>(m, "DerivedPTMFBuffer", py::buffer_protocol())
+    struct DerivedBuffer : public Buffer { };
+    py::class_<DerivedBuffer>(m, "DerivedBuffer", py::buffer_protocol())
         .def(py::init<>())
-        .def_readwrite("value", (int32_t DerivedPTMFBuffer::*) &DerivedPTMFBuffer::value)
-        .def_buffer(&DerivedPTMFBuffer::get_buffer_info);
-});
+        .def_readwrite("value", (int32_t DerivedBuffer::*) &DerivedBuffer::value)
+        .def_buffer(&DerivedBuffer::get_buffer_info);
+
+    struct BufferReadOnly {
+        const uint8_t value = 0;
+        BufferReadOnly(uint8_t value): value(value) {}
+
+        py::buffer_info get_buffer_info() {
+            return py::buffer_info(&value, 1);
+        }
+    };
+    py::class_<BufferReadOnly>(m, "BufferReadOnly", py::buffer_protocol())
+        .def(py::init<uint8_t>())
+        .def_buffer(&BufferReadOnly::get_buffer_info);
+
+    struct BufferReadOnlySelect {
+        uint8_t value = 0;
+        bool readonly = false;
+
+        py::buffer_info get_buffer_info() {
+            return py::buffer_info(&value, 1, readonly);
+        }
+    };
+    py::class_<BufferReadOnlySelect>(m, "BufferReadOnlySelect", py::buffer_protocol())
+        .def(py::init<>())
+        .def_readwrite("value", &BufferReadOnlySelect::value)
+        .def_readwrite("readonly", &BufferReadOnlySelect::readonly)
+        .def_buffer(&BufferReadOnlySelect::get_buffer_info);
+
+}
diff --git a/src/pybind11/tests/test_buffers.py b/src/pybind11/tests/test_buffers.py
index a937411..bf7aaed 100644
--- a/src/pybind11/tests/test_buffers.py
+++ b/src/pybind11/tests/test_buffers.py
@@ -1,6 +1,13 @@
+import io
 import struct
+import sys
+
 import pytest
-from pybind11_tests import Matrix, ConstructorStats, PTMFBuffer, ConstPTMFBuffer, DerivedPTMFBuffer
+
+from pybind11_tests import buffers as m
+from pybind11_tests import ConstructorStats
+
+PY3 = sys.version_info[0] >= 3
 
 pytestmark = pytest.requires_numpy
 
@@ -10,17 +17,17 @@ with pytest.suppress(ImportError):
 
 def test_from_python():
     with pytest.raises(RuntimeError) as excinfo:
-        Matrix(np.array([1, 2, 3]))  # trying to assign a 1D array
+        m.Matrix(np.array([1, 2, 3]))  # trying to assign a 1D array
     assert str(excinfo.value) == "Incompatible buffer format!"
 
     m3 = np.array([[1, 2, 3], [4, 5, 6]]).astype(np.float32)
-    m4 = Matrix(m3)
+    m4 = m.Matrix(m3)
 
     for i in range(m4.rows()):
         for j in range(m4.cols()):
             assert m3[i, j] == m4[i, j]
 
-    cstats = ConstructorStats.get(Matrix)
+    cstats = ConstructorStats.get(m.Matrix)
     assert cstats.alive() == 1
     del m3, m4
     assert cstats.alive() == 0
@@ -35,29 +42,33 @@ def test_from_python():
 # https://bitbucket.org/pypy/pypy/issues/2444
 @pytest.unsupported_on_pypy
 def test_to_python():
-    m = Matrix(5, 5)
-    assert memoryview(m).shape == (5, 5)
-
-    assert m[2, 3] == 0
-    m[2, 3] = 4
-    assert m[2, 3] == 4
-
-    m2 = np.array(m, copy=False)
-    assert m2.shape == (5, 5)
-    assert abs(m2).sum() == 4
-    assert m2[2, 3] == 4
-    m2[2, 3] = 5
-    assert m2[2, 3] == 5
-
-    cstats = ConstructorStats.get(Matrix)
+    mat = m.Matrix(5, 4)
+    assert memoryview(mat).shape == (5, 4)
+
+    assert mat[2, 3] == 0
+    mat[2, 3] = 4.0
+    mat[3, 2] = 7.0
+    assert mat[2, 3] == 4
+    assert mat[3, 2] == 7
+    assert struct.unpack_from('f', mat, (3 * 4 + 2) * 4) == (7, )
+    assert struct.unpack_from('f', mat, (2 * 4 + 3) * 4) == (4, )
+
+    mat2 = np.array(mat, copy=False)
+    assert mat2.shape == (5, 4)
+    assert abs(mat2).sum() == 11
+    assert mat2[2, 3] == 4 and mat2[3, 2] == 7
+    mat2[2, 3] = 5
+    assert mat2[2, 3] == 5
+
+    cstats = ConstructorStats.get(m.Matrix)
     assert cstats.alive() == 1
-    del m
+    del mat
     pytest.gc_collect()
     assert cstats.alive() == 1
-    del m2  # holds an m reference
+    del mat2  # holds a mat reference
     pytest.gc_collect()
     assert cstats.alive() == 0
-    assert cstats.values() == ["5x5 matrix"]
+    assert cstats.values() == ["5x4 matrix"]
     assert cstats.copy_constructions == 0
     # assert cstats.move_constructions >= 0  # Don't invoke any
     assert cstats.copy_assignments == 0
@@ -67,17 +78,41 @@ def test_to_python():
 @pytest.unsupported_on_pypy
 def test_inherited_protocol():
     """SquareMatrix is derived from Matrix and inherits the buffer protocol"""
-    from pybind11_tests import SquareMatrix
 
-    matrix = SquareMatrix(5)
+    matrix = m.SquareMatrix(5)
     assert memoryview(matrix).shape == (5, 5)
     assert np.asarray(matrix).shape == (5, 5)
 
 
 @pytest.unsupported_on_pypy
-def test_ptmf():
-    for cls in [PTMFBuffer, ConstPTMFBuffer, DerivedPTMFBuffer]:
+def test_pointer_to_member_fn():
+    for cls in [m.Buffer, m.ConstBuffer, m.DerivedBuffer]:
         buf = cls()
         buf.value = 0x12345678
         value = struct.unpack('i', bytearray(buf))[0]
         assert value == 0x12345678
+
+
+@pytest.unsupported_on_pypy
+def test_readonly_buffer():
+    buf = m.BufferReadOnly(0x64)
+    view = memoryview(buf)
+    assert view[0] == 0x64 if PY3 else b'd'
+    assert view.readonly
+
+
+@pytest.unsupported_on_pypy
+def test_selective_readonly_buffer():
+    buf = m.BufferReadOnlySelect()
+
+    memoryview(buf)[0] = 0x64 if PY3 else b'd'
+    assert buf.value == 0x64
+
+    io.BytesIO(b'A').readinto(buf)
+    assert buf.value == ord(b'A')
+
+    buf.readonly = True
+    with pytest.raises(TypeError):
+        memoryview(buf)[0] = 0 if PY3 else b'\0'
+    with pytest.raises(TypeError):
+        io.BytesIO(b'1').readinto(buf)
diff --git a/src/pybind11/tests/test_builtin_casters.cpp b/src/pybind11/tests/test_builtin_casters.cpp
index 33fe689..acb2446 100644
--- a/src/pybind11/tests/test_builtin_casters.cpp
+++ b/src/pybind11/tests/test_builtin_casters.cpp
@@ -30,7 +30,7 @@ TEST_SUBMODULE(builtin_casters, m) {
     else { wstr.push_back((wchar_t) mathbfA32); } // 𝐀, utf32
     wstr.push_back(0x7a); // z
 
-    m.def("good_utf8_string", []() { return std::string(u8"Say utf8\u203d \U0001f382 \U0001d400"); }); // Say utf8‽ 🎂 𝐀
+    m.def("good_utf8_string", []() { return std::string((const char*)u8"Say utf8\u203d \U0001f382 \U0001d400"); }); // Say utf8‽ 🎂 𝐀
     m.def("good_utf16_string", [=]() { return std::u16string({ b16, ib16, cake16_1, cake16_2, mathbfA16_1, mathbfA16_2, z16 }); }); // b‽🎂𝐀z
     m.def("good_utf32_string", [=]() { return std::u32string({ a32, mathbfA32, cake32, ib32, z32 }); }); // a𝐀🎂‽z
     m.def("good_wchar_string", [=]() { return wstr; }); // a‽𝐀z
@@ -50,7 +50,9 @@ TEST_SUBMODULE(builtin_casters, m) {
     // test_single_char_arguments
     m.attr("wchar_size") = py::cast(sizeof(wchar_t));
     m.def("ord_char", [](char c) -> int { return static_cast<unsigned char>(c); });
+    m.def("ord_char_lv", [](char &c) -> int { return static_cast<unsigned char>(c); });
     m.def("ord_char16", [](char16_t c) -> uint16_t { return c; });
+    m.def("ord_char16_lv", [](char16_t &c) -> uint16_t { return c; });
     m.def("ord_char32", [](char32_t c) -> uint32_t { return c; });
     m.def("ord_wchar", [](wchar_t c) -> int { return c; });
 
@@ -58,6 +60,18 @@ TEST_SUBMODULE(builtin_casters, m) {
     m.def("strlen", [](char *s) { return strlen(s); });
     m.def("string_length", [](std::string s) { return s.length(); });
 
+#ifdef PYBIND11_HAS_U8STRING
+    m.attr("has_u8string") = true;
+    m.def("good_utf8_u8string", []() { return std::u8string(u8"Say utf8\u203d \U0001f382 \U0001d400"); }); // Say utf8‽ 🎂 𝐀
+    m.def("bad_utf8_u8string", []()  { return std::u8string((const char8_t*)"abc\xd0" "def"); });
+
+    m.def("u8_char8_Z", []() -> char8_t { return u8'Z'; });
+
+    // test_single_char_arguments
+    m.def("ord_char8", [](char8_t c) -> int { return static_cast<unsigned char>(c); });
+    m.def("ord_char8_lv", [](char8_t &c) -> int { return static_cast<unsigned char>(c); });
+#endif
+
     // test_string_view
 #ifdef PYBIND11_HAS_STRING_VIEW
     m.attr("has_string_view") = true;
@@ -67,11 +81,23 @@ TEST_SUBMODULE(builtin_casters, m) {
     m.def("string_view_chars",   [](std::string_view s)    { py::list l; for (auto c : s) l.append((std::uint8_t) c); return l; });
     m.def("string_view16_chars", [](std::u16string_view s) { py::list l; for (auto c : s) l.append((int) c); return l; });
     m.def("string_view32_chars", [](std::u32string_view s) { py::list l; for (auto c : s) l.append((int) c); return l; });
-    m.def("string_view_return",   []() { return std::string_view(u8"utf8 secret \U0001f382"); });
+    m.def("string_view_return",   []() { return std::string_view((const char*)u8"utf8 secret \U0001f382"); });
     m.def("string_view16_return", []() { return std::u16string_view(u"utf16 secret \U0001f382"); });
     m.def("string_view32_return", []() { return std::u32string_view(U"utf32 secret \U0001f382"); });
+
+#   ifdef PYBIND11_HAS_U8STRING
+    m.def("string_view8_print",  [](std::u8string_view s) { py::print(s, s.size()); });
+    m.def("string_view8_chars",  [](std::u8string_view s) { py::list l; for (auto c : s) l.append((std::uint8_t) c); return l; });
+    m.def("string_view8_return", []() { return std::u8string_view(u8"utf8 secret \U0001f382"); });
+#   endif
 #endif
 
+    // test_integer_casting
+    m.def("i32_str", [](std::int32_t v) { return std::to_string(v); });
+    m.def("u32_str", [](std::uint32_t v) { return std::to_string(v); });
+    m.def("i64_str", [](std::int64_t v) { return std::to_string(v); });
+    m.def("u64_str", [](std::uint64_t v) { return std::to_string(v); });
+
     // test_tuple
     m.def("pair_passthrough", [](std::pair<bool, std::string> input) {
         return std::make_pair(input.second, input.first);
@@ -79,7 +105,17 @@ TEST_SUBMODULE(builtin_casters, m) {
     m.def("tuple_passthrough", [](std::tuple<bool, std::string, int> input) {
         return std::make_tuple(std::get<2>(input), std::get<1>(input), std::get<0>(input));
     }, "Return a triple in reversed order");
-
+    m.def("empty_tuple", []() { return std::tuple<>(); });
+    static std::pair<RValueCaster, RValueCaster> lvpair;
+    static std::tuple<RValueCaster, RValueCaster, RValueCaster> lvtuple;
+    static std::pair<RValueCaster, std::tuple<RValueCaster, std::pair<RValueCaster, RValueCaster>>> lvnested;
+    m.def("rvalue_pair", []() { return std::make_pair(RValueCaster{}, RValueCaster{}); });
+    m.def("lvalue_pair", []() -> const decltype(lvpair) & { return lvpair; });
+    m.def("rvalue_tuple", []() { return std::make_tuple(RValueCaster{}, RValueCaster{}, RValueCaster{}); });
+    m.def("lvalue_tuple", []() -> const decltype(lvtuple) & { return lvtuple; });
+    m.def("rvalue_nested", []() {
+        return std::make_pair(RValueCaster{}, std::make_tuple(RValueCaster{}, std::make_pair(RValueCaster{}, RValueCaster{}))); });
+    m.def("lvalue_nested", []() -> const decltype(lvnested) & { return lvnested; });
 
     // test_builtins_cast_return_none
     m.def("return_none_string", []() -> std::string * { return nullptr; });
@@ -100,6 +136,10 @@ TEST_SUBMODULE(builtin_casters, m) {
     m.def("load_nullptr_t", [](std::nullptr_t) {}); // not useful, but it should still compile
     m.def("cast_nullptr_t", []() { return std::nullptr_t{}; });
 
+    // test_bool_caster
+    m.def("bool_passthrough", [](bool arg) { return arg; });
+    m.def("bool_passthrough_noconvert", [](bool arg) { return arg; }, py::arg().noconvert());
+
     // test_reference_wrapper
     m.def("refwrap_builtin", [](std::reference_wrapper<int> p) { return 10 * p.get(); });
     m.def("refwrap_usertype", [](std::reference_wrapper<UserType> p) { return p.get().value(); });
@@ -133,4 +173,16 @@ TEST_SUBMODULE(builtin_casters, m) {
     // test_complex
     m.def("complex_cast", [](float x) { return "{}"_s.format(x); });
     m.def("complex_cast", [](std::complex<float> x) { return "({}, {})"_s.format(x.real(), x.imag()); });
+
+    // test int vs. long (Python 2)
+    m.def("int_cast", []() {return (int) 42;});
+    m.def("long_cast", []() {return (long) 42;});
+    m.def("longlong_cast", []() {return  ULLONG_MAX;});
+
+    /// test void* cast operator
+    m.def("test_void_caster", []() -> bool {
+        void *v = (void *) 0xabcd;
+        py::object o = py::cast(v);
+        return py::cast<void *>(o) == v;
+    });
 }
diff --git a/src/pybind11/tests/test_builtin_casters.py b/src/pybind11/tests/test_builtin_casters.py
index 59af0ee..9142258 100644
--- a/src/pybind11/tests/test_builtin_casters.py
+++ b/src/pybind11/tests/test_builtin_casters.py
@@ -15,6 +15,8 @@ def test_unicode_conversion():
     assert m.good_utf16_string() == u"b‽🎂𝐀z"
     assert m.good_utf32_string() == u"a𝐀🎂‽z"
     assert m.good_wchar_string() == u"a⸘𝐀z"
+    if hasattr(m, "has_u8string"):
+        assert m.good_utf8_u8string() == u"Say utf8‽ 🎂 𝐀"
 
     with pytest.raises(UnicodeDecodeError):
         m.bad_utf8_string()
@@ -29,12 +31,17 @@ def test_unicode_conversion():
     if hasattr(m, "bad_wchar_string"):
         with pytest.raises(UnicodeDecodeError):
             m.bad_wchar_string()
+    if hasattr(m, "has_u8string"):
+        with pytest.raises(UnicodeDecodeError):
+            m.bad_utf8_u8string()
 
     assert m.u8_Z() == 'Z'
     assert m.u8_eacute() == u'é'
     assert m.u16_ibang() == u'‽'
     assert m.u32_mathbfA() == u'𝐀'
     assert m.wchar_heart() == u'♥'
+    if hasattr(m, "has_u8string"):
+        assert m.u8_char8_Z() == 'Z'
 
 
 def test_single_char_arguments():
@@ -44,6 +51,7 @@ def test_single_char_arguments():
     toolong_message = "Expected a character, but multi-character string found"
 
     assert m.ord_char(u'a') == 0x61  # simple ASCII
+    assert m.ord_char_lv(u'b') == 0x62
     assert m.ord_char(u'é') == 0xE9  # requires 2 bytes in utf-8, but can be stuffed in a char
     with pytest.raises(ValueError) as excinfo:
         assert m.ord_char(u'Ā') == 0x100  # requires 2 bytes, doesn't fit in a char
@@ -54,9 +62,11 @@ def test_single_char_arguments():
 
     assert m.ord_char16(u'a') == 0x61
     assert m.ord_char16(u'é') == 0xE9
+    assert m.ord_char16_lv(u'ê') == 0xEA
     assert m.ord_char16(u'Ā') == 0x100
     assert m.ord_char16(u'‽') == 0x203d
     assert m.ord_char16(u'♥') == 0x2665
+    assert m.ord_char16_lv(u'♡') == 0x2661
     with pytest.raises(ValueError) as excinfo:
         assert m.ord_char16(u'🎂') == 0x1F382  # requires surrogate pair
     assert str(excinfo.value) == toobig_message(0x10000)
@@ -89,6 +99,17 @@ def test_single_char_arguments():
         assert m.ord_wchar(u'aa')
     assert str(excinfo.value) == toolong_message
 
+    if hasattr(m, "has_u8string"):
+        assert m.ord_char8(u'a') == 0x61  # simple ASCII
+        assert m.ord_char8_lv(u'b') == 0x62
+        assert m.ord_char8(u'é') == 0xE9  # requires 2 bytes in utf-8, but can be stuffed in a char
+        with pytest.raises(ValueError) as excinfo:
+            assert m.ord_char8(u'Ā') == 0x100  # requires 2 bytes, doesn't fit in a char
+        assert str(excinfo.value) == toobig_message(0x100)
+        with pytest.raises(ValueError) as excinfo:
+            assert m.ord_char8(u'ab')
+        assert str(excinfo.value) == toolong_message
+
 
 def test_bytes_to_string():
     """Tests the ability to pass bytes to C++ string-accepting functions.  Note that this is
@@ -113,10 +134,15 @@ def test_string_view(capture):
     assert m.string_view_chars("Hi 🎂") == [72, 105, 32, 0xf0, 0x9f, 0x8e, 0x82]
     assert m.string_view16_chars("Hi 🎂") == [72, 105, 32, 0xd83c, 0xdf82]
     assert m.string_view32_chars("Hi 🎂") == [72, 105, 32, 127874]
+    if hasattr(m, "has_u8string"):
+        assert m.string_view8_chars("Hi") == [72, 105]
+        assert m.string_view8_chars("Hi 🎂") == [72, 105, 32, 0xf0, 0x9f, 0x8e, 0x82]
 
     assert m.string_view_return() == "utf8 secret 🎂"
     assert m.string_view16_return() == "utf16 secret 🎂"
     assert m.string_view32_return() == "utf32 secret 🎂"
+    if hasattr(m, "has_u8string"):
+        assert m.string_view8_return() == "utf8 secret 🎂"
 
     with capture:
         m.string_view_print("Hi")
@@ -129,6 +155,14 @@ def test_string_view(capture):
         utf16 🎂 8
         utf32 🎂 7
     """
+    if hasattr(m, "has_u8string"):
+        with capture:
+            m.string_view8_print("Hi")
+            m.string_view8_print("utf8 🎂")
+        assert capture == """
+            Hi 2
+            utf8 🎂 9
+        """
 
     with capture:
         m.string_view_print("Hi, ascii")
@@ -141,6 +175,52 @@ def test_string_view(capture):
         Hi, utf16 🎂 12
         Hi, utf32 🎂 11
     """
+    if hasattr(m, "has_u8string"):
+        with capture:
+            m.string_view8_print("Hi, ascii")
+            m.string_view8_print("Hi, utf8 🎂")
+        assert capture == """
+            Hi, ascii 9
+            Hi, utf8 🎂 13
+        """
+
+
+def test_integer_casting():
+    """Issue #929 - out-of-range integer values shouldn't be accepted"""
+    import sys
+    assert m.i32_str(-1) == "-1"
+    assert m.i64_str(-1) == "-1"
+    assert m.i32_str(2000000000) == "2000000000"
+    assert m.u32_str(2000000000) == "2000000000"
+    if sys.version_info < (3,):
+        assert m.i32_str(long(-1)) == "-1"  # noqa: F821 undefined name 'long'
+        assert m.i64_str(long(-1)) == "-1"  # noqa: F821 undefined name 'long'
+        assert m.i64_str(long(-999999999999)) == "-999999999999"  # noqa: F821 undefined name
+        assert m.u64_str(long(999999999999)) == "999999999999"  # noqa: F821 undefined name 'long'
+    else:
+        assert m.i64_str(-999999999999) == "-999999999999"
+        assert m.u64_str(999999999999) == "999999999999"
+
+    with pytest.raises(TypeError) as excinfo:
+        m.u32_str(-1)
+    assert "incompatible function arguments" in str(excinfo.value)
+    with pytest.raises(TypeError) as excinfo:
+        m.u64_str(-1)
+    assert "incompatible function arguments" in str(excinfo.value)
+    with pytest.raises(TypeError) as excinfo:
+        m.i32_str(-3000000000)
+    assert "incompatible function arguments" in str(excinfo.value)
+    with pytest.raises(TypeError) as excinfo:
+        m.i32_str(3000000000)
+    assert "incompatible function arguments" in str(excinfo.value)
+
+    if sys.version_info < (3,):
+        with pytest.raises(TypeError) as excinfo:
+            m.u32_str(long(-1))  # noqa: F821 undefined name 'long'
+        assert "incompatible function arguments" in str(excinfo.value)
+        with pytest.raises(TypeError) as excinfo:
+            m.u64_str(long(-1))  # noqa: F821 undefined name 'long'
+        assert "incompatible function arguments" in str(excinfo.value)
 
 
 def test_tuple(doc):
@@ -150,6 +230,7 @@ def test_tuple(doc):
     # Any sequence can be cast to a std::pair or std::tuple
     assert m.pair_passthrough([True, "test"]) == ("test", True)
     assert m.tuple_passthrough([True, "test", 5]) == (5, "test", True)
+    assert m.empty_tuple() == ()
 
     assert doc(m.pair_passthrough) == """
         pair_passthrough(arg0: Tuple[bool, str]) -> Tuple[str, bool]
@@ -162,6 +243,13 @@ def test_tuple(doc):
         Return a triple in reversed order
     """
 
+    assert m.rvalue_pair() == ("rvalue", "rvalue")
+    assert m.lvalue_pair() == ("lvalue", "lvalue")
+    assert m.rvalue_tuple() == ("rvalue", "rvalue", "rvalue")
+    assert m.lvalue_tuple() == ("lvalue", "lvalue", "lvalue")
+    assert m.rvalue_nested() == ("rvalue", ("rvalue", ("rvalue", "rvalue")))
+    assert m.lvalue_nested() == ("lvalue", ("lvalue", ("lvalue", "lvalue")))
+
 
 def test_builtins_cast_return_none():
     """Casters produced with PYBIND11_TYPE_CASTER() should convert nullptr to None"""
@@ -219,3 +307,79 @@ def test_complex_cast():
     """std::complex casts"""
     assert m.complex_cast(1) == "1.0"
     assert m.complex_cast(2j) == "(0.0, 2.0)"
+
+
+def test_bool_caster():
+    """Test bool caster implicit conversions."""
+    convert, noconvert = m.bool_passthrough, m.bool_passthrough_noconvert
+
+    def require_implicit(v):
+        pytest.raises(TypeError, noconvert, v)
+
+    def cant_convert(v):
+        pytest.raises(TypeError, convert, v)
+
+    # straight up bool
+    assert convert(True) is True
+    assert convert(False) is False
+    assert noconvert(True) is True
+    assert noconvert(False) is False
+
+    # None requires implicit conversion
+    require_implicit(None)
+    assert convert(None) is False
+
+    class A(object):
+        def __init__(self, x):
+            self.x = x
+
+        def __nonzero__(self):
+            return self.x
+
+        def __bool__(self):
+            return self.x
+
+    class B(object):
+        pass
+
+    # Arbitrary objects are not accepted
+    cant_convert(object())
+    cant_convert(B())
+
+    # Objects with __nonzero__ / __bool__ defined can be converted
+    require_implicit(A(True))
+    assert convert(A(True)) is True
+    assert convert(A(False)) is False
+
+
+@pytest.requires_numpy
+def test_numpy_bool():
+    import numpy as np
+    convert, noconvert = m.bool_passthrough, m.bool_passthrough_noconvert
+
+    def cant_convert(v):
+        pytest.raises(TypeError, convert, v)
+
+    # np.bool_ is not considered implicit
+    assert convert(np.bool_(True)) is True
+    assert convert(np.bool_(False)) is False
+    assert noconvert(np.bool_(True)) is True
+    assert noconvert(np.bool_(False)) is False
+    cant_convert(np.zeros(2, dtype='int'))
+
+
+def test_int_long():
+    """In Python 2, a C++ int should return a Python int rather than long
+    if possible: longs are not always accepted where ints are used (such
+    as the argument to sys.exit()). A C++ long long is always a Python
+    long."""
+
+    import sys
+    must_be_long = type(getattr(sys, 'maxint', 1) + 1)
+    assert isinstance(m.int_cast(), int)
+    assert isinstance(m.long_cast(), int)
+    assert isinstance(m.longlong_cast(), must_be_long)
+
+
+def test_void_caster_2():
+    assert m.test_void_caster()
diff --git a/src/pybind11/tests/test_call_policies.cpp b/src/pybind11/tests/test_call_policies.cpp
index 1527592..fd24557 100644
--- a/src/pybind11/tests/test_call_policies.cpp
+++ b/src/pybind11/tests/test_call_policies.cpp
@@ -9,47 +9,6 @@
 
 #include "pybind11_tests.h"
 
-class Child {
-public:
-    Child() { py::print("Allocating child."); }
-    ~Child() { py::print("Releasing child."); }
-};
-
-class Parent {
-public:
-    Parent() { py::print("Allocating parent."); }
-    ~Parent() { py::print("Releasing parent."); }
-    void addChild(Child *) { }
-    Child *returnChild() { return new Child(); }
-    Child *returnNullChild() { return nullptr; }
-};
-
-#if !defined(PYPY_VERSION)
-class ParentGC : public Parent {
-public:
-    using Parent::Parent;
-};
-#endif
-
-test_initializer keep_alive([](py::module &m) {
-    py::class_<Parent>(m, "Parent")
-        .def(py::init<>())
-        .def("addChild", &Parent::addChild)
-        .def("addChildKeepAlive", &Parent::addChild, py::keep_alive<1, 2>())
-        .def("returnChild", &Parent::returnChild)
-        .def("returnChildKeepAlive", &Parent::returnChild, py::keep_alive<1, 0>())
-        .def("returnNullChildKeepAliveChild", &Parent::returnNullChild, py::keep_alive<1, 0>())
-        .def("returnNullChildKeepAliveParent", &Parent::returnNullChild, py::keep_alive<0, 1>());
-
-#if !defined(PYPY_VERSION)
-    py::class_<ParentGC, Parent>(m, "ParentGC", py::dynamic_attr())
-        .def(py::init<>());
-#endif
-
-    py::class_<Child>(m, "Child")
-        .def(py::init<>());
-});
-
 struct CustomGuard {
     static bool enabled;
 
@@ -58,7 +17,6 @@ struct CustomGuard {
 
     static const char *report_status() { return enabled ? "guarded" : "unguarded"; }
 };
-
 bool CustomGuard::enabled = false;
 
 struct DependentGuard {
@@ -69,12 +27,51 @@ struct DependentGuard {
 
     static const char *report_status() { return enabled ? "guarded" : "unguarded"; }
 };
-
 bool DependentGuard::enabled = false;
 
-test_initializer call_guard([](py::module &pm) {
-    auto m = pm.def_submodule("call_policies");
+TEST_SUBMODULE(call_policies, m) {
+    // Parent/Child are used in:
+    // test_keep_alive_argument, test_keep_alive_return_value, test_alive_gc_derived,
+    // test_alive_gc_multi_derived, test_return_none, test_keep_alive_constructor
+    class Child {
+    public:
+        Child() { py::print("Allocating child."); }
+        Child(const Child &) = default;
+        Child(Child &&) = default;
+        ~Child() { py::print("Releasing child."); }
+    };
+    py::class_<Child>(m, "Child")
+        .def(py::init<>());
+
+    class Parent {
+    public:
+        Parent() { py::print("Allocating parent."); }
+        ~Parent() { py::print("Releasing parent."); }
+        void addChild(Child *) { }
+        Child *returnChild() { return new Child(); }
+        Child *returnNullChild() { return nullptr; }
+    };
+    py::class_<Parent>(m, "Parent")
+        .def(py::init<>())
+        .def(py::init([](Child *) { return new Parent(); }), py::keep_alive<1, 2>())
+        .def("addChild", &Parent::addChild)
+        .def("addChildKeepAlive", &Parent::addChild, py::keep_alive<1, 2>())
+        .def("returnChild", &Parent::returnChild)
+        .def("returnChildKeepAlive", &Parent::returnChild, py::keep_alive<1, 0>())
+        .def("returnNullChildKeepAliveChild", &Parent::returnNullChild, py::keep_alive<1, 0>())
+        .def("returnNullChildKeepAliveParent", &Parent::returnNullChild, py::keep_alive<0, 1>());
+
+#if !defined(PYPY_VERSION)
+    // test_alive_gc
+    class ParentGC : public Parent {
+    public:
+        using Parent::Parent;
+    };
+    py::class_<ParentGC, Parent>(m, "ParentGC", py::dynamic_attr())
+        .def(py::init<>());
+#endif
 
+    // test_call_guard
     m.def("unguarded_call", &CustomGuard::report_status);
     m.def("guarded_call", &CustomGuard::report_status, py::call_guard<CustomGuard>());
 
@@ -100,4 +97,4 @@ test_initializer call_guard([](py::module &pm) {
     m.def("with_gil", report_gil_status);
     m.def("without_gil", report_gil_status, py::call_guard<py::gil_scoped_release>());
 #endif
-});
+}
diff --git a/src/pybind11/tests/test_call_policies.py b/src/pybind11/tests/test_call_policies.py
index de4ec96..7c83559 100644
--- a/src/pybind11/tests/test_call_policies.py
+++ b/src/pybind11/tests/test_call_policies.py
@@ -1,15 +1,15 @@
 import pytest
+from pybind11_tests import call_policies as m
+from pybind11_tests import ConstructorStats
 
 
 def test_keep_alive_argument(capture):
-    from pybind11_tests import Parent, Child, ConstructorStats
-
     n_inst = ConstructorStats.detail_reg_inst()
     with capture:
-        p = Parent()
+        p = m.Parent()
     assert capture == "Allocating parent."
     with capture:
-        p.addChild(Child())
+        p.addChild(m.Child())
         assert ConstructorStats.detail_reg_inst() == n_inst + 1
     assert capture == """
         Allocating child.
@@ -21,10 +21,10 @@ def test_keep_alive_argument(capture):
     assert capture == "Releasing parent."
 
     with capture:
-        p = Parent()
+        p = m.Parent()
     assert capture == "Allocating parent."
     with capture:
-        p.addChildKeepAlive(Child())
+        p.addChildKeepAlive(m.Child())
         assert ConstructorStats.detail_reg_inst() == n_inst + 2
     assert capture == "Allocating child."
     with capture:
@@ -37,11 +37,9 @@ def test_keep_alive_argument(capture):
 
 
 def test_keep_alive_return_value(capture):
-    from pybind11_tests import Parent, ConstructorStats
-
     n_inst = ConstructorStats.detail_reg_inst()
     with capture:
-        p = Parent()
+        p = m.Parent()
     assert capture == "Allocating parent."
     with capture:
         p.returnChild()
@@ -56,7 +54,7 @@ def test_keep_alive_return_value(capture):
     assert capture == "Releasing parent."
 
     with capture:
-        p = Parent()
+        p = m.Parent()
     assert capture == "Allocating parent."
     with capture:
         p.returnChildKeepAlive()
@@ -74,11 +72,9 @@ def test_keep_alive_return_value(capture):
 # https://bitbucket.org/pypy/pypy/issues/2447
 @pytest.unsupported_on_pypy
 def test_alive_gc(capture):
-    from pybind11_tests import ParentGC, Child, ConstructorStats
-
     n_inst = ConstructorStats.detail_reg_inst()
-    p = ParentGC()
-    p.addChildKeepAlive(Child())
+    p = m.ParentGC()
+    p.addChildKeepAlive(m.Child())
     assert ConstructorStats.detail_reg_inst() == n_inst + 2
     lst = [p]
     lst.append(lst)   # creates a circular reference
@@ -92,14 +88,12 @@ def test_alive_gc(capture):
 
 
 def test_alive_gc_derived(capture):
-    from pybind11_tests import Parent, Child, ConstructorStats
-
-    class Derived(Parent):
+    class Derived(m.Parent):
         pass
 
     n_inst = ConstructorStats.detail_reg_inst()
     p = Derived()
-    p.addChildKeepAlive(Child())
+    p.addChildKeepAlive(m.Child())
     assert ConstructorStats.detail_reg_inst() == n_inst + 2
     lst = [p]
     lst.append(lst)   # creates a circular reference
@@ -113,14 +107,14 @@ def test_alive_gc_derived(capture):
 
 
 def test_alive_gc_multi_derived(capture):
-    from pybind11_tests import Parent, Child, ConstructorStats
-
-    class Derived(Parent, Child):
-        pass
+    class Derived(m.Parent, m.Child):
+        def __init__(self):
+            m.Parent.__init__(self)
+            m.Child.__init__(self)
 
     n_inst = ConstructorStats.detail_reg_inst()
     p = Derived()
-    p.addChildKeepAlive(Child())
+    p.addChildKeepAlive(m.Child())
     # +3 rather than +2 because Derived corresponds to two registered instances
     assert ConstructorStats.detail_reg_inst() == n_inst + 3
     lst = [p]
@@ -131,15 +125,14 @@ def test_alive_gc_multi_derived(capture):
     assert capture == """
         Releasing parent.
         Releasing child.
+        Releasing child.
     """
 
 
 def test_return_none(capture):
-    from pybind11_tests import Parent, ConstructorStats
-
     n_inst = ConstructorStats.detail_reg_inst()
     with capture:
-        p = Parent()
+        p = m.Parent()
     assert capture == "Allocating parent."
     with capture:
         p.returnNullChildKeepAliveChild()
@@ -151,7 +144,7 @@ def test_return_none(capture):
     assert capture == "Releasing parent."
 
     with capture:
-        p = Parent()
+        p = m.Parent()
     assert capture == "Allocating parent."
     with capture:
         p.returnNullChildKeepAliveParent()
@@ -163,15 +156,32 @@ def test_return_none(capture):
     assert capture == "Releasing parent."
 
 
-def test_call_guard():
-    from pybind11_tests import call_policies
+def test_keep_alive_constructor(capture):
+    n_inst = ConstructorStats.detail_reg_inst()
 
-    assert call_policies.unguarded_call() == "unguarded"
-    assert call_policies.guarded_call() == "guarded"
+    with capture:
+        p = m.Parent(m.Child())
+        assert ConstructorStats.detail_reg_inst() == n_inst + 2
+    assert capture == """
+        Allocating child.
+        Allocating parent.
+    """
+    with capture:
+        del p
+        assert ConstructorStats.detail_reg_inst() == n_inst
+    assert capture == """
+        Releasing parent.
+        Releasing child.
+    """
+
+
+def test_call_guard():
+    assert m.unguarded_call() == "unguarded"
+    assert m.guarded_call() == "guarded"
 
-    assert call_policies.multiple_guards_correct_order() == "guarded & guarded"
-    assert call_policies.multiple_guards_wrong_order() == "unguarded & guarded"
+    assert m.multiple_guards_correct_order() == "guarded & guarded"
+    assert m.multiple_guards_wrong_order() == "unguarded & guarded"
 
-    if hasattr(call_policies, "with_gil"):
-        assert call_policies.with_gil() == "GIL held"
-        assert call_policies.without_gil() == "GIL released"
+    if hasattr(m, "with_gil"):
+        assert m.with_gil() == "GIL held"
+        assert m.without_gil() == "GIL released"
diff --git a/src/pybind11/tests/test_callbacks.cpp b/src/pybind11/tests/test_callbacks.cpp
index f26f6c3..71b88c4 100644
--- a/src/pybind11/tests/test_callbacks.cpp
+++ b/src/pybind11/tests/test_callbacks.cpp
@@ -10,96 +10,23 @@
 #include "pybind11_tests.h"
 #include "constructor_stats.h"
 #include <pybind11/functional.h>
+#include <thread>
 
 
-py::object test_callback1(py::object func) {
-    return func();
-}
-
-py::tuple test_callback2(py::object func) {
-    return func("Hello", 'x', true, 5);
-}
-
-std::string test_callback3(const std::function<int(int)> &func) {
-    return "func(43) = " + std::to_string(func(43));
-}
-
-std::function<int(int)> test_callback4() {
-    return [](int i) { return i+1; };
-}
-
-py::cpp_function test_callback5() {
-    return py::cpp_function([](int i) { return i+1; },
-       py::arg("number"));
-}
-
 int dummy_function(int i) { return i + 1; }
-int dummy_function2(int i, int j) { return i + j; }
-std::function<int(int)> roundtrip(std::function<int(int)> f, bool expect_none = false) {
-    if (expect_none && f) {
-        throw std::runtime_error("Expected None to be converted to empty std::function");
-    }
-    return f;
-}
 
-std::string test_dummy_function(const std::function<int(int)> &f) {
-    using fn_type = int (*)(int);
-    auto result = f.target<fn_type>();
-    if (!result) {
-        auto r = f(1);
-        return "can't convert to function pointer: eval(1) = " + std::to_string(r);
-    } else if (*result == dummy_function) {
-        auto r = (*result)(1);
-        return "matches dummy_function: eval(1) = " + std::to_string(r);
-    } else {
-        return "argument does NOT match dummy_function. This should never happen!";
-    }
-}
+TEST_SUBMODULE(callbacks, m) {
+    // test_callbacks, test_function_signatures
+    m.def("test_callback1", [](py::object func) { return func(); });
+    m.def("test_callback2", [](py::object func) { return func("Hello", 'x', true, 5); });
+    m.def("test_callback3", [](const std::function<int(int)> &func) {
+        return "func(43) = " + std::to_string(func(43)); });
+    m.def("test_callback4", []() -> std::function<int(int)> { return [](int i) { return i+1; }; });
+    m.def("test_callback5", []() {
+        return py::cpp_function([](int i) { return i+1; }, py::arg("number"));
+    });
 
-struct Payload {
-    Payload() {
-        print_default_created(this);
-    }
-    ~Payload() {
-        print_destroyed(this);
-    }
-    Payload(const Payload &) {
-        print_copy_created(this);
-    }
-    Payload(Payload &&) {
-        print_move_created(this);
-    }
-};
-
-class AbstractBase {
-public:
-  virtual unsigned int func() = 0;
-};
-
-void func_accepting_func_accepting_base(std::function<double(AbstractBase&)>) { }
-
-struct MovableObject {
-  bool valid = true;
-
-  MovableObject() = default;
-  MovableObject(const MovableObject &) = default;
-  MovableObject &operator=(const MovableObject &) = default;
-  MovableObject(MovableObject &&o) : valid(o.valid) { o.valid = false; }
-  MovableObject &operator=(MovableObject &&o) {
-    valid = o.valid;
-    o.valid = false;
-    return *this;
-  }
-};
-
-test_initializer callbacks([](py::module &m) {
-    m.def("test_callback1", &test_callback1);
-    m.def("test_callback2", &test_callback2);
-    m.def("test_callback3", &test_callback3);
-    m.def("test_callback4", &test_callback4);
-    m.def("test_callback5", &test_callback5);
-
-    // Test keyword args and generalized unpacking
+    // test_keyword_args_and_generalized_unpacking
     m.def("test_tuple_unpacking", [](py::function f) {
         auto t1 = py::make_tuple(2, 3);
         auto t2 = py::make_tuple(5, 6);
@@ -148,6 +75,15 @@ test_initializer callbacks([](py::module &m) {
         f(234, "expected_name"_a=UnregisteredType(), "kw"_a=567);
     });
 
+    // test_lambda_closure_cleanup
+    struct Payload {
+        Payload() { print_default_created(this); }
+        ~Payload() { print_destroyed(this); }
+        Payload(const Payload &) { print_copy_created(this); }
+        Payload(Payload &&) { print_move_created(this); }
+    };
+    // Export the payload constructor statistics for testing purposes:
+    m.def("payload_cstats", &ConstructorStats::get<Payload>);
     /* Test cleanup of lambda closure */
     m.def("test_cleanup", []() -> std::function<void(void)> {
         Payload p;
@@ -158,27 +94,75 @@ test_initializer callbacks([](py::module &m) {
         };
     });
 
+    // test_cpp_function_roundtrip
     /* Test if passing a function pointer from C++ -> Python -> C++ yields the original pointer */
     m.def("dummy_function", &dummy_function);
-    m.def("dummy_function2", &dummy_function2);
-    m.def("roundtrip", &roundtrip, py::arg("f"), py::arg("expect_none")=false);
-    m.def("test_dummy_function", &test_dummy_function);
-    // Export the payload constructor statistics for testing purposes:
-    m.def("payload_cstats", &ConstructorStats::get<Payload>);
-
-    m.def("func_accepting_func_accepting_base",
-          func_accepting_func_accepting_base);
+    m.def("dummy_function2", [](int i, int j) { return i + j; });
+    m.def("roundtrip", [](std::function<int(int)> f, bool expect_none = false) {
+        if (expect_none && f)
+            throw std::runtime_error("Expected None to be converted to empty std::function");
+        return f;
+    }, py::arg("f"), py::arg("expect_none")=false);
+    m.def("test_dummy_function", [](const std::function<int(int)> &f) -> std::string {
+        using fn_type = int (*)(int);
+        auto result = f.target<fn_type>();
+        if (!result) {
+            auto r = f(1);
+            return "can't convert to function pointer: eval(1) = " + std::to_string(r);
+        } else if (*result == dummy_function) {
+            auto r = (*result)(1);
+            return "matches dummy_function: eval(1) = " + std::to_string(r);
+        } else {
+            return "argument does NOT match dummy_function. This should never happen!";
+        }
+    });
 
+    class AbstractBase { public: virtual unsigned int func() = 0; };
+    m.def("func_accepting_func_accepting_base", [](std::function<double(AbstractBase&)>) { });
+
+    struct MovableObject {
+        bool valid = true;
+
+        MovableObject() = default;
+        MovableObject(const MovableObject &) = default;
+        MovableObject &operator=(const MovableObject &) = default;
+        MovableObject(MovableObject &&o) : valid(o.valid) { o.valid = false; }
+        MovableObject &operator=(MovableObject &&o) {
+            valid = o.valid;
+            o.valid = false;
+            return *this;
+        }
+    };
     py::class_<MovableObject>(m, "MovableObject");
 
+    // test_movable_object
     m.def("callback_with_movable", [](std::function<void(MovableObject &)> f) {
         auto x = MovableObject();
         f(x); // lvalue reference shouldn't move out object
         return x.valid; // must still return `true`
-      });
+    });
 
+    // test_bound_method_callback
     struct CppBoundMethodTest {};
     py::class_<CppBoundMethodTest>(m, "CppBoundMethodTest")
         .def(py::init<>())
         .def("triple", [](CppBoundMethodTest &, int val) { return 3 * val; });
-});
+
+    // test async Python callbacks
+    using callback_f = std::function<void(int)>;
+    m.def("test_async_callback", [](callback_f f, py::list work) {
+        // make detached thread that calls `f` with piece of work after a little delay
+        auto start_f = [f](int j) {
+            auto invoke_f = [f, j] {
+                std::this_thread::sleep_for(std::chrono::milliseconds(50));
+                f(j);
+            };
+            auto t = std::thread(std::move(invoke_f));
+            t.detach();
+        };
+
+        // spawn worker threads
+        for (auto i : work)
+            start_f(py::cast<int>(i));
+    });
+}
diff --git a/src/pybind11/tests/test_callbacks.py b/src/pybind11/tests/test_callbacks.py
index a5109d0..6439c8e 100644
--- a/src/pybind11/tests/test_callbacks.py
+++ b/src/pybind11/tests/test_callbacks.py
@@ -1,10 +1,10 @@
 import pytest
+from pybind11_tests import callbacks as m
+from threading import Thread
 
 
 def test_callbacks():
     from functools import partial
-    from pybind11_tests import (test_callback1, test_callback2, test_callback3,
-                                test_callback4, test_callback5)
 
     def func1():
         return "func1"
@@ -15,73 +15,65 @@ def test_callbacks():
     def func3(a):
         return "func3({})".format(a)
 
-    assert test_callback1(func1) == "func1"
-    assert test_callback2(func2) == ("func2", "Hello", "x", True, 5)
-    assert test_callback1(partial(func2, 1, 2, 3, 4)) == ("func2", 1, 2, 3, 4)
-    assert test_callback1(partial(func3, "partial")) == "func3(partial)"
-    assert test_callback3(lambda i: i + 1) == "func(43) = 44"
+    assert m.test_callback1(func1) == "func1"
+    assert m.test_callback2(func2) == ("func2", "Hello", "x", True, 5)
+    assert m.test_callback1(partial(func2, 1, 2, 3, 4)) == ("func2", 1, 2, 3, 4)
+    assert m.test_callback1(partial(func3, "partial")) == "func3(partial)"
+    assert m.test_callback3(lambda i: i + 1) == "func(43) = 44"
 
-    f = test_callback4()
+    f = m.test_callback4()
     assert f(43) == 44
-    f = test_callback5()
+    f = m.test_callback5()
     assert f(number=43) == 44
 
 
 def test_bound_method_callback():
-    from pybind11_tests import test_callback3, CppBoundMethodTest
-
     # Bound Python method:
     class MyClass:
         def double(self, val):
             return 2 * val
 
     z = MyClass()
-    assert test_callback3(z.double) == "func(43) = 86"
+    assert m.test_callback3(z.double) == "func(43) = 86"
 
-    z = CppBoundMethodTest()
-    assert test_callback3(z.triple) == "func(43) = 129"
+    z = m.CppBoundMethodTest()
+    assert m.test_callback3(z.triple) == "func(43) = 129"
 
 
 def test_keyword_args_and_generalized_unpacking():
-    from pybind11_tests import (test_tuple_unpacking, test_dict_unpacking, test_keyword_args,
-                                test_unpacking_and_keywords1, test_unpacking_and_keywords2,
-                                test_unpacking_error1, test_unpacking_error2,
-                                test_arg_conversion_error1, test_arg_conversion_error2)
 
     def f(*args, **kwargs):
         return args, kwargs
 
-    assert test_tuple_unpacking(f) == (("positional", 1, 2, 3, 4, 5, 6), {})
-    assert test_dict_unpacking(f) == (("positional", 1), {"key": "value", "a": 1, "b": 2})
-    assert test_keyword_args(f) == ((), {"x": 10, "y": 20})
-    assert test_unpacking_and_keywords1(f) == ((1, 2), {"c": 3, "d": 4})
-    assert test_unpacking_and_keywords2(f) == (
+    assert m.test_tuple_unpacking(f) == (("positional", 1, 2, 3, 4, 5, 6), {})
+    assert m.test_dict_unpacking(f) == (("positional", 1), {"key": "value", "a": 1, "b": 2})
+    assert m.test_keyword_args(f) == ((), {"x": 10, "y": 20})
+    assert m.test_unpacking_and_keywords1(f) == ((1, 2), {"c": 3, "d": 4})
+    assert m.test_unpacking_and_keywords2(f) == (
         ("positional", 1, 2, 3, 4, 5),
         {"key": "value", "a": 1, "b": 2, "c": 3, "d": 4, "e": 5}
     )
 
     with pytest.raises(TypeError) as excinfo:
-        test_unpacking_error1(f)
+        m.test_unpacking_error1(f)
     assert "Got multiple values for keyword argument" in str(excinfo.value)
 
     with pytest.raises(TypeError) as excinfo:
-        test_unpacking_error2(f)
+        m.test_unpacking_error2(f)
     assert "Got multiple values for keyword argument" in str(excinfo.value)
 
     with pytest.raises(RuntimeError) as excinfo:
-        test_arg_conversion_error1(f)
+        m.test_arg_conversion_error1(f)
     assert "Unable to convert call argument" in str(excinfo.value)
 
     with pytest.raises(RuntimeError) as excinfo:
-        test_arg_conversion_error2(f)
+        m.test_arg_conversion_error2(f)
     assert "Unable to convert call argument" in str(excinfo.value)
 
 
 def test_lambda_closure_cleanup():
-    from pybind11_tests import test_cleanup, payload_cstats
-
-    test_cleanup()
-    cstats = payload_cstats()
+    m.test_cleanup()
+    cstats = m.payload_cstats()
     assert cstats.alive() == 0
     assert cstats.copy_constructions == 1
     assert cstats.move_constructions >= 1
@@ -89,31 +81,56 @@ def test_lambda_closure_cleanup():
 
 def test_cpp_function_roundtrip():
     """Test if passing a function pointer from C++ -> Python -> C++ yields the original pointer"""
-    from pybind11_tests import dummy_function, dummy_function2, test_dummy_function, roundtrip
 
-    assert test_dummy_function(dummy_function) == "matches dummy_function: eval(1) = 2"
-    assert test_dummy_function(roundtrip(dummy_function)) == "matches dummy_function: eval(1) = 2"
-    assert roundtrip(None, expect_none=True) is None
-    assert test_dummy_function(lambda x: x + 2) == "can't convert to function pointer: eval(1) = 3"
+    assert m.test_dummy_function(m.dummy_function) == "matches dummy_function: eval(1) = 2"
+    assert (m.test_dummy_function(m.roundtrip(m.dummy_function)) ==
+            "matches dummy_function: eval(1) = 2")
+    assert m.roundtrip(None, expect_none=True) is None
+    assert (m.test_dummy_function(lambda x: x + 2) ==
+            "can't convert to function pointer: eval(1) = 3")
 
     with pytest.raises(TypeError) as excinfo:
-        test_dummy_function(dummy_function2)
+        m.test_dummy_function(m.dummy_function2)
     assert "incompatible function arguments" in str(excinfo.value)
 
     with pytest.raises(TypeError) as excinfo:
-        test_dummy_function(lambda x, y: x + y)
+        m.test_dummy_function(lambda x, y: x + y)
     assert any(s in str(excinfo.value) for s in ("missing 1 required positional argument",
                                                  "takes exactly 2 arguments"))
 
 
 def test_function_signatures(doc):
-    from pybind11_tests import test_callback3, test_callback4
-
-    assert doc(test_callback3) == "test_callback3(arg0: Callable[[int], int]) -> str"
-    assert doc(test_callback4) == "test_callback4() -> Callable[[int], int]"
+    assert doc(m.test_callback3) == "test_callback3(arg0: Callable[[int], int]) -> str"
+    assert doc(m.test_callback4) == "test_callback4() -> Callable[[int], int]"
 
 
 def test_movable_object():
-    from pybind11_tests import callback_with_movable
+    assert m.callback_with_movable(lambda _: None) is True
+
+
+def test_async_callbacks():
+    # serves as state for async callback
+    class Item:
+        def __init__(self, value):
+            self.value = value
+
+    res = []
+
+    # generate stateful lambda that will store result in `res`
+    def gen_f():
+        s = Item(3)
+        return lambda j: res.append(s.value + j)
+
+    # do some work async
+    work = [1, 2, 3, 4]
+    m.test_async_callback(gen_f(), work)
+    # wait until work is done
+    from time import sleep
+    sleep(0.5)
+    assert sum(res) == sum([x + 3 for x in work])
+
 
-    assert callback_with_movable(lambda _: None) is True
+def test_async_async_callbacks():
+    t = Thread(target=test_async_callbacks)
+    t.start()
+    t.join()
diff --git a/src/pybind11/tests/test_chrono.cpp b/src/pybind11/tests/test_chrono.cpp
index fcc1b61..899d08d 100644
--- a/src/pybind11/tests/test_chrono.cpp
+++ b/src/pybind11/tests/test_chrono.cpp
@@ -8,58 +8,48 @@
     BSD-style license that can be found in the LICENSE file.
 */
 
-
 #include "pybind11_tests.h"
-#include "constructor_stats.h"
 #include <pybind11/chrono.h>
 
-// Return the current time off the wall clock
-std::chrono::system_clock::time_point test_chrono1() {
-    return std::chrono::system_clock::now();
-}
+TEST_SUBMODULE(chrono, m) {
+    using system_time = std::chrono::system_clock::time_point;
+    using steady_time = std::chrono::steady_clock::time_point;
 
-// Round trip the passed in system clock time
-std::chrono::system_clock::time_point test_chrono2(std::chrono::system_clock::time_point t) {
-    return t;
-}
+    using timespan = std::chrono::duration<int64_t, std::nano>;
+    using timestamp = std::chrono::time_point<std::chrono::system_clock, timespan>;
 
-// Round trip the passed in duration
-std::chrono::system_clock::duration test_chrono3(std::chrono::system_clock::duration d) {
-    return d;
-}
+    // test_chrono_system_clock
+    // Return the current time off the wall clock
+    m.def("test_chrono1", []() { return std::chrono::system_clock::now(); });
 
-// Difference between two passed in time_points
-std::chrono::system_clock::duration test_chrono4(std::chrono::system_clock::time_point a, std::chrono::system_clock::time_point b) {
-    return a - b;
-}
+    // test_chrono_system_clock_roundtrip
+    // Round trip the passed in system clock time
+    m.def("test_chrono2", [](system_time t) { return t; });
 
-// Return the current time off the steady_clock
-std::chrono::steady_clock::time_point test_chrono5() {
-    return std::chrono::steady_clock::now();
-}
+    // test_chrono_duration_roundtrip
+    // Round trip the passed in duration
+    m.def("test_chrono3", [](std::chrono::system_clock::duration d) { return d; });
 
-// Round trip a steady clock timepoint
-std::chrono::steady_clock::time_point test_chrono6(std::chrono::steady_clock::time_point t) {
-    return t;
-}
+    // test_chrono_duration_subtraction_equivalence
+    // Difference between two passed in time_points
+    m.def("test_chrono4", [](system_time a, system_time b) { return a - b; });
 
-// Roundtrip a duration in microseconds from a float argument
-std::chrono::microseconds test_chrono7(std::chrono::microseconds t) {
-    return t;
-}
+    // test_chrono_steady_clock
+    // Return the current time off the steady_clock
+    m.def("test_chrono5", []() { return std::chrono::steady_clock::now(); });
 
-// Float durations (issue #719)
-std::chrono::duration<double> test_chrono_float_diff(std::chrono::duration<float> a, std::chrono::duration<float> b) {
-    return a - b;
-}
+    // test_chrono_steady_clock_roundtrip
+    // Round trip a steady clock timepoint
+    m.def("test_chrono6", [](steady_time t) { return t; });
 
-test_initializer chrono([] (py::module &m) {
-    m.def("test_chrono1", &test_chrono1);
-    m.def("test_chrono2", &test_chrono2);
-    m.def("test_chrono3", &test_chrono3);
-    m.def("test_chrono4", &test_chrono4);
-    m.def("test_chrono5", &test_chrono5);
-    m.def("test_chrono6", &test_chrono6);
-    m.def("test_chrono7", &test_chrono7);
-    m.def("test_chrono_float_diff", &test_chrono_float_diff);
-});
+    // test_floating_point_duration
+    // Roundtrip a duration in microseconds from a float argument
+    m.def("test_chrono7", [](std::chrono::microseconds t) { return t; });
+    // Float durations (issue #719)
+    m.def("test_chrono_float_diff", [](std::chrono::duration<float> a, std::chrono::duration<float> b) {
+        return a - b; });
+
+    m.def("test_nano_timepoint", [](timestamp start, timespan delta) -> timestamp {
+        return start + delta;
+    });
+}
diff --git a/src/pybind11/tests/test_chrono.py b/src/pybind11/tests/test_chrono.py
index 55094ed..55c9544 100644
--- a/src/pybind11/tests/test_chrono.py
+++ b/src/pybind11/tests/test_chrono.py
@@ -1,11 +1,11 @@
+from pybind11_tests import chrono as m
+import datetime
 
 
 def test_chrono_system_clock():
-    from pybind11_tests import test_chrono1
-    import datetime
 
     # Get the time from both c++ and datetime
-    date1 = test_chrono1()
+    date1 = m.test_chrono1()
     date2 = datetime.datetime.today()
 
     # The returned value should be a datetime
@@ -25,13 +25,10 @@ def test_chrono_system_clock():
 
 
 def test_chrono_system_clock_roundtrip():
-    from pybind11_tests import test_chrono2
-    import datetime
-
     date1 = datetime.datetime.today()
 
     # Roundtrip the time
-    date2 = test_chrono2(date1)
+    date2 = m.test_chrono2(date1)
 
     # The returned value should be a datetime
     assert isinstance(date2, datetime.datetime)
@@ -43,9 +40,63 @@ def test_chrono_system_clock_roundtrip():
     assert diff.microseconds == 0
 
 
+def test_chrono_system_clock_roundtrip_date():
+    date1 = datetime.date.today()
+
+    # Roundtrip the time
+    datetime2 = m.test_chrono2(date1)
+    date2 = datetime2.date()
+    time2 = datetime2.time()
+
+    # The returned value should be a datetime
+    assert isinstance(datetime2, datetime.datetime)
+    assert isinstance(date2, datetime.date)
+    assert isinstance(time2, datetime.time)
+
+    # They should be identical (no information lost on roundtrip)
+    diff = abs(date1 - date2)
+    assert diff.days == 0
+    assert diff.seconds == 0
+    assert diff.microseconds == 0
+
+    # Year, Month & Day should be the same after the round trip
+    assert date1.year == date2.year
+    assert date1.month == date2.month
+    assert date1.day == date2.day
+
+    # There should be no time information
+    assert time2.hour == 0
+    assert time2.minute == 0
+    assert time2.second == 0
+    assert time2.microsecond == 0
+
+
+def test_chrono_system_clock_roundtrip_time():
+    time1 = datetime.datetime.today().time()
+
+    # Roundtrip the time
+    datetime2 = m.test_chrono2(time1)
+    date2 = datetime2.date()
+    time2 = datetime2.time()
+
+    # The returned value should be a datetime
+    assert isinstance(datetime2, datetime.datetime)
+    assert isinstance(date2, datetime.date)
+    assert isinstance(time2, datetime.time)
+
+    # Hour, Minute, Second & Microsecond should be the same after the round trip
+    assert time1.hour == time2.hour
+    assert time1.minute == time2.minute
+    assert time1.second == time2.second
+    assert time1.microsecond == time2.microsecond
+
+    # There should be no date information (i.e. date = python base date)
+    assert date2.year == 1970
+    assert date2.month == 1
+    assert date2.day == 1
+
+
 def test_chrono_duration_roundtrip():
-    from pybind11_tests import test_chrono3
-    import datetime
 
     # Get the difference between two times (a timedelta)
     date1 = datetime.datetime.today()
@@ -55,7 +106,7 @@ def test_chrono_duration_roundtrip():
     # Make sure this is a timedelta
     assert isinstance(diff, datetime.timedelta)
 
-    cpp_diff = test_chrono3(diff)
+    cpp_diff = m.test_chrono3(diff)
 
     assert cpp_diff.days == diff.days
     assert cpp_diff.seconds == diff.seconds
@@ -63,37 +114,39 @@ def test_chrono_duration_roundtrip():
 
 
 def test_chrono_duration_subtraction_equivalence():
-    from pybind11_tests import test_chrono4
-    import datetime
 
     date1 = datetime.datetime.today()
     date2 = datetime.datetime.today()
 
     diff = date2 - date1
-    cpp_diff = test_chrono4(date2, date1)
+    cpp_diff = m.test_chrono4(date2, date1)
 
     assert cpp_diff.days == diff.days
     assert cpp_diff.seconds == diff.seconds
     assert cpp_diff.microseconds == diff.microseconds
 
 
-def test_chrono_steady_clock():
-    from pybind11_tests import test_chrono5
-    import datetime
+def test_chrono_duration_subtraction_equivalence_date():
+
+    date1 = datetime.date.today()
+    date2 = datetime.date.today()
+
+    diff = date2 - date1
+    cpp_diff = m.test_chrono4(date2, date1)
+
+    assert cpp_diff.days == diff.days
+    assert cpp_diff.seconds == diff.seconds
+    assert cpp_diff.microseconds == diff.microseconds
 
-    time1 = test_chrono5()
-    time2 = test_chrono5()
 
+def test_chrono_steady_clock():
+    time1 = m.test_chrono5()
     assert isinstance(time1, datetime.timedelta)
-    assert isinstance(time2, datetime.timedelta)
 
 
 def test_chrono_steady_clock_roundtrip():
-    from pybind11_tests import test_chrono6
-    import datetime
-
     time1 = datetime.timedelta(days=10, seconds=10, microseconds=100)
-    time2 = test_chrono6(time1)
+    time2 = m.test_chrono6(time1)
 
     assert isinstance(time2, datetime.timedelta)
 
@@ -104,17 +157,20 @@ def test_chrono_steady_clock_roundtrip():
 
 
 def test_floating_point_duration():
-    from pybind11_tests import test_chrono7, test_chrono_float_diff
-    import datetime
-
-    # Test using 35.525123 seconds as an example floating point number in seconds
-    time = test_chrono7(35.525123)
+    # Test using a floating point number in seconds
+    time = m.test_chrono7(35.525123)
 
     assert isinstance(time, datetime.timedelta)
 
     assert time.seconds == 35
     assert 525122 <= time.microseconds <= 525123
 
-    diff = test_chrono_float_diff(43.789012, 1.123456)
+    diff = m.test_chrono_float_diff(43.789012, 1.123456)
     assert diff.seconds == 42
     assert 665556 <= diff.microseconds <= 665557
+
+
+def test_nano_timepoint():
+    time = datetime.datetime.now()
+    time1 = m.test_nano_timepoint(time, datetime.timedelta(seconds=60))
+    assert(time1 == time + datetime.timedelta(seconds=60))
diff --git a/src/pybind11/tests/test_class.cpp b/src/pybind11/tests/test_class.cpp
index f616ba7..499d0cc 100644
--- a/src/pybind11/tests/test_class.cpp
+++ b/src/pybind11/tests/test_class.cpp
@@ -9,10 +9,28 @@
 
 #include "pybind11_tests.h"
 #include "constructor_stats.h"
+#include "local_bindings.h"
+#include <pybind11/stl.h>
+
+#if defined(_MSC_VER)
+#  pragma warning(disable: 4324) // warning C4324: structure was padded due to alignment specifier
+#endif
+
+// test_brace_initialization
+struct NoBraceInitialization {
+    NoBraceInitialization(std::vector<int> v) : vec{std::move(v)} {}
+    template <typename T>
+    NoBraceInitialization(std::initializer_list<T> l) : vec(l) {}
+
+    std::vector<int> vec;
+};
 
 TEST_SUBMODULE(class_, m) {
     // test_instance
     struct NoConstructor {
+        NoConstructor() = default;
+        NoConstructor(const NoConstructor &) = default;
+        NoConstructor(NoConstructor &&) = default;
         static NoConstructor *new_instance() {
             auto *ptr = new NoConstructor();
             print_created(ptr, "via new_instance");
@@ -81,7 +99,12 @@ TEST_SUBMODULE(class_, m) {
     m.def("dog_bark", [](const Dog &dog) { return dog.bark(); });
 
     // test_automatic_upcasting
-    struct BaseClass { virtual ~BaseClass() {} };
+    struct BaseClass {
+        BaseClass() = default;
+        BaseClass(const BaseClass &) = default;
+        BaseClass(BaseClass &&) = default;
+        virtual ~BaseClass() {}
+    };
     struct DerivedClass1 : BaseClass { };
     struct DerivedClass2 : BaseClass { };
 
@@ -184,9 +207,169 @@ TEST_SUBMODULE(class_, m) {
         auto def = new PyMethodDef{"f", f, METH_VARARGS, nullptr};
         return py::reinterpret_steal<py::object>(PyCFunction_NewEx(def, nullptr, m.ptr()));
     }());
+
+    // test_operator_new_delete
+    struct HasOpNewDel {
+        std::uint64_t i;
+        static void *operator new(size_t s) { py::print("A new", s); return ::operator new(s); }
+        static void *operator new(size_t s, void *ptr) { py::print("A placement-new", s); return ptr; }
+        static void operator delete(void *p) { py::print("A delete"); return ::operator delete(p); }
+    };
+    struct HasOpNewDelSize {
+        std::uint32_t i;
+        static void *operator new(size_t s) { py::print("B new", s); return ::operator new(s); }
+        static void *operator new(size_t s, void *ptr) { py::print("B placement-new", s); return ptr; }
+        static void operator delete(void *p, size_t s) { py::print("B delete", s); return ::operator delete(p); }
+    };
+    struct AliasedHasOpNewDelSize {
+        std::uint64_t i;
+        static void *operator new(size_t s) { py::print("C new", s); return ::operator new(s); }
+        static void *operator new(size_t s, void *ptr) { py::print("C placement-new", s); return ptr; }
+        static void operator delete(void *p, size_t s) { py::print("C delete", s); return ::operator delete(p); }
+        virtual ~AliasedHasOpNewDelSize() = default;
+    };
+    struct PyAliasedHasOpNewDelSize : AliasedHasOpNewDelSize {
+        PyAliasedHasOpNewDelSize() = default;
+        PyAliasedHasOpNewDelSize(int) { }
+        std::uint64_t j;
+    };
+    struct HasOpNewDelBoth {
+        std::uint32_t i[8];
+        static void *operator new(size_t s) { py::print("D new", s); return ::operator new(s); }
+        static void *operator new(size_t s, void *ptr) { py::print("D placement-new", s); return ptr; }
+        static void operator delete(void *p) { py::print("D delete"); return ::operator delete(p); }
+        static void operator delete(void *p, size_t s) { py::print("D wrong delete", s); return ::operator delete(p); }
+    };
+    py::class_<HasOpNewDel>(m, "HasOpNewDel").def(py::init<>());
+    py::class_<HasOpNewDelSize>(m, "HasOpNewDelSize").def(py::init<>());
+    py::class_<HasOpNewDelBoth>(m, "HasOpNewDelBoth").def(py::init<>());
+    py::class_<AliasedHasOpNewDelSize, PyAliasedHasOpNewDelSize> aliased(m, "AliasedHasOpNewDelSize");
+    aliased.def(py::init<>());
+    aliased.attr("size_noalias") = py::int_(sizeof(AliasedHasOpNewDelSize));
+    aliased.attr("size_alias") = py::int_(sizeof(PyAliasedHasOpNewDelSize));
+
+    // This test is actually part of test_local_bindings (test_duplicate_local), but we need a
+    // definition in a different compilation unit within the same module:
+    bind_local<LocalExternal, 17>(m, "LocalExternal", py::module_local());
+
+    // test_bind_protected_functions
+    class ProtectedA {
+    protected:
+        int foo() const { return value; }
+
+    private:
+        int value = 42;
+    };
+
+    class PublicistA : public ProtectedA {
+    public:
+        using ProtectedA::foo;
+    };
+
+    py::class_<ProtectedA>(m, "ProtectedA")
+        .def(py::init<>())
+#if !defined(_MSC_VER) || _MSC_VER >= 1910
+        .def("foo", &PublicistA::foo);
+#else
+        .def("foo", static_cast<int (ProtectedA::*)() const>(&PublicistA::foo));
+#endif
+
+    class ProtectedB {
+    public:
+        virtual ~ProtectedB() = default;
+
+    protected:
+        virtual int foo() const { return value; }
+
+    private:
+        int value = 42;
+    };
+
+    class TrampolineB : public ProtectedB {
+    public:
+        int foo() const override { PYBIND11_OVERLOAD(int, ProtectedB, foo, ); }
+    };
+
+    class PublicistB : public ProtectedB {
+    public:
+        using ProtectedB::foo;
+    };
+
+    py::class_<ProtectedB, TrampolineB>(m, "ProtectedB")
+        .def(py::init<>())
+#if !defined(_MSC_VER) || _MSC_VER >= 1910
+        .def("foo", &PublicistB::foo);
+#else
+        .def("foo", static_cast<int (ProtectedB::*)() const>(&PublicistB::foo));
+#endif
+
+    // test_brace_initialization
+    struct BraceInitialization {
+        int field1;
+        std::string field2;
+    };
+
+    py::class_<BraceInitialization>(m, "BraceInitialization")
+        .def(py::init<int, const std::string &>())
+        .def_readwrite("field1", &BraceInitialization::field1)
+        .def_readwrite("field2", &BraceInitialization::field2);
+    // We *don't* want to construct using braces when the given constructor argument maps to a
+    // constructor, because brace initialization could go to the wrong place (in particular when
+    // there is also an `initializer_list<T>`-accept constructor):
+    py::class_<NoBraceInitialization>(m, "NoBraceInitialization")
+        .def(py::init<std::vector<int>>())
+        .def_readonly("vec", &NoBraceInitialization::vec);
+
+    // test_reentrant_implicit_conversion_failure
+    // #1035: issue with runaway reentrant implicit conversion
+    struct BogusImplicitConversion {
+        BogusImplicitConversion(const BogusImplicitConversion &) { }
+    };
+
+    py::class_<BogusImplicitConversion>(m, "BogusImplicitConversion")
+        .def(py::init<const BogusImplicitConversion &>());
+
+    py::implicitly_convertible<int, BogusImplicitConversion>();
+
+    // test_qualname
+    // #1166: nested class docstring doesn't show nested name
+    // Also related: tests that __qualname__ is set properly
+    struct NestBase {};
+    struct Nested {};
+    py::class_<NestBase> base(m, "NestBase");
+    base.def(py::init<>());
+    py::class_<Nested>(base, "Nested")
+        .def(py::init<>())
+        .def("fn", [](Nested &, int, NestBase &, Nested &) {})
+        .def("fa", [](Nested &, int, NestBase &, Nested &) {},
+                "a"_a, "b"_a, "c"_a);
+    base.def("g", [](NestBase &, Nested &) {});
+    base.def("h", []() { return NestBase(); });
+
+    // test_error_after_conversion
+    // The second-pass path through dispatcher() previously didn't
+    // remember which overload was used, and would crash trying to
+    // generate a useful error message
+
+    struct NotRegistered {};
+    struct StringWrapper { std::string str; };
+    m.def("test_error_after_conversions", [](int) {});
+    m.def("test_error_after_conversions",
+          [](StringWrapper) -> NotRegistered { return {}; });
+    py::class_<StringWrapper>(m, "StringWrapper").def(py::init<std::string>());
+    py::implicitly_convertible<std::string, StringWrapper>();
+
+    #if defined(PYBIND11_CPP17)
+        struct alignas(1024) Aligned {
+            std::uintptr_t ptr() const { return (uintptr_t) this; }
+        };
+        py::class_<Aligned>(m, "Aligned")
+            .def(py::init<>())
+            .def("ptr", &Aligned::ptr);
+    #endif
 }
 
-template <int N> class BreaksBase {};
+template <int N> class BreaksBase { public: virtual ~BreaksBase() = default; };
 template <int N> class BreaksTramp : public BreaksBase<N> {};
 // These should all compile just fine:
 typedef py::class_<BreaksBase<1>, std::unique_ptr<BreaksBase<1>>, BreaksTramp<1>> DoesntBreak1;
diff --git a/src/pybind11/tests/test_class.py b/src/pybind11/tests/test_class.py
index 611a287..ed63ca8 100644
--- a/src/pybind11/tests/test_class.py
+++ b/src/pybind11/tests/test_class.py
@@ -35,7 +35,7 @@ def test_docstrings(doc):
 
         Get value using a method
     """
-    assert doc(UserType.value) == "Get value using a property"
+    assert doc(UserType.value) == "Get/set value using a property"
 
     assert doc(m.NoConstructor.new_instance) == """
         new_instance() -> m.class_.NoConstructor
@@ -44,6 +44,31 @@ def test_docstrings(doc):
     """
 
 
+def test_qualname(doc):
+    """Tests that a properly qualified name is set in __qualname__ (even in pre-3.3, where we
+    backport the attribute) and that generated docstrings properly use it and the module name"""
+    assert m.NestBase.__qualname__ == "NestBase"
+    assert m.NestBase.Nested.__qualname__ == "NestBase.Nested"
+
+    assert doc(m.NestBase.__init__) == """
+        __init__(self: m.class_.NestBase) -> None
+    """
+    assert doc(m.NestBase.g) == """
+        g(self: m.class_.NestBase, arg0: m.class_.NestBase.Nested) -> None
+    """
+    assert doc(m.NestBase.Nested.__init__) == """
+        __init__(self: m.class_.NestBase.Nested) -> None
+    """
+    assert doc(m.NestBase.Nested.fn) == """
+        fn(self: m.class_.NestBase.Nested, arg0: int, arg1: m.class_.NestBase, arg2: m.class_.NestBase.Nested) -> None
+    """  # noqa: E501 line too long
+    assert doc(m.NestBase.Nested.fa) == """
+        fa(self: m.class_.NestBase.Nested, a: int, b: m.class_.NestBase, c: m.class_.NestBase.Nested) -> None
+    """  # noqa: E501 line too long
+    assert m.NestBase.__module__ == "pybind11_tests.class_"
+    assert m.NestBase.Nested.__module__ == "pybind11_tests.class_"
+
+
 def test_inheritance(msg):
     roger = m.Rabbit('Rabbit')
     assert roger.name() + " is a " + roger.species() == "Rabbit is a parrot"
@@ -127,3 +152,130 @@ def test_implicit_conversion_life_support():
     assert m.implicitly_convert_variable(UserType(5)) == 5
 
     assert "outside a bound function" in m.implicitly_convert_variable_fail(UserType(5))
+
+
+def test_operator_new_delete(capture):
+    """Tests that class-specific operator new/delete functions are invoked"""
+
+    class SubAliased(m.AliasedHasOpNewDelSize):
+        pass
+
+    with capture:
+        a = m.HasOpNewDel()
+        b = m.HasOpNewDelSize()
+        d = m.HasOpNewDelBoth()
+    assert capture == """
+        A new 8
+        B new 4
+        D new 32
+    """
+    sz_alias = str(m.AliasedHasOpNewDelSize.size_alias)
+    sz_noalias = str(m.AliasedHasOpNewDelSize.size_noalias)
+    with capture:
+        c = m.AliasedHasOpNewDelSize()
+        c2 = SubAliased()
+    assert capture == (
+        "C new " + sz_noalias + "\n" +
+        "C new " + sz_alias + "\n"
+    )
+
+    with capture:
+        del a
+        pytest.gc_collect()
+        del b
+        pytest.gc_collect()
+        del d
+        pytest.gc_collect()
+    assert capture == """
+        A delete
+        B delete 4
+        D delete
+    """
+
+    with capture:
+        del c
+        pytest.gc_collect()
+        del c2
+        pytest.gc_collect()
+    assert capture == (
+        "C delete " + sz_noalias + "\n" +
+        "C delete " + sz_alias + "\n"
+    )
+
+
+def test_bind_protected_functions():
+    """Expose protected member functions to Python using a helper class"""
+    a = m.ProtectedA()
+    assert a.foo() == 42
+
+    b = m.ProtectedB()
+    assert b.foo() == 42
+
+    class C(m.ProtectedB):
+        def __init__(self):
+            m.ProtectedB.__init__(self)
+
+        def foo(self):
+            return 0
+
+    c = C()
+    assert c.foo() == 0
+
+
+def test_brace_initialization():
+    """ Tests that simple POD classes can be constructed using C++11 brace initialization """
+    a = m.BraceInitialization(123, "test")
+    assert a.field1 == 123
+    assert a.field2 == "test"
+
+    # Tests that a non-simple class doesn't get brace initialization (if the
+    # class defines an initializer_list constructor, in particular, it would
+    # win over the expected constructor).
+    b = m.NoBraceInitialization([123, 456])
+    assert b.vec == [123, 456]
+
+
+@pytest.unsupported_on_pypy
+def test_class_refcount():
+    """Instances must correctly increase/decrease the reference count of their types (#1029)"""
+    from sys import getrefcount
+
+    class PyDog(m.Dog):
+        pass
+
+    for cls in m.Dog, PyDog:
+        refcount_1 = getrefcount(cls)
+        molly = [cls("Molly") for _ in range(10)]
+        refcount_2 = getrefcount(cls)
+
+        del molly
+        pytest.gc_collect()
+        refcount_3 = getrefcount(cls)
+
+        assert refcount_1 == refcount_3
+        assert refcount_2 > refcount_1
+
+
+def test_reentrant_implicit_conversion_failure(msg):
+    # ensure that there is no runaway reentrant implicit conversion (#1035)
+    with pytest.raises(TypeError) as excinfo:
+        m.BogusImplicitConversion(0)
+    assert msg(excinfo.value) == '''
+        __init__(): incompatible constructor arguments. The following argument types are supported:
+            1. m.class_.BogusImplicitConversion(arg0: m.class_.BogusImplicitConversion)
+
+        Invoked with: 0
+    '''
+
+
+def test_error_after_conversions():
+    with pytest.raises(TypeError) as exc_info:
+        m.test_error_after_conversions("hello")
+    assert str(exc_info.value).startswith(
+        "Unable to convert function return value to a Python type!")
+
+
+def test_aligned():
+    if hasattr(m, "Aligned"):
+        p = m.Aligned().ptr()
+        assert p % 1024 == 0
diff --git a/src/pybind11/tests/test_cmake_build/subdirectory_embed/CMakeLists.txt b/src/pybind11/tests/test_cmake_build/subdirectory_embed/CMakeLists.txt
index 7b3babb..88ba60d 100644
--- a/src/pybind11/tests/test_cmake_build/subdirectory_embed/CMakeLists.txt
+++ b/src/pybind11/tests/test_cmake_build/subdirectory_embed/CMakeLists.txt
@@ -1,9 +1,25 @@
 cmake_minimum_required(VERSION 3.0)
 project(test_subdirectory_embed CXX)
 
+set(PYBIND11_INSTALL ON CACHE BOOL "")
+set(PYBIND11_EXPORT_NAME test_export)
+
 add_subdirectory(${PYBIND11_PROJECT_DIR} pybind11)
 
+# Test basic target functionality
 add_executable(test_cmake_build ../embed.cpp)
 target_link_libraries(test_cmake_build PRIVATE pybind11::embed)
 
 add_custom_target(check $<TARGET_FILE:test_cmake_build> ${PROJECT_SOURCE_DIR}/../test.py)
+
+# Test custom export group -- PYBIND11_EXPORT_NAME
+add_library(test_embed_lib ../embed.cpp)
+target_link_libraries(test_embed_lib PRIVATE pybind11::embed)
+
+install(TARGETS test_embed_lib
+        EXPORT  test_export
+        ARCHIVE DESTINATION bin
+        LIBRARY DESTINATION lib
+        RUNTIME DESTINATION lib)
+install(EXPORT      test_export
+        DESTINATION lib/cmake/test_export/test_export-Targets.cmake)
diff --git a/src/pybind11/tests/test_constants_and_functions.cpp b/src/pybind11/tests/test_constants_and_functions.cpp
index 653bdf6..e8ec74b 100644
--- a/src/pybind11/tests/test_constants_and_functions.cpp
+++ b/src/pybind11/tests/test_constants_and_functions.cpp
@@ -23,6 +23,8 @@ std::string test_function3(int i) {
     return "test_function(" + std::to_string(i) + ")";
 }
 
+py::str test_function4()           { return "test_function()"; }
+py::str test_function4(char *)     { return "test_function(char *)"; }
 py::str test_function4(int, float) { return "test_function(int, float)"; }
 py::str test_function4(float, int) { return "test_function(float, int)"; }
 
@@ -47,7 +49,14 @@ namespace test_exc_sp {
 int f1(int x) noexcept { return x+1; }
 int f2(int x) noexcept(true) { return x+2; }
 int f3(int x) noexcept(false) { return x+3; }
+#if defined(__GNUG__)
+#  pragma GCC diagnostic push
+#  pragma GCC diagnostic ignored "-Wdeprecated"
+#endif
 int f4(int x) throw() { return x+4; } // Deprecated equivalent to noexcept(true)
+#if defined(__GNUG__)
+#  pragma GCC diagnostic pop
+#endif
 struct C {
     int m1(int x) noexcept { return x-1; }
     int m2(int x) const noexcept { return x-2; }
@@ -55,23 +64,36 @@ struct C {
     int m4(int x) const noexcept(true) { return x-4; }
     int m5(int x) noexcept(false) { return x-5; }
     int m6(int x) const noexcept(false) { return x-6; }
+#if defined(__GNUG__)
+#  pragma GCC diagnostic push
+#  pragma GCC diagnostic ignored "-Wdeprecated"
+#endif
     int m7(int x) throw() { return x-7; }
     int m8(int x) const throw() { return x-8; }
+#if defined(__GNUG__)
+#  pragma GCC diagnostic pop
+#endif
 };
 }
 
 
-test_initializer constants_and_functions([](py::module &m) {
+TEST_SUBMODULE(constants_and_functions, m) {
+    // test_constants
     m.attr("some_constant") = py::int_(14);
 
+    // test_function_overloading
     m.def("test_function", &test_function1);
     m.def("test_function", &test_function2);
     m.def("test_function", &test_function3);
 
 #if defined(PYBIND11_OVERLOAD_CAST)
+    m.def("test_function", py::overload_cast<>(&test_function4));
+    m.def("test_function", py::overload_cast<char *>(&test_function4));
     m.def("test_function", py::overload_cast<int, float>(&test_function4));
     m.def("test_function", py::overload_cast<float, int>(&test_function4));
 #else
+    m.def("test_function", static_cast<py::str (*)()>(&test_function4));
+    m.def("test_function", static_cast<py::str (*)(char *)>(&test_function4));
     m.def("test_function", static_cast<py::str (*)(int, float)>(&test_function4));
     m.def("test_function", static_cast<py::str (*)(float, int)>(&test_function4));
 #endif
@@ -81,12 +103,13 @@ test_initializer constants_and_functions([](py::module &m) {
         .value("ESecondEntry", ESecondEntry)
         .export_values();
 
+    // test_bytes
     m.def("return_bytes", &return_bytes);
     m.def("print_bytes", &print_bytes);
 
+    // test_exception_specifiers
     using namespace test_exc_sp;
-    py::module m2 = m.def_submodule("exc_sp");
-    py::class_<C>(m2, "C")
+    py::class_<C>(m, "C")
         .def(py::init<>())
         .def("m1", &C::m1)
         .def("m2", &C::m2)
@@ -97,8 +120,8 @@ test_initializer constants_and_functions([](py::module &m) {
         .def("m7", &C::m7)
         .def("m8", &C::m8)
         ;
-    m2.def("f1", f1);
-    m2.def("f2", f2);
-    m2.def("f3", f3);
-    m2.def("f4", f4);
-});
+    m.def("f1", f1);
+    m.def("f2", f2);
+    m.def("f3", f3);
+    m.def("f4", f4);
+}
diff --git a/src/pybind11/tests/test_constants_and_functions.py b/src/pybind11/tests/test_constants_and_functions.py
index 2a570d2..472682d 100644
--- a/src/pybind11/tests/test_constants_and_functions.py
+++ b/src/pybind11/tests/test_constants_and_functions.py
@@ -1,33 +1,29 @@
+from pybind11_tests import constants_and_functions as m
 
 
 def test_constants():
-    from pybind11_tests import some_constant
-
-    assert some_constant == 14
+    assert m.some_constant == 14
 
 
 def test_function_overloading():
-    from pybind11_tests import MyEnum, test_function
-
-    assert test_function() == "test_function()"
-    assert test_function(7) == "test_function(7)"
-    assert test_function(MyEnum.EFirstEntry) == "test_function(enum=1)"
-    assert test_function(MyEnum.ESecondEntry) == "test_function(enum=2)"
+    assert m.test_function() == "test_function()"
+    assert m.test_function(7) == "test_function(7)"
+    assert m.test_function(m.MyEnum.EFirstEntry) == "test_function(enum=1)"
+    assert m.test_function(m.MyEnum.ESecondEntry) == "test_function(enum=2)"
 
-    assert test_function(1, 1.0) == "test_function(int, float)"
-    assert test_function(2.0, 2) == "test_function(float, int)"
+    assert m.test_function() == "test_function()"
+    assert m.test_function("abcd") == "test_function(char *)"
+    assert m.test_function(1, 1.0) == "test_function(int, float)"
+    assert m.test_function(1, 1.0) == "test_function(int, float)"
+    assert m.test_function(2.0, 2) == "test_function(float, int)"
 
 
 def test_bytes():
-    from pybind11_tests import return_bytes, print_bytes
-
-    assert print_bytes(return_bytes()) == "bytes[1 0 2 0]"
+    assert m.print_bytes(m.return_bytes()) == "bytes[1 0 2 0]"
 
 
 def test_exception_specifiers():
-    from pybind11_tests.exc_sp import C, f1, f2, f3, f4
-
-    c = C()
+    c = m.C()
     assert c.m1(2) == 1
     assert c.m2(3) == 1
     assert c.m3(5) == 2
@@ -37,7 +33,7 @@ def test_exception_specifiers():
     assert c.m7(20) == 13
     assert c.m8(29) == 21
 
-    assert f1(33) == 34
-    assert f2(53) == 55
-    assert f3(86) == 89
-    assert f4(140) == 144
+    assert m.f1(33) == 34
+    assert m.f2(53) == 55
+    assert m.f3(86) == 89
+    assert m.f4(140) == 144
diff --git a/src/pybind11/tests/test_copy_move.cpp b/src/pybind11/tests/test_copy_move.cpp
index e80cdb8..98d5e0a 100644
--- a/src/pybind11/tests/test_copy_move.cpp
+++ b/src/pybind11/tests/test_copy_move.cpp
@@ -68,7 +68,8 @@ public:
 
     int value;
 };
-namespace pybind11 { namespace detail {
+NAMESPACE_BEGIN(pybind11)
+NAMESPACE_BEGIN(detail)
 template <> struct type_caster<MoveOnlyInt> {
     PYBIND11_TYPE_CASTER(MoveOnlyInt, _("MoveOnlyInt"));
     bool load(handle src, bool) { value = MoveOnlyInt(src.cast<int>()); return true; }
@@ -85,7 +86,7 @@ template <> struct type_caster<CopyOnlyInt> {
 protected:
     CopyOnlyInt value;
 public:
-    static PYBIND11_DESCR name() { return _("CopyOnlyInt"); }
+    static constexpr auto name = _("CopyOnlyInt");
     bool load(handle src, bool) { value = CopyOnlyInt(src.cast<int>()); return true; }
     static handle cast(const CopyOnlyInt &m, return_value_policy r, handle p) { return pybind11::cast(m.value, r, p); }
     static handle cast(const CopyOnlyInt *src, return_value_policy policy, handle parent) {
@@ -96,32 +97,20 @@ public:
     operator CopyOnlyInt&() { return value; }
     template <typename T> using cast_op_type = pybind11::detail::cast_op_type<T>;
 };
-}}
+NAMESPACE_END(detail)
+NAMESPACE_END(pybind11)
 
-struct PrivateOpNew {
-    int value = 1;
-
-private:
-    void *operator new(size_t bytes);
-};
-
-test_initializer copy_move_policies([](py::module &m) {
+TEST_SUBMODULE(copy_move_policies, m) {
+    // test_lacking_copy_ctor
     py::class_<lacking_copy_ctor>(m, "lacking_copy_ctor")
         .def_static("get_one", &lacking_copy_ctor::get_one,
                     py::return_value_policy::copy);
+    // test_lacking_move_ctor
     py::class_<lacking_move_ctor>(m, "lacking_move_ctor")
         .def_static("get_one", &lacking_move_ctor::get_one,
                     py::return_value_policy::move);
 
-    m.def("move_only", [](MoveOnlyInt m) {
-        return m.value;
-    });
-    m.def("move_or_copy", [](MoveOrCopyInt m) {
-        return m.value;
-    });
-    m.def("copy_only", [](CopyOnlyInt m) {
-        return m.value;
-    });
+    // test_move_and_copy_casts
     m.def("move_and_copy_casts", [](py::object o) {
         int r = 0;
         r += py::cast<MoveOrCopyInt>(o).value; /* moves */
@@ -134,6 +123,11 @@ test_initializer copy_move_policies([](py::module &m) {
 
         return r;
     });
+
+    // test_move_and_copy_loads
+    m.def("move_only", [](MoveOnlyInt m) { return m.value; });
+    m.def("move_or_copy", [](MoveOrCopyInt m) { return m.value; });
+    m.def("copy_only", [](CopyOnlyInt m) { return m.value; });
     m.def("move_pair", [](std::pair<MoveOnlyInt, MoveOrCopyInt> p) {
         return p.first.value + p.second.value;
     });
@@ -163,6 +157,7 @@ test_initializer copy_move_policies([](py::module &m) {
         return d;
     });
 #ifdef PYBIND11_HAS_OPTIONAL
+    // test_move_and_copy_load_optional
     m.attr("has_optional") = true;
     m.def("move_optional", [](std::optional<MoveOnlyInt> o) {
         return o->value;
@@ -181,6 +176,14 @@ test_initializer copy_move_policies([](py::module &m) {
 #endif
 
     // #70 compilation issue if operator new is not public
+    struct PrivateOpNew {
+        int value = 1;
+    private:
+#if defined(_MSC_VER)
+#  pragma warning(disable: 4822) // warning C4822: local class member function does not have a body
+#endif
+        void *operator new(size_t bytes);
+    };
     py::class_<PrivateOpNew>(m, "PrivateOpNew").def_readonly("value", &PrivateOpNew::value);
     m.def("private_op_new_value", []() { return PrivateOpNew(); });
     m.def("private_op_new_reference", []() -> const PrivateOpNew & {
@@ -188,6 +191,7 @@ test_initializer copy_move_policies([](py::module &m) {
         return x;
     }, py::return_value_policy::reference);
 
+    // test_move_fallback
     // #389: rvp::move should fall-through to copy on non-movable objects
     struct MoveIssue1 {
         int v;
@@ -195,15 +199,15 @@ test_initializer copy_move_policies([](py::module &m) {
         MoveIssue1(const MoveIssue1 &c) = default;
         MoveIssue1(MoveIssue1 &&) = delete;
     };
+    py::class_<MoveIssue1>(m, "MoveIssue1").def(py::init<int>()).def_readwrite("value", &MoveIssue1::v);
 
     struct MoveIssue2 {
         int v;
         MoveIssue2(int v) : v{v} {}
         MoveIssue2(MoveIssue2 &&) = default;
     };
-
-    py::class_<MoveIssue1>(m, "MoveIssue1").def(py::init<int>()).def_readwrite("value", &MoveIssue1::v);
     py::class_<MoveIssue2>(m, "MoveIssue2").def(py::init<int>()).def_readwrite("value", &MoveIssue2::v);
+
     m.def("get_moveissue1", [](int i) { return new MoveIssue1(i); }, py::return_value_policy::move);
     m.def("get_moveissue2", [](int i) { return MoveIssue2(i); }, py::return_value_policy::move);
-});
+}
diff --git a/src/pybind11/tests/test_copy_move.py b/src/pybind11/tests/test_copy_move.py
index 452f6fb..0e671d9 100644
--- a/src/pybind11/tests/test_copy_move.py
+++ b/src/pybind11/tests/test_copy_move.py
@@ -1,63 +1,58 @@
 import pytest
-from pybind11_tests import has_optional
+from pybind11_tests import copy_move_policies as m
 
 
 def test_lacking_copy_ctor():
-    from pybind11_tests import lacking_copy_ctor
     with pytest.raises(RuntimeError) as excinfo:
-        lacking_copy_ctor.get_one()
-    assert "the object is non-copyable!" in str(excinfo.value)
+        m.lacking_copy_ctor.get_one()
+    assert "is non-copyable!" in str(excinfo.value)
 
 
 def test_lacking_move_ctor():
-    from pybind11_tests import lacking_move_ctor
     with pytest.raises(RuntimeError) as excinfo:
-        lacking_move_ctor.get_one()
-    assert "the object is neither movable nor copyable!" in str(excinfo.value)
+        m.lacking_move_ctor.get_one()
+    assert "is neither movable nor copyable!" in str(excinfo.value)
 
 
 def test_move_and_copy_casts():
     """Cast some values in C++ via custom type casters and count the number of moves/copies."""
-    from pybind11_tests import move_and_copy_casts, move_and_copy_cstats
 
-    cstats = move_and_copy_cstats()
+    cstats = m.move_and_copy_cstats()
     c_m, c_mc, c_c = cstats["MoveOnlyInt"], cstats["MoveOrCopyInt"], cstats["CopyOnlyInt"]
 
     # The type move constructions/assignments below each get incremented: the move assignment comes
     # from the type_caster load; the move construction happens when extracting that via a cast or
     # loading into an argument.
-    assert move_and_copy_casts(3) == 18
+    assert m.move_and_copy_casts(3) == 18
     assert c_m.copy_assignments + c_m.copy_constructions == 0
     assert c_m.move_assignments == 2
-    assert c_m.move_constructions == 2
+    assert c_m.move_constructions >= 2
     assert c_mc.alive() == 0
     assert c_mc.copy_assignments + c_mc.copy_constructions == 0
     assert c_mc.move_assignments == 2
-    assert c_mc.move_constructions == 2
+    assert c_mc.move_constructions >= 2
     assert c_c.alive() == 0
     assert c_c.copy_assignments == 2
-    assert c_c.copy_constructions == 2
+    assert c_c.copy_constructions >= 2
     assert c_m.alive() + c_mc.alive() + c_c.alive() == 0
 
 
 def test_move_and_copy_loads():
     """Call some functions that load arguments via custom type casters and count the number of
     moves/copies."""
-    from pybind11_tests import (move_and_copy_cstats, move_only, move_or_copy, copy_only,
-                                move_pair, move_tuple, copy_tuple, move_copy_nested)
 
-    cstats = move_and_copy_cstats()
+    cstats = m.move_and_copy_cstats()
     c_m, c_mc, c_c = cstats["MoveOnlyInt"], cstats["MoveOrCopyInt"], cstats["CopyOnlyInt"]
 
-    assert move_only(10) == 10  # 1 move, c_m
-    assert move_or_copy(11) == 11  # 1 move, c_mc
-    assert copy_only(12) == 12  # 1 copy, c_c
-    assert move_pair((13, 14)) == 27  # 1 c_m move, 1 c_mc move
-    assert move_tuple((15, 16, 17)) == 48  # 2 c_m moves, 1 c_mc move
-    assert copy_tuple((18, 19)) == 37  # 2 c_c copies
+    assert m.move_only(10) == 10  # 1 move, c_m
+    assert m.move_or_copy(11) == 11  # 1 move, c_mc
+    assert m.copy_only(12) == 12  # 1 copy, c_c
+    assert m.move_pair((13, 14)) == 27  # 1 c_m move, 1 c_mc move
+    assert m.move_tuple((15, 16, 17)) == 48  # 2 c_m moves, 1 c_mc move
+    assert m.copy_tuple((18, 19)) == 37  # 2 c_c copies
     # Direct constructions: 2 c_m moves, 2 c_mc moves, 1 c_c copy
     # Extra moves/copies when moving pairs/tuples: 3 c_m, 3 c_mc, 2 c_c
-    assert move_copy_nested((1, ((2, 3, (4,)), 5))) == 15
+    assert m.move_copy_nested((1, ((2, 3, (4,)), 5))) == 15
 
     assert c_m.copy_assignments + c_m.copy_constructions == 0
     assert c_m.move_assignments == 6
@@ -70,24 +65,22 @@ def test_move_and_copy_loads():
     assert c_m.alive() + c_mc.alive() + c_c.alive() == 0
 
 
-@pytest.mark.skipif(not has_optional, reason='no <optional>')
+@pytest.mark.skipif(not m.has_optional, reason='no <optional>')
 def test_move_and_copy_load_optional():
     """Tests move/copy loads of std::optional arguments"""
-    from pybind11_tests import (move_and_copy_cstats, move_optional, move_or_copy_optional,
-                                copy_optional, move_optional_tuple)
 
-    cstats = move_and_copy_cstats()
+    cstats = m.move_and_copy_cstats()
     c_m, c_mc, c_c = cstats["MoveOnlyInt"], cstats["MoveOrCopyInt"], cstats["CopyOnlyInt"]
 
     # The extra move/copy constructions below come from the std::optional move (which has to move
     # its arguments):
-    assert move_optional(10) == 10  # c_m: 1 move assign, 2 move construct
-    assert move_or_copy_optional(11) == 11  # c_mc: 1 move assign, 2 move construct
-    assert copy_optional(12) == 12  # c_c: 1 copy assign, 2 copy construct
+    assert m.move_optional(10) == 10  # c_m: 1 move assign, 2 move construct
+    assert m.move_or_copy_optional(11) == 11  # c_mc: 1 move assign, 2 move construct
+    assert m.copy_optional(12) == 12  # c_c: 1 copy assign, 2 copy construct
     # 1 move assign + move construct moves each of c_m, c_mc, 1 c_c copy
     # +1 move/copy construct each from moving the tuple
     # +1 move/copy construct each from moving the optional (which moves the tuple again)
-    assert move_optional_tuple((3, 4, 5)) == 12
+    assert m.move_optional_tuple((3, 4, 5)) == 12
 
     assert c_m.copy_assignments + c_m.copy_constructions == 0
     assert c_m.move_assignments == 2
@@ -102,20 +95,18 @@ def test_move_and_copy_load_optional():
 
 def test_private_op_new():
     """An object with a private `operator new` cannot be returned by value"""
-    import pybind11_tests as m
 
     with pytest.raises(RuntimeError) as excinfo:
         m.private_op_new_value()
-    assert "the object is neither movable nor copyable" in str(excinfo.value)
+    assert "is neither movable nor copyable" in str(excinfo.value)
 
     assert m.private_op_new_reference().value == 1
 
 
 def test_move_fallback():
     """#389: rvp::move should fall-through to copy on non-movable objects"""
-    from pybind11_tests import get_moveissue1, get_moveissue2
 
-    m2 = get_moveissue2(2)
+    m2 = m.get_moveissue2(2)
     assert m2.value == 2
-    m1 = get_moveissue1(1)
+    m1 = m.get_moveissue1(1)
     assert m1.value == 1
diff --git a/src/pybind11/tests/test_docstring_options.cpp b/src/pybind11/tests/test_docstring_options.cpp
index 9a9297c..8c8f79f 100644
--- a/src/pybind11/tests/test_docstring_options.cpp
+++ b/src/pybind11/tests/test_docstring_options.cpp
@@ -9,14 +9,8 @@
 
 #include "pybind11_tests.h"
 
-struct DocstringTestFoo {
-    int value;
-    void setValue(int v) { value = v; }
-    int getValue() const { return value; }
-};
-
-test_initializer docstring_generation([](py::module &m) {
-
+TEST_SUBMODULE(docstring_options, m) {
+    // test_docstring_options
     {
         py::options options;
         options.disable_function_signatures();
@@ -55,8 +49,13 @@ test_initializer docstring_generation([](py::module &m) {
         py::options options;
         options.disable_user_defined_docstrings();
 
+        struct DocstringTestFoo {
+            int value;
+            void setValue(int v) { value = v; }
+            int getValue() const { return value; }
+        };
         py::class_<DocstringTestFoo>(m, "DocstringTestFoo", "This is a class docstring")
             .def_property("value_prop", &DocstringTestFoo::getValue, &DocstringTestFoo::setValue, "This is a property docstring")
         ;
     }
-});
+}
diff --git a/src/pybind11/tests/test_docstring_options.py b/src/pybind11/tests/test_docstring_options.py
index 5e40f68..0dbca60 100644
--- a/src/pybind11/tests/test_docstring_options.py
+++ b/src/pybind11/tests/test_docstring_options.py
@@ -1,42 +1,38 @@
+from pybind11_tests import docstring_options as m
 
 
 def test_docstring_options():
-    from pybind11_tests import (test_function1, test_function2, test_function3,
-                                test_function4, test_function5, test_function6,
-                                test_function7, DocstringTestFoo,
-                                test_overloaded1, test_overloaded2, test_overloaded3)
-
     # options.disable_function_signatures()
-    assert not test_function1.__doc__
+    assert not m.test_function1.__doc__
 
-    assert test_function2.__doc__ == "A custom docstring"
+    assert m.test_function2.__doc__ == "A custom docstring"
 
     # docstring specified on just the first overload definition:
-    assert test_overloaded1.__doc__ == "Overload docstring"
+    assert m.test_overloaded1.__doc__ == "Overload docstring"
 
     # docstring on both overloads:
-    assert test_overloaded2.__doc__ == "overload docstring 1\noverload docstring 2"
+    assert m.test_overloaded2.__doc__ == "overload docstring 1\noverload docstring 2"
 
     # docstring on only second overload:
-    assert test_overloaded3.__doc__ == "Overload docstr"
+    assert m.test_overloaded3.__doc__ == "Overload docstr"
 
     # options.enable_function_signatures()
-    assert test_function3.__doc__ .startswith("test_function3(a: int, b: int) -> None")
+    assert m.test_function3.__doc__ .startswith("test_function3(a: int, b: int) -> None")
 
-    assert test_function4.__doc__ .startswith("test_function4(a: int, b: int) -> None")
-    assert test_function4.__doc__ .endswith("A custom docstring\n")
+    assert m.test_function4.__doc__ .startswith("test_function4(a: int, b: int) -> None")
+    assert m.test_function4.__doc__ .endswith("A custom docstring\n")
 
     # options.disable_function_signatures()
     # options.disable_user_defined_docstrings()
-    assert not test_function5.__doc__
+    assert not m.test_function5.__doc__
 
     # nested options.enable_user_defined_docstrings()
-    assert test_function6.__doc__ == "A custom docstring"
+    assert m.test_function6.__doc__ == "A custom docstring"
 
     # RAII destructor
-    assert test_function7.__doc__ .startswith("test_function7(a: int, b: int) -> None")
-    assert test_function7.__doc__ .endswith("A custom docstring\n")
+    assert m.test_function7.__doc__ .startswith("test_function7(a: int, b: int) -> None")
+    assert m.test_function7.__doc__ .endswith("A custom docstring\n")
 
     # Suppression of user-defined docstrings for non-function objects
-    assert not DocstringTestFoo.__doc__
-    assert not DocstringTestFoo.value_prop.__doc__
+    assert not m.DocstringTestFoo.__doc__
+    assert not m.DocstringTestFoo.value_prop.__doc__
diff --git a/src/pybind11/tests/test_eigen.cpp b/src/pybind11/tests/test_eigen.cpp
index 413fed3..aba088d 100644
--- a/src/pybind11/tests/test_eigen.cpp
+++ b/src/pybind11/tests/test_eigen.cpp
@@ -11,6 +11,11 @@
 #include "constructor_stats.h"
 #include <pybind11/eigen.h>
 #include <pybind11/stl.h>
+
+#if defined(_MSC_VER)
+#  pragma warning(disable: 4996) // C4996: std::unary_negation is deprecated
+#endif
+
 #include <Eigen/Cholesky>
 
 using MatrixXdR = Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>;
@@ -70,20 +75,21 @@ struct CustomOperatorNew {
     EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
 };
 
-test_initializer eigen([](py::module &m) {
-    typedef Eigen::Matrix<float, 5, 6, Eigen::RowMajor> FixedMatrixR;
-    typedef Eigen::Matrix<float, 5, 6> FixedMatrixC;
-    typedef Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor> DenseMatrixR;
-    typedef Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic> DenseMatrixC;
-    typedef Eigen::Matrix<float, 4, Eigen::Dynamic> FourRowMatrixC;
-    typedef Eigen::Matrix<float, Eigen::Dynamic, 4> FourColMatrixC;
-    typedef Eigen::Matrix<float, 4, Eigen::Dynamic> FourRowMatrixR;
-    typedef Eigen::Matrix<float, Eigen::Dynamic, 4> FourColMatrixR;
-    typedef Eigen::SparseMatrix<float, Eigen::RowMajor> SparseMatrixR;
-    typedef Eigen::SparseMatrix<float> SparseMatrixC;
+TEST_SUBMODULE(eigen, m) {
+    using FixedMatrixR = Eigen::Matrix<float, 5, 6, Eigen::RowMajor>;
+    using FixedMatrixC = Eigen::Matrix<float, 5, 6>;
+    using DenseMatrixR = Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>;
+    using DenseMatrixC = Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic>;
+    using FourRowMatrixC = Eigen::Matrix<float, 4, Eigen::Dynamic>;
+    using FourColMatrixC = Eigen::Matrix<float, Eigen::Dynamic, 4>;
+    using FourRowMatrixR = Eigen::Matrix<float, 4, Eigen::Dynamic>;
+    using FourColMatrixR = Eigen::Matrix<float, Eigen::Dynamic, 4>;
+    using SparseMatrixR = Eigen::SparseMatrix<float, Eigen::RowMajor>;
+    using SparseMatrixC = Eigen::SparseMatrix<float>;
 
     m.attr("have_eigen") = true;
 
+    // various tests
     m.def("double_col", [](const Eigen::VectorXf &x) -> Eigen::VectorXf { return 2.0f * x; });
     m.def("double_row", [](const Eigen::RowVectorXf &x) -> Eigen::RowVectorXf { return 2.0f * x; });
     m.def("double_complex", [](const Eigen::VectorXcf &x) -> Eigen::VectorXcf { return 2.0f * x; });
@@ -92,12 +98,14 @@ test_initializer eigen([](py::module &m) {
     m.def("double_mat_cm", [](Eigen::MatrixXf x) -> Eigen::MatrixXf { return 2.0f * x; });
     m.def("double_mat_rm", [](DenseMatrixR x) -> DenseMatrixR { return 2.0f * x; });
 
+    // test_eigen_ref_to_python
     // Different ways of passing via Eigen::Ref; the first and second are the Eigen-recommended
     m.def("cholesky1", [](Eigen::Ref<MatrixXdR> x) -> Eigen::MatrixXd { return x.llt().matrixL(); });
     m.def("cholesky2", [](const Eigen::Ref<const MatrixXdR> &x) -> Eigen::MatrixXd { return x.llt().matrixL(); });
     m.def("cholesky3", [](const Eigen::Ref<MatrixXdR> &x) -> Eigen::MatrixXd { return x.llt().matrixL(); });
     m.def("cholesky4", [](Eigen::Ref<const MatrixXdR> x) -> Eigen::MatrixXd { return x.llt().matrixL(); });
 
+    // test_eigen_ref_mutators
     // Mutators: these add some value to the given element using Eigen, but Eigen should be mapping into
     // the numpy array data and so the result should show up there.  There are three versions: one that
     // works on a contiguous-row matrix (numpy's default), one for a contiguous-column matrix, and one
@@ -116,25 +124,12 @@ test_initializer eigen([](py::module &m) {
     // This one accepts a matrix of any stride:
     m.def("add_any", [](py::EigenDRef<Eigen::MatrixXd> x, int r, int c, double v) { x(r,c) += v; });
 
-    // Return mutable references (numpy maps into eigen varibles)
+    // Return mutable references (numpy maps into eigen variables)
     m.def("get_cm_ref", []() { return Eigen::Ref<Eigen::MatrixXd>(get_cm()); });
     m.def("get_rm_ref", []() { return Eigen::Ref<MatrixXdR>(get_rm()); });
     // The same references, but non-mutable (numpy maps into eigen variables, but is !writeable)
     m.def("get_cm_const_ref", []() { return Eigen::Ref<const Eigen::MatrixXd>(get_cm()); });
     m.def("get_rm_const_ref", []() { return Eigen::Ref<const MatrixXdR>(get_rm()); });
-    // Just the corners (via a Map instead of a Ref):
-    m.def("get_cm_corners", []() {
-        auto &x = get_cm();
-        return py::EigenDMap<Eigen::Matrix2d>(
-                x.data(),
-                py::EigenDStride(x.outerStride() * (x.rows() - 1), x.innerStride() * (x.cols() - 1)));
-    });
-    m.def("get_cm_corners_const", []() {
-        const auto &x = get_cm();
-        return py::EigenDMap<const Eigen::Matrix2d>(
-                x.data(),
-                py::EigenDStride(x.outerStride() * (x.rows() - 1), x.innerStride() * (x.cols() - 1)));
-    });
 
     m.def("reset_refs", reset_refs); // Restores get_{cm,rm}_ref to original values
 
@@ -174,6 +169,7 @@ test_initializer eigen([](py::module &m) {
         return x.block(start_row, start_col, block_rows, block_cols);
     });
 
+    // test_eigen_return_references, test_eigen_keepalive
     // return value referencing/copying tests:
     class ReturnTester {
         Eigen::MatrixXd mat = create();
@@ -220,6 +216,7 @@ test_initializer eigen([](py::module &m) {
         .def("corners_const", &ReturnTester::cornersConst, rvp::reference_internal)
         ;
 
+    // test_special_matrix_objects
     // Returns a DiagonalMatrix with diagonal (1,2,3,...)
     m.def("incr_diag", [](int k) {
         Eigen::DiagonalMatrix<int, Eigen::Dynamic> m(k);
@@ -244,27 +241,33 @@ test_initializer eigen([](py::module &m) {
            0,  0,  0,  0,  0, 11,
            0,  0, 14,  0,  8, 11;
 
+    // test_fixed, and various other tests
     m.def("fixed_r", [mat]() -> FixedMatrixR { return FixedMatrixR(mat); });
     m.def("fixed_r_const", [mat]() -> const FixedMatrixR { return FixedMatrixR(mat); });
     m.def("fixed_c", [mat]() -> FixedMatrixC { return FixedMatrixC(mat); });
     m.def("fixed_copy_r", [](const FixedMatrixR &m) -> FixedMatrixR { return m; });
     m.def("fixed_copy_c", [](const FixedMatrixC &m) -> FixedMatrixC { return m; });
+    // test_mutator_descriptors
     m.def("fixed_mutator_r", [](Eigen::Ref<FixedMatrixR>) {});
     m.def("fixed_mutator_c", [](Eigen::Ref<FixedMatrixC>) {});
     m.def("fixed_mutator_a", [](py::EigenDRef<FixedMatrixC>) {});
+    // test_dense
     m.def("dense_r", [mat]() -> DenseMatrixR { return DenseMatrixR(mat); });
     m.def("dense_c", [mat]() -> DenseMatrixC { return DenseMatrixC(mat); });
     m.def("dense_copy_r", [](const DenseMatrixR &m) -> DenseMatrixR { return m; });
     m.def("dense_copy_c", [](const DenseMatrixC &m) -> DenseMatrixC { return m; });
+    // test_sparse, test_sparse_signature
     m.def("sparse_r", [mat]() -> SparseMatrixR { return Eigen::SparseView<Eigen::MatrixXf>(mat); });
     m.def("sparse_c", [mat]() -> SparseMatrixC { return Eigen::SparseView<Eigen::MatrixXf>(mat); });
     m.def("sparse_copy_r", [](const SparseMatrixR &m) -> SparseMatrixR { return m; });
     m.def("sparse_copy_c", [](const SparseMatrixC &m) -> SparseMatrixC { return m; });
+    // test_partially_fixed
     m.def("partial_copy_four_rm_r", [](const FourRowMatrixR &m) -> FourRowMatrixR { return m; });
     m.def("partial_copy_four_rm_c", [](const FourColMatrixR &m) -> FourColMatrixR { return m; });
     m.def("partial_copy_four_cm_r", [](const FourRowMatrixC &m) -> FourRowMatrixC { return m; });
     m.def("partial_copy_four_cm_c", [](const FourColMatrixC &m) -> FourColMatrixC { return m; });
 
+    // test_cpp_casting
     // Test that we can cast a numpy object to a Eigen::MatrixXd explicitly
     m.def("cpp_copy", [](py::handle m) { return m.cast<Eigen::MatrixXd>()(1, 0); });
     m.def("cpp_ref_c", [](py::handle m) { return m.cast<Eigen::Ref<Eigen::MatrixXd>>()(1, 0); });
@@ -272,6 +275,7 @@ test_initializer eigen([](py::module &m) {
     m.def("cpp_ref_any", [](py::handle m) { return m.cast<py::EigenDRef<Eigen::MatrixXd>>()(1, 0); });
 
 
+    // test_nocopy_wrapper
     // Test that we can prevent copying into an argument that would normally copy: First a version
     // that would allow copying (if types or strides don't match) for comparison:
     m.def("get_elem", &get_elem);
@@ -282,12 +286,21 @@ test_initializer eigen([](py::module &m) {
     m.def("get_elem_rm_nocopy", [](Eigen::Ref<const Eigen::Matrix<long, -1, -1, Eigen::RowMajor>> &m) -> long { return m(2, 1); },
             py::arg().noconvert());
 
+    // test_issue738
     // Issue #738: 1xN or Nx1 2D matrices were neither accepted nor properly copied with an
     // incompatible stride value on the length-1 dimension--but that should be allowed (without
     // requiring a copy!) because the stride value can be safely ignored on a size-1 dimension.
     m.def("iss738_f1", &adjust_matrix<const Eigen::Ref<const Eigen::MatrixXd> &>, py::arg().noconvert());
     m.def("iss738_f2", &adjust_matrix<const Eigen::Ref<const Eigen::Matrix<double, -1, -1, Eigen::RowMajor>> &>, py::arg().noconvert());
 
+    // test_issue1105
+    // Issue #1105: when converting from a numpy two-dimensional (Nx1) or (1xN) value into a dense
+    // eigen Vector or RowVector, the argument would fail to load because the numpy copy would fail:
+    // numpy won't broadcast a Nx1 into a 1-dimensional vector.
+    m.def("iss1105_col", [](Eigen::VectorXd) { return true; });
+    m.def("iss1105_row", [](Eigen::RowVectorXd) { return true; });
+
+    // test_named_arguments
     // Make sure named arguments are working properly:
     m.def("matrix_multiply", [](const py::EigenDRef<const Eigen::MatrixXd> A, const py::EigenDRef<const Eigen::MatrixXd> B)
             -> Eigen::MatrixXd {
@@ -295,6 +308,7 @@ test_initializer eigen([](py::module &m) {
         return A * B;
     }, py::arg("A"), py::arg("B"));
 
+    // test_custom_operator_new
     py::class_<CustomOperatorNew>(m, "CustomOperatorNew")
         .def(py::init<>())
         .def_readonly("a", &CustomOperatorNew::a)
@@ -312,4 +326,4 @@ test_initializer eigen([](py::module &m) {
         py::module::import("numpy").attr("ones")(10);
         return v[0](5);
     });
-});
+}
diff --git a/src/pybind11/tests/test_eigen.py b/src/pybind11/tests/test_eigen.py
index c9fe69f..55d9351 100644
--- a/src/pybind11/tests/test_eigen.py
+++ b/src/pybind11/tests/test_eigen.py
@@ -1,8 +1,10 @@
 import pytest
+from pybind11_tests import ConstructorStats
 
 pytestmark = pytest.requires_eigen_and_numpy
 
 with pytest.suppress(ImportError):
+    from pybind11_tests import eigen as m
     import numpy as np
 
     ref = np.array([[ 0.,  3,  0,  0,  0, 11],
@@ -17,55 +19,48 @@ def assert_equal_ref(mat):
 
 
 def assert_sparse_equal_ref(sparse_mat):
-    assert_equal_ref(sparse_mat.todense())
+    assert_equal_ref(sparse_mat.toarray())
 
 
 def test_fixed():
-    from pybind11_tests import fixed_r, fixed_c, fixed_copy_r, fixed_copy_c
-
-    assert_equal_ref(fixed_c())
-    assert_equal_ref(fixed_r())
-    assert_equal_ref(fixed_copy_r(fixed_r()))
-    assert_equal_ref(fixed_copy_c(fixed_c()))
-    assert_equal_ref(fixed_copy_r(fixed_c()))
-    assert_equal_ref(fixed_copy_c(fixed_r()))
+    assert_equal_ref(m.fixed_c())
+    assert_equal_ref(m.fixed_r())
+    assert_equal_ref(m.fixed_copy_r(m.fixed_r()))
+    assert_equal_ref(m.fixed_copy_c(m.fixed_c()))
+    assert_equal_ref(m.fixed_copy_r(m.fixed_c()))
+    assert_equal_ref(m.fixed_copy_c(m.fixed_r()))
 
 
 def test_dense():
-    from pybind11_tests import dense_r, dense_c, dense_copy_r, dense_copy_c
-
-    assert_equal_ref(dense_r())
-    assert_equal_ref(dense_c())
-    assert_equal_ref(dense_copy_r(dense_r()))
-    assert_equal_ref(dense_copy_c(dense_c()))
-    assert_equal_ref(dense_copy_r(dense_c()))
-    assert_equal_ref(dense_copy_c(dense_r()))
+    assert_equal_ref(m.dense_r())
+    assert_equal_ref(m.dense_c())
+    assert_equal_ref(m.dense_copy_r(m.dense_r()))
+    assert_equal_ref(m.dense_copy_c(m.dense_c()))
+    assert_equal_ref(m.dense_copy_r(m.dense_c()))
+    assert_equal_ref(m.dense_copy_c(m.dense_r()))
 
 
 def test_partially_fixed():
-    from pybind11_tests import (partial_copy_four_rm_r, partial_copy_four_rm_c,
-                                partial_copy_four_cm_r, partial_copy_four_cm_c)
-
     ref2 = np.array([[0., 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]])
-    np.testing.assert_array_equal(partial_copy_four_rm_r(ref2), ref2)
-    np.testing.assert_array_equal(partial_copy_four_rm_c(ref2), ref2)
-    np.testing.assert_array_equal(partial_copy_four_rm_r(ref2[:, 1]), ref2[:, [1]])
-    np.testing.assert_array_equal(partial_copy_four_rm_c(ref2[0, :]), ref2[[0], :])
-    np.testing.assert_array_equal(partial_copy_four_rm_r(ref2[:, (0, 2)]), ref2[:, (0, 2)])
+    np.testing.assert_array_equal(m.partial_copy_four_rm_r(ref2), ref2)
+    np.testing.assert_array_equal(m.partial_copy_four_rm_c(ref2), ref2)
+    np.testing.assert_array_equal(m.partial_copy_four_rm_r(ref2[:, 1]), ref2[:, [1]])
+    np.testing.assert_array_equal(m.partial_copy_four_rm_c(ref2[0, :]), ref2[[0], :])
+    np.testing.assert_array_equal(m.partial_copy_four_rm_r(ref2[:, (0, 2)]), ref2[:, (0, 2)])
     np.testing.assert_array_equal(
-        partial_copy_four_rm_c(ref2[(3, 1, 2), :]), ref2[(3, 1, 2), :])
+        m.partial_copy_four_rm_c(ref2[(3, 1, 2), :]), ref2[(3, 1, 2), :])
 
-    np.testing.assert_array_equal(partial_copy_four_cm_r(ref2), ref2)
-    np.testing.assert_array_equal(partial_copy_four_cm_c(ref2), ref2)
-    np.testing.assert_array_equal(partial_copy_four_cm_r(ref2[:, 1]), ref2[:, [1]])
-    np.testing.assert_array_equal(partial_copy_four_cm_c(ref2[0, :]), ref2[[0], :])
-    np.testing.assert_array_equal(partial_copy_four_cm_r(ref2[:, (0, 2)]), ref2[:, (0, 2)])
+    np.testing.assert_array_equal(m.partial_copy_four_cm_r(ref2), ref2)
+    np.testing.assert_array_equal(m.partial_copy_four_cm_c(ref2), ref2)
+    np.testing.assert_array_equal(m.partial_copy_four_cm_r(ref2[:, 1]), ref2[:, [1]])
+    np.testing.assert_array_equal(m.partial_copy_four_cm_c(ref2[0, :]), ref2[[0], :])
+    np.testing.assert_array_equal(m.partial_copy_four_cm_r(ref2[:, (0, 2)]), ref2[:, (0, 2)])
     np.testing.assert_array_equal(
-        partial_copy_four_cm_c(ref2[(3, 1, 2), :]), ref2[(3, 1, 2), :])
+        m.partial_copy_four_cm_c(ref2[(3, 1, 2), :]), ref2[(3, 1, 2), :])
 
     # TypeError should be raise for a shape mismatch
-    functions = [partial_copy_four_rm_r, partial_copy_four_rm_c,
-                 partial_copy_four_cm_r, partial_copy_four_cm_c]
+    functions = [m.partial_copy_four_rm_r, m.partial_copy_four_rm_c,
+                 m.partial_copy_four_cm_r, m.partial_copy_four_cm_c]
     matrix_with_wrong_shape = [[1, 2],
                                [3, 4]]
     for f in functions:
@@ -75,159 +70,141 @@ def test_partially_fixed():
 
 
 def test_mutator_descriptors():
-    from pybind11_tests import fixed_mutator_r, fixed_mutator_c, fixed_mutator_a
     zr = np.arange(30, dtype='float32').reshape(5, 6)  # row-major
     zc = zr.reshape(6, 5).transpose()  # column-major
 
-    fixed_mutator_r(zr)
-    fixed_mutator_c(zc)
-    fixed_mutator_a(zr)
-    fixed_mutator_a(zc)
+    m.fixed_mutator_r(zr)
+    m.fixed_mutator_c(zc)
+    m.fixed_mutator_a(zr)
+    m.fixed_mutator_a(zc)
     with pytest.raises(TypeError) as excinfo:
-        fixed_mutator_r(zc)
+        m.fixed_mutator_r(zc)
     assert ('(arg0: numpy.ndarray[float32[5, 6], flags.writeable, flags.c_contiguous]) -> None'
             in str(excinfo.value))
     with pytest.raises(TypeError) as excinfo:
-        fixed_mutator_c(zr)
+        m.fixed_mutator_c(zr)
     assert ('(arg0: numpy.ndarray[float32[5, 6], flags.writeable, flags.f_contiguous]) -> None'
             in str(excinfo.value))
     with pytest.raises(TypeError) as excinfo:
-        fixed_mutator_a(np.array([[1, 2], [3, 4]], dtype='float32'))
+        m.fixed_mutator_a(np.array([[1, 2], [3, 4]], dtype='float32'))
     assert ('(arg0: numpy.ndarray[float32[5, 6], flags.writeable]) -> None'
             in str(excinfo.value))
     zr.flags.writeable = False
     with pytest.raises(TypeError):
-        fixed_mutator_r(zr)
+        m.fixed_mutator_r(zr)
     with pytest.raises(TypeError):
-        fixed_mutator_a(zr)
+        m.fixed_mutator_a(zr)
 
 
 def test_cpp_casting():
-    from pybind11_tests import (cpp_copy, cpp_ref_c, cpp_ref_r, cpp_ref_any,
-                                fixed_r, fixed_c, get_cm_ref, get_rm_ref, ReturnTester)
-    assert cpp_copy(fixed_r()) == 22.
-    assert cpp_copy(fixed_c()) == 22.
+    assert m.cpp_copy(m.fixed_r()) == 22.
+    assert m.cpp_copy(m.fixed_c()) == 22.
     z = np.array([[5., 6], [7, 8]])
-    assert cpp_copy(z) == 7.
-    assert cpp_copy(get_cm_ref()) == 21.
-    assert cpp_copy(get_rm_ref()) == 21.
-    assert cpp_ref_c(get_cm_ref()) == 21.
-    assert cpp_ref_r(get_rm_ref()) == 21.
+    assert m.cpp_copy(z) == 7.
+    assert m.cpp_copy(m.get_cm_ref()) == 21.
+    assert m.cpp_copy(m.get_rm_ref()) == 21.
+    assert m.cpp_ref_c(m.get_cm_ref()) == 21.
+    assert m.cpp_ref_r(m.get_rm_ref()) == 21.
     with pytest.raises(RuntimeError) as excinfo:
-        # Can't reference fixed_c: it contains floats, cpp_ref_any wants doubles
-        cpp_ref_any(fixed_c())
+        # Can't reference m.fixed_c: it contains floats, m.cpp_ref_any wants doubles
+        m.cpp_ref_any(m.fixed_c())
     assert 'Unable to cast Python instance' in str(excinfo.value)
     with pytest.raises(RuntimeError) as excinfo:
-        # Can't reference fixed_r: it contains floats, cpp_ref_any wants doubles
-        cpp_ref_any(fixed_r())
+        # Can't reference m.fixed_r: it contains floats, m.cpp_ref_any wants doubles
+        m.cpp_ref_any(m.fixed_r())
     assert 'Unable to cast Python instance' in str(excinfo.value)
-    assert cpp_ref_any(ReturnTester.create()) == 1.
+    assert m.cpp_ref_any(m.ReturnTester.create()) == 1.
 
-    assert cpp_ref_any(get_cm_ref()) == 21.
-    assert cpp_ref_any(get_cm_ref()) == 21.
+    assert m.cpp_ref_any(m.get_cm_ref()) == 21.
+    assert m.cpp_ref_any(m.get_cm_ref()) == 21.
 
 
 def test_pass_readonly_array():
-    from pybind11_tests import fixed_copy_r, fixed_r, fixed_r_const
     z = np.full((5, 6), 42.0)
     z.flags.writeable = False
-    np.testing.assert_array_equal(z, fixed_copy_r(z))
-    np.testing.assert_array_equal(fixed_r_const(), fixed_r())
-    assert not fixed_r_const().flags.writeable
-    np.testing.assert_array_equal(fixed_copy_r(fixed_r_const()), fixed_r_const())
+    np.testing.assert_array_equal(z, m.fixed_copy_r(z))
+    np.testing.assert_array_equal(m.fixed_r_const(), m.fixed_r())
+    assert not m.fixed_r_const().flags.writeable
+    np.testing.assert_array_equal(m.fixed_copy_r(m.fixed_r_const()), m.fixed_r_const())
 
 
 def test_nonunit_stride_from_python():
-    from pybind11_tests import (
-        double_row, double_col, double_complex, double_mat_cm, double_mat_rm,
-        double_threec, double_threer)
-
     counting_mat = np.arange(9.0, dtype=np.float32).reshape((3, 3))
     second_row = counting_mat[1, :]
     second_col = counting_mat[:, 1]
-    np.testing.assert_array_equal(double_row(second_row), 2.0 * second_row)
-    np.testing.assert_array_equal(double_col(second_row), 2.0 * second_row)
-    np.testing.assert_array_equal(double_complex(second_row), 2.0 * second_row)
-    np.testing.assert_array_equal(double_row(second_col), 2.0 * second_col)
-    np.testing.assert_array_equal(double_col(second_col), 2.0 * second_col)
-    np.testing.assert_array_equal(double_complex(second_col), 2.0 * second_col)
+    np.testing.assert_array_equal(m.double_row(second_row), 2.0 * second_row)
+    np.testing.assert_array_equal(m.double_col(second_row), 2.0 * second_row)
+    np.testing.assert_array_equal(m.double_complex(second_row), 2.0 * second_row)
+    np.testing.assert_array_equal(m.double_row(second_col), 2.0 * second_col)
+    np.testing.assert_array_equal(m.double_col(second_col), 2.0 * second_col)
+    np.testing.assert_array_equal(m.double_complex(second_col), 2.0 * second_col)
 
     counting_3d = np.arange(27.0, dtype=np.float32).reshape((3, 3, 3))
     slices = [counting_3d[0, :, :], counting_3d[:, 0, :], counting_3d[:, :, 0]]
     for slice_idx, ref_mat in enumerate(slices):
-        np.testing.assert_array_equal(double_mat_cm(ref_mat), 2.0 * ref_mat)
-        np.testing.assert_array_equal(double_mat_rm(ref_mat), 2.0 * ref_mat)
+        np.testing.assert_array_equal(m.double_mat_cm(ref_mat), 2.0 * ref_mat)
+        np.testing.assert_array_equal(m.double_mat_rm(ref_mat), 2.0 * ref_mat)
 
     # Mutator:
-    double_threer(second_row)
-    double_threec(second_col)
+    m.double_threer(second_row)
+    m.double_threec(second_col)
     np.testing.assert_array_equal(counting_mat, [[0., 2, 2], [6, 16, 10], [6, 14, 8]])
 
 
 def test_negative_stride_from_python(msg):
-    from pybind11_tests import (
-        double_row, double_col, double_complex, double_mat_cm, double_mat_rm,
-        double_threec, double_threer)
-
-    # Eigen doesn't support (as of yet) negative strides. When a function takes an Eigen
-    # matrix by copy or const reference, we can pass a numpy array that has negative strides.
-    # Otherwise, an exception will be thrown as Eigen will not be able to map the numpy array.
+    """Eigen doesn't support (as of yet) negative strides. When a function takes an Eigen matrix by
+    copy or const reference, we can pass a numpy array that has negative strides.  Otherwise, an
+    exception will be thrown as Eigen will not be able to map the numpy array."""
 
     counting_mat = np.arange(9.0, dtype=np.float32).reshape((3, 3))
     counting_mat = counting_mat[::-1, ::-1]
     second_row = counting_mat[1, :]
     second_col = counting_mat[:, 1]
-    np.testing.assert_array_equal(double_row(second_row), 2.0 * second_row)
-    np.testing.assert_array_equal(double_col(second_row), 2.0 * second_row)
-    np.testing.assert_array_equal(double_complex(second_row), 2.0 * second_row)
-    np.testing.assert_array_equal(double_row(second_col), 2.0 * second_col)
-    np.testing.assert_array_equal(double_col(second_col), 2.0 * second_col)
-    np.testing.assert_array_equal(double_complex(second_col), 2.0 * second_col)
+    np.testing.assert_array_equal(m.double_row(second_row), 2.0 * second_row)
+    np.testing.assert_array_equal(m.double_col(second_row), 2.0 * second_row)
+    np.testing.assert_array_equal(m.double_complex(second_row), 2.0 * second_row)
+    np.testing.assert_array_equal(m.double_row(second_col), 2.0 * second_col)
+    np.testing.assert_array_equal(m.double_col(second_col), 2.0 * second_col)
+    np.testing.assert_array_equal(m.double_complex(second_col), 2.0 * second_col)
 
     counting_3d = np.arange(27.0, dtype=np.float32).reshape((3, 3, 3))
     counting_3d = counting_3d[::-1, ::-1, ::-1]
     slices = [counting_3d[0, :, :], counting_3d[:, 0, :], counting_3d[:, :, 0]]
     for slice_idx, ref_mat in enumerate(slices):
-        np.testing.assert_array_equal(double_mat_cm(ref_mat), 2.0 * ref_mat)
-        np.testing.assert_array_equal(double_mat_rm(ref_mat), 2.0 * ref_mat)
+        np.testing.assert_array_equal(m.double_mat_cm(ref_mat), 2.0 * ref_mat)
+        np.testing.assert_array_equal(m.double_mat_rm(ref_mat), 2.0 * ref_mat)
 
     # Mutator:
     with pytest.raises(TypeError) as excinfo:
-        double_threer(second_row)
+        m.double_threer(second_row)
     assert msg(excinfo.value) == """
-    double_threer(): incompatible function arguments. The following argument types are supported:
-        1. (arg0: numpy.ndarray[float32[1, 3], flags.writeable]) -> None
+        double_threer(): incompatible function arguments. The following argument types are supported:
+            1. (arg0: numpy.ndarray[float32[1, 3], flags.writeable]) -> None
 
-    Invoked with: array([ 5.,  4.,  3.], dtype=float32)
-"""
+        Invoked with: """ + repr(np.array([ 5.,  4.,  3.], dtype='float32'))  # noqa: E501 line too long
 
     with pytest.raises(TypeError) as excinfo:
-        double_threec(second_col)
+        m.double_threec(second_col)
     assert msg(excinfo.value) == """
-    double_threec(): incompatible function arguments. The following argument types are supported:
-        1. (arg0: numpy.ndarray[float32[3, 1], flags.writeable]) -> None
+        double_threec(): incompatible function arguments. The following argument types are supported:
+            1. (arg0: numpy.ndarray[float32[3, 1], flags.writeable]) -> None
 
-    Invoked with: array([ 7.,  4.,  1.], dtype=float32)
-"""
+        Invoked with: """ + repr(np.array([ 7.,  4.,  1.], dtype='float32'))  # noqa: E501 line too long
 
 
 def test_nonunit_stride_to_python():
-    from pybind11_tests import diagonal, diagonal_1, diagonal_n, block
-
-    assert np.all(diagonal(ref) == ref.diagonal())
-    assert np.all(diagonal_1(ref) == ref.diagonal(1))
+    assert np.all(m.diagonal(ref) == ref.diagonal())
+    assert np.all(m.diagonal_1(ref) == ref.diagonal(1))
     for i in range(-5, 7):
-        assert np.all(diagonal_n(ref, i) == ref.diagonal(i)), "diagonal_n({})".format(i)
+        assert np.all(m.diagonal_n(ref, i) == ref.diagonal(i)), "m.diagonal_n({})".format(i)
 
-    assert np.all(block(ref, 2, 1, 3, 3) == ref[2:5, 1:4])
-    assert np.all(block(ref, 1, 4, 4, 2) == ref[1:, 4:])
-    assert np.all(block(ref, 1, 4, 3, 2) == ref[1:4, 4:])
+    assert np.all(m.block(ref, 2, 1, 3, 3) == ref[2:5, 1:4])
+    assert np.all(m.block(ref, 1, 4, 4, 2) == ref[1:, 4:])
+    assert np.all(m.block(ref, 1, 4, 3, 2) == ref[1:4, 4:])
 
 
 def test_eigen_ref_to_python():
-    from pybind11_tests import cholesky1, cholesky2, cholesky3, cholesky4
-
-    chols = [cholesky1, cholesky2, cholesky3, cholesky4]
+    chols = [m.cholesky1, m.cholesky2, m.cholesky3, m.cholesky4]
     for i, chol in enumerate(chols, start=1):
         mymat = chol(np.array([[1., 2, 4], [2, 13, 23], [4, 23, 77]]))
         assert np.all(mymat == np.array([[1, 0, 0], [2, 3, 0], [4, 5, 6]])), "cholesky{}".format(i)
@@ -246,9 +223,9 @@ def array_copy_but_one(a, r, c, v):
 
 def test_eigen_return_references():
     """Tests various ways of returning references and non-referencing copies"""
-    from pybind11_tests import ReturnTester
+
     master = np.ones((10, 10))
-    a = ReturnTester()
+    a = m.ReturnTester()
     a_get1 = a.get()
     assert not a_get1.flags.owndata and a_get1.flags.writeable
     assign_both(a_get1, master, 3, 3, 5)
@@ -358,7 +335,6 @@ def test_eigen_return_references():
 
 
 def assert_keeps_alive(cl, method, *args):
-    from pybind11_tests import ConstructorStats
     cstats = ConstructorStats.get(cl)
     start_with = cstats.alive()
     a = cl()
@@ -374,10 +350,8 @@ def assert_keeps_alive(cl, method, *args):
 
 
 def test_eigen_keepalive():
-    from pybind11_tests import ReturnTester, ConstructorStats
-    a = ReturnTester()
-
-    cstats = ConstructorStats.get(ReturnTester)
+    a = m.ReturnTester()
+    cstats = ConstructorStats.get(m.ReturnTester)
     assert cstats.alive() == 1
     unsafe = [a.ref(), a.ref_const(), a.block(1, 2, 3, 4)]
     copies = [a.copy_get(), a.copy_view(), a.copy_ref(), a.copy_ref_const(),
@@ -387,43 +361,43 @@ def test_eigen_keepalive():
     del unsafe
     del copies
 
-    for meth in [ReturnTester.get, ReturnTester.get_ptr, ReturnTester.view,
-                 ReturnTester.view_ptr, ReturnTester.ref_safe, ReturnTester.ref_const_safe,
-                 ReturnTester.corners, ReturnTester.corners_const]:
-        assert_keeps_alive(ReturnTester, meth)
+    for meth in [m.ReturnTester.get, m.ReturnTester.get_ptr, m.ReturnTester.view,
+                 m.ReturnTester.view_ptr, m.ReturnTester.ref_safe, m.ReturnTester.ref_const_safe,
+                 m.ReturnTester.corners, m.ReturnTester.corners_const]:
+        assert_keeps_alive(m.ReturnTester, meth)
 
-    for meth in [ReturnTester.block_safe, ReturnTester.block_const]:
-        assert_keeps_alive(ReturnTester, meth, 4, 3, 2, 1)
+    for meth in [m.ReturnTester.block_safe, m.ReturnTester.block_const]:
+        assert_keeps_alive(m.ReturnTester, meth, 4, 3, 2, 1)
 
 
 def test_eigen_ref_mutators():
-    """Tests whether Eigen can mutate numpy values"""
-    from pybind11_tests import add_rm, add_cm, add_any, add1, add2
+    """Tests Eigen's ability to mutate numpy values"""
+
     orig = np.array([[1., 2, 3], [4, 5, 6], [7, 8, 9]])
     zr = np.array(orig)
     zc = np.array(orig, order='F')
-    add_rm(zr, 1, 0, 100)
+    m.add_rm(zr, 1, 0, 100)
     assert np.all(zr == np.array([[1., 2, 3], [104, 5, 6], [7, 8, 9]]))
-    add_cm(zc, 1, 0, 200)
+    m.add_cm(zc, 1, 0, 200)
     assert np.all(zc == np.array([[1., 2, 3], [204, 5, 6], [7, 8, 9]]))
 
-    add_any(zr, 1, 0, 20)
+    m.add_any(zr, 1, 0, 20)
     assert np.all(zr == np.array([[1., 2, 3], [124, 5, 6], [7, 8, 9]]))
-    add_any(zc, 1, 0, 10)
+    m.add_any(zc, 1, 0, 10)
     assert np.all(zc == np.array([[1., 2, 3], [214, 5, 6], [7, 8, 9]]))
 
     # Can't reference a col-major array with a row-major Ref, and vice versa:
     with pytest.raises(TypeError):
-        add_rm(zc, 1, 0, 1)
+        m.add_rm(zc, 1, 0, 1)
     with pytest.raises(TypeError):
-        add_cm(zr, 1, 0, 1)
+        m.add_cm(zr, 1, 0, 1)
 
     # Overloads:
-    add1(zr, 1, 0, -100)
-    add2(zr, 1, 0, -20)
+    m.add1(zr, 1, 0, -100)
+    m.add2(zr, 1, 0, -20)
     assert np.all(zr == orig)
-    add1(zc, 1, 0, -200)
-    add2(zc, 1, 0, -10)
+    m.add1(zc, 1, 0, -200)
+    m.add2(zc, 1, 0, -10)
     assert np.all(zc == orig)
 
     # a non-contiguous slice (this won't work on either the row- or
@@ -435,15 +409,15 @@ def test_eigen_ref_mutators():
     assert np.all(cornersc == np.array([[1., 3], [7, 9]]))
 
     with pytest.raises(TypeError):
-        add_rm(cornersr, 0, 1, 25)
+        m.add_rm(cornersr, 0, 1, 25)
     with pytest.raises(TypeError):
-        add_cm(cornersr, 0, 1, 25)
+        m.add_cm(cornersr, 0, 1, 25)
     with pytest.raises(TypeError):
-        add_rm(cornersc, 0, 1, 25)
+        m.add_rm(cornersc, 0, 1, 25)
     with pytest.raises(TypeError):
-        add_cm(cornersc, 0, 1, 25)
-    add_any(cornersr, 0, 1, 25)
-    add_any(cornersc, 0, 1, 44)
+        m.add_cm(cornersc, 0, 1, 25)
+    m.add_any(cornersr, 0, 1, 25)
+    m.add_any(cornersc, 0, 1, 44)
     assert np.all(zr == np.array([[1., 2, 28], [4, 5, 6], [7, 8, 9]]))
     assert np.all(zc == np.array([[1., 2, 47], [4, 5, 6], [7, 8, 9]]))
 
@@ -451,30 +425,29 @@ def test_eigen_ref_mutators():
     zro = zr[0:4, 0:4]
     zro.flags.writeable = False
     with pytest.raises(TypeError):
-        add_rm(zro, 0, 0, 0)
+        m.add_rm(zro, 0, 0, 0)
     with pytest.raises(TypeError):
-        add_any(zro, 0, 0, 0)
+        m.add_any(zro, 0, 0, 0)
     with pytest.raises(TypeError):
-        add1(zro, 0, 0, 0)
+        m.add1(zro, 0, 0, 0)
     with pytest.raises(TypeError):
-        add2(zro, 0, 0, 0)
+        m.add2(zro, 0, 0, 0)
 
     # integer array shouldn't be passable to a double-matrix-accepting mutating func:
     zi = np.array([[1, 2], [3, 4]])
     with pytest.raises(TypeError):
-        add_rm(zi)
+        m.add_rm(zi)
 
 
 def test_numpy_ref_mutators():
     """Tests numpy mutating Eigen matrices (for returned Eigen::Ref<...>s)"""
-    from pybind11_tests import (
-        get_cm_ref, get_cm_const_ref, get_rm_ref, get_rm_const_ref, reset_refs)
-    reset_refs()  # In case another test already changed it
 
-    zc = get_cm_ref()
-    zcro = get_cm_const_ref()
-    zr = get_rm_ref()
-    zrro = get_rm_const_ref()
+    m.reset_refs()  # In case another test already changed it
+
+    zc = m.get_cm_ref()
+    zcro = m.get_cm_const_ref()
+    zr = m.get_rm_ref()
+    zrro = m.get_rm_const_ref()
 
     assert [zc[1, 2], zcro[1, 2], zr[1, 2], zrro[1, 2]] == [23] * 4
 
@@ -488,12 +461,12 @@ def test_numpy_ref_mutators():
     # We should have just changed zc, of course, but also zcro and the original eigen matrix
     assert np.all(zc == expect)
     assert np.all(zcro == expect)
-    assert np.all(get_cm_ref() == expect)
+    assert np.all(m.get_cm_ref() == expect)
 
     zr[1, 2] = 99
     assert np.all(zr == expect)
     assert np.all(zrro == expect)
-    assert np.all(get_rm_ref() == expect)
+    assert np.all(m.get_rm_ref() == expect)
 
     # Make sure the readonly ones are numpy-readonly:
     with pytest.raises(ValueError):
@@ -503,7 +476,7 @@ def test_numpy_ref_mutators():
 
     # We should be able to explicitly copy like this (and since we're copying,
     # the const should drop away)
-    y1 = np.array(get_cm_const_ref())
+    y1 = np.array(m.get_cm_const_ref())
 
     assert y1.flags.owndata and y1.flags.writeable
     # We should get copies of the eigen data, which was modified above:
@@ -515,19 +488,18 @@ def test_numpy_ref_mutators():
 
 def test_both_ref_mutators():
     """Tests a complex chain of nested eigen/numpy references"""
-    from pybind11_tests import (
-        incr_matrix, get_cm_ref, incr_matrix_any, even_cols, even_rows, reset_refs)
-    reset_refs()  # In case another test already changed it
 
-    z = get_cm_ref()  # numpy -> eigen
+    m.reset_refs()  # In case another test already changed it
+
+    z = m.get_cm_ref()  # numpy -> eigen
     z[0, 2] -= 3
-    z2 = incr_matrix(z, 1)  # numpy -> eigen -> numpy -> eigen
+    z2 = m.incr_matrix(z, 1)  # numpy -> eigen -> numpy -> eigen
     z2[1, 1] += 6
-    z3 = incr_matrix(z, 2)  # (numpy -> eigen)^3
+    z3 = m.incr_matrix(z, 2)  # (numpy -> eigen)^3
     z3[2, 2] += -5
-    z4 = incr_matrix(z, 3)  # (numpy -> eigen)^4
+    z4 = m.incr_matrix(z, 3)  # (numpy -> eigen)^4
     z4[1, 1] -= 1
-    z5 = incr_matrix(z, 4)  # (numpy -> eigen)^5
+    z5 = m.incr_matrix(z, 4)  # (numpy -> eigen)^5
     z5[0, 0] = 0
     assert np.all(z == z2)
     assert np.all(z == z3)
@@ -537,11 +509,11 @@ def test_both_ref_mutators():
     assert np.all(z == expect)
 
     y = np.array(range(100), dtype='float64').reshape(10, 10)
-    y2 = incr_matrix_any(y, 10)  # np -> eigen -> np
-    y3 = incr_matrix_any(y2[0::2, 0::2], -33)  # np -> eigen -> np slice -> np -> eigen -> np
-    y4 = even_rows(y3)  # numpy -> eigen slice -> (... y3)
-    y5 = even_cols(y4)  # numpy -> eigen slice -> (... y4)
-    y6 = incr_matrix_any(y5, 1000)  # numpy -> eigen -> (... y5)
+    y2 = m.incr_matrix_any(y, 10)  # np -> eigen -> np
+    y3 = m.incr_matrix_any(y2[0::2, 0::2], -33)  # np -> eigen -> np slice -> np -> eigen -> np
+    y4 = m.even_rows(y3)  # numpy -> eigen slice -> (... y3)
+    y5 = m.even_cols(y4)  # numpy -> eigen slice -> (... y4)
+    y6 = m.incr_matrix_any(y5, 1000)  # numpy -> eigen -> (... y5)
 
     # Apply same mutations using just numpy:
     yexpect = np.array(range(100), dtype='float64').reshape(10, 10)
@@ -557,7 +529,6 @@ def test_both_ref_mutators():
 
 
 def test_nocopy_wrapper():
-    from pybind11_tests import get_elem, get_elem_nocopy, get_elem_rm_nocopy
     # get_elem requires a column-contiguous matrix reference, but should be
     # callable with other types of matrix (via copying):
     int_matrix_colmajor = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]], order='F')
@@ -566,38 +537,38 @@ def test_nocopy_wrapper():
     dbl_matrix_rowmajor = np.array(int_matrix_rowmajor, dtype='double', order='C', copy=True)
 
     # All should be callable via get_elem:
-    assert get_elem(int_matrix_colmajor) == 8
-    assert get_elem(dbl_matrix_colmajor) == 8
-    assert get_elem(int_matrix_rowmajor) == 8
-    assert get_elem(dbl_matrix_rowmajor) == 8
+    assert m.get_elem(int_matrix_colmajor) == 8
+    assert m.get_elem(dbl_matrix_colmajor) == 8
+    assert m.get_elem(int_matrix_rowmajor) == 8
+    assert m.get_elem(dbl_matrix_rowmajor) == 8
 
-    # All but the second should fail with get_elem_nocopy:
+    # All but the second should fail with m.get_elem_nocopy:
     with pytest.raises(TypeError) as excinfo:
-        get_elem_nocopy(int_matrix_colmajor)
+        m.get_elem_nocopy(int_matrix_colmajor)
     assert ('get_elem_nocopy(): incompatible function arguments.' in str(excinfo.value) and
             ', flags.f_contiguous' in str(excinfo.value))
-    assert get_elem_nocopy(dbl_matrix_colmajor) == 8
+    assert m.get_elem_nocopy(dbl_matrix_colmajor) == 8
     with pytest.raises(TypeError) as excinfo:
-        get_elem_nocopy(int_matrix_rowmajor)
+        m.get_elem_nocopy(int_matrix_rowmajor)
     assert ('get_elem_nocopy(): incompatible function arguments.' in str(excinfo.value) and
             ', flags.f_contiguous' in str(excinfo.value))
     with pytest.raises(TypeError) as excinfo:
-        get_elem_nocopy(dbl_matrix_rowmajor)
+        m.get_elem_nocopy(dbl_matrix_rowmajor)
     assert ('get_elem_nocopy(): incompatible function arguments.' in str(excinfo.value) and
             ', flags.f_contiguous' in str(excinfo.value))
 
     # For the row-major test, we take a long matrix in row-major, so only the third is allowed:
     with pytest.raises(TypeError) as excinfo:
-        get_elem_rm_nocopy(int_matrix_colmajor)
+        m.get_elem_rm_nocopy(int_matrix_colmajor)
     assert ('get_elem_rm_nocopy(): incompatible function arguments.' in str(excinfo.value) and
             ', flags.c_contiguous' in str(excinfo.value))
     with pytest.raises(TypeError) as excinfo:
-        get_elem_rm_nocopy(dbl_matrix_colmajor)
+        m.get_elem_rm_nocopy(dbl_matrix_colmajor)
     assert ('get_elem_rm_nocopy(): incompatible function arguments.' in str(excinfo.value) and
             ', flags.c_contiguous' in str(excinfo.value))
-    assert get_elem_rm_nocopy(int_matrix_rowmajor) == 8
+    assert m.get_elem_rm_nocopy(int_matrix_rowmajor) == 8
     with pytest.raises(TypeError) as excinfo:
-        get_elem_rm_nocopy(dbl_matrix_rowmajor)
+        m.get_elem_rm_nocopy(dbl_matrix_rowmajor)
     assert ('get_elem_rm_nocopy(): incompatible function arguments.' in str(excinfo.value) and
             ', flags.c_contiguous' in str(excinfo.value))
 
@@ -608,19 +579,16 @@ def test_eigen_ref_life_support():
     The `Ref` caster sometimes creates a copy which needs to stay alive. This needs to
     happen both for directs casts (just the array) or indirectly (e.g. list of arrays).
     """
-    from pybind11_tests import get_elem_direct, get_elem_indirect
 
     a = np.full(shape=10, fill_value=8, dtype=np.int8)
-    assert get_elem_direct(a) == 8
+    assert m.get_elem_direct(a) == 8
 
     list_of_a = [a]
-    assert get_elem_indirect(list_of_a) == 8
+    assert m.get_elem_indirect(list_of_a) == 8
 
 
 def test_special_matrix_objects():
-    from pybind11_tests import incr_diag, symmetric_upper, symmetric_lower
-
-    assert np.all(incr_diag(7) == np.diag([1., 2, 3, 4, 5, 6, 7]))
+    assert np.all(m.incr_diag(7) == np.diag([1., 2, 3, 4, 5, 6, 7]))
 
     asymm = np.array([[ 1.,  2,  3,  4],
                       [ 5,  6,  7,  8],
@@ -633,89 +601,94 @@ def test_special_matrix_objects():
             symm_lower[i, j] = symm_lower[j, i]
             symm_upper[j, i] = symm_upper[i, j]
 
-    assert np.all(symmetric_lower(asymm) == symm_lower)
-    assert np.all(symmetric_upper(asymm) == symm_upper)
+    assert np.all(m.symmetric_lower(asymm) == symm_lower)
+    assert np.all(m.symmetric_upper(asymm) == symm_upper)
 
 
 def test_dense_signature(doc):
-    from pybind11_tests import double_col, double_row, double_complex, double_mat_rm
-
-    assert doc(double_col) == """
+    assert doc(m.double_col) == """
         double_col(arg0: numpy.ndarray[float32[m, 1]]) -> numpy.ndarray[float32[m, 1]]
     """
-    assert doc(double_row) == """
+    assert doc(m.double_row) == """
         double_row(arg0: numpy.ndarray[float32[1, n]]) -> numpy.ndarray[float32[1, n]]
     """
-    assert doc(double_complex) == """
+    assert doc(m.double_complex) == """
         double_complex(arg0: numpy.ndarray[complex64[m, 1]]) -> numpy.ndarray[complex64[m, 1]]
     """
-    assert doc(double_mat_rm) == """
+    assert doc(m.double_mat_rm) == """
         double_mat_rm(arg0: numpy.ndarray[float32[m, n]]) -> numpy.ndarray[float32[m, n]]
     """
 
 
 def test_named_arguments():
-    from pybind11_tests import matrix_multiply
-
     a = np.array([[1.0, 2], [3, 4], [5, 6]])
     b = np.ones((2, 1))
 
-    assert np.all(matrix_multiply(a, b) == np.array([[3.], [7], [11]]))
-    assert np.all(matrix_multiply(A=a, B=b) == np.array([[3.], [7], [11]]))
-    assert np.all(matrix_multiply(B=b, A=a) == np.array([[3.], [7], [11]]))
+    assert np.all(m.matrix_multiply(a, b) == np.array([[3.], [7], [11]]))
+    assert np.all(m.matrix_multiply(A=a, B=b) == np.array([[3.], [7], [11]]))
+    assert np.all(m.matrix_multiply(B=b, A=a) == np.array([[3.], [7], [11]]))
 
     with pytest.raises(ValueError) as excinfo:
-        matrix_multiply(b, a)
+        m.matrix_multiply(b, a)
     assert str(excinfo.value) == 'Nonconformable matrices!'
 
     with pytest.raises(ValueError) as excinfo:
-        matrix_multiply(A=b, B=a)
+        m.matrix_multiply(A=b, B=a)
     assert str(excinfo.value) == 'Nonconformable matrices!'
 
     with pytest.raises(ValueError) as excinfo:
-        matrix_multiply(B=a, A=b)
+        m.matrix_multiply(B=a, A=b)
     assert str(excinfo.value) == 'Nonconformable matrices!'
 
 
 @pytest.requires_eigen_and_scipy
 def test_sparse():
-    from pybind11_tests import sparse_r, sparse_c, sparse_copy_r, sparse_copy_c
-
-    assert_sparse_equal_ref(sparse_r())
-    assert_sparse_equal_ref(sparse_c())
-    assert_sparse_equal_ref(sparse_copy_r(sparse_r()))
-    assert_sparse_equal_ref(sparse_copy_c(sparse_c()))
-    assert_sparse_equal_ref(sparse_copy_r(sparse_c()))
-    assert_sparse_equal_ref(sparse_copy_c(sparse_r()))
+    assert_sparse_equal_ref(m.sparse_r())
+    assert_sparse_equal_ref(m.sparse_c())
+    assert_sparse_equal_ref(m.sparse_copy_r(m.sparse_r()))
+    assert_sparse_equal_ref(m.sparse_copy_c(m.sparse_c()))
+    assert_sparse_equal_ref(m.sparse_copy_r(m.sparse_c()))
+    assert_sparse_equal_ref(m.sparse_copy_c(m.sparse_r()))
 
 
 @pytest.requires_eigen_and_scipy
 def test_sparse_signature(doc):
-    from pybind11_tests import sparse_copy_r, sparse_copy_c
-
-    assert doc(sparse_copy_r) == """
+    assert doc(m.sparse_copy_r) == """
         sparse_copy_r(arg0: scipy.sparse.csr_matrix[float32]) -> scipy.sparse.csr_matrix[float32]
     """  # noqa: E501 line too long
-    assert doc(sparse_copy_c) == """
+    assert doc(m.sparse_copy_c) == """
         sparse_copy_c(arg0: scipy.sparse.csc_matrix[float32]) -> scipy.sparse.csc_matrix[float32]
     """  # noqa: E501 line too long
 
 
 def test_issue738():
-    from pybind11_tests import iss738_f1, iss738_f2
+    """Ignore strides on a length-1 dimension (even if they would be incompatible length > 1)"""
+    assert np.all(m.iss738_f1(np.array([[1., 2, 3]])) == np.array([[1., 102, 203]]))
+    assert np.all(m.iss738_f1(np.array([[1.], [2], [3]])) == np.array([[1.], [12], [23]]))
+
+    assert np.all(m.iss738_f2(np.array([[1., 2, 3]])) == np.array([[1., 102, 203]]))
+    assert np.all(m.iss738_f2(np.array([[1.], [2], [3]])) == np.array([[1.], [12], [23]]))
+
 
-    assert np.all(iss738_f1(np.array([[1., 2, 3]])) == np.array([[1., 102, 203]]))
-    assert np.all(iss738_f1(np.array([[1.], [2], [3]])) == np.array([[1.], [12], [23]]))
+def test_issue1105():
+    """Issue 1105: 1xN or Nx1 input arrays weren't accepted for eigen
+    compile-time row vectors or column vector"""
+    assert m.iss1105_row(np.ones((1, 7)))
+    assert m.iss1105_col(np.ones((7, 1)))
 
-    assert np.all(iss738_f2(np.array([[1., 2, 3]])) == np.array([[1., 102, 203]]))
-    assert np.all(iss738_f2(np.array([[1.], [2], [3]])) == np.array([[1.], [12], [23]]))
+    # These should still fail (incompatible dimensions):
+    with pytest.raises(TypeError) as excinfo:
+        m.iss1105_row(np.ones((7, 1)))
+    assert "incompatible function arguments" in str(excinfo.value)
+    with pytest.raises(TypeError) as excinfo:
+        m.iss1105_col(np.ones((1, 7)))
+    assert "incompatible function arguments" in str(excinfo.value)
 
 
 def test_custom_operator_new():
     """Using Eigen types as member variables requires a class-specific
     operator new with proper alignment"""
-    from pybind11_tests import CustomOperatorNew
 
-    o = CustomOperatorNew()
+    o = m.CustomOperatorNew()
     np.testing.assert_allclose(o.a, 0.0)
     np.testing.assert_allclose(o.b.diagonal(), 1.0)
diff --git a/src/pybind11/tests/test_embed/CMakeLists.txt b/src/pybind11/tests/test_embed/CMakeLists.txt
index 0a43e0e..8b4f1f8 100644
--- a/src/pybind11/tests/test_embed/CMakeLists.txt
+++ b/src/pybind11/tests/test_embed/CMakeLists.txt
@@ -5,7 +5,9 @@ if(${PYTHON_MODULE_EXTENSION} MATCHES "pypy")
 endif()
 
 find_package(Catch 1.9.3)
-if(NOT CATCH_FOUND)
+if(CATCH_FOUND)
+  message(STATUS "Building interpreter tests using Catch v${CATCH_VERSION}")
+else()
   message(STATUS "Catch not detected. Interpreter tests will be skipped. Install Catch headers"
                  " manually or use `cmake -DDOWNLOAD_CATCH=1` to fetch them automatically.")
   return()
@@ -31,4 +33,9 @@ target_link_libraries(test_embed PUBLIC ${CMAKE_THREAD_LIBS_INIT})
 
 add_custom_target(cpptest COMMAND $<TARGET_FILE:test_embed>
                   WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})
+
+pybind11_add_module(external_module THIN_LTO external_module.cpp)
+set_target_properties(external_module PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})
+add_dependencies(cpptest external_module)
+
 add_dependencies(check cpptest)
diff --git a/src/pybind11/tests/test_embed/catch.cpp b/src/pybind11/tests/test_embed/catch.cpp
index cface48..dd13738 100644
--- a/src/pybind11/tests/test_embed/catch.cpp
+++ b/src/pybind11/tests/test_embed/catch.cpp
@@ -3,12 +3,18 @@
 
 #include <pybind11/embed.h>
 
+#ifdef _MSC_VER
+// Silence MSVC C++17 deprecation warning from Catch regarding std::uncaught_exceptions (up to catch
+// 2.0.1; this should be fixed in the next catch release after 2.0.1).
+#  pragma warning(disable: 4996)
+#endif
+
 #define CATCH_CONFIG_RUNNER
 #include <catch.hpp>
 
 namespace py = pybind11;
 
-int main(int argc, const char *argv[]) {
+int main(int argc, char *argv[]) {
     py::scoped_interpreter guard{};
     auto result = Catch::Session().run(argc, argv);
 
diff --git a/src/pybind11/tests/test_embed/external_module.cpp b/src/pybind11/tests/test_embed/external_module.cpp
new file mode 100644
index 0000000..e9a6058
--- /dev/null
+++ b/src/pybind11/tests/test_embed/external_module.cpp
@@ -0,0 +1,23 @@
+#include <pybind11/pybind11.h>
+
+namespace py = pybind11;
+
+/* Simple test module/test class to check that the referenced internals data of external pybind11
+ * modules aren't preserved over a finalize/initialize.
+ */
+
+PYBIND11_MODULE(external_module, m) {
+    class A {
+    public:
+        A(int value) : v{value} {};
+        int v;
+    };
+
+    py::class_<A>(m, "A")
+        .def(py::init<int>())
+        .def_readwrite("value", &A::v);
+
+    m.def("internals_at", []() {
+        return reinterpret_cast<uintptr_t>(&py::detail::get_internals());
+    });
+}
diff --git a/src/pybind11/tests/test_embed/test_interpreter.cpp b/src/pybind11/tests/test_embed/test_interpreter.cpp
index acbad6b..222bd56 100644
--- a/src/pybind11/tests/test_embed/test_interpreter.cpp
+++ b/src/pybind11/tests/test_embed/test_interpreter.cpp
@@ -1,7 +1,16 @@
 #include <pybind11/embed.h>
+
+#ifdef _MSC_VER
+// Silence MSVC C++17 deprecation warning from Catch regarding std::uncaught_exceptions (up to catch
+// 2.0.1; this should be fixed in the next catch release after 2.0.1).
+#  pragma warning(disable: 4996)
+#endif
+
 #include <catch.hpp>
 
 #include <thread>
+#include <fstream>
+#include <functional>
 
 namespace py = pybind11;
 using namespace py::literals;
@@ -92,7 +101,8 @@ bool has_pybind11_internals_builtin() {
 };
 
 bool has_pybind11_internals_static() {
-    return py::detail::get_internals_ptr() != nullptr;
+    auto **&ipp = py::detail::get_internals_pp();
+    return ipp && *ipp;
 }
 
 TEST_CASE("Restart the interpreter") {
@@ -100,6 +110,11 @@ TEST_CASE("Restart the interpreter") {
     REQUIRE(py::module::import("widget_module").attr("add")(1, 2).cast<int>() == 3);
     REQUIRE(has_pybind11_internals_builtin());
     REQUIRE(has_pybind11_internals_static());
+    REQUIRE(py::module::import("external_module").attr("A")(123).attr("value").cast<int>() == 123);
+
+    // local and foreign module internals should point to the same internals:
+    REQUIRE(reinterpret_cast<uintptr_t>(*py::detail::get_internals_pp()) ==
+            py::module::import("external_module").attr("internals_at")().cast<uintptr_t>());
 
     // Restart the interpreter.
     py::finalize_interpreter();
@@ -114,6 +129,8 @@ TEST_CASE("Restart the interpreter") {
     pybind11::detail::get_internals();
     REQUIRE(has_pybind11_internals_builtin());
     REQUIRE(has_pybind11_internals_static());
+    REQUIRE(reinterpret_cast<uintptr_t>(*py::detail::get_internals_pp()) ==
+            py::module::import("external_module").attr("internals_at")().cast<uintptr_t>());
 
     // Make sure that an interpreter with no get_internals() created until finalize still gets the
     // internals destroyed
@@ -216,3 +233,52 @@ TEST_CASE("Threads") {
 
     REQUIRE(locals["count"].cast<int>() == num_threads);
 }
+
+// Scope exit utility https://stackoverflow.com/a/36644501/7255855
+struct scope_exit {
+    std::function<void()> f_;
+    explicit scope_exit(std::function<void()> f) noexcept : f_(std::move(f)) {}
+    ~scope_exit() { if (f_) f_(); }
+};
+
+TEST_CASE("Reload module from file") {
+    // Disable generation of cached bytecode (.pyc files) for this test, otherwise
+    // Python might pick up an old version from the cache instead of the new versions
+    // of the .py files generated below
+    auto sys = py::module::import("sys");
+    bool dont_write_bytecode = sys.attr("dont_write_bytecode").cast<bool>();
+    sys.attr("dont_write_bytecode") = true;
+    // Reset the value at scope exit
+    scope_exit reset_dont_write_bytecode([&]() {
+        sys.attr("dont_write_bytecode") = dont_write_bytecode;
+    });
+
+    std::string module_name = "test_module_reload";
+    std::string module_file = module_name + ".py";
+
+    // Create the module .py file
+    std::ofstream test_module(module_file);
+    test_module << "def test():\n";
+    test_module << "    return 1\n";
+    test_module.close();
+    // Delete the file at scope exit
+    scope_exit delete_module_file([&]() {
+        std::remove(module_file.c_str());
+    });
+
+    // Import the module from file
+    auto module = py::module::import(module_name.c_str());
+    int result = module.attr("test")().cast<int>();
+    REQUIRE(result == 1);
+
+    // Update the module .py file with a small change
+    test_module.open(module_file);
+    test_module << "def test():\n";
+    test_module << "    return 2\n";
+    test_module.close();
+
+    // Reload the module
+    module.reload();
+    result = module.attr("test")().cast<int>();
+    REQUIRE(result == 2);
+}
diff --git a/src/pybind11/tests/test_enum.cpp b/src/pybind11/tests/test_enum.cpp
index 67341f4..3153089 100644
--- a/src/pybind11/tests/test_enum.cpp
+++ b/src/pybind11/tests/test_enum.cpp
@@ -9,56 +9,56 @@
 
 #include "pybind11_tests.h"
 
-enum UnscopedEnum {
-    EOne = 1,
-    ETwo
-};
-
-enum class ScopedEnum {
-    Two = 2,
-    Three
-};
-
-enum Flags {
-    Read = 4,
-    Write = 2,
-    Execute = 1
-};
-
-class ClassWithUnscopedEnum {
-public:
-    enum EMode {
-        EFirstMode = 1,
-        ESecondMode
+TEST_SUBMODULE(enums, m) {
+    // test_unscoped_enum
+    enum UnscopedEnum {
+        EOne = 1,
+        ETwo,
+        EThree
     };
-
-    static EMode test_function(EMode mode) {
-        return mode;
-    }
-};
-
-std::string test_scoped_enum(ScopedEnum z) {
-    return "ScopedEnum::" + std::string(z == ScopedEnum::Two ? "Two" : "Three");
-}
-
-test_initializer enums([](py::module &m) {
-    m.def("test_scoped_enum", &test_scoped_enum);
-
-    py::enum_<UnscopedEnum>(m, "UnscopedEnum", py::arithmetic())
-        .value("EOne", EOne)
-        .value("ETwo", ETwo)
+    py::enum_<UnscopedEnum>(m, "UnscopedEnum", py::arithmetic(), "An unscoped enumeration")
+        .value("EOne", EOne, "Docstring for EOne")
+        .value("ETwo", ETwo, "Docstring for ETwo")
+        .value("EThree", EThree, "Docstring for EThree")
         .export_values();
 
+    // test_scoped_enum
+    enum class ScopedEnum {
+        Two = 2,
+        Three
+    };
     py::enum_<ScopedEnum>(m, "ScopedEnum", py::arithmetic())
         .value("Two", ScopedEnum::Two)
         .value("Three", ScopedEnum::Three);
 
+    m.def("test_scoped_enum", [](ScopedEnum z) {
+        return "ScopedEnum::" + std::string(z == ScopedEnum::Two ? "Two" : "Three");
+    });
+
+    // test_binary_operators
+    enum Flags {
+        Read = 4,
+        Write = 2,
+        Execute = 1
+    };
     py::enum_<Flags>(m, "Flags", py::arithmetic())
         .value("Read", Flags::Read)
         .value("Write", Flags::Write)
         .value("Execute", Flags::Execute)
         .export_values();
 
+    // test_implicit_conversion
+    class ClassWithUnscopedEnum {
+    public:
+        enum EMode {
+            EFirstMode = 1,
+            ESecondMode
+        };
+
+        static EMode test_function(EMode mode) {
+            return mode;
+        }
+    };
     py::class_<ClassWithUnscopedEnum> exenum_class(m, "ClassWithUnscopedEnum");
     exenum_class.def_static("test_function", &ClassWithUnscopedEnum::test_function);
     py::enum_<ClassWithUnscopedEnum::EMode>(exenum_class, "EMode")
@@ -66,7 +66,22 @@ test_initializer enums([](py::module &m) {
         .value("ESecondMode", ClassWithUnscopedEnum::ESecondMode)
         .export_values();
 
+    // test_enum_to_int
     m.def("test_enum_to_int", [](int) { });
     m.def("test_enum_to_uint", [](uint32_t) { });
     m.def("test_enum_to_long_long", [](long long) { });
-});
+
+    // test_duplicate_enum_name
+    enum SimpleEnum
+    {
+        ONE, TWO, THREE
+    };
+
+    m.def("register_bad_enum", [m]() {
+        py::enum_<SimpleEnum>(m, "SimpleEnum")
+            .value("ONE", SimpleEnum::ONE)          //NOTE: all value function calls are called with the same first parameter value
+            .value("ONE", SimpleEnum::TWO)
+            .value("ONE", SimpleEnum::THREE)
+            .export_values();
+    });
+}
diff --git a/src/pybind11/tests/test_enum.py b/src/pybind11/tests/test_enum.py
index 6cc4887..7fe9b61 100644
--- a/src/pybind11/tests/test_enum.py
+++ b/src/pybind11/tests/test_enum.py
@@ -1,76 +1,151 @@
 import pytest
+from pybind11_tests import enums as m
 
 
 def test_unscoped_enum():
-    from pybind11_tests import UnscopedEnum, EOne
+    assert str(m.UnscopedEnum.EOne) == "UnscopedEnum.EOne"
+    assert str(m.UnscopedEnum.ETwo) == "UnscopedEnum.ETwo"
+    assert str(m.EOne) == "UnscopedEnum.EOne"
+
+    # name property
+    assert m.UnscopedEnum.EOne.name == "EOne"
+    assert m.UnscopedEnum.ETwo.name == "ETwo"
+    assert m.EOne.name == "EOne"
+    # name readonly
+    with pytest.raises(AttributeError):
+        m.UnscopedEnum.EOne.name = ""
+    # name returns a copy
+    foo = m.UnscopedEnum.EOne.name
+    foo = "bar"
+    assert m.UnscopedEnum.EOne.name == "EOne"
 
-    assert str(UnscopedEnum.EOne) == "UnscopedEnum.EOne"
-    assert str(UnscopedEnum.ETwo) == "UnscopedEnum.ETwo"
-    assert str(EOne) == "UnscopedEnum.EOne"
     # __members__ property
-    assert UnscopedEnum.__members__ == {"EOne": UnscopedEnum.EOne, "ETwo": UnscopedEnum.ETwo}
+    assert m.UnscopedEnum.__members__ == \
+        {"EOne": m.UnscopedEnum.EOne, "ETwo": m.UnscopedEnum.ETwo, "EThree": m.UnscopedEnum.EThree}
     # __members__ readonly
     with pytest.raises(AttributeError):
-        UnscopedEnum.__members__ = {}
+        m.UnscopedEnum.__members__ = {}
     # __members__ returns a copy
-    foo = UnscopedEnum.__members__
+    foo = m.UnscopedEnum.__members__
     foo["bar"] = "baz"
-    assert UnscopedEnum.__members__ == {"EOne": UnscopedEnum.EOne, "ETwo": UnscopedEnum.ETwo}
+    assert m.UnscopedEnum.__members__ == \
+        {"EOne": m.UnscopedEnum.EOne, "ETwo": m.UnscopedEnum.ETwo, "EThree": m.UnscopedEnum.EThree}
+
+    for docstring_line in '''An unscoped enumeration
+
+Members:
+
+  EOne : Docstring for EOne
 
-    # no TypeError exception for unscoped enum ==/!= int comparisons
-    y = UnscopedEnum.ETwo
+  ETwo : Docstring for ETwo
+
+  EThree : Docstring for EThree'''.split('\n'):
+        assert docstring_line in m.UnscopedEnum.__doc__
+
+    # Unscoped enums will accept ==/!= int comparisons
+    y = m.UnscopedEnum.ETwo
     assert y == 2
+    assert 2 == y
     assert y != 3
+    assert 3 != y
+    # Compare with None
+    assert (y != None)  # noqa: E711
+    assert not (y == None)  # noqa: E711
+    # Compare with an object
+    assert (y != object())
+    assert not (y == object())
+    # Compare with string
+    assert y != "2"
+    assert "2" != y
+    assert not ("2" == y)
+    assert not (y == "2")
 
-    assert int(UnscopedEnum.ETwo) == 2
-    assert str(UnscopedEnum(2)) == "UnscopedEnum.ETwo"
+    with pytest.raises(TypeError):
+        y < object()
 
-    # order
-    assert UnscopedEnum.EOne < UnscopedEnum.ETwo
-    assert UnscopedEnum.EOne < 2
-    assert UnscopedEnum.ETwo > UnscopedEnum.EOne
-    assert UnscopedEnum.ETwo > 1
-    assert UnscopedEnum.ETwo <= 2
-    assert UnscopedEnum.ETwo >= 2
-    assert UnscopedEnum.EOne <= UnscopedEnum.ETwo
-    assert UnscopedEnum.EOne <= 2
-    assert UnscopedEnum.ETwo >= UnscopedEnum.EOne
-    assert UnscopedEnum.ETwo >= 1
-    assert not (UnscopedEnum.ETwo < UnscopedEnum.EOne)
-    assert not (2 < UnscopedEnum.EOne)
+    with pytest.raises(TypeError):
+        y <= object()
 
+    with pytest.raises(TypeError):
+        y > object()
 
-def test_scoped_enum():
-    from pybind11_tests import ScopedEnum, test_scoped_enum
+    with pytest.raises(TypeError):
+        y >= object()
 
-    assert test_scoped_enum(ScopedEnum.Three) == "ScopedEnum::Three"
-    z = ScopedEnum.Two
-    assert test_scoped_enum(z) == "ScopedEnum::Two"
+    with pytest.raises(TypeError):
+        y | object()
 
-    # expected TypeError exceptions for scoped enum ==/!= int comparisons
     with pytest.raises(TypeError):
-        assert z == 2
+        y & object()
+
     with pytest.raises(TypeError):
-        assert z != 3
+        y ^ object()
+
+    assert int(m.UnscopedEnum.ETwo) == 2
+    assert str(m.UnscopedEnum(2)) == "UnscopedEnum.ETwo"
 
     # order
-    assert ScopedEnum.Two < ScopedEnum.Three
-    assert ScopedEnum.Three > ScopedEnum.Two
-    assert ScopedEnum.Two <= ScopedEnum.Three
-    assert ScopedEnum.Two <= ScopedEnum.Two
-    assert ScopedEnum.Two >= ScopedEnum.Two
-    assert ScopedEnum.Three >= ScopedEnum.Two
+    assert m.UnscopedEnum.EOne < m.UnscopedEnum.ETwo
+    assert m.UnscopedEnum.EOne < 2
+    assert m.UnscopedEnum.ETwo > m.UnscopedEnum.EOne
+    assert m.UnscopedEnum.ETwo > 1
+    assert m.UnscopedEnum.ETwo <= 2
+    assert m.UnscopedEnum.ETwo >= 2
+    assert m.UnscopedEnum.EOne <= m.UnscopedEnum.ETwo
+    assert m.UnscopedEnum.EOne <= 2
+    assert m.UnscopedEnum.ETwo >= m.UnscopedEnum.EOne
+    assert m.UnscopedEnum.ETwo >= 1
+    assert not (m.UnscopedEnum.ETwo < m.UnscopedEnum.EOne)
+    assert not (2 < m.UnscopedEnum.EOne)
+
+    # arithmetic
+    assert m.UnscopedEnum.EOne & m.UnscopedEnum.EThree == m.UnscopedEnum.EOne
+    assert m.UnscopedEnum.EOne | m.UnscopedEnum.ETwo == m.UnscopedEnum.EThree
+    assert m.UnscopedEnum.EOne ^ m.UnscopedEnum.EThree == m.UnscopedEnum.ETwo
 
 
-def test_implicit_conversion():
-    from pybind11_tests import ClassWithUnscopedEnum
+def test_scoped_enum():
+    assert m.test_scoped_enum(m.ScopedEnum.Three) == "ScopedEnum::Three"
+    z = m.ScopedEnum.Two
+    assert m.test_scoped_enum(z) == "ScopedEnum::Two"
+
+    # Scoped enums will *NOT* accept ==/!= int comparisons (Will always return False)
+    assert not z == 3
+    assert not 3 == z
+    assert z != 3
+    assert 3 != z
+    # Compare with None
+    assert (z != None)  # noqa: E711
+    assert not (z == None)  # noqa: E711
+    # Compare with an object
+    assert (z != object())
+    assert not (z == object())
+    # Scoped enums will *NOT* accept >, <, >= and <= int comparisons (Will throw exceptions)
+    with pytest.raises(TypeError):
+        z > 3
+    with pytest.raises(TypeError):
+        z < 3
+    with pytest.raises(TypeError):
+        z >= 3
+    with pytest.raises(TypeError):
+        z <= 3
+
+    # order
+    assert m.ScopedEnum.Two < m.ScopedEnum.Three
+    assert m.ScopedEnum.Three > m.ScopedEnum.Two
+    assert m.ScopedEnum.Two <= m.ScopedEnum.Three
+    assert m.ScopedEnum.Two <= m.ScopedEnum.Two
+    assert m.ScopedEnum.Two >= m.ScopedEnum.Two
+    assert m.ScopedEnum.Three >= m.ScopedEnum.Two
+
 
-    assert str(ClassWithUnscopedEnum.EMode.EFirstMode) == "EMode.EFirstMode"
-    assert str(ClassWithUnscopedEnum.EFirstMode) == "EMode.EFirstMode"
+def test_implicit_conversion():
+    assert str(m.ClassWithUnscopedEnum.EMode.EFirstMode) == "EMode.EFirstMode"
+    assert str(m.ClassWithUnscopedEnum.EFirstMode) == "EMode.EFirstMode"
 
-    f = ClassWithUnscopedEnum.test_function
-    first = ClassWithUnscopedEnum.EFirstMode
-    second = ClassWithUnscopedEnum.ESecondMode
+    f = m.ClassWithUnscopedEnum.test_function
+    first = m.ClassWithUnscopedEnum.EFirstMode
+    second = m.ClassWithUnscopedEnum.ESecondMode
 
     assert f(first) == 1
 
@@ -95,21 +170,20 @@ def test_implicit_conversion():
 
 
 def test_binary_operators():
-    from pybind11_tests import Flags
-
-    assert int(Flags.Read) == 4
-    assert int(Flags.Write) == 2
-    assert int(Flags.Execute) == 1
-    assert int(Flags.Read | Flags.Write | Flags.Execute) == 7
-    assert int(Flags.Read | Flags.Write) == 6
-    assert int(Flags.Read | Flags.Execute) == 5
-    assert int(Flags.Write | Flags.Execute) == 3
-    assert int(Flags.Write | 1) == 3
-
-    state = Flags.Read | Flags.Write
-    assert (state & Flags.Read) != 0
-    assert (state & Flags.Write) != 0
-    assert (state & Flags.Execute) == 0
+    assert int(m.Flags.Read) == 4
+    assert int(m.Flags.Write) == 2
+    assert int(m.Flags.Execute) == 1
+    assert int(m.Flags.Read | m.Flags.Write | m.Flags.Execute) == 7
+    assert int(m.Flags.Read | m.Flags.Write) == 6
+    assert int(m.Flags.Read | m.Flags.Execute) == 5
+    assert int(m.Flags.Write | m.Flags.Execute) == 3
+    assert int(m.Flags.Write | 1) == 3
+    assert ~m.Flags.Write == -3
+
+    state = m.Flags.Read | m.Flags.Write
+    assert (state & m.Flags.Read) != 0
+    assert (state & m.Flags.Write) != 0
+    assert (state & m.Flags.Execute) == 0
     assert (state & 1) == 0
 
     state2 = ~state
@@ -118,12 +192,15 @@ def test_binary_operators():
 
 
 def test_enum_to_int():
-    from pybind11_tests import Flags, ClassWithUnscopedEnum
-    from pybind11_tests import test_enum_to_int, test_enum_to_uint, test_enum_to_long_long
-
-    test_enum_to_int(Flags.Read)
-    test_enum_to_int(ClassWithUnscopedEnum.EMode.EFirstMode)
-    test_enum_to_uint(Flags.Read)
-    test_enum_to_uint(ClassWithUnscopedEnum.EMode.EFirstMode)
-    test_enum_to_long_long(Flags.Read)
-    test_enum_to_long_long(ClassWithUnscopedEnum.EMode.EFirstMode)
+    m.test_enum_to_int(m.Flags.Read)
+    m.test_enum_to_int(m.ClassWithUnscopedEnum.EMode.EFirstMode)
+    m.test_enum_to_uint(m.Flags.Read)
+    m.test_enum_to_uint(m.ClassWithUnscopedEnum.EMode.EFirstMode)
+    m.test_enum_to_long_long(m.Flags.Read)
+    m.test_enum_to_long_long(m.ClassWithUnscopedEnum.EMode.EFirstMode)
+
+
+def test_duplicate_enum_name():
+    with pytest.raises(ValueError) as excinfo:
+        m.register_bad_enum()
+    assert str(excinfo.value) == 'SimpleEnum: element "ONE" already exists!'
diff --git a/src/pybind11/tests/test_eval.cpp b/src/pybind11/tests/test_eval.cpp
index 610d0e2..e094821 100644
--- a/src/pybind11/tests/test_eval.cpp
+++ b/src/pybind11/tests/test_eval.cpp
@@ -11,7 +11,9 @@
 #include <pybind11/eval.h>
 #include "pybind11_tests.h"
 
-test_initializer eval([](py::module &m) {
+TEST_SUBMODULE(eval_, m) {
+    // test_evals
+
     auto global = py::dict(py::module::import("__main__").attr("__dict__"));
 
     m.def("test_eval_statements", [global]() {
@@ -86,4 +88,4 @@ test_initializer eval([](py::module &m) {
         }
         return false;
     });
-});
+}
diff --git a/src/pybind11/tests/test_eval.py b/src/pybind11/tests/test_eval.py
index 8715dba..bda4ef6 100644
--- a/src/pybind11/tests/test_eval.py
+++ b/src/pybind11/tests/test_eval.py
@@ -1,19 +1,17 @@
 import os
+from pybind11_tests import eval_ as m
 
 
 def test_evals(capture):
-    from pybind11_tests import (test_eval_statements, test_eval, test_eval_single_statement,
-                                test_eval_file, test_eval_failure, test_eval_file_failure)
-
     with capture:
-        assert test_eval_statements()
+        assert m.test_eval_statements()
     assert capture == "Hello World!"
 
-    assert test_eval()
-    assert test_eval_single_statement()
+    assert m.test_eval()
+    assert m.test_eval_single_statement()
 
     filename = os.path.join(os.path.dirname(__file__), "test_eval_call.py")
-    assert test_eval_file(filename)
+    assert m.test_eval_file(filename)
 
-    assert test_eval_failure()
-    assert test_eval_file_failure()
+    assert m.test_eval_failure()
+    assert m.test_eval_file_failure()
diff --git a/src/pybind11/tests/test_exceptions.cpp b/src/pybind11/tests/test_exceptions.cpp
index 01efc70..56cd9bc 100644
--- a/src/pybind11/tests/test_exceptions.cpp
+++ b/src/pybind11/tests/test_exceptions.cpp
@@ -9,7 +9,7 @@
 
 #include "pybind11_tests.h"
 
-// A type that should be raised as an exeption in Python
+// A type that should be raised as an exception in Python
 class MyException : public std::exception {
 public:
     explicit MyException(const char * m) : message{m} {}
@@ -58,48 +58,6 @@ class MyException5_1 : public MyException5 {
     using MyException5::MyException5;
 };
 
-void throws1() {
-    throw MyException("this error should go to a custom type");
-}
-
-void throws2() {
-    throw MyException2("this error should go to a standard Python exception");
-}
-
-void throws3() {
-    throw MyException3("this error cannot be translated");
-}
-
-void throws4() {
-    throw MyException4("this error is rethrown");
-}
-
-void throws5() {
-    throw MyException5("this is a helper-defined translated exception");
-}
-
-void throws5_1() {
-    throw MyException5_1("MyException5 subclass");
-}
-
-void throws_logic_error() {
-    throw std::logic_error("this error should fall through to the standard handler");
-}
-
-// Test error_already_set::matches() method
-void exception_matches() {
-    py::dict foo;
-    try {
-        foo["bar"];
-    }
-    catch (py::error_already_set& ex) {
-        if (ex.matches(PyExc_KeyError))
-            ex.clear();
-        else
-            throw;
-    }
-}
-
 struct PythonCallInDestructor {
     PythonCallInDestructor(const py::dict &d) : d(d) {}
     ~PythonCallInDestructor() { d["good"] = true; }
@@ -107,7 +65,7 @@ struct PythonCallInDestructor {
     py::dict d;
 };
 
-test_initializer custom_exceptions([](py::module &m) {
+TEST_SUBMODULE(exceptions, m) {
     m.def("throw_std_exception", []() {
         throw std::runtime_error("This exception was intentionally thrown.");
     });
@@ -151,14 +109,49 @@ test_initializer custom_exceptions([](py::module &m) {
     // A slightly more complicated one that declares MyException5_1 as a subclass of MyException5
     py::register_exception<MyException5_1>(m, "MyException5_1", ex5.ptr());
 
-    m.def("throws1", &throws1);
-    m.def("throws2", &throws2);
-    m.def("throws3", &throws3);
-    m.def("throws4", &throws4);
-    m.def("throws5", &throws5);
-    m.def("throws5_1", &throws5_1);
-    m.def("throws_logic_error", &throws_logic_error);
-    m.def("exception_matches", &exception_matches);
+    m.def("throws1", []() { throw MyException("this error should go to a custom type"); });
+    m.def("throws2", []() { throw MyException2("this error should go to a standard Python exception"); });
+    m.def("throws3", []() { throw MyException3("this error cannot be translated"); });
+    m.def("throws4", []() { throw MyException4("this error is rethrown"); });
+    m.def("throws5", []() { throw MyException5("this is a helper-defined translated exception"); });
+    m.def("throws5_1", []() { throw MyException5_1("MyException5 subclass"); });
+    m.def("throws_logic_error", []() { throw std::logic_error("this error should fall through to the standard handler"); });
+    m.def("throws_overflow_error", []() {throw std::overflow_error(""); });
+    m.def("exception_matches", []() {
+        py::dict foo;
+        try {
+            // Assign to a py::object to force read access of nonexistent dict entry
+            py::object o = foo["bar"];
+        }
+        catch (py::error_already_set& ex) {
+            if (!ex.matches(PyExc_KeyError)) throw;
+            return true;
+        }
+        return false;
+    });
+    m.def("exception_matches_base", []() {
+        py::dict foo;
+        try {
+            // Assign to a py::object to force read access of nonexistent dict entry
+            py::object o = foo["bar"];
+        }
+        catch (py::error_already_set &ex) {
+            if (!ex.matches(PyExc_Exception)) throw;
+            return true;
+        }
+        return false;
+    });
+    m.def("modulenotfound_exception_matches_base", []() {
+        try {
+            // On Python >= 3.6, this raises a ModuleNotFoundError, a subclass of ImportError
+            py::module::import("nonexistent");
+        }
+        catch (py::error_already_set &ex) {
+            if (!ex.matches(PyExc_ImportError)) throw;
+            return true;
+        }
+        return false;
+    });
 
     m.def("throw_already_set", [](bool err) {
         if (err)
@@ -189,4 +182,16 @@ test_initializer custom_exceptions([](py::module &m) {
         }
         return false;
     });
-});
+
+    // test_nested_throws
+    m.def("try_catch", [m](py::object exc_type, py::function f, py::args args) {
+        try { f(*args); }
+        catch (py::error_already_set &ex) {
+            if (ex.matches(exc_type))
+                py::print(ex.what());
+            else
+                throw;
+        }
+    });
+
+}
diff --git a/src/pybind11/tests/test_exceptions.py b/src/pybind11/tests/test_exceptions.py
index 15d4787..ac2b360 100644
--- a/src/pybind11/tests/test_exceptions.py
+++ b/src/pybind11/tests/test_exceptions.py
@@ -1,87 +1,150 @@
 import pytest
 
+from pybind11_tests import exceptions as m
+import pybind11_cross_module_tests as cm
 
-def test_std_exception(msg):
-    from pybind11_tests import throw_std_exception
 
+def test_std_exception(msg):
     with pytest.raises(RuntimeError) as excinfo:
-        throw_std_exception()
+        m.throw_std_exception()
     assert msg(excinfo.value) == "This exception was intentionally thrown."
 
 
 def test_error_already_set(msg):
-    from pybind11_tests import throw_already_set
-
     with pytest.raises(RuntimeError) as excinfo:
-        throw_already_set(False)
+        m.throw_already_set(False)
     assert msg(excinfo.value) == "Unknown internal error occurred"
 
     with pytest.raises(ValueError) as excinfo:
-        throw_already_set(True)
+        m.throw_already_set(True)
     assert msg(excinfo.value) == "foo"
 
 
-def test_python_call_in_catch():
-    from pybind11_tests import python_call_in_destructor
+def test_cross_module_exceptions():
+    with pytest.raises(RuntimeError) as excinfo:
+        cm.raise_runtime_error()
+    assert str(excinfo.value) == "My runtime error"
+
+    with pytest.raises(ValueError) as excinfo:
+        cm.raise_value_error()
+    assert str(excinfo.value) == "My value error"
+
+    with pytest.raises(ValueError) as excinfo:
+        cm.throw_pybind_value_error()
+    assert str(excinfo.value) == "pybind11 value error"
+
+    with pytest.raises(TypeError) as excinfo:
+        cm.throw_pybind_type_error()
+    assert str(excinfo.value) == "pybind11 type error"
+
+    with pytest.raises(StopIteration) as excinfo:
+        cm.throw_stop_iteration()
+
 
+def test_python_call_in_catch():
     d = {}
-    assert python_call_in_destructor(d) is True
+    assert m.python_call_in_destructor(d) is True
     assert d["good"] is True
 
 
 def test_exception_matches():
-    from pybind11_tests import exception_matches
-    exception_matches()
+    assert m.exception_matches()
+    assert m.exception_matches_base()
+    assert m.modulenotfound_exception_matches_base()
 
 
 def test_custom(msg):
-    from pybind11_tests import (MyException, MyException5, MyException5_1,
-                                throws1, throws2, throws3, throws4, throws5, throws5_1,
-                                throws_logic_error)
-
-    # Can we catch a MyException?"
-    with pytest.raises(MyException) as excinfo:
-        throws1()
+    # Can we catch a MyException?
+    with pytest.raises(m.MyException) as excinfo:
+        m.throws1()
     assert msg(excinfo.value) == "this error should go to a custom type"
 
     # Can we translate to standard Python exceptions?
     with pytest.raises(RuntimeError) as excinfo:
-        throws2()
+        m.throws2()
     assert msg(excinfo.value) == "this error should go to a standard Python exception"
 
     # Can we handle unknown exceptions?
     with pytest.raises(RuntimeError) as excinfo:
-        throws3()
+        m.throws3()
     assert msg(excinfo.value) == "Caught an unknown exception!"
 
     # Can we delegate to another handler by rethrowing?
-    with pytest.raises(MyException) as excinfo:
-        throws4()
+    with pytest.raises(m.MyException) as excinfo:
+        m.throws4()
     assert msg(excinfo.value) == "this error is rethrown"
 
-    # "Can we fall-through to the default handler?"
+    # Can we fall-through to the default handler?
     with pytest.raises(RuntimeError) as excinfo:
-        throws_logic_error()
+        m.throws_logic_error()
     assert msg(excinfo.value) == "this error should fall through to the standard handler"
 
+    # OverFlow error translation.
+    with pytest.raises(OverflowError) as excinfo:
+        m.throws_overflow_error()
+
     # Can we handle a helper-declared exception?
-    with pytest.raises(MyException5) as excinfo:
-        throws5()
+    with pytest.raises(m.MyException5) as excinfo:
+        m.throws5()
     assert msg(excinfo.value) == "this is a helper-defined translated exception"
 
     # Exception subclassing:
-    with pytest.raises(MyException5) as excinfo:
-        throws5_1()
+    with pytest.raises(m.MyException5) as excinfo:
+        m.throws5_1()
     assert msg(excinfo.value) == "MyException5 subclass"
-    assert isinstance(excinfo.value, MyException5_1)
+    assert isinstance(excinfo.value, m.MyException5_1)
 
-    with pytest.raises(MyException5_1) as excinfo:
-        throws5_1()
+    with pytest.raises(m.MyException5_1) as excinfo:
+        m.throws5_1()
     assert msg(excinfo.value) == "MyException5 subclass"
 
-    with pytest.raises(MyException5) as excinfo:
+    with pytest.raises(m.MyException5) as excinfo:
         try:
-            throws5()
-        except MyException5_1:
+            m.throws5()
+        except m.MyException5_1:
             raise RuntimeError("Exception error: caught child from parent")
     assert msg(excinfo.value) == "this is a helper-defined translated exception"
+
+
+def test_nested_throws(capture):
+    """Tests nested (e.g. C++ -> Python -> C++) exception handling"""
+
+    def throw_myex():
+        raise m.MyException("nested error")
+
+    def throw_myex5():
+        raise m.MyException5("nested error 5")
+
+    # In the comments below, the exception is caught in the first step, thrown in the last step
+
+    # C++ -> Python
+    with capture:
+        m.try_catch(m.MyException5, throw_myex5)
+    assert str(capture).startswith("MyException5: nested error 5")
+
+    # Python -> C++ -> Python
+    with pytest.raises(m.MyException) as excinfo:
+        m.try_catch(m.MyException5, throw_myex)
+    assert str(excinfo.value) == "nested error"
+
+    def pycatch(exctype, f, *args):
+        try:
+            f(*args)
+        except m.MyException as e:
+            print(e)
+
+    # C++ -> Python -> C++ -> Python
+    with capture:
+        m.try_catch(
+            m.MyException5, pycatch, m.MyException, m.try_catch, m.MyException, throw_myex5)
+    assert str(capture).startswith("MyException5: nested error 5")
+
+    # C++ -> Python -> C++
+    with capture:
+        m.try_catch(m.MyException, pycatch, m.MyException5, m.throws4)
+    assert capture == "this error is rethrown"
+
+    # Python -> C++ -> Python -> C++
+    with pytest.raises(m.MyException5) as excinfo:
+        m.try_catch(m.MyException, pycatch, m.MyException, m.throws5)
+    assert str(excinfo.value) == "this is a helper-defined translated exception"
diff --git a/src/pybind11/tests/test_factory_constructors.cpp b/src/pybind11/tests/test_factory_constructors.cpp
new file mode 100644
index 0000000..5cfbfdc
--- /dev/null
+++ b/src/pybind11/tests/test_factory_constructors.cpp
@@ -0,0 +1,338 @@
+/*
+    tests/test_factory_constructors.cpp -- tests construction from a factory function
+                                           via py::init_factory()
+
+    Copyright (c) 2017 Jason Rhinelander <jason@imaginary.ca>
+
+    All rights reserved. Use of this source code is governed by a
+    BSD-style license that can be found in the LICENSE file.
+*/
+
+#include "pybind11_tests.h"
+#include "constructor_stats.h"
+#include <cmath>
+
+// Classes for testing python construction via C++ factory function:
+// Not publicly constructible, copyable, or movable:
+class TestFactory1 {
+    friend class TestFactoryHelper;
+    TestFactory1() : value("(empty)") { print_default_created(this); }
+    TestFactory1(int v) : value(std::to_string(v)) { print_created(this, value); }
+    TestFactory1(std::string v) : value(std::move(v)) { print_created(this, value); }
+    TestFactory1(TestFactory1 &&) = delete;
+    TestFactory1(const TestFactory1 &) = delete;
+    TestFactory1 &operator=(TestFactory1 &&) = delete;
+    TestFactory1 &operator=(const TestFactory1 &) = delete;
+public:
+    std::string value;
+    ~TestFactory1() { print_destroyed(this); }
+};
+// Non-public construction, but moveable:
+class TestFactory2 {
+    friend class TestFactoryHelper;
+    TestFactory2() : value("(empty2)") { print_default_created(this); }
+    TestFactory2(int v) : value(std::to_string(v)) { print_created(this, value); }
+    TestFactory2(std::string v) : value(std::move(v)) { print_created(this, value); }
+public:
+    TestFactory2(TestFactory2 &&m) { value = std::move(m.value); print_move_created(this); }
+    TestFactory2 &operator=(TestFactory2 &&m) { value = std::move(m.value); print_move_assigned(this); return *this; }
+    std::string value;
+    ~TestFactory2() { print_destroyed(this); }
+};
+// Mixed direct/factory construction:
+class TestFactory3 {
+protected:
+    friend class TestFactoryHelper;
+    TestFactory3() : value("(empty3)") { print_default_created(this); }
+    TestFactory3(int v) : value(std::to_string(v)) { print_created(this, value); }
+public:
+    TestFactory3(std::string v) : value(std::move(v)) { print_created(this, value); }
+    TestFactory3(TestFactory3 &&m) { value = std::move(m.value); print_move_created(this); }
+    TestFactory3 &operator=(TestFactory3 &&m) { value = std::move(m.value); print_move_assigned(this); return *this; }
+    std::string value;
+    virtual ~TestFactory3() { print_destroyed(this); }
+};
+// Inheritance test
+class TestFactory4 : public TestFactory3 {
+public:
+    TestFactory4() : TestFactory3() { print_default_created(this); }
+    TestFactory4(int v) : TestFactory3(v) { print_created(this, v); }
+    virtual ~TestFactory4() { print_destroyed(this); }
+};
+// Another class for an invalid downcast test
+class TestFactory5 : public TestFactory3 {
+public:
+    TestFactory5(int i) : TestFactory3(i) { print_created(this, i); }
+    virtual ~TestFactory5() { print_destroyed(this); }
+};
+
+class TestFactory6 {
+protected:
+    int value;
+    bool alias = false;
+public:
+    TestFactory6(int i) : value{i} { print_created(this, i); }
+    TestFactory6(TestFactory6 &&f) { print_move_created(this); value = f.value; alias = f.alias; }
+    TestFactory6(const TestFactory6 &f) { print_copy_created(this); value = f.value; alias = f.alias; }
+    virtual ~TestFactory6() { print_destroyed(this); }
+    virtual int get() { return value; }
+    bool has_alias() { return alias; }
+};
+class PyTF6 : public TestFactory6 {
+public:
+    // Special constructor that allows the factory to construct a PyTF6 from a TestFactory6 only
+    // when an alias is needed:
+    PyTF6(TestFactory6 &&base) : TestFactory6(std::move(base)) { alias = true; print_created(this, "move", value); }
+    PyTF6(int i) : TestFactory6(i) { alias = true; print_created(this, i); }
+    PyTF6(PyTF6 &&f) : TestFactory6(std::move(f)) { print_move_created(this); }
+    PyTF6(const PyTF6 &f) : TestFactory6(f) { print_copy_created(this); }
+    PyTF6(std::string s) : TestFactory6((int) s.size()) { alias = true; print_created(this, s); }
+    virtual ~PyTF6() { print_destroyed(this); }
+    int get() override { PYBIND11_OVERLOAD(int, TestFactory6, get, /*no args*/); }
+};
+
+class TestFactory7 {
+protected:
+    int value;
+    bool alias = false;
+public:
+    TestFactory7(int i) : value{i} { print_created(this, i); }
+    TestFactory7(TestFactory7 &&f) { print_move_created(this); value = f.value; alias = f.alias; }
+    TestFactory7(const TestFactory7 &f) { print_copy_created(this); value = f.value; alias = f.alias; }
+    virtual ~TestFactory7() { print_destroyed(this); }
+    virtual int get() { return value; }
+    bool has_alias() { return alias; }
+};
+class PyTF7 : public TestFactory7 {
+public:
+    PyTF7(int i) : TestFactory7(i) { alias = true; print_created(this, i); }
+    PyTF7(PyTF7 &&f) : TestFactory7(std::move(f)) { print_move_created(this); }
+    PyTF7(const PyTF7 &f) : TestFactory7(f) { print_copy_created(this); }
+    virtual ~PyTF7() { print_destroyed(this); }
+    int get() override { PYBIND11_OVERLOAD(int, TestFactory7, get, /*no args*/); }
+};
+
+
+class TestFactoryHelper {
+public:
+    // Non-movable, non-copyable type:
+    // Return via pointer:
+    static TestFactory1 *construct1() { return new TestFactory1(); }
+    // Holder:
+    static std::unique_ptr<TestFactory1> construct1(int a) { return std::unique_ptr<TestFactory1>(new TestFactory1(a)); }
+    // pointer again
+    static TestFactory1 *construct1_string(std::string a) { return new TestFactory1(a); }
+
+    // Moveable type:
+    // pointer:
+    static TestFactory2 *construct2() { return new TestFactory2(); }
+    // holder:
+    static std::unique_ptr<TestFactory2> construct2(int a) { return std::unique_ptr<TestFactory2>(new TestFactory2(a)); }
+    // by value moving:
+    static TestFactory2 construct2(std::string a) { return TestFactory2(a); }
+
+    // shared_ptr holder type:
+    // pointer:
+    static TestFactory3 *construct3() { return new TestFactory3(); }
+    // holder:
+    static std::shared_ptr<TestFactory3> construct3(int a) { return std::shared_ptr<TestFactory3>(new TestFactory3(a)); }
+};
+
+TEST_SUBMODULE(factory_constructors, m) {
+
+    // Define various trivial types to allow simpler overload resolution:
+    py::module m_tag = m.def_submodule("tag");
+#define MAKE_TAG_TYPE(Name) \
+    struct Name##_tag {}; \
+    py::class_<Name##_tag>(m_tag, #Name "_tag").def(py::init<>()); \
+    m_tag.attr(#Name) = py::cast(Name##_tag{})
+    MAKE_TAG_TYPE(pointer);
+    MAKE_TAG_TYPE(unique_ptr);
+    MAKE_TAG_TYPE(move);
+    MAKE_TAG_TYPE(shared_ptr);
+    MAKE_TAG_TYPE(derived);
+    MAKE_TAG_TYPE(TF4);
+    MAKE_TAG_TYPE(TF5);
+    MAKE_TAG_TYPE(null_ptr);
+    MAKE_TAG_TYPE(base);
+    MAKE_TAG_TYPE(invalid_base);
+    MAKE_TAG_TYPE(alias);
+    MAKE_TAG_TYPE(unaliasable);
+    MAKE_TAG_TYPE(mixed);
+
+    // test_init_factory_basic, test_bad_type
+    py::class_<TestFactory1>(m, "TestFactory1")
+        .def(py::init([](unique_ptr_tag, int v) { return TestFactoryHelper::construct1(v); }))
+        .def(py::init(&TestFactoryHelper::construct1_string)) // raw function pointer
+        .def(py::init([](pointer_tag) { return TestFactoryHelper::construct1(); }))
+        .def(py::init([](py::handle, int v, py::handle) { return TestFactoryHelper::construct1(v); }))
+        .def_readwrite("value", &TestFactory1::value)
+        ;
+    py::class_<TestFactory2>(m, "TestFactory2")
+        .def(py::init([](pointer_tag, int v) { return TestFactoryHelper::construct2(v); }))
+        .def(py::init([](unique_ptr_tag, std::string v) { return TestFactoryHelper::construct2(v); }))
+        .def(py::init([](move_tag) { return TestFactoryHelper::construct2(); }))
+        .def_readwrite("value", &TestFactory2::value)
+        ;
+
+    // Stateful & reused:
+    int c = 1;
+    auto c4a = [c](pointer_tag, TF4_tag, int a) { (void) c; return new TestFactory4(a);};
+
+    // test_init_factory_basic, test_init_factory_casting
+    py::class_<TestFactory3, std::shared_ptr<TestFactory3>>(m, "TestFactory3")
+        .def(py::init([](pointer_tag, int v) { return TestFactoryHelper::construct3(v); }))
+        .def(py::init([](shared_ptr_tag) { return TestFactoryHelper::construct3(); }))
+        .def("__init__", [](TestFactory3 &self, std::string v) { new (&self) TestFactory3(v); }) // placement-new ctor
+
+        // factories returning a derived type:
+        .def(py::init(c4a)) // derived ptr
+        .def(py::init([](pointer_tag, TF5_tag, int a) { return new TestFactory5(a); }))
+        // derived shared ptr:
+        .def(py::init([](shared_ptr_tag, TF4_tag, int a) { return std::make_shared<TestFactory4>(a); }))
+        .def(py::init([](shared_ptr_tag, TF5_tag, int a) { return std::make_shared<TestFactory5>(a); }))
+
+        // Returns nullptr:
+        .def(py::init([](null_ptr_tag) { return (TestFactory3 *) nullptr; }))
+
+        .def_readwrite("value", &TestFactory3::value)
+        ;
+
+    // test_init_factory_casting
+    py::class_<TestFactory4, TestFactory3, std::shared_ptr<TestFactory4>>(m, "TestFactory4")
+        .def(py::init(c4a)) // pointer
+        ;
+
+    // Doesn't need to be registered, but registering makes getting ConstructorStats easier:
+    py::class_<TestFactory5, TestFactory3, std::shared_ptr<TestFactory5>>(m, "TestFactory5");
+
+    // test_init_factory_alias
+    // Alias testing
+    py::class_<TestFactory6, PyTF6>(m, "TestFactory6")
+        .def(py::init([](base_tag, int i) { return TestFactory6(i); }))
+        .def(py::init([](alias_tag, int i) { return PyTF6(i); }))
+        .def(py::init([](alias_tag, std::string s) { return PyTF6(s); }))
+        .def(py::init([](alias_tag, pointer_tag, int i) { return new PyTF6(i); }))
+        .def(py::init([](base_tag, pointer_tag, int i) { return new TestFactory6(i); }))
+        .def(py::init([](base_tag, alias_tag, pointer_tag, int i) { return (TestFactory6 *) new PyTF6(i); }))
+
+        .def("get", &TestFactory6::get)
+        .def("has_alias", &TestFactory6::has_alias)
+
+        .def_static("get_cstats", &ConstructorStats::get<TestFactory6>, py::return_value_policy::reference)
+        .def_static("get_alias_cstats", &ConstructorStats::get<PyTF6>, py::return_value_policy::reference)
+        ;
+
+    // test_init_factory_dual
+    // Separate alias constructor testing
+    py::class_<TestFactory7, PyTF7, std::shared_ptr<TestFactory7>>(m, "TestFactory7")
+        .def(py::init(
+            [](int i) { return TestFactory7(i); },
+            [](int i) { return PyTF7(i); }))
+        .def(py::init(
+            [](pointer_tag, int i) { return new TestFactory7(i); },
+            [](pointer_tag, int i) { return new PyTF7(i); }))
+        .def(py::init(
+            [](mixed_tag, int i) { return new TestFactory7(i); },
+            [](mixed_tag, int i) { return PyTF7(i); }))
+        .def(py::init(
+            [](mixed_tag, std::string s) { return TestFactory7((int) s.size()); },
+            [](mixed_tag, std::string s) { return new PyTF7((int) s.size()); }))
+        .def(py::init(
+            [](base_tag, pointer_tag, int i) { return new TestFactory7(i); },
+            [](base_tag, pointer_tag, int i) { return (TestFactory7 *) new PyTF7(i); }))
+        .def(py::init(
+            [](alias_tag, pointer_tag, int i) { return new PyTF7(i); },
+            [](alias_tag, pointer_tag, int i) { return new PyTF7(10*i); }))
+        .def(py::init(
+            [](shared_ptr_tag, base_tag, int i) { return std::make_shared<TestFactory7>(i); },
+            [](shared_ptr_tag, base_tag, int i) { auto *p = new PyTF7(i); return std::shared_ptr<TestFactory7>(p); }))
+        .def(py::init(
+            [](shared_ptr_tag, invalid_base_tag, int i) { return std::make_shared<TestFactory7>(i); },
+            [](shared_ptr_tag, invalid_base_tag, int i) { return std::make_shared<TestFactory7>(i); })) // <-- invalid alias factory
+
+        .def("get", &TestFactory7::get)
+        .def("has_alias", &TestFactory7::has_alias)
+
+        .def_static("get_cstats", &ConstructorStats::get<TestFactory7>, py::return_value_policy::reference)
+        .def_static("get_alias_cstats", &ConstructorStats::get<PyTF7>, py::return_value_policy::reference)
+        ;
+
+    // test_placement_new_alternative
+    // Class with a custom new operator but *without* a placement new operator (issue #948)
+    class NoPlacementNew {
+    public:
+        NoPlacementNew(int i) : i(i) { }
+        static void *operator new(std::size_t s) {
+            auto *p = ::operator new(s);
+            py::print("operator new called, returning", reinterpret_cast<uintptr_t>(p));
+            return p;
+        }
+        static void operator delete(void *p) {
+            py::print("operator delete called on", reinterpret_cast<uintptr_t>(p));
+            ::operator delete(p);
+        }
+        int i;
+    };
+    // As of 2.2, `py::init<args>` no longer requires placement new
+    py::class_<NoPlacementNew>(m, "NoPlacementNew")
+        .def(py::init<int>())
+        .def(py::init([]() { return new NoPlacementNew(100); }))
+        .def_readwrite("i", &NoPlacementNew::i)
+        ;
+
+
+    // test_reallocations
+    // Class that has verbose operator_new/operator_delete calls
+    struct NoisyAlloc {
+        NoisyAlloc(const NoisyAlloc &) = default;
+        NoisyAlloc(int i) { py::print(py::str("NoisyAlloc(int {})").format(i)); }
+        NoisyAlloc(double d) { py::print(py::str("NoisyAlloc(double {})").format(d)); }
+        ~NoisyAlloc() { py::print("~NoisyAlloc()"); }
+
+        static void *operator new(size_t s) { py::print("noisy new"); return ::operator new(s); }
+        static void *operator new(size_t, void *p) { py::print("noisy placement new"); return p; }
+        static void operator delete(void *p, size_t) { py::print("noisy delete"); ::operator delete(p); }
+        static void operator delete(void *, void *) { py::print("noisy placement delete"); }
+#if defined(_MSC_VER) && _MSC_VER < 1910
+        // MSVC 2015 bug: the above "noisy delete" isn't invoked (fixed in MSVC 2017)
+        static void operator delete(void *p) { py::print("noisy delete"); ::operator delete(p); }
+#endif
+    };
+    py::class_<NoisyAlloc>(m, "NoisyAlloc")
+        // Since these overloads have the same number of arguments, the dispatcher will try each of
+        // them until the arguments convert.  Thus we can get a pre-allocation here when passing a
+        // single non-integer:
+        .def("__init__", [](NoisyAlloc *a, int i) { new (a) NoisyAlloc(i); }) // Regular constructor, runs first, requires preallocation
+        .def(py::init([](double d) { return new NoisyAlloc(d); }))
+
+        // The two-argument version: first the factory pointer overload.
+        .def(py::init([](int i, int) { return new NoisyAlloc(i); }))
+        // Return-by-value:
+        .def(py::init([](double d, int) { return NoisyAlloc(d); }))
+        // Old-style placement new init; requires preallocation
+        .def("__init__", [](NoisyAlloc &a, double d, double) { new (&a) NoisyAlloc(d); })
+        // Requires deallocation of previous overload preallocated value:
+        .def(py::init([](int i, double) { return new NoisyAlloc(i); }))
+        // Regular again: requires yet another preallocation
+        .def("__init__", [](NoisyAlloc &a, int i, std::string) { new (&a) NoisyAlloc(i); })
+        ;
+
+
+
+
+    // static_assert testing (the following def's should all fail with appropriate compilation errors):
+#if 0
+    struct BadF1Base {};
+    struct BadF1 : BadF1Base {};
+    struct PyBadF1 : BadF1 {};
+    py::class_<BadF1, PyBadF1, std::shared_ptr<BadF1>> bf1(m, "BadF1");
+    // wrapped factory function must return a compatible pointer, holder, or value
+    bf1.def(py::init([]() { return 3; }));
+    // incompatible factory function pointer return type
+    bf1.def(py::init([]() { static int three = 3; return &three; }));
+    // incompatible factory function std::shared_ptr<T> return type: cannot convert shared_ptr<T> to holder
+    // (non-polymorphic base)
+    bf1.def(py::init([]() { return std::shared_ptr<BadF1Base>(new BadF1()); }));
+#endif
+}
diff --git a/src/pybind11/tests/test_factory_constructors.py b/src/pybind11/tests/test_factory_constructors.py
new file mode 100644
index 0000000..78a3910
--- /dev/null
+++ b/src/pybind11/tests/test_factory_constructors.py
@@ -0,0 +1,459 @@
+import pytest
+import re
+
+from pybind11_tests import factory_constructors as m
+from pybind11_tests.factory_constructors import tag
+from pybind11_tests import ConstructorStats
+
+
+def test_init_factory_basic():
+    """Tests py::init_factory() wrapper around various ways of returning the object"""
+
+    cstats = [ConstructorStats.get(c) for c in [m.TestFactory1, m.TestFactory2, m.TestFactory3]]
+    cstats[0].alive()  # force gc
+    n_inst = ConstructorStats.detail_reg_inst()
+
+    x1 = m.TestFactory1(tag.unique_ptr, 3)
+    assert x1.value == "3"
+    y1 = m.TestFactory1(tag.pointer)
+    assert y1.value == "(empty)"
+    z1 = m.TestFactory1("hi!")
+    assert z1.value == "hi!"
+
+    assert ConstructorStats.detail_reg_inst() == n_inst + 3
+
+    x2 = m.TestFactory2(tag.move)
+    assert x2.value == "(empty2)"
+    y2 = m.TestFactory2(tag.pointer, 7)
+    assert y2.value == "7"
+    z2 = m.TestFactory2(tag.unique_ptr, "hi again")
+    assert z2.value == "hi again"
+
+    assert ConstructorStats.detail_reg_inst() == n_inst + 6
+
+    x3 = m.TestFactory3(tag.shared_ptr)
+    assert x3.value == "(empty3)"
+    y3 = m.TestFactory3(tag.pointer, 42)
+    assert y3.value == "42"
+    z3 = m.TestFactory3("bye")
+    assert z3.value == "bye"
+
+    with pytest.raises(TypeError) as excinfo:
+        m.TestFactory3(tag.null_ptr)
+    assert str(excinfo.value) == "pybind11::init(): factory function returned nullptr"
+
+    assert [i.alive() for i in cstats] == [3, 3, 3]
+    assert ConstructorStats.detail_reg_inst() == n_inst + 9
+
+    del x1, y2, y3, z3
+    assert [i.alive() for i in cstats] == [2, 2, 1]
+    assert ConstructorStats.detail_reg_inst() == n_inst + 5
+    del x2, x3, y1, z1, z2
+    assert [i.alive() for i in cstats] == [0, 0, 0]
+    assert ConstructorStats.detail_reg_inst() == n_inst
+
+    assert [i.values() for i in cstats] == [
+        ["3", "hi!"],
+        ["7", "hi again"],
+        ["42", "bye"]
+    ]
+    assert [i.default_constructions for i in cstats] == [1, 1, 1]
+
+
+def test_init_factory_signature(msg):
+    with pytest.raises(TypeError) as excinfo:
+        m.TestFactory1("invalid", "constructor", "arguments")
+    assert msg(excinfo.value) == """
+        __init__(): incompatible constructor arguments. The following argument types are supported:
+            1. m.factory_constructors.TestFactory1(arg0: m.factory_constructors.tag.unique_ptr_tag, arg1: int)
+            2. m.factory_constructors.TestFactory1(arg0: str)
+            3. m.factory_constructors.TestFactory1(arg0: m.factory_constructors.tag.pointer_tag)
+            4. m.factory_constructors.TestFactory1(arg0: handle, arg1: int, arg2: handle)
+
+        Invoked with: 'invalid', 'constructor', 'arguments'
+    """  # noqa: E501 line too long
+
+    assert msg(m.TestFactory1.__init__.__doc__) == """
+        __init__(*args, **kwargs)
+        Overloaded function.
+
+        1. __init__(self: m.factory_constructors.TestFactory1, arg0: m.factory_constructors.tag.unique_ptr_tag, arg1: int) -> None
+
+        2. __init__(self: m.factory_constructors.TestFactory1, arg0: str) -> None
+
+        3. __init__(self: m.factory_constructors.TestFactory1, arg0: m.factory_constructors.tag.pointer_tag) -> None
+
+        4. __init__(self: m.factory_constructors.TestFactory1, arg0: handle, arg1: int, arg2: handle) -> None
+    """  # noqa: E501 line too long
+
+
+def test_init_factory_casting():
+    """Tests py::init_factory() wrapper with various upcasting and downcasting returns"""
+
+    cstats = [ConstructorStats.get(c) for c in [m.TestFactory3, m.TestFactory4, m.TestFactory5]]
+    cstats[0].alive()  # force gc
+    n_inst = ConstructorStats.detail_reg_inst()
+
+    # Construction from derived references:
+    a = m.TestFactory3(tag.pointer, tag.TF4, 4)
+    assert a.value == "4"
+    b = m.TestFactory3(tag.shared_ptr, tag.TF4, 5)
+    assert b.value == "5"
+    c = m.TestFactory3(tag.pointer, tag.TF5, 6)
+    assert c.value == "6"
+    d = m.TestFactory3(tag.shared_ptr, tag.TF5, 7)
+    assert d.value == "7"
+
+    assert ConstructorStats.detail_reg_inst() == n_inst + 4
+
+    # Shared a lambda with TF3:
+    e = m.TestFactory4(tag.pointer, tag.TF4, 8)
+    assert e.value == "8"
+
+    assert ConstructorStats.detail_reg_inst() == n_inst + 5
+    assert [i.alive() for i in cstats] == [5, 3, 2]
+
+    del a
+    assert [i.alive() for i in cstats] == [4, 2, 2]
+    assert ConstructorStats.detail_reg_inst() == n_inst + 4
+
+    del b, c, e
+    assert [i.alive() for i in cstats] == [1, 0, 1]
+    assert ConstructorStats.detail_reg_inst() == n_inst + 1
+
+    del d
+    assert [i.alive() for i in cstats] == [0, 0, 0]
+    assert ConstructorStats.detail_reg_inst() == n_inst
+
+    assert [i.values() for i in cstats] == [
+        ["4", "5", "6", "7", "8"],
+        ["4", "5", "8"],
+        ["6", "7"]
+    ]
+
+
+def test_init_factory_alias():
+    """Tests py::init_factory() wrapper with value conversions and alias types"""
+
+    cstats = [m.TestFactory6.get_cstats(), m.TestFactory6.get_alias_cstats()]
+    cstats[0].alive()  # force gc
+    n_inst = ConstructorStats.detail_reg_inst()
+
+    a = m.TestFactory6(tag.base, 1)
+    assert a.get() == 1
+    assert not a.has_alias()
+    b = m.TestFactory6(tag.alias, "hi there")
+    assert b.get() == 8
+    assert b.has_alias()
+    c = m.TestFactory6(tag.alias, 3)
+    assert c.get() == 3
+    assert c.has_alias()
+    d = m.TestFactory6(tag.alias, tag.pointer, 4)
+    assert d.get() == 4
+    assert d.has_alias()
+    e = m.TestFactory6(tag.base, tag.pointer, 5)
+    assert e.get() == 5
+    assert not e.has_alias()
+    f = m.TestFactory6(tag.base, tag.alias, tag.pointer, 6)
+    assert f.get() == 6
+    assert f.has_alias()
+
+    assert ConstructorStats.detail_reg_inst() == n_inst + 6
+    assert [i.alive() for i in cstats] == [6, 4]
+
+    del a, b, e
+    assert [i.alive() for i in cstats] == [3, 3]
+    assert ConstructorStats.detail_reg_inst() == n_inst + 3
+    del f, c, d
+    assert [i.alive() for i in cstats] == [0, 0]
+    assert ConstructorStats.detail_reg_inst() == n_inst
+
+    class MyTest(m.TestFactory6):
+        def __init__(self, *args):
+            m.TestFactory6.__init__(self, *args)
+
+        def get(self):
+            return -5 + m.TestFactory6.get(self)
+
+    # Return Class by value, moved into new alias:
+    z = MyTest(tag.base, 123)
+    assert z.get() == 118
+    assert z.has_alias()
+
+    # Return alias by value, moved into new alias:
+    y = MyTest(tag.alias, "why hello!")
+    assert y.get() == 5
+    assert y.has_alias()
+
+    # Return Class by pointer, moved into new alias then original destroyed:
+    x = MyTest(tag.base, tag.pointer, 47)
+    assert x.get() == 42
+    assert x.has_alias()
+
+    assert ConstructorStats.detail_reg_inst() == n_inst + 3
+    assert [i.alive() for i in cstats] == [3, 3]
+    del x, y, z
+    assert [i.alive() for i in cstats] == [0, 0]
+    assert ConstructorStats.detail_reg_inst() == n_inst
+
+    assert [i.values() for i in cstats] == [
+        ["1", "8", "3", "4", "5", "6", "123", "10", "47"],
+        ["hi there", "3", "4", "6", "move", "123", "why hello!", "move", "47"]
+    ]
+
+
+def test_init_factory_dual():
+    """Tests init factory functions with dual main/alias factory functions"""
+    from pybind11_tests.factory_constructors import TestFactory7
+
+    cstats = [TestFactory7.get_cstats(), TestFactory7.get_alias_cstats()]
+    cstats[0].alive()  # force gc
+    n_inst = ConstructorStats.detail_reg_inst()
+
+    class PythFactory7(TestFactory7):
+        def get(self):
+            return 100 + TestFactory7.get(self)
+
+    a1 = TestFactory7(1)
+    a2 = PythFactory7(2)
+    assert a1.get() == 1
+    assert a2.get() == 102
+    assert not a1.has_alias()
+    assert a2.has_alias()
+
+    b1 = TestFactory7(tag.pointer, 3)
+    b2 = PythFactory7(tag.pointer, 4)
+    assert b1.get() == 3
+    assert b2.get() == 104
+    assert not b1.has_alias()
+    assert b2.has_alias()
+
+    c1 = TestFactory7(tag.mixed, 5)
+    c2 = PythFactory7(tag.mixed, 6)
+    assert c1.get() == 5
+    assert c2.get() == 106
+    assert not c1.has_alias()
+    assert c2.has_alias()
+
+    d1 = TestFactory7(tag.base, tag.pointer, 7)
+    d2 = PythFactory7(tag.base, tag.pointer, 8)
+    assert d1.get() == 7
+    assert d2.get() == 108
+    assert not d1.has_alias()
+    assert d2.has_alias()
+
+    # Both return an alias; the second multiplies the value by 10:
+    e1 = TestFactory7(tag.alias, tag.pointer, 9)
+    e2 = PythFactory7(tag.alias, tag.pointer, 10)
+    assert e1.get() == 9
+    assert e2.get() == 200
+    assert e1.has_alias()
+    assert e2.has_alias()
+
+    f1 = TestFactory7(tag.shared_ptr, tag.base, 11)
+    f2 = PythFactory7(tag.shared_ptr, tag.base, 12)
+    assert f1.get() == 11
+    assert f2.get() == 112
+    assert not f1.has_alias()
+    assert f2.has_alias()
+
+    g1 = TestFactory7(tag.shared_ptr, tag.invalid_base, 13)
+    assert g1.get() == 13
+    assert not g1.has_alias()
+    with pytest.raises(TypeError) as excinfo:
+        PythFactory7(tag.shared_ptr, tag.invalid_base, 14)
+    assert (str(excinfo.value) ==
+            "pybind11::init(): construction failed: returned holder-wrapped instance is not an "
+            "alias instance")
+
+    assert [i.alive() for i in cstats] == [13, 7]
+    assert ConstructorStats.detail_reg_inst() == n_inst + 13
+
+    del a1, a2, b1, d1, e1, e2
+    assert [i.alive() for i in cstats] == [7, 4]
+    assert ConstructorStats.detail_reg_inst() == n_inst + 7
+    del b2, c1, c2, d2, f1, f2, g1
+    assert [i.alive() for i in cstats] == [0, 0]
+    assert ConstructorStats.detail_reg_inst() == n_inst
+
+    assert [i.values() for i in cstats] == [
+        ["1", "2", "3", "4", "5", "6", "7", "8", "9", "100", "11", "12", "13", "14"],
+        ["2", "4", "6", "8", "9", "100", "12"]
+    ]
+
+
+def test_no_placement_new(capture):
+    """Prior to 2.2, `py::init<...>` relied on the type supporting placement
+    new; this tests a class without placement new support."""
+    with capture:
+        a = m.NoPlacementNew(123)
+
+    found = re.search(r'^operator new called, returning (\d+)\n$', str(capture))
+    assert found
+    assert a.i == 123
+    with capture:
+        del a
+        pytest.gc_collect()
+    assert capture == "operator delete called on " + found.group(1)
+
+    with capture:
+        b = m.NoPlacementNew()
+
+    found = re.search(r'^operator new called, returning (\d+)\n$', str(capture))
+    assert found
+    assert b.i == 100
+    with capture:
+        del b
+        pytest.gc_collect()
+    assert capture == "operator delete called on " + found.group(1)
+
+
+def test_multiple_inheritance():
+    class MITest(m.TestFactory1, m.TestFactory2):
+        def __init__(self):
+            m.TestFactory1.__init__(self, tag.unique_ptr, 33)
+            m.TestFactory2.__init__(self, tag.move)
+
+    a = MITest()
+    assert m.TestFactory1.value.fget(a) == "33"
+    assert m.TestFactory2.value.fget(a) == "(empty2)"
+
+
+def create_and_destroy(*args):
+    a = m.NoisyAlloc(*args)
+    print("---")
+    del a
+    pytest.gc_collect()
+
+
+def strip_comments(s):
+    return re.sub(r'\s+#.*', '', s)
+
+
+def test_reallocations(capture, msg):
+    """When the constructor is overloaded, previous overloads can require a preallocated value.
+    This test makes sure that such preallocated values only happen when they might be necessary,
+    and that they are deallocated properly"""
+
+    pytest.gc_collect()
+
+    with capture:
+        create_and_destroy(1)
+    assert msg(capture) == """
+        noisy new
+        noisy placement new
+        NoisyAlloc(int 1)
+        ---
+        ~NoisyAlloc()
+        noisy delete
+    """
+    with capture:
+        create_and_destroy(1.5)
+    assert msg(capture) == strip_comments("""
+        noisy new               # allocation required to attempt first overload
+        noisy delete            # have to dealloc before considering factory init overload
+        noisy new               # pointer factory calling "new", part 1: allocation
+        NoisyAlloc(double 1.5)  # ... part two, invoking constructor
+        ---
+        ~NoisyAlloc()  # Destructor
+        noisy delete   # operator delete
+    """)
+
+    with capture:
+        create_and_destroy(2, 3)
+    assert msg(capture) == strip_comments("""
+        noisy new          # pointer factory calling "new", allocation
+        NoisyAlloc(int 2)  # constructor
+        ---
+        ~NoisyAlloc()  # Destructor
+        noisy delete   # operator delete
+    """)
+
+    with capture:
+        create_and_destroy(2.5, 3)
+    assert msg(capture) == strip_comments("""
+        NoisyAlloc(double 2.5)  # construction (local func variable: operator_new not called)
+        noisy new               # return-by-value "new" part 1: allocation
+        ~NoisyAlloc()           # moved-away local func variable destruction
+        ---
+        ~NoisyAlloc()  # Destructor
+        noisy delete   # operator delete
+    """)
+
+    with capture:
+        create_and_destroy(3.5, 4.5)
+    assert msg(capture) == strip_comments("""
+        noisy new               # preallocation needed before invoking placement-new overload
+        noisy placement new     # Placement new
+        NoisyAlloc(double 3.5)  # construction
+        ---
+        ~NoisyAlloc()  # Destructor
+        noisy delete   # operator delete
+    """)
+
+    with capture:
+        create_and_destroy(4, 0.5)
+    assert msg(capture) == strip_comments("""
+        noisy new          # preallocation needed before invoking placement-new overload
+        noisy delete       # deallocation of preallocated storage
+        noisy new          # Factory pointer allocation
+        NoisyAlloc(int 4)  # factory pointer construction
+        ---
+        ~NoisyAlloc()  # Destructor
+        noisy delete   # operator delete
+    """)
+
+    with capture:
+        create_and_destroy(5, "hi")
+    assert msg(capture) == strip_comments("""
+        noisy new            # preallocation needed before invoking first placement new
+        noisy delete         # delete before considering new-style constructor
+        noisy new            # preallocation for second placement new
+        noisy placement new  # Placement new in the second placement new overload
+        NoisyAlloc(int 5)    # construction
+        ---
+        ~NoisyAlloc()  # Destructor
+        noisy delete   # operator delete
+    """)
+
+
+@pytest.unsupported_on_py2
+def test_invalid_self():
+    """Tests invocation of the pybind-registered base class with an invalid `self` argument.  You
+    can only actually do this on Python 3: Python 2 raises an exception itself if you try."""
+    class NotPybindDerived(object):
+        pass
+
+    # Attempts to initialize with an invalid type passed as `self`:
+    class BrokenTF1(m.TestFactory1):
+        def __init__(self, bad):
+            if bad == 1:
+                a = m.TestFactory2(tag.pointer, 1)
+                m.TestFactory1.__init__(a, tag.pointer)
+            elif bad == 2:
+                a = NotPybindDerived()
+                m.TestFactory1.__init__(a, tag.pointer)
+
+    # Same as above, but for a class with an alias:
+    class BrokenTF6(m.TestFactory6):
+        def __init__(self, bad):
+            if bad == 1:
+                a = m.TestFactory2(tag.pointer, 1)
+                m.TestFactory6.__init__(a, tag.base, 1)
+            elif bad == 2:
+                a = m.TestFactory2(tag.pointer, 1)
+                m.TestFactory6.__init__(a, tag.alias, 1)
+            elif bad == 3:
+                m.TestFactory6.__init__(NotPybindDerived.__new__(NotPybindDerived), tag.base, 1)
+            elif bad == 4:
+                m.TestFactory6.__init__(NotPybindDerived.__new__(NotPybindDerived), tag.alias, 1)
+
+    for arg in (1, 2):
+        with pytest.raises(TypeError) as excinfo:
+            BrokenTF1(arg)
+        assert str(excinfo.value) == "__init__(self, ...) called with invalid `self` argument"
+
+    for arg in (1, 2, 3, 4):
+        with pytest.raises(TypeError) as excinfo:
+            BrokenTF6(arg)
+        assert str(excinfo.value) == "__init__(self, ...) called with invalid `self` argument"
diff --git a/src/pybind11/tests/test_gil_scoped.cpp b/src/pybind11/tests/test_gil_scoped.cpp
new file mode 100644
index 0000000..76c17fd
--- /dev/null
+++ b/src/pybind11/tests/test_gil_scoped.cpp
@@ -0,0 +1,52 @@
+/*
+    tests/test_gil_scoped.cpp -- acquire and release gil
+
+    Copyright (c) 2017 Borja Zarco (Google LLC) <bzarco@google.com>
+
+    All rights reserved. Use of this source code is governed by a
+    BSD-style license that can be found in the LICENSE file.
+*/
+
+#include "pybind11_tests.h"
+#include <pybind11/functional.h>
+
+
+class VirtClass  {
+public:
+    virtual ~VirtClass() {}
+    virtual void virtual_func() {}
+    virtual void pure_virtual_func() = 0;
+};
+
+class PyVirtClass : public VirtClass {
+    void virtual_func() override {
+        PYBIND11_OVERLOAD(void, VirtClass, virtual_func,);
+    }
+    void pure_virtual_func() override {
+        PYBIND11_OVERLOAD_PURE(void, VirtClass, pure_virtual_func,);
+    }
+};
+
+TEST_SUBMODULE(gil_scoped, m) {
+  py::class_<VirtClass, PyVirtClass>(m, "VirtClass")
+      .def(py::init<>())
+      .def("virtual_func", &VirtClass::virtual_func)
+      .def("pure_virtual_func", &VirtClass::pure_virtual_func);
+
+    m.def("test_callback_py_obj",
+          [](py::object func) { func(); });
+    m.def("test_callback_std_func",
+          [](const std::function<void()> &func) { func(); });
+    m.def("test_callback_virtual_func",
+          [](VirtClass &virt) { virt.virtual_func(); });
+    m.def("test_callback_pure_virtual_func",
+          [](VirtClass &virt) { virt.pure_virtual_func(); });
+    m.def("test_cross_module_gil",
+          []() {
+              auto cm = py::module::import("cross_module_gil_utils");
+              auto gil_acquire = reinterpret_cast<void (*)()>(
+                  PyLong_AsVoidPtr(cm.attr("gil_acquire_funcaddr").ptr()));
+              py::gil_scoped_release gil_release;
+              gil_acquire();
+          });
+}
diff --git a/src/pybind11/tests/test_gil_scoped.py b/src/pybind11/tests/test_gil_scoped.py
new file mode 100644
index 0000000..1548337
--- /dev/null
+++ b/src/pybind11/tests/test_gil_scoped.py
@@ -0,0 +1,85 @@
+import multiprocessing
+import threading
+from pybind11_tests import gil_scoped as m
+
+
+def _run_in_process(target, *args, **kwargs):
+    """Runs target in process and returns its exitcode after 10s (None if still alive)."""
+    process = multiprocessing.Process(target=target, args=args, kwargs=kwargs)
+    process.daemon = True
+    try:
+        process.start()
+        # Do not need to wait much, 10s should be more than enough.
+        process.join(timeout=10)
+        return process.exitcode
+    finally:
+        if process.is_alive():
+            process.terminate()
+
+
+def _python_to_cpp_to_python():
+    """Calls different C++ functions that come back to Python."""
+    class ExtendedVirtClass(m.VirtClass):
+        def virtual_func(self):
+            pass
+
+        def pure_virtual_func(self):
+            pass
+
+    extended = ExtendedVirtClass()
+    m.test_callback_py_obj(lambda: None)
+    m.test_callback_std_func(lambda: None)
+    m.test_callback_virtual_func(extended)
+    m.test_callback_pure_virtual_func(extended)
+
+
+def _python_to_cpp_to_python_from_threads(num_threads, parallel=False):
+    """Calls different C++ functions that come back to Python, from Python threads."""
+    threads = []
+    for _ in range(num_threads):
+        thread = threading.Thread(target=_python_to_cpp_to_python)
+        thread.daemon = True
+        thread.start()
+        if parallel:
+            threads.append(thread)
+        else:
+            thread.join()
+    for thread in threads:
+        thread.join()
+
+
+def test_python_to_cpp_to_python_from_thread():
+    """Makes sure there is no GIL deadlock when running in a thread.
+
+    It runs in a separate process to be able to stop and assert if it deadlocks.
+    """
+    assert _run_in_process(_python_to_cpp_to_python_from_threads, 1) == 0
+
+
+def test_python_to_cpp_to_python_from_thread_multiple_parallel():
+    """Makes sure there is no GIL deadlock when running in a thread multiple times in parallel.
+
+    It runs in a separate process to be able to stop and assert if it deadlocks.
+    """
+    assert _run_in_process(_python_to_cpp_to_python_from_threads, 8, parallel=True) == 0
+
+
+def test_python_to_cpp_to_python_from_thread_multiple_sequential():
+    """Makes sure there is no GIL deadlock when running in a thread multiple times sequentially.
+
+    It runs in a separate process to be able to stop and assert if it deadlocks.
+    """
+    assert _run_in_process(_python_to_cpp_to_python_from_threads, 8, parallel=False) == 0
+
+
+def test_python_to_cpp_to_python_from_process():
+    """Makes sure there is no GIL deadlock when using processes.
+
+    This test is for completion, but it was never an issue.
+    """
+    assert _run_in_process(_python_to_cpp_to_python) == 0
+
+
+def test_cross_module_gil():
+    """Makes sure that the GIL can be acquired by another module from a GIL-released state."""
+    m.test_cross_module_gil()  # Should not raise a SIGSEGV
diff --git a/src/pybind11/tests/test_iostream.cpp b/src/pybind11/tests/test_iostream.cpp
new file mode 100644
index 0000000..e67f88a
--- /dev/null
+++ b/src/pybind11/tests/test_iostream.cpp
@@ -0,0 +1,73 @@
+/*
+    tests/test_iostream.cpp -- Usage of scoped_output_redirect
+
+    Copyright (c) 2017 Henry F. Schreiner
+
+    All rights reserved. Use of this source code is governed by a
+    BSD-style license that can be found in the LICENSE file.
+*/
+
+
+#include <pybind11/iostream.h>
+#include "pybind11_tests.h"
+#include <iostream>
+
+
+void noisy_function(std::string msg, bool flush) {
+
+    std::cout << msg;
+    if (flush)
+        std::cout << std::flush;
+}
+
+void noisy_funct_dual(std::string msg, std::string emsg) {
+    std::cout << msg;
+    std::cerr << emsg;
+}
+
+TEST_SUBMODULE(iostream, m) {
+
+    add_ostream_redirect(m);
+
+    // test_evals
+
+    m.def("captured_output_default", [](std::string msg) {
+        py::scoped_ostream_redirect redir;
+        std::cout << msg << std::flush;
+    });
+
+    m.def("captured_output", [](std::string msg) {
+        py::scoped_ostream_redirect redir(std::cout, py::module::import("sys").attr("stdout"));
+        std::cout << msg << std::flush;
+    });
+
+    m.def("guard_output", &noisy_function,
+            py::call_guard<py::scoped_ostream_redirect>(),
+            py::arg("msg"), py::arg("flush")=true);
+
+    m.def("captured_err", [](std::string msg) {
+        py::scoped_ostream_redirect redir(std::cerr, py::module::import("sys").attr("stderr"));
+        std::cerr << msg << std::flush;
+    });
+
+    m.def("noisy_function", &noisy_function, py::arg("msg"), py::arg("flush") = true);
+
+    m.def("dual_guard", &noisy_funct_dual,
+            py::call_guard<py::scoped_ostream_redirect, py::scoped_estream_redirect>(),
+            py::arg("msg"), py::arg("emsg"));
+
+    m.def("raw_output", [](std::string msg) {
+        std::cout << msg << std::flush;
+    });
+
+    m.def("raw_err", [](std::string msg) {
+        std::cerr << msg << std::flush;
+    });
+
+    m.def("captured_dual", [](std::string msg, std::string emsg) {
+        py::scoped_ostream_redirect redirout(std::cout, py::module::import("sys").attr("stdout"));
+        py::scoped_ostream_redirect redirerr(std::cerr, py::module::import("sys").attr("stderr"));
+        std::cout << msg << std::flush;
+        std::cerr << emsg << std::flush;
+    });
+}
diff --git a/src/pybind11/tests/test_iostream.py b/src/pybind11/tests/test_iostream.py
new file mode 100644
index 0000000..27095b2
--- /dev/null
+++ b/src/pybind11/tests/test_iostream.py
@@ -0,0 +1,214 @@
+from pybind11_tests import iostream as m
+import sys
+
+from contextlib import contextmanager
+
+try:
+    # Python 3
+    from io import StringIO
+except ImportError:
+    # Python 2
+    try:
+        from cStringIO import StringIO
+    except ImportError:
+        from StringIO import StringIO
+
+try:
+    # Python 3.4
+    from contextlib import redirect_stdout
+except ImportError:
+    @contextmanager
+    def redirect_stdout(target):
+        original = sys.stdout
+        sys.stdout = target
+        yield
+        sys.stdout = original
+
+try:
+    # Python 3.5
+    from contextlib import redirect_stderr
+except ImportError:
+    @contextmanager
+    def redirect_stderr(target):
+        original = sys.stderr
+        sys.stderr = target
+        yield
+        sys.stderr = original
+
+
+def test_captured(capsys):
+    msg = "I've been redirected to Python, I hope!"
+    m.captured_output(msg)
+    stdout, stderr = capsys.readouterr()
+    assert stdout == msg
+    assert stderr == ''
+
+    m.captured_output_default(msg)
+    stdout, stderr = capsys.readouterr()
+    assert stdout == msg
+    assert stderr == ''
+
+    m.captured_err(msg)
+    stdout, stderr = capsys.readouterr()
+    assert stdout == ''
+    assert stderr == msg
+
+
+def test_captured_large_string(capsys):
+    # Make this bigger than the buffer used on the C++ side: 1024 chars
+    msg = "I've been redirected to Python, I hope!"
+    msg = msg * (1024 // len(msg) + 1)
+
+    m.captured_output_default(msg)
+    stdout, stderr = capsys.readouterr()
+    assert stdout == msg
+    assert stderr == ''
+
+
+def test_guard_capture(capsys):
+    msg = "I've been redirected to Python, I hope!"
+    m.guard_output(msg)
+    stdout, stderr = capsys.readouterr()
+    assert stdout == msg
+    assert stderr == ''
+
+
+def test_series_captured(capture):
+    with capture:
+        m.captured_output("a")
+        m.captured_output("b")
+    assert capture == "ab"
+
+
+def test_flush(capfd):
+    msg = "(not flushed)"
+    msg2 = "(flushed)"
+
+    with m.ostream_redirect():
+        m.noisy_function(msg, flush=False)
+        stdout, stderr = capfd.readouterr()
+        assert stdout == ''
+
+        m.noisy_function(msg2, flush=True)
+        stdout, stderr = capfd.readouterr()
+        assert stdout == msg + msg2
+
+        m.noisy_function(msg, flush=False)
+
+    stdout, stderr = capfd.readouterr()
+    assert stdout == msg
+
+
+def test_not_captured(capfd):
+    msg = "Something that should not show up in log"
+    stream = StringIO()
+    with redirect_stdout(stream):
+        m.raw_output(msg)
+    stdout, stderr = capfd.readouterr()
+    assert stdout == msg
+    assert stderr == ''
+    assert stream.getvalue() == ''
+
+    stream = StringIO()
+    with redirect_stdout(stream):
+        m.captured_output(msg)
+    stdout, stderr = capfd.readouterr()
+    assert stdout == ''
+    assert stderr == ''
+    assert stream.getvalue() == msg
+
+
+def test_err(capfd):
+    msg = "Something that should not show up in log"
+    stream = StringIO()
+    with redirect_stderr(stream):
+        m.raw_err(msg)
+    stdout, stderr = capfd.readouterr()
+    assert stdout == ''
+    assert stderr == msg
+    assert stream.getvalue() == ''
+
+    stream = StringIO()
+    with redirect_stderr(stream):
+        m.captured_err(msg)
+    stdout, stderr = capfd.readouterr()
+    assert stdout == ''
+    assert stderr == ''
+    assert stream.getvalue() == msg
+
+
+def test_multi_captured(capfd):
+    stream = StringIO()
+    with redirect_stdout(stream):
+        m.captured_output("a")
+        m.raw_output("b")
+        m.captured_output("c")
+        m.raw_output("d")
+    stdout, stderr = capfd.readouterr()
+    assert stdout == 'bd'
+    assert stream.getvalue() == 'ac'
+
+
+def test_dual(capsys):
+    m.captured_dual("a", "b")
+    stdout, stderr = capsys.readouterr()
+    assert stdout == "a"
+    assert stderr == "b"
+
+
+def test_redirect(capfd):
+    msg = "Should not be in log!"
+    stream = StringIO()
+    with redirect_stdout(stream):
+        m.raw_output(msg)
+    stdout, stderr = capfd.readouterr()
+    assert stdout == msg
+    assert stream.getvalue() == ''
+
+    stream = StringIO()
+    with redirect_stdout(stream):
+        with m.ostream_redirect():
+            m.raw_output(msg)
+    stdout, stderr = capfd.readouterr()
+    assert stdout == ''
+    assert stream.getvalue() == msg
+
+    stream = StringIO()
+    with redirect_stdout(stream):
+        m.raw_output(msg)
+    stdout, stderr = capfd.readouterr()
+    assert stdout == msg
+    assert stream.getvalue() == ''
+
+
+def test_redirect_err(capfd):
+    msg = "StdOut"
+    msg2 = "StdErr"
+
+    stream = StringIO()
+    with redirect_stderr(stream):
+        with m.ostream_redirect(stdout=False):
+            m.raw_output(msg)
+            m.raw_err(msg2)
+    stdout, stderr = capfd.readouterr()
+    assert stdout == msg
+    assert stderr == ''
+    assert stream.getvalue() == msg2
+
+
+def test_redirect_both(capfd):
+    msg = "StdOut"
+    msg2 = "StdErr"
+
+    stream = StringIO()
+    stream2 = StringIO()
+    with redirect_stdout(stream):
+        with redirect_stderr(stream2):
+            with m.ostream_redirect():
+                m.raw_output(msg)
+                m.raw_err(msg2)
+    stdout, stderr = capfd.readouterr()
+    assert stdout == ''
+    assert stderr == ''
+    assert stream.getvalue() == msg
+    assert stream2.getvalue() == msg2
diff --git a/src/pybind11/tests/test_kwargs_and_defaults.cpp b/src/pybind11/tests/test_kwargs_and_defaults.cpp
index 3180123..6563fb9 100644
--- a/src/pybind11/tests/test_kwargs_and_defaults.cpp
+++ b/src/pybind11/tests/test_kwargs_and_defaults.cpp
@@ -8,86 +8,95 @@
 */
 
 #include "pybind11_tests.h"
+#include "constructor_stats.h"
 #include <pybind11/stl.h>
 
-std::string kw_func(int x, int y) { return "x=" + std::to_string(x) + ", y=" + std::to_string(y); }
+TEST_SUBMODULE(kwargs_and_defaults, m) {
+    auto kw_func = [](int x, int y) { return "x=" + std::to_string(x) + ", y=" + std::to_string(y); };
 
-std::string kw_func4(const std::vector<int> &entries) {
-    std::string ret = "{";
-    for (int i : entries)
-        ret += std::to_string(i) + " ";
-    ret.back() = '}';
-    return ret;
-}
-
-py::tuple args_function(py::args args) {
-    return args;
-}
-
-py::tuple args_kwargs_function(py::args args, py::kwargs kwargs) {
-    return py::make_tuple(args, kwargs);
-}
-
-py::tuple mixed_plus_args(int i, double j, py::args args) {
-    return py::make_tuple(i, j, args);
-}
-
-py::tuple mixed_plus_kwargs(int i, double j, py::kwargs kwargs) {
-    return py::make_tuple(i, j, kwargs);
-}
-
-py::tuple mixed_plus_args_kwargs(int i, double j, py::args args, py::kwargs kwargs) {
-    return py::make_tuple(i, j, args, kwargs);
-}
-
-// pybind11 won't allow these to be bound: args and kwargs, if present, must be at the end.
-void bad_args1(py::args, int) {}
-void bad_args2(py::kwargs, int) {}
-void bad_args3(py::kwargs, py::args) {}
-void bad_args4(py::args, int, py::kwargs) {}
-void bad_args5(py::args, py::kwargs, int) {}
-void bad_args6(py::args, py::args) {}
-void bad_args7(py::kwargs, py::kwargs) {}
-
-struct KWClass {
-    void foo(int, float) {}
-};
-
-test_initializer arg_keywords_and_defaults([](py::module &m) {
-    m.def("kw_func0", &kw_func);
-    m.def("kw_func1", &kw_func, py::arg("x"), py::arg("y"));
-    m.def("kw_func2", &kw_func, py::arg("x") = 100, py::arg("y") = 200);
+    // test_named_arguments
+    m.def("kw_func0", kw_func);
+    m.def("kw_func1", kw_func, py::arg("x"), py::arg("y"));
+    m.def("kw_func2", kw_func, py::arg("x") = 100, py::arg("y") = 200);
     m.def("kw_func3", [](const char *) { }, py::arg("data") = std::string("Hello world!"));
 
     /* A fancier default argument */
-    std::vector<int> list;
-    list.push_back(13);
-    list.push_back(17);
-    m.def("kw_func4", &kw_func4, py::arg("myList") = list);
-
-    m.def("args_function", &args_function);
-    m.def("args_kwargs_function", &args_kwargs_function);
-
-    m.def("kw_func_udl", &kw_func, "x"_a, "y"_a=300);
-    m.def("kw_func_udl_z", &kw_func, "x"_a, "y"_a=0);
+    std::vector<int> list{{13, 17}};
+    m.def("kw_func4", [](const std::vector<int> &entries) {
+        std::string ret = "{";
+        for (int i : entries)
+            ret += std::to_string(i) + " ";
+        ret.back() = '}';
+        return ret;
+    }, py::arg("myList") = list);
+
+    m.def("kw_func_udl", kw_func, "x"_a, "y"_a=300);
+    m.def("kw_func_udl_z", kw_func, "x"_a, "y"_a=0);
+
+    // test_args_and_kwargs
+    m.def("args_function", [](py::args args) -> py::tuple {
+        return std::move(args);
+    });
+    m.def("args_kwargs_function", [](py::args args, py::kwargs kwargs) {
+        return py::make_tuple(args, kwargs);
+    });
+
+    // test_mixed_args_and_kwargs
+    m.def("mixed_plus_args", [](int i, double j, py::args args) {
+        return py::make_tuple(i, j, args);
+    });
+    m.def("mixed_plus_kwargs", [](int i, double j, py::kwargs kwargs) {
+        return py::make_tuple(i, j, kwargs);
+    });
+    auto mixed_plus_both = [](int i, double j, py::args args, py::kwargs kwargs) {
+        return py::make_tuple(i, j, args, kwargs);
+    };
+    m.def("mixed_plus_args_kwargs", mixed_plus_both);
+
+    m.def("mixed_plus_args_kwargs_defaults", mixed_plus_both,
+            py::arg("i") = 1, py::arg("j") = 3.14159);
 
+    // test_args_refcount
+    // PyPy needs a garbage collection to get the reference count values to match CPython's behaviour
+    #ifdef PYPY_VERSION
+    #define GC_IF_NEEDED ConstructorStats::gc()
+    #else
+    #define GC_IF_NEEDED
+    #endif
+    m.def("arg_refcount_h", [](py::handle h) { GC_IF_NEEDED; return h.ref_count(); });
+    m.def("arg_refcount_h", [](py::handle h, py::handle, py::handle) { GC_IF_NEEDED; return h.ref_count(); });
+    m.def("arg_refcount_o", [](py::object o) { GC_IF_NEEDED; return o.ref_count(); });
+    m.def("args_refcount", [](py::args a) {
+        GC_IF_NEEDED;
+        py::tuple t(a.size());
+        for (size_t i = 0; i < a.size(); i++)
+            // Use raw Python API here to avoid an extra, intermediate incref on the tuple item:
+            t[i] = (int) Py_REFCNT(PyTuple_GET_ITEM(a.ptr(), static_cast<ssize_t>(i)));
+        return t;
+    });
+    m.def("mixed_args_refcount", [](py::object o, py::args a) {
+        GC_IF_NEEDED;
+        py::tuple t(a.size() + 1);
+        t[0] = o.ref_count();
+        for (size_t i = 0; i < a.size(); i++)
+            // Use raw Python API here to avoid an extra, intermediate incref on the tuple item:
+            t[i + 1] = (int) Py_REFCNT(PyTuple_GET_ITEM(a.ptr(), static_cast<ssize_t>(i)));
+        return t;
+    });
+
+    // pybind11 won't allow these to be bound: args and kwargs, if present, must be at the end.
+    // Uncomment these to test that the static_assert is indeed working:
+//    m.def("bad_args1", [](py::args, int) {});
+//    m.def("bad_args2", [](py::kwargs, int) {});
+//    m.def("bad_args3", [](py::kwargs, py::args) {});
+//    m.def("bad_args4", [](py::args, int, py::kwargs) {});
+//    m.def("bad_args5", [](py::args, py::kwargs, int) {});
+//    m.def("bad_args6", [](py::args, py::args) {});
+//    m.def("bad_args7", [](py::kwargs, py::kwargs) {});
+
+    // test_function_signatures (along with most of the above)
+    struct KWClass { void foo(int, float) {} };
     py::class_<KWClass>(m, "KWClass")
         .def("foo0", &KWClass::foo)
         .def("foo1", &KWClass::foo, "x"_a, "y"_a);
-
-    m.def("mixed_plus_args", &mixed_plus_args);
-    m.def("mixed_plus_kwargs", &mixed_plus_kwargs);
-    m.def("mixed_plus_args_kwargs", &mixed_plus_args_kwargs);
-
-    m.def("mixed_plus_args_kwargs_defaults", &mixed_plus_args_kwargs,
-            py::arg("i") = 1, py::arg("j") = 3.14159);
-
-    // Uncomment these to test that the static_assert is indeed working:
-//    m.def("bad_args1", &bad_args1);
-//    m.def("bad_args2", &bad_args2);
-//    m.def("bad_args3", &bad_args3);
-//    m.def("bad_args4", &bad_args4);
-//    m.def("bad_args5", &bad_args5);
-//    m.def("bad_args6", &bad_args6);
-//    m.def("bad_args7", &bad_args7);
-});
+}
diff --git a/src/pybind11/tests/test_kwargs_and_defaults.py b/src/pybind11/tests/test_kwargs_and_defaults.py
index 90f8489..27a05a0 100644
--- a/src/pybind11/tests/test_kwargs_and_defaults.py
+++ b/src/pybind11/tests/test_kwargs_and_defaults.py
@@ -1,65 +1,64 @@
 import pytest
-from pybind11_tests import (kw_func0, kw_func1, kw_func2, kw_func3, kw_func4, args_function,
-                            args_kwargs_function, kw_func_udl, kw_func_udl_z, KWClass)
+from pybind11_tests import kwargs_and_defaults as m
 
 
 def test_function_signatures(doc):
-    assert doc(kw_func0) == "kw_func0(arg0: int, arg1: int) -> str"
-    assert doc(kw_func1) == "kw_func1(x: int, y: int) -> str"
-    assert doc(kw_func2) == "kw_func2(x: int=100, y: int=200) -> str"
-    assert doc(kw_func3) == "kw_func3(data: str='Hello world!') -> None"
-    assert doc(kw_func4) == "kw_func4(myList: List[int]=[13, 17]) -> str"
-    assert doc(kw_func_udl) == "kw_func_udl(x: int, y: int=300) -> str"
-    assert doc(kw_func_udl_z) == "kw_func_udl_z(x: int, y: int=0) -> str"
-    assert doc(args_function) == "args_function(*args) -> tuple"
-    assert doc(args_kwargs_function) == "args_kwargs_function(*args, **kwargs) -> tuple"
-    assert doc(KWClass.foo0) == "foo0(self: m.KWClass, arg0: int, arg1: float) -> None"
-    assert doc(KWClass.foo1) == "foo1(self: m.KWClass, x: int, y: float) -> None"
+    assert doc(m.kw_func0) == "kw_func0(arg0: int, arg1: int) -> str"
+    assert doc(m.kw_func1) == "kw_func1(x: int, y: int) -> str"
+    assert doc(m.kw_func2) == "kw_func2(x: int = 100, y: int = 200) -> str"
+    assert doc(m.kw_func3) == "kw_func3(data: str = 'Hello world!') -> None"
+    assert doc(m.kw_func4) == "kw_func4(myList: List[int] = [13, 17]) -> str"
+    assert doc(m.kw_func_udl) == "kw_func_udl(x: int, y: int = 300) -> str"
+    assert doc(m.kw_func_udl_z) == "kw_func_udl_z(x: int, y: int = 0) -> str"
+    assert doc(m.args_function) == "args_function(*args) -> tuple"
+    assert doc(m.args_kwargs_function) == "args_kwargs_function(*args, **kwargs) -> tuple"
+    assert doc(m.KWClass.foo0) == \
+        "foo0(self: m.kwargs_and_defaults.KWClass, arg0: int, arg1: float) -> None"
+    assert doc(m.KWClass.foo1) == \
+        "foo1(self: m.kwargs_and_defaults.KWClass, x: int, y: float) -> None"
 
 
 def test_named_arguments(msg):
-    assert kw_func0(5, 10) == "x=5, y=10"
+    assert m.kw_func0(5, 10) == "x=5, y=10"
 
-    assert kw_func1(5, 10) == "x=5, y=10"
-    assert kw_func1(5, y=10) == "x=5, y=10"
-    assert kw_func1(y=10, x=5) == "x=5, y=10"
+    assert m.kw_func1(5, 10) == "x=5, y=10"
+    assert m.kw_func1(5, y=10) == "x=5, y=10"
+    assert m.kw_func1(y=10, x=5) == "x=5, y=10"
 
-    assert kw_func2() == "x=100, y=200"
-    assert kw_func2(5) == "x=5, y=200"
-    assert kw_func2(x=5) == "x=5, y=200"
-    assert kw_func2(y=10) == "x=100, y=10"
-    assert kw_func2(5, 10) == "x=5, y=10"
-    assert kw_func2(x=5, y=10) == "x=5, y=10"
+    assert m.kw_func2() == "x=100, y=200"
+    assert m.kw_func2(5) == "x=5, y=200"
+    assert m.kw_func2(x=5) == "x=5, y=200"
+    assert m.kw_func2(y=10) == "x=100, y=10"
+    assert m.kw_func2(5, 10) == "x=5, y=10"
+    assert m.kw_func2(x=5, y=10) == "x=5, y=10"
 
     with pytest.raises(TypeError) as excinfo:
         # noinspection PyArgumentList
-        kw_func2(x=5, y=10, z=12)
+        m.kw_func2(x=5, y=10, z=12)
     assert excinfo.match(
         r'(?s)^kw_func2\(\): incompatible.*Invoked with: kwargs: ((x=5|y=10|z=12)(, |$))' + '{3}$')
 
-    assert kw_func4() == "{13 17}"
-    assert kw_func4(myList=[1, 2, 3]) == "{1 2 3}"
+    assert m.kw_func4() == "{13 17}"
+    assert m.kw_func4(myList=[1, 2, 3]) == "{1 2 3}"
 
-    assert kw_func_udl(x=5, y=10) == "x=5, y=10"
-    assert kw_func_udl_z(x=5) == "x=5, y=0"
+    assert m.kw_func_udl(x=5, y=10) == "x=5, y=10"
+    assert m.kw_func_udl_z(x=5) == "x=5, y=0"
 
 
 def test_arg_and_kwargs():
     args = 'arg1_value', 'arg2_value', 3
-    assert args_function(*args) == args
+    assert m.args_function(*args) == args
 
     args = 'a1', 'a2'
     kwargs = dict(arg3='a3', arg4=4)
-    assert args_kwargs_function(*args, **kwargs) == (args, kwargs)
+    assert m.args_kwargs_function(*args, **kwargs) == (args, kwargs)
 
 
 def test_mixed_args_and_kwargs(msg):
-    from pybind11_tests import (mixed_plus_args, mixed_plus_kwargs, mixed_plus_args_kwargs,
-                                mixed_plus_args_kwargs_defaults)
-    mpa = mixed_plus_args
-    mpk = mixed_plus_kwargs
-    mpak = mixed_plus_args_kwargs
-    mpakd = mixed_plus_args_kwargs_defaults
+    mpa = m.mixed_plus_args
+    mpk = m.mixed_plus_kwargs
+    mpak = m.mixed_plus_args_kwargs
+    mpakd = m.mixed_plus_args_kwargs_defaults
 
     assert mpa(1, 2.5, 4, 99.5, None) == (1, 2.5, (4, 99.5, None))
     assert mpa(1, 2.5) == (1, 2.5, ())
@@ -94,7 +93,7 @@ def test_mixed_args_and_kwargs(msg):
         assert mpakd(1, i=1)
     assert msg(excinfo.value) == """
         mixed_plus_args_kwargs_defaults(): incompatible function arguments. The following argument types are supported:
-            1. (i: int=1, j: float=3.14159, *args, **kwargs) -> tuple
+            1. (i: int = 1, j: float = 3.14159, *args, **kwargs) -> tuple
 
         Invoked with: 1; kwargs: i=1
     """  # noqa: E501 line too long
@@ -102,7 +101,47 @@ def test_mixed_args_and_kwargs(msg):
         assert mpakd(1, 2, j=1)
     assert msg(excinfo.value) == """
         mixed_plus_args_kwargs_defaults(): incompatible function arguments. The following argument types are supported:
-            1. (i: int=1, j: float=3.14159, *args, **kwargs) -> tuple
+            1. (i: int = 1, j: float = 3.14159, *args, **kwargs) -> tuple
 
         Invoked with: 1, 2; kwargs: j=1
     """  # noqa: E501 line too long
+
+
+def test_args_refcount():
+    """Issue/PR #1216 - py::args elements get double-inc_ref()ed when combined with regular
+    arguments"""
+    refcount = m.arg_refcount_h
+
+    myval = 54321
+    expected = refcount(myval)
+    assert m.arg_refcount_h(myval) == expected
+    assert m.arg_refcount_o(myval) == expected + 1
+    assert m.arg_refcount_h(myval) == expected
+    assert refcount(myval) == expected
+
+    assert m.mixed_plus_args(1, 2.0, "a", myval) == (1, 2.0, ("a", myval))
+    assert refcount(myval) == expected
+
+    assert m.mixed_plus_kwargs(3, 4.0, a=1, b=myval) == (3, 4.0, {"a": 1, "b": myval})
+    assert refcount(myval) == expected
+
+    assert m.args_function(-1, myval) == (-1, myval)
+    assert refcount(myval) == expected
+
+    assert m.mixed_plus_args_kwargs(5, 6.0, myval, a=myval) == (5, 6.0, (myval,), {"a": myval})
+    assert refcount(myval) == expected
+
+    assert m.args_kwargs_function(7, 8, myval, a=1, b=myval) == \
+        ((7, 8, myval), {"a": 1, "b": myval})
+    assert refcount(myval) == expected
+
+    exp3 = refcount(myval, myval, myval)
+    assert m.args_refcount(myval, myval, myval) == (exp3, exp3, exp3)
+    assert refcount(myval) == expected
+
+    # This function takes the first arg as a `py::object` and the rest as a `py::args`.  Unlike the
+    # previous case, when we have both positional and `py::args` we need to construct a new tuple
+    # for the `py::args`; in the previous case, we could simply inc_ref and pass on Python's input
+    # tuple without having to inc_ref the individual elements, but here we can't, hence the extra
+    # refs.
+    assert m.mixed_args_refcount(myval, myval, myval) == (exp3 + 3, exp3 + 3, exp3 + 3)
diff --git a/src/pybind11/tests/test_local_bindings.cpp b/src/pybind11/tests/test_local_bindings.cpp
new file mode 100644
index 0000000..97c02db
--- /dev/null
+++ b/src/pybind11/tests/test_local_bindings.cpp
@@ -0,0 +1,101 @@
+/*
+    tests/test_local_bindings.cpp -- tests the py::module_local class feature which makes a class
+                                     binding local to the module in which it is defined.
+
+    Copyright (c) 2017 Jason Rhinelander <jason@imaginary.ca>
+
+    All rights reserved. Use of this source code is governed by a
+    BSD-style license that can be found in the LICENSE file.
+*/
+
+#include "pybind11_tests.h"
+#include "local_bindings.h"
+#include <pybind11/stl.h>
+#include <pybind11/stl_bind.h>
+#include <numeric>
+
+TEST_SUBMODULE(local_bindings, m) {
+    // test_load_external
+    m.def("load_external1", [](ExternalType1 &e) { return e.i; });
+    m.def("load_external2", [](ExternalType2 &e) { return e.i; });
+
+    // test_local_bindings
+    // Register a class with py::module_local:
+    bind_local<LocalType, -1>(m, "LocalType", py::module_local())
+        .def("get3", [](LocalType &t) { return t.i + 3; })
+        ;
+
+    m.def("local_value", [](LocalType &l) { return l.i; });
+
+    // test_nonlocal_failure
+    // The main pybind11 test module is loaded first, so this registration will succeed (the second
+    // one, in pybind11_cross_module_tests.cpp, is designed to fail):
+    bind_local<NonLocalType, 0>(m, "NonLocalType")
+        .def(py::init<int>())
+        .def("get", [](LocalType &i) { return i.i; })
+        ;
+
+    // test_duplicate_local
+    // py::module_local declarations should be visible across compilation units that get linked together;
+    // this tries to register a duplicate local.  It depends on a definition in test_class.cpp and
+    // should raise a runtime error from the duplicate definition attempt.  If test_class isn't
+    // available it *also* throws a runtime error (with "test_class not enabled" as value).
+    m.def("register_local_external", [m]() {
+        auto main = py::module::import("pybind11_tests");
+        if (py::hasattr(main, "class_")) {
+            bind_local<LocalExternal, 7>(m, "LocalExternal", py::module_local());
+        }
+        else throw std::runtime_error("test_class not enabled");
+    });
+
+    // test_stl_bind_local
+    // stl_bind.h binders defaults to py::module_local if the types are local or converting:
+    py::bind_vector<LocalVec>(m, "LocalVec");
+    py::bind_map<LocalMap>(m, "LocalMap");
+    // and global if the type (or one of the types, for the map) is global:
+    py::bind_vector<NonLocalVec>(m, "NonLocalVec");
+    py::bind_map<NonLocalMap>(m, "NonLocalMap");
+
+    // test_stl_bind_global
+    // They can, however, be overridden to global using `py::module_local(false)`:
+    bind_local<NonLocal2, 10>(m, "NonLocal2");
+    py::bind_vector<LocalVec2>(m, "LocalVec2", py::module_local());
+    py::bind_map<NonLocalMap2>(m, "NonLocalMap2", py::module_local(false));
+
+    // test_mixed_local_global
+    // We try this both with the global type registered first and vice versa (the order shouldn't
+    // matter).
+    m.def("register_mixed_global", [m]() {
+        bind_local<MixedGlobalLocal, 100>(m, "MixedGlobalLocal", py::module_local(false));
+    });
+    m.def("register_mixed_local", [m]() {
+        bind_local<MixedLocalGlobal, 1000>(m, "MixedLocalGlobal", py::module_local());
+    });
+    m.def("get_mixed_gl", [](int i) { return MixedGlobalLocal(i); });
+    m.def("get_mixed_lg", [](int i) { return MixedLocalGlobal(i); });
+
+    // test_internal_locals_differ
+    m.def("local_cpp_types_addr", []() { return (uintptr_t) &py::detail::registered_local_types_cpp(); });
+
+    // test_stl_caster_vs_stl_bind
+    m.def("load_vector_via_caster", [](std::vector<int> v) {
+        return std::accumulate(v.begin(), v.end(), 0);
+    });
+
+    // test_cross_module_calls
+    m.def("return_self", [](LocalVec *v) { return v; });
+    m.def("return_copy", [](const LocalVec &v) { return LocalVec(v); });
+
+    class Cat : public pets::Pet { public: Cat(std::string name) : Pet(name) {}; };
+    py::class_<pets::Pet>(m, "Pet", py::module_local())
+        .def("get_name", &pets::Pet::name);
+    // Binding for local extending class:
+    py::class_<Cat, pets::Pet>(m, "Cat")
+        .def(py::init<std::string>());
+    m.def("pet_name", [](pets::Pet &p) { return p.name(); });
+
+    py::class_<MixGL>(m, "MixGL").def(py::init<int>());
+    m.def("get_gl_value", [](MixGL &o) { return o.i + 10; });
+
+    py::class_<MixGL2>(m, "MixGL2").def(py::init<int>());
+}
diff --git a/src/pybind11/tests/test_local_bindings.py b/src/pybind11/tests/test_local_bindings.py
new file mode 100644
index 0000000..b380376
--- /dev/null
+++ b/src/pybind11/tests/test_local_bindings.py
@@ -0,0 +1,226 @@
+import pytest
+
+from pybind11_tests import local_bindings as m
+
+
+def test_load_external():
+    """Load a `py::module_local` type that's only registered in an external module"""
+    import pybind11_cross_module_tests as cm
+
+    assert m.load_external1(cm.ExternalType1(11)) == 11
+    assert m.load_external2(cm.ExternalType2(22)) == 22
+
+    with pytest.raises(TypeError) as excinfo:
+        assert m.load_external2(cm.ExternalType1(21)) == 21
+    assert "incompatible function arguments" in str(excinfo.value)
+
+    with pytest.raises(TypeError) as excinfo:
+        assert m.load_external1(cm.ExternalType2(12)) == 12
+    assert "incompatible function arguments" in str(excinfo.value)
+
+
+def test_local_bindings():
+    """Tests that duplicate `py::module_local` class bindings work across modules"""
+
+    # Make sure we can load the second module with the conflicting (but local) definition:
+    import pybind11_cross_module_tests as cm
+
+    i1 = m.LocalType(5)
+    assert i1.get() == 4
+    assert i1.get3() == 8
+
+    i2 = cm.LocalType(10)
+    assert i2.get() == 11
+    assert i2.get2() == 12
+
+    assert not hasattr(i1, 'get2')
+    assert not hasattr(i2, 'get3')
+
+    # Loading within the local module
+    assert m.local_value(i1) == 5
+    assert cm.local_value(i2) == 10
+
+    # Cross-module loading works as well (on failure, the type loader looks for
+    # external module-local converters):
+    assert m.local_value(i2) == 10
+    assert cm.local_value(i1) == 5
+
+
+def test_nonlocal_failure():
+    """Tests that attempting to register a non-local type in multiple modules fails"""
+    import pybind11_cross_module_tests as cm
+
+    with pytest.raises(RuntimeError) as excinfo:
+        cm.register_nonlocal()
+    assert str(excinfo.value) == 'generic_type: type "NonLocalType" is already registered!'
+
+
+def test_duplicate_local():
+    """Tests expected failure when registering a class twice with py::local in the same module"""
+    with pytest.raises(RuntimeError) as excinfo:
+        m.register_local_external()
+    import pybind11_tests
+    assert str(excinfo.value) == (
+        'generic_type: type "LocalExternal" is already registered!'
+        if hasattr(pybind11_tests, 'class_') else 'test_class not enabled')
+
+
+def test_stl_bind_local():
+    import pybind11_cross_module_tests as cm
+
+    v1, v2 = m.LocalVec(), cm.LocalVec()
+    v1.append(m.LocalType(1))
+    v1.append(m.LocalType(2))
+    v2.append(cm.LocalType(1))
+    v2.append(cm.LocalType(2))
+
+    # Cross module value loading:
+    v1.append(cm.LocalType(3))
+    v2.append(m.LocalType(3))
+
+    assert [i.get() for i in v1] == [0, 1, 2]
+    assert [i.get() for i in v2] == [2, 3, 4]
+
+    v3, v4 = m.NonLocalVec(), cm.NonLocalVec2()
+    v3.append(m.NonLocalType(1))
+    v3.append(m.NonLocalType(2))
+    v4.append(m.NonLocal2(3))
+    v4.append(m.NonLocal2(4))
+
+    assert [i.get() for i in v3] == [1, 2]
+    assert [i.get() for i in v4] == [13, 14]
+
+    d1, d2 = m.LocalMap(), cm.LocalMap()
+    d1["a"] = v1[0]
+    d1["b"] = v1[1]
+    d2["c"] = v2[0]
+    d2["d"] = v2[1]
+    assert {i: d1[i].get() for i in d1} == {'a': 0, 'b': 1}
+    assert {i: d2[i].get() for i in d2} == {'c': 2, 'd': 3}
+
+
+def test_stl_bind_global():
+    import pybind11_cross_module_tests as cm
+
+    with pytest.raises(RuntimeError) as excinfo:
+        cm.register_nonlocal_map()
+    assert str(excinfo.value) == 'generic_type: type "NonLocalMap" is already registered!'
+
+    with pytest.raises(RuntimeError) as excinfo:
+        cm.register_nonlocal_vec()
+    assert str(excinfo.value) == 'generic_type: type "NonLocalVec" is already registered!'
+
+    with pytest.raises(RuntimeError) as excinfo:
+        cm.register_nonlocal_map2()
+    assert str(excinfo.value) == 'generic_type: type "NonLocalMap2" is already registered!'
+
+
+def test_mixed_local_global():
+    """Local types take precedence over globally registered types: a module with a `module_local`
+    type can be registered even if the type is already registered globally.  With the module,
+    casting will go to the local type; outside the module casting goes to the global type."""
+    import pybind11_cross_module_tests as cm
+    m.register_mixed_global()
+    m.register_mixed_local()
+
+    a = []
+    a.append(m.MixedGlobalLocal(1))
+    a.append(m.MixedLocalGlobal(2))
+    a.append(m.get_mixed_gl(3))
+    a.append(m.get_mixed_lg(4))
+
+    assert [x.get() for x in a] == [101, 1002, 103, 1004]
+
+    cm.register_mixed_global_local()
+    cm.register_mixed_local_global()
+    a.append(m.MixedGlobalLocal(5))
+    a.append(m.MixedLocalGlobal(6))
+    a.append(cm.MixedGlobalLocal(7))
+    a.append(cm.MixedLocalGlobal(8))
+    a.append(m.get_mixed_gl(9))
+    a.append(m.get_mixed_lg(10))
+    a.append(cm.get_mixed_gl(11))
+    a.append(cm.get_mixed_lg(12))
+
+    assert [x.get() for x in a] == \
+        [101, 1002, 103, 1004, 105, 1006, 207, 2008, 109, 1010, 211, 2012]
+
+
+def test_internal_locals_differ():
+    """Makes sure the internal local type map differs across the two modules"""
+    import pybind11_cross_module_tests as cm
+    assert m.local_cpp_types_addr() != cm.local_cpp_types_addr()
+
+
+def test_stl_caster_vs_stl_bind(msg):
+    """One module uses a generic vector caster from `<pybind11/stl.h>` while the other
+    exports `std::vector<int>` via `py:bind_vector` and `py::module_local`"""
+    import pybind11_cross_module_tests as cm
+
+    v1 = cm.VectorInt([1, 2, 3])
+    assert m.load_vector_via_caster(v1) == 6
+    assert cm.load_vector_via_binding(v1) == 6
+
+    v2 = [1, 2, 3]
+    assert m.load_vector_via_caster(v2) == 6
+    with pytest.raises(TypeError) as excinfo:
+        cm.load_vector_via_binding(v2) == 6
+    assert msg(excinfo.value) == """
+    load_vector_via_binding(): incompatible function arguments. The following argument types are supported:
+        1. (arg0: pybind11_cross_module_tests.VectorInt) -> int
+
+    Invoked with: [1, 2, 3]
+    """  # noqa: E501 line too long
+
+
+def test_cross_module_calls():
+    import pybind11_cross_module_tests as cm
+
+    v1 = m.LocalVec()
+    v1.append(m.LocalType(1))
+    v2 = cm.LocalVec()
+    v2.append(cm.LocalType(2))
+
+    # Returning the self pointer should get picked up as returning an existing
+    # instance (even when that instance is of a foreign, non-local type).
+    assert m.return_self(v1) is v1
+    assert cm.return_self(v2) is v2
+    assert m.return_self(v2) is v2
+    assert cm.return_self(v1) is v1
+
+    assert m.LocalVec is not cm.LocalVec
+    # Returning a copy, on the other hand, always goes to the local type,
+    # regardless of where the source type came from.
+    assert type(m.return_copy(v1)) is m.LocalVec
+    assert type(m.return_copy(v2)) is m.LocalVec
+    assert type(cm.return_copy(v1)) is cm.LocalVec
+    assert type(cm.return_copy(v2)) is cm.LocalVec
+
+    # Test the example given in the documentation (which also tests inheritance casting):
+    mycat = m.Cat("Fluffy")
+    mydog = cm.Dog("Rover")
+    assert mycat.get_name() == "Fluffy"
+    assert mydog.name() == "Rover"
+    assert m.Cat.__base__.__name__ == "Pet"
+    assert cm.Dog.__base__.__name__ == "Pet"
+    assert m.Cat.__base__ is not cm.Dog.__base__
+    assert m.pet_name(mycat) == "Fluffy"
+    assert m.pet_name(mydog) == "Rover"
+    assert cm.pet_name(mycat) == "Fluffy"
+    assert cm.pet_name(mydog) == "Rover"
+
+    assert m.MixGL is not cm.MixGL
+    a = m.MixGL(1)
+    b = cm.MixGL(2)
+    assert m.get_gl_value(a) == 11
+    assert m.get_gl_value(b) == 12
+    assert cm.get_gl_value(a) == 101
+    assert cm.get_gl_value(b) == 102
+
+    c, d = m.MixGL2(3), cm.MixGL2(4)
+    with pytest.raises(TypeError) as excinfo:
+        m.get_gl_value(c)
+    assert "incompatible function arguments" in str(excinfo.value)
+    with pytest.raises(TypeError) as excinfo:
+        m.get_gl_value(d)
+    assert "incompatible function arguments" in str(excinfo.value)
diff --git a/src/pybind11/tests/test_methods_and_attributes.cpp b/src/pybind11/tests/test_methods_and_attributes.cpp
index 670f6c3..c7b82f1 100644
--- a/src/pybind11/tests/test_methods_and_attributes.cpp
+++ b/src/pybind11/tests/test_methods_and_attributes.cpp
@@ -11,6 +11,11 @@
 #include "pybind11_tests.h"
 #include "constructor_stats.h"
 
+#if !defined(PYBIND11_OVERLOAD_CAST)
+template <typename... Args>
+using overload_cast_ = pybind11::detail::overload_cast_impl<Args...>;
+#endif
+
 class ExampleMandA {
 public:
     ExampleMandA() { print_default_created(this); }
@@ -26,40 +31,43 @@ public:
     void operator=(const ExampleMandA &e) { print_copy_assigned(this); value = e.value; }
     void operator=(ExampleMandA &&e) { print_move_assigned(this); value = e.value; }
 
-    void add1(ExampleMandA other) { value += other.value; }           // passing by value
-    void add2(ExampleMandA &other) { value += other.value; }          // passing by reference
-    void add3(const ExampleMandA &other) { value += other.value; }    // passing by const reference
-    void add4(ExampleMandA *other) { value += other->value; }         // passing by pointer
-    void add5(const ExampleMandA *other) { value += other->value; }   // passing by const pointer
-
-    void add6(int other) { value += other; }                      // passing by value
-    void add7(int &other) { value += other; }                     // passing by reference
-    void add8(const int &other) { value += other; }               // passing by const reference
-    void add9(int *other) { value += *other; }                    // passing by pointer
-    void add10(const int *other) { value += *other; }             // passing by const pointer
-
-    ExampleMandA self1() { return *this; }                            // return by value
-    ExampleMandA &self2() { return *this; }                           // return by reference
-    const ExampleMandA &self3() { return *this; }                     // return by const reference
-    ExampleMandA *self4() { return this; }                            // return by pointer
-    const ExampleMandA *self5() { return this; }                      // return by const pointer
-
-    int internal1() { return value; }                             // return by value
-    int &internal2() { return value; }                            // return by reference
-    const int &internal3() { return value; }                      // return by const reference
-    int *internal4() { return &value; }                           // return by pointer
-    const int *internal5() { return &value; }                     // return by const pointer
-
+    void add1(ExampleMandA other) { value += other.value; }         // passing by value
+    void add2(ExampleMandA &other) { value += other.value; }        // passing by reference
+    void add3(const ExampleMandA &other) { value += other.value; }  // passing by const reference
+    void add4(ExampleMandA *other) { value += other->value; }       // passing by pointer
+    void add5(const ExampleMandA *other) { value += other->value; } // passing by const pointer
+
+    void add6(int other) { value += other; }                        // passing by value
+    void add7(int &other) { value += other; }                       // passing by reference
+    void add8(const int &other) { value += other; }                 // passing by const reference
+    void add9(int *other) { value += *other; }                      // passing by pointer
+    void add10(const int *other) { value += *other; }               // passing by const pointer
+
+    ExampleMandA self1() { return *this; }                          // return by value
+    ExampleMandA &self2() { return *this; }                         // return by reference
+    const ExampleMandA &self3() { return *this; }                   // return by const reference
+    ExampleMandA *self4() { return this; }                          // return by pointer
+    const ExampleMandA *self5() { return this; }                    // return by const pointer
+
+    int internal1() { return value; }                               // return by value
+    int &internal2() { return value; }                              // return by reference
+    const int &internal3() { return value; }                        // return by const reference
+    int *internal4() { return &value; }                             // return by pointer
+    const int *internal5() { return &value; }                       // return by const pointer
+
+    py::str overloaded()             { return "()"; }
+    py::str overloaded(int)          { return "(int)"; }
     py::str overloaded(int, float)   { return "(int, float)"; }
     py::str overloaded(float, int)   { return "(float, int)"; }
     py::str overloaded(int, int)     { return "(int, int)"; }
     py::str overloaded(float, float) { return "(float, float)"; }
+    py::str overloaded(int)          const { return "(int) const"; }
     py::str overloaded(int, float)   const { return "(int, float) const"; }
     py::str overloaded(float, int)   const { return "(float, int) const"; }
     py::str overloaded(int, int)     const { return "(int, int) const"; }
     py::str overloaded(float, float) const { return "(float, float) const"; }
 
-    static py::str overloaded() { return "static"; }
+    static py::str overloaded(float) { return "static float"; }
 
     int value = 0;
 };
@@ -74,41 +82,28 @@ struct TestProperties {
     static int static_get() { return static_value; }
     static void static_set(int v) { static_value = v; }
 };
-
 int TestProperties::static_value = 1;
 
 struct TestPropertiesOverride : TestProperties {
     int value = 99;
     static int static_value;
 };
-
 int TestPropertiesOverride::static_value = 99;
 
-struct SimpleValue { int value = 1; };
-
 struct TestPropRVP {
-    SimpleValue v1;
-    SimpleValue v2;
-    static SimpleValue sv1;
-    static SimpleValue sv2;
-
-    const SimpleValue &get1() const { return v1; }
-    const SimpleValue &get2() const { return v2; }
-    SimpleValue get_rvalue() const { return v2; }
-    void set1(int v) { v1.value = v; }
-    void set2(int v) { v2.value = v; }
+    UserType v1{1};
+    UserType v2{1};
+    static UserType sv1;
+    static UserType sv2;
+
+    const UserType &get1() const { return v1; }
+    const UserType &get2() const { return v2; }
+    UserType get_rvalue() const { return v2; }
+    void set1(int v) { v1.set(v); }
+    void set2(int v) { v2.set(v); }
 };
-
-SimpleValue TestPropRVP::sv1{};
-SimpleValue TestPropRVP::sv2{};
-
-class DynamicClass {
-public:
-    DynamicClass() { print_default_created(this); }
-    ~DynamicClass() { print_destroyed(this); }
-};
-
-class CppDerivedDynamicClass : public DynamicClass { };
+UserType TestPropRVP::sv1(1);
+UserType TestPropRVP::sv2(1);
 
 // py::arg/py::arg_v testing: these arguments just record their argument when invoked
 class ArgInspector1 { public: std::string arg = "(default arg inspector 1)"; };
@@ -154,13 +149,31 @@ public:
     }
 
     static handle cast(const ArgAlwaysConverts &, return_value_policy, handle) {
-        return py::none();
+        return py::none().release();
     }
 };
 }}
 
-/// Issue/PR #648: bad arg default debugging output
-class NotRegistered {};
+// test_custom_caster_destruction
+class DestructionTester {
+public:
+    DestructionTester() { print_default_created(this); }
+    ~DestructionTester() { print_destroyed(this); }
+    DestructionTester(const DestructionTester &) { print_copy_created(this); }
+    DestructionTester(DestructionTester &&) { print_move_created(this); }
+    DestructionTester &operator=(const DestructionTester &) { print_copy_assigned(this); return *this; }
+    DestructionTester &operator=(DestructionTester &&) { print_move_assigned(this); return *this; }
+};
+namespace pybind11 { namespace detail {
+template <> struct type_caster<DestructionTester> {
+    PYBIND11_TYPE_CASTER(DestructionTester, _("DestructionTester"));
+    bool load(handle, bool) { return true; }
+
+    static handle cast(const DestructionTester &, return_value_policy, handle) {
+        return py::bool_(true).release();
+    }
+};
+}}
 
 // Test None-allowed py::arg argument policy
 class NoneTester { public: int answer = 42; };
@@ -177,7 +190,25 @@ struct StrIssue {
     StrIssue(int i) : val{i} {}
 };
 
-test_initializer methods_and_attributes([](py::module &m) {
+// Issues #854, #910: incompatible function args when member function/pointer is in unregistered base class
+class UnregisteredBase {
+public:
+    void do_nothing() const {}
+    void increase_value() { rw_value++; ro_value += 0.25; }
+    void set_int(int v) { rw_value = v; }
+    int get_int() const { return rw_value; }
+    double get_double() const { return ro_value; }
+    int rw_value = 42;
+    double ro_value = 1.25;
+};
+class RegisteredDerived : public UnregisteredBase {
+public:
+    using UnregisteredBase::UnregisteredBase;
+    double sum() const { return rw_value + ro_value; }
+};
+
+TEST_SUBMODULE(methods_and_attributes, m) {
+    // test_methods_and_attributes
     py::class_<ExampleMandA> emna(m, "ExampleMandA");
     emna.def(py::init<>())
         .def(py::init<int>())
@@ -203,53 +234,71 @@ test_initializer methods_and_attributes([](py::module &m) {
         .def("internal4", &ExampleMandA::internal4)
         .def("internal5", &ExampleMandA::internal5)
 #if defined(PYBIND11_OVERLOAD_CAST)
+        .def("overloaded", py::overload_cast<>(&ExampleMandA::overloaded))
+        .def("overloaded", py::overload_cast<int>(&ExampleMandA::overloaded))
         .def("overloaded", py::overload_cast<int,   float>(&ExampleMandA::overloaded))
         .def("overloaded", py::overload_cast<float,   int>(&ExampleMandA::overloaded))
         .def("overloaded", py::overload_cast<int,     int>(&ExampleMandA::overloaded))
         .def("overloaded", py::overload_cast<float, float>(&ExampleMandA::overloaded))
         .def("overloaded_float", py::overload_cast<float, float>(&ExampleMandA::overloaded))
+        .def("overloaded_const", py::overload_cast<int         >(&ExampleMandA::overloaded, py::const_))
         .def("overloaded_const", py::overload_cast<int,   float>(&ExampleMandA::overloaded, py::const_))
         .def("overloaded_const", py::overload_cast<float,   int>(&ExampleMandA::overloaded, py::const_))
         .def("overloaded_const", py::overload_cast<int,     int>(&ExampleMandA::overloaded, py::const_))
         .def("overloaded_const", py::overload_cast<float, float>(&ExampleMandA::overloaded, py::const_))
 #else
-        .def("overloaded", static_cast<py::str (ExampleMandA::*)(int,   float)>(&ExampleMandA::overloaded))
+        // Use both the traditional static_cast method and the C++11 compatible overload_cast_
+        .def("overloaded", overload_cast_<>()(&ExampleMandA::overloaded))
+        .def("overloaded", overload_cast_<int>()(&ExampleMandA::overloaded))
+        .def("overloaded", overload_cast_<int,   float>()(&ExampleMandA::overloaded))
         .def("overloaded", static_cast<py::str (ExampleMandA::*)(float,   int)>(&ExampleMandA::overloaded))
         .def("overloaded", static_cast<py::str (ExampleMandA::*)(int,     int)>(&ExampleMandA::overloaded))
         .def("overloaded", static_cast<py::str (ExampleMandA::*)(float, float)>(&ExampleMandA::overloaded))
-        .def("overloaded_float", static_cast<py::str (ExampleMandA::*)(float, float)>(&ExampleMandA::overloaded))
-        .def("overloaded_const", static_cast<py::str (ExampleMandA::*)(int,   float) const>(&ExampleMandA::overloaded))
+        .def("overloaded_float", overload_cast_<float, float>()(&ExampleMandA::overloaded))
+        .def("overloaded_const", overload_cast_<int         >()(&ExampleMandA::overloaded, py::const_))
+        .def("overloaded_const", overload_cast_<int,   float>()(&ExampleMandA::overloaded, py::const_))
         .def("overloaded_const", static_cast<py::str (ExampleMandA::*)(float,   int) const>(&ExampleMandA::overloaded))
         .def("overloaded_const", static_cast<py::str (ExampleMandA::*)(int,     int) const>(&ExampleMandA::overloaded))
         .def("overloaded_const", static_cast<py::str (ExampleMandA::*)(float, float) const>(&ExampleMandA::overloaded))
 #endif
+        // test_no_mixed_overloads
         // Raise error if trying to mix static/non-static overloads on the same name:
         .def_static("add_mixed_overloads1", []() {
-            auto emna = py::reinterpret_borrow<py::class_<ExampleMandA>>(py::module::import("pybind11_tests").attr("ExampleMandA"));
+            auto emna = py::reinterpret_borrow<py::class_<ExampleMandA>>(py::module::import("pybind11_tests.methods_and_attributes").attr("ExampleMandA"));
             emna.def       ("overload_mixed1", static_cast<py::str (ExampleMandA::*)(int, int)>(&ExampleMandA::overloaded))
-                .def_static("overload_mixed1", static_cast<py::str (              *)(        )>(&ExampleMandA::overloaded));
+                .def_static("overload_mixed1", static_cast<py::str (              *)(float   )>(&ExampleMandA::overloaded));
         })
         .def_static("add_mixed_overloads2", []() {
-            auto emna = py::reinterpret_borrow<py::class_<ExampleMandA>>(py::module::import("pybind11_tests").attr("ExampleMandA"));
-            emna.def_static("overload_mixed2", static_cast<py::str (              *)(        )>(&ExampleMandA::overloaded))
+            auto emna = py::reinterpret_borrow<py::class_<ExampleMandA>>(py::module::import("pybind11_tests.methods_and_attributes").attr("ExampleMandA"));
+            emna.def_static("overload_mixed2", static_cast<py::str (              *)(float   )>(&ExampleMandA::overloaded))
                 .def       ("overload_mixed2", static_cast<py::str (ExampleMandA::*)(int, int)>(&ExampleMandA::overloaded));
         })
         .def("__str__", &ExampleMandA::toString)
         .def_readwrite("value", &ExampleMandA::value);
 
+    // test_copy_method
     // Issue #443: can't call copied methods in Python 3
     emna.attr("add2b") = emna.attr("add2");
 
+    // test_properties, test_static_properties, test_static_cls
     py::class_<TestProperties>(m, "TestProperties")
         .def(py::init<>())
         .def_readonly("def_readonly", &TestProperties::value)
         .def_readwrite("def_readwrite", &TestProperties::value)
+        .def_property("def_writeonly", nullptr,
+                      [](TestProperties& s,int v) { s.value = v; } )
+        .def_property("def_property_writeonly", nullptr, &TestProperties::set)
         .def_property_readonly("def_property_readonly", &TestProperties::get)
         .def_property("def_property", &TestProperties::get, &TestProperties::set)
+        .def_property("def_property_impossible", nullptr, nullptr)
         .def_readonly_static("def_readonly_static", &TestProperties::static_value)
         .def_readwrite_static("def_readwrite_static", &TestProperties::static_value)
+        .def_property_static("def_writeonly_static", nullptr,
+                             [](py::object, int v) { TestProperties::static_value = v; })
         .def_property_readonly_static("def_property_readonly_static",
                                       [](py::object) { return TestProperties::static_get(); })
+        .def_property_static("def_property_writeonly_static", nullptr,
+                             [](py::object, int v) { return TestProperties::static_set(v); })
         .def_property_static("def_property_static",
                              [](py::object) { return TestProperties::static_get(); },
                              [](py::object, int v) { TestProperties::static_set(v); })
@@ -262,15 +311,13 @@ test_initializer methods_and_attributes([](py::module &m) {
         .def_readonly("def_readonly", &TestPropertiesOverride::value)
         .def_readonly_static("def_readonly_static", &TestPropertiesOverride::static_value);
 
-    py::class_<SimpleValue>(m, "SimpleValue")
-        .def_readwrite("value", &SimpleValue::value);
-
-    auto static_get1 = [](py::object) -> const SimpleValue & { return TestPropRVP::sv1; };
-    auto static_get2 = [](py::object) -> const SimpleValue & { return TestPropRVP::sv2; };
-    auto static_set1 = [](py::object, int v) { TestPropRVP::sv1.value = v; };
-    auto static_set2 = [](py::object, int v) { TestPropRVP::sv2.value = v; };
+    auto static_get1 = [](py::object) -> const UserType & { return TestPropRVP::sv1; };
+    auto static_get2 = [](py::object) -> const UserType & { return TestPropRVP::sv2; };
+    auto static_set1 = [](py::object, int v) { TestPropRVP::sv1.set(v); };
+    auto static_set2 = [](py::object, int v) { TestPropRVP::sv2.set(v); };
     auto rvp_copy = py::return_value_policy::copy;
 
+    // test_property_return_value_policies
     py::class_<TestPropRVP>(m, "TestPropRVP")
         .def(py::init<>())
         .def_property_readonly("ro_ref", &TestPropRVP::get1)
@@ -285,21 +332,32 @@ test_initializer methods_and_attributes([](py::module &m) {
         .def_property_static("static_rw_ref", static_get1, static_set1)
         .def_property_static("static_rw_copy", static_get2, static_set2, rvp_copy)
         .def_property_static("static_rw_func", py::cpp_function(static_get2, rvp_copy), static_set2)
+        // test_property_rvalue_policy
         .def_property_readonly("rvalue", &TestPropRVP::get_rvalue)
-        .def_property_readonly_static("static_rvalue", [](py::object) { return SimpleValue(); });
+        .def_property_readonly_static("static_rvalue", [](py::object) { return UserType(1); });
 
+    // test_metaclass_override
     struct MetaclassOverride { };
     py::class_<MetaclassOverride>(m, "MetaclassOverride", py::metaclass((PyObject *) &PyType_Type))
         .def_property_readonly_static("readonly", [](py::object) { return 1; });
 
 #if !defined(PYPY_VERSION)
+    // test_dynamic_attributes
+    class DynamicClass {
+    public:
+        DynamicClass() { print_default_created(this); }
+        ~DynamicClass() { print_destroyed(this); }
+    };
     py::class_<DynamicClass>(m, "DynamicClass", py::dynamic_attr())
         .def(py::init());
 
+    class CppDerivedDynamicClass : public DynamicClass { };
     py::class_<CppDerivedDynamicClass, DynamicClass>(m, "CppDerivedDynamicClass")
         .def(py::init());
 #endif
 
+    // test_noconvert_args
+    //
     // Test converting.  The ArgAlwaysConverts is just there to make the first no-conversion pass
     // fail so that our call always ends up happening via the second dispatch (the one that allows
     // some conversion).
@@ -325,7 +383,8 @@ test_initializer methods_and_attributes([](py::module &m) {
     m.def("ints_preferred", [](int i) { return i / 2; }, py::arg("i"));
     m.def("ints_only", [](int i) { return i / 2; }, py::arg("i").noconvert());
 
-    /// Issue/PR #648: bad arg default debugging output
+    // test_bad_arg_default
+    // Issue/PR #648: bad arg default debugging output
 #if !defined(NDEBUG)
     m.attr("debug_enabled") = true;
 #else
@@ -333,13 +392,14 @@ test_initializer methods_and_attributes([](py::module &m) {
 #endif
     m.def("bad_arg_def_named", []{
         auto m = py::module::import("pybind11_tests");
-        m.def("should_fail", [](int, NotRegistered) {}, py::arg(), py::arg("a") = NotRegistered());
+        m.def("should_fail", [](int, UnregisteredType) {}, py::arg(), py::arg("a") = UnregisteredType());
     });
     m.def("bad_arg_def_unnamed", []{
         auto m = py::module::import("pybind11_tests");
-        m.def("should_fail", [](int, NotRegistered) {}, py::arg(), py::arg() = NotRegistered());
+        m.def("should_fail", [](int, UnregisteredType) {}, py::arg(), py::arg() = UnregisteredType());
     });
 
+    // test_accepts_none
     py::class_<NoneTester, std::shared_ptr<NoneTester>>(m, "NoneTester")
         .def(py::init<>());
     m.def("no_none1", &none1, py::arg().none(false));
@@ -353,6 +413,7 @@ test_initializer methods_and_attributes([](py::module &m) {
     m.def("ok_none4", &none4, py::arg().none(true));
     m.def("ok_none5", &none5);
 
+    // test_str_issue
     // Issue #283: __str__ called on uninitialized instance when constructor arguments invalid
     py::class_<StrIssue>(m, "StrIssue")
         .def(py::init<int>())
@@ -360,4 +421,40 @@ test_initializer methods_and_attributes([](py::module &m) {
         .def("__str__", [](const StrIssue &si) {
             return "StrIssue[" + std::to_string(si.val) + "]"; }
         );
-});
+
+    // test_unregistered_base_implementations
+    //
+    // Issues #854/910: incompatible function args when member function/pointer is in unregistered
+    // base class The methods and member pointers below actually resolve to members/pointers in
+    // UnregisteredBase; before this test/fix they would be registered via lambda with a first
+    // argument of an unregistered type, and thus uncallable.
+    py::class_<RegisteredDerived>(m, "RegisteredDerived")
+        .def(py::init<>())
+        .def("do_nothing", &RegisteredDerived::do_nothing)
+        .def("increase_value", &RegisteredDerived::increase_value)
+        .def_readwrite("rw_value", &RegisteredDerived::rw_value)
+        .def_readonly("ro_value", &RegisteredDerived::ro_value)
+        // These should trigger a static_assert if uncommented
+        //.def_readwrite("fails", &UserType::value) // should trigger a static_assert if uncommented
+        //.def_readonly("fails", &UserType::value) // should trigger a static_assert if uncommented
+        .def_property("rw_value_prop", &RegisteredDerived::get_int, &RegisteredDerived::set_int)
+        .def_property_readonly("ro_value_prop", &RegisteredDerived::get_double)
+        // This one is in the registered class:
+        .def("sum", &RegisteredDerived::sum)
+        ;
+
+    using Adapted = decltype(py::method_adaptor<RegisteredDerived>(&RegisteredDerived::do_nothing));
+    static_assert(std::is_same<Adapted, void (RegisteredDerived::*)() const>::value, "");
+
+    // test_custom_caster_destruction
+    // Test that `take_ownership` works on types with a custom type caster when given a pointer
+
+    // default policy: don't take ownership:
+    m.def("custom_caster_no_destroy", []() { static auto *dt = new DestructionTester(); return dt; });
+
+    m.def("custom_caster_destroy", []() { return new DestructionTester(); },
+            py::return_value_policy::take_ownership); // Takes ownership: destroy when finished
+    m.def("custom_caster_destroy_const", []() -> const DestructionTester * { return new DestructionTester(); },
+            py::return_value_policy::take_ownership); // Likewise (const doesn't inhibit destruction)
+    m.def("destruction_tester_cstats", &ConstructorStats::get<DestructionTester>, py::return_value_policy::reference);
+}
diff --git a/src/pybind11/tests/test_methods_and_attributes.py b/src/pybind11/tests/test_methods_and_attributes.py
index 95049cf..f1c862b 100644
--- a/src/pybind11/tests/test_methods_and_attributes.py
+++ b/src/pybind11/tests/test_methods_and_attributes.py
@@ -1,10 +1,11 @@
 import pytest
-from pybind11_tests import ExampleMandA, ConstructorStats
+from pybind11_tests import methods_and_attributes as m
+from pybind11_tests import ConstructorStats
 
 
 def test_methods_and_attributes():
-    instance1 = ExampleMandA()
-    instance2 = ExampleMandA(32)
+    instance1 = m.ExampleMandA()
+    instance2 = m.ExampleMandA(32)
 
     instance1.add1(instance2)
     instance1.add2(instance2)
@@ -31,10 +32,13 @@ def test_methods_and_attributes():
     assert instance1.internal4() == 320
     assert instance1.internal5() == 320
 
+    assert instance1.overloaded() == "()"
+    assert instance1.overloaded(0) == "(int)"
     assert instance1.overloaded(1, 1.0) == "(int, float)"
     assert instance1.overloaded(2.0, 2) == "(float, int)"
     assert instance1.overloaded(3,   3) == "(int, int)"
     assert instance1.overloaded(4., 4.) == "(float, float)"
+    assert instance1.overloaded_const(-3) == "(int) const"
     assert instance1.overloaded_const(5, 5.0) == "(int, float) const"
     assert instance1.overloaded_const(6.0, 6) == "(float, int) const"
     assert instance1.overloaded_const(7,   7) == "(int, int) const"
@@ -48,7 +52,7 @@ def test_methods_and_attributes():
     instance1.value = 100
     assert str(instance1) == "ExampleMandA[value=100]"
 
-    cstats = ConstructorStats.get(ExampleMandA)
+    cstats = ConstructorStats.get(m.ExampleMandA)
     assert cstats.alive() == 2
     del instance1, instance2
     assert cstats.alive() == 0
@@ -60,10 +64,25 @@ def test_methods_and_attributes():
     assert cstats.move_assignments == 0
 
 
-def test_properties():
-    from pybind11_tests import TestProperties
+def test_copy_method():
+    """Issue #443: calling copied methods fails in Python 3"""
 
-    instance = TestProperties()
+    m.ExampleMandA.add2c = m.ExampleMandA.add2
+    m.ExampleMandA.add2d = m.ExampleMandA.add2b
+    a = m.ExampleMandA(123)
+    assert a.value == 123
+    a.add2(m.ExampleMandA(-100))
+    assert a.value == 23
+    a.add2b(m.ExampleMandA(20))
+    assert a.value == 43
+    a.add2c(m.ExampleMandA(6))
+    assert a.value == 49
+    a.add2d(m.ExampleMandA(-7))
+    assert a.value == 42
+
+
+def test_properties():
+    instance = m.TestProperties()
 
     assert instance.def_readonly == 1
     with pytest.raises(AttributeError):
@@ -79,123 +98,134 @@ def test_properties():
     instance.def_property = 3
     assert instance.def_property == 3
 
+    with pytest.raises(AttributeError) as excinfo:
+        dummy = instance.def_property_writeonly  # noqa: F841 unused var
+    assert "unreadable attribute" in str(excinfo.value)
 
-def test_copy_method():
-    """Issue #443: calling copied methods fails in Python 3"""
-    from pybind11_tests import ExampleMandA
+    instance.def_property_writeonly = 4
+    assert instance.def_property_readonly == 4
 
-    ExampleMandA.add2c = ExampleMandA.add2
-    ExampleMandA.add2d = ExampleMandA.add2b
-    a = ExampleMandA(123)
-    assert a.value == 123
-    a.add2(ExampleMandA(-100))
-    assert a.value == 23
-    a.add2b(ExampleMandA(20))
-    assert a.value == 43
-    a.add2c(ExampleMandA(6))
-    assert a.value == 49
-    a.add2d(ExampleMandA(-7))
-    assert a.value == 42
+    with pytest.raises(AttributeError) as excinfo:
+        dummy = instance.def_property_impossible  # noqa: F841 unused var
+    assert "unreadable attribute" in str(excinfo.value)
+
+    with pytest.raises(AttributeError) as excinfo:
+        instance.def_property_impossible = 5
+    assert "can't set attribute" in str(excinfo.value)
 
 
 def test_static_properties():
-    from pybind11_tests import TestProperties as Type
+    assert m.TestProperties.def_readonly_static == 1
+    with pytest.raises(AttributeError) as excinfo:
+        m.TestProperties.def_readonly_static = 2
+    assert "can't set attribute" in str(excinfo.value)
+
+    m.TestProperties.def_readwrite_static = 2
+    assert m.TestProperties.def_readwrite_static == 2
+
+    with pytest.raises(AttributeError) as excinfo:
+        dummy = m.TestProperties.def_writeonly_static  # noqa: F841 unused var
+    assert "unreadable attribute" in str(excinfo.value)
+
+    m.TestProperties.def_writeonly_static = 3
+    assert m.TestProperties.def_readonly_static == 3
 
-    assert Type.def_readonly_static == 1
+    assert m.TestProperties.def_property_readonly_static == 3
     with pytest.raises(AttributeError) as excinfo:
-        Type.def_readonly_static = 2
-    assert "can't set attribute" in str(excinfo)
+        m.TestProperties.def_property_readonly_static = 99
+    assert "can't set attribute" in str(excinfo.value)
 
-    Type.def_readwrite_static = 2
-    assert Type.def_readwrite_static == 2
+    m.TestProperties.def_property_static = 4
+    assert m.TestProperties.def_property_static == 4
 
-    assert Type.def_property_readonly_static == 2
     with pytest.raises(AttributeError) as excinfo:
-        Type.def_property_readonly_static = 3
-    assert "can't set attribute" in str(excinfo)
+        dummy = m.TestProperties.def_property_writeonly_static
+    assert "unreadable attribute" in str(excinfo.value)
 
-    Type.def_property_static = 3
-    assert Type.def_property_static == 3
+    m.TestProperties.def_property_writeonly_static = 5
+    assert m.TestProperties.def_property_static == 5
 
     # Static property read and write via instance
-    instance = Type()
+    instance = m.TestProperties()
 
-    Type.def_readwrite_static = 0
-    assert Type.def_readwrite_static == 0
+    m.TestProperties.def_readwrite_static = 0
+    assert m.TestProperties.def_readwrite_static == 0
     assert instance.def_readwrite_static == 0
 
     instance.def_readwrite_static = 2
-    assert Type.def_readwrite_static == 2
+    assert m.TestProperties.def_readwrite_static == 2
     assert instance.def_readwrite_static == 2
 
-    # It should be possible to override properties in derived classes
-    from pybind11_tests import TestPropertiesOverride as TypeOverride
+    with pytest.raises(AttributeError) as excinfo:
+        dummy = instance.def_property_writeonly_static  # noqa: F841 unused var
+    assert "unreadable attribute" in str(excinfo.value)
+
+    instance.def_property_writeonly_static = 4
+    assert instance.def_property_static == 4
 
-    assert TypeOverride().def_readonly == 99
-    assert TypeOverride.def_readonly_static == 99
+    # It should be possible to override properties in derived classes
+    assert m.TestPropertiesOverride().def_readonly == 99
+    assert m.TestPropertiesOverride.def_readonly_static == 99
 
 
 def test_static_cls():
     """Static property getter and setters expect the type object as the their only argument"""
-    from pybind11_tests import TestProperties as Type
 
-    instance = Type()
-    assert Type.static_cls is Type
-    assert instance.static_cls is Type
+    instance = m.TestProperties()
+    assert m.TestProperties.static_cls is m.TestProperties
+    assert instance.static_cls is m.TestProperties
 
     def check_self(self):
-        assert self is Type
+        assert self is m.TestProperties
 
-    Type.static_cls = check_self
+    m.TestProperties.static_cls = check_self
     instance.static_cls = check_self
 
 
 def test_metaclass_override():
     """Overriding pybind11's default metaclass changes the behavior of `static_property`"""
-    from pybind11_tests import MetaclassOverride
 
-    assert type(ExampleMandA).__name__ == "pybind11_type"
-    assert type(MetaclassOverride).__name__ == "type"
+    assert type(m.ExampleMandA).__name__ == "pybind11_type"
+    assert type(m.MetaclassOverride).__name__ == "type"
 
-    assert MetaclassOverride.readonly == 1
-    assert type(MetaclassOverride.__dict__["readonly"]).__name__ == "pybind11_static_property"
+    assert m.MetaclassOverride.readonly == 1
+    assert type(m.MetaclassOverride.__dict__["readonly"]).__name__ == "pybind11_static_property"
 
     # Regular `type` replaces the property instead of calling `__set__()`
-    MetaclassOverride.readonly = 2
-    assert MetaclassOverride.readonly == 2
-    assert isinstance(MetaclassOverride.__dict__["readonly"], int)
+    m.MetaclassOverride.readonly = 2
+    assert m.MetaclassOverride.readonly == 2
+    assert isinstance(m.MetaclassOverride.__dict__["readonly"], int)
 
 
 def test_no_mixed_overloads():
     from pybind11_tests import debug_enabled
 
     with pytest.raises(RuntimeError) as excinfo:
-        ExampleMandA.add_mixed_overloads1()
+        m.ExampleMandA.add_mixed_overloads1()
     assert (str(excinfo.value) ==
             "overloading a method with both static and instance methods is not supported; " +
             ("compile in debug mode for more details" if not debug_enabled else
              "error while attempting to bind static method ExampleMandA.overload_mixed1"
-             "() -> str")
+             "(arg0: float) -> str")
             )
 
     with pytest.raises(RuntimeError) as excinfo:
-        ExampleMandA.add_mixed_overloads2()
+        m.ExampleMandA.add_mixed_overloads2()
     assert (str(excinfo.value) ==
             "overloading a method with both static and instance methods is not supported; " +
             ("compile in debug mode for more details" if not debug_enabled else
              "error while attempting to bind instance method ExampleMandA.overload_mixed2"
-             "(self: pybind11_tests.ExampleMandA, arg0: int, arg1: int) -> str")
+             "(self: pybind11_tests.methods_and_attributes.ExampleMandA, arg0: int, arg1: int)"
+             " -> str")
             )
 
 
 @pytest.mark.parametrize("access", ["ro", "rw", "static_ro", "static_rw"])
 def test_property_return_value_policies(access):
-    from pybind11_tests import TestPropRVP
-
     if not access.startswith("static"):
-        obj = TestPropRVP()
+        obj = m.TestPropRVP()
     else:
-        obj = TestPropRVP
+        obj = m.TestPropRVP
 
     ref = getattr(obj, access + "_ref")
     assert ref.value == 1
@@ -216,30 +246,20 @@ def test_property_return_value_policies(access):
 
 def test_property_rvalue_policy():
     """When returning an rvalue, the return value policy is automatically changed from
-    `reference(_internal)` to `move`. The following would not work otherwise.
-    """
-    from pybind11_tests import TestPropRVP
+    `reference(_internal)` to `move`. The following would not work otherwise."""
 
-    instance = TestPropRVP()
+    instance = m.TestPropRVP()
     o = instance.rvalue
     assert o.value == 1
 
-
-def test_property_rvalue_policy_static():
-    """When returning an rvalue, the return value policy is automatically changed from
-    `reference(_internal)` to `move`. The following would not work otherwise.
-    """
-    from pybind11_tests import TestPropRVP
-    o = TestPropRVP.static_rvalue
-    assert o.value == 1
+    os = m.TestPropRVP.static_rvalue
+    assert os.value == 1
 
 
 # https://bitbucket.org/pypy/pypy/issues/2447
 @pytest.unsupported_on_pypy
 def test_dynamic_attributes():
-    from pybind11_tests import DynamicClass, CppDerivedDynamicClass
-
-    instance = DynamicClass()
+    instance = m.DynamicClass()
     assert not hasattr(instance, "foo")
     assert "foo" not in dir(instance)
 
@@ -259,16 +279,16 @@ def test_dynamic_attributes():
         instance.__dict__ = []
     assert str(excinfo.value) == "__dict__ must be set to a dictionary, not a 'list'"
 
-    cstats = ConstructorStats.get(DynamicClass)
+    cstats = ConstructorStats.get(m.DynamicClass)
     assert cstats.alive() == 1
     del instance
     assert cstats.alive() == 0
 
     # Derived classes should work as well
-    class PythonDerivedDynamicClass(DynamicClass):
+    class PythonDerivedDynamicClass(m.DynamicClass):
         pass
 
-    for cls in CppDerivedDynamicClass, PythonDerivedDynamicClass:
+    for cls in m.CppDerivedDynamicClass, PythonDerivedDynamicClass:
         derived = cls()
         derived.foobar = 100
         assert derived.foobar == 100
@@ -281,20 +301,18 @@ def test_dynamic_attributes():
 # https://bitbucket.org/pypy/pypy/issues/2447
 @pytest.unsupported_on_pypy
 def test_cyclic_gc():
-    from pybind11_tests import DynamicClass
-
     # One object references itself
-    instance = DynamicClass()
+    instance = m.DynamicClass()
     instance.circular_reference = instance
 
-    cstats = ConstructorStats.get(DynamicClass)
+    cstats = ConstructorStats.get(m.DynamicClass)
     assert cstats.alive() == 1
     del instance
     assert cstats.alive() == 0
 
     # Two object reference each other
-    i1 = DynamicClass()
-    i2 = DynamicClass()
+    i1 = m.DynamicClass()
+    i2 = m.DynamicClass()
     i1.cycle = i2
     i2.cycle = i1
 
@@ -304,8 +322,6 @@ def test_cyclic_gc():
 
 
 def test_noconvert_args(msg):
-    import pybind11_tests as m
-
     a = m.ArgInspector()
     assert msg(a.f("hi")) == """
         loading ArgInspector1 argument WITH conversion allowed.  Argument value = hi
@@ -369,23 +385,23 @@ def test_noconvert_args(msg):
 
 
 def test_bad_arg_default(msg):
-    from pybind11_tests import debug_enabled, bad_arg_def_named, bad_arg_def_unnamed
+    from pybind11_tests import debug_enabled
 
     with pytest.raises(RuntimeError) as excinfo:
-        bad_arg_def_named()
+        m.bad_arg_def_named()
     assert msg(excinfo.value) == (
-        "arg(): could not convert default argument 'a: NotRegistered' in function 'should_fail' "
-        "into a Python object (type not registered yet?)"
+        "arg(): could not convert default argument 'a: UnregisteredType' in function "
+        "'should_fail' into a Python object (type not registered yet?)"
         if debug_enabled else
         "arg(): could not convert default argument into a Python object (type not registered "
         "yet?). Compile in debug mode for more information."
     )
 
     with pytest.raises(RuntimeError) as excinfo:
-        bad_arg_def_unnamed()
+        m.bad_arg_def_unnamed()
     assert msg(excinfo.value) == (
-        "arg(): could not convert default argument 'NotRegistered' in function 'should_fail' "
-        "into a Python object (type not registered yet?)"
+        "arg(): could not convert default argument 'UnregisteredType' in function "
+        "'should_fail' into a Python object (type not registered yet?)"
         if debug_enabled else
         "arg(): could not convert default argument into a Python object (type not registered "
         "yet?). Compile in debug mode for more information."
@@ -393,67 +409,104 @@ def test_bad_arg_default(msg):
 
 
 def test_accepts_none(msg):
-    from pybind11_tests import (NoneTester,
-                                no_none1, no_none2, no_none3, no_none4, no_none5,
-                                ok_none1, ok_none2, ok_none3, ok_none4, ok_none5)
-
-    a = NoneTester()
-    assert no_none1(a) == 42
-    assert no_none2(a) == 42
-    assert no_none3(a) == 42
-    assert no_none4(a) == 42
-    assert no_none5(a) == 42
-    assert ok_none1(a) == 42
-    assert ok_none2(a) == 42
-    assert ok_none3(a) == 42
-    assert ok_none4(a) == 42
-    assert ok_none5(a) == 42
+    a = m.NoneTester()
+    assert m.no_none1(a) == 42
+    assert m.no_none2(a) == 42
+    assert m.no_none3(a) == 42
+    assert m.no_none4(a) == 42
+    assert m.no_none5(a) == 42
+    assert m.ok_none1(a) == 42
+    assert m.ok_none2(a) == 42
+    assert m.ok_none3(a) == 42
+    assert m.ok_none4(a) == 42
+    assert m.ok_none5(a) == 42
 
     with pytest.raises(TypeError) as excinfo:
-        no_none1(None)
+        m.no_none1(None)
     assert "incompatible function arguments" in str(excinfo.value)
     with pytest.raises(TypeError) as excinfo:
-        no_none2(None)
+        m.no_none2(None)
     assert "incompatible function arguments" in str(excinfo.value)
     with pytest.raises(TypeError) as excinfo:
-        no_none3(None)
+        m.no_none3(None)
     assert "incompatible function arguments" in str(excinfo.value)
     with pytest.raises(TypeError) as excinfo:
-        no_none4(None)
+        m.no_none4(None)
     assert "incompatible function arguments" in str(excinfo.value)
     with pytest.raises(TypeError) as excinfo:
-        no_none5(None)
+        m.no_none5(None)
     assert "incompatible function arguments" in str(excinfo.value)
 
     # The first one still raises because you can't pass None as a lvalue reference arg:
     with pytest.raises(TypeError) as excinfo:
-        assert ok_none1(None) == -1
+        assert m.ok_none1(None) == -1
     assert msg(excinfo.value) == """
         ok_none1(): incompatible function arguments. The following argument types are supported:
-            1. (arg0: m.NoneTester) -> int
+            1. (arg0: m.methods_and_attributes.NoneTester) -> int
 
         Invoked with: None
     """
 
     # The rest take the argument as pointer or holder, and accept None:
-    assert ok_none2(None) == -1
-    assert ok_none3(None) == -1
-    assert ok_none4(None) == -1
-    assert ok_none5(None) == -1
+    assert m.ok_none2(None) == -1
+    assert m.ok_none3(None) == -1
+    assert m.ok_none4(None) == -1
+    assert m.ok_none5(None) == -1
 
 
 def test_str_issue(msg):
     """#283: __str__ called on uninitialized instance when constructor arguments invalid"""
-    from pybind11_tests import StrIssue
 
-    assert str(StrIssue(3)) == "StrIssue[3]"
+    assert str(m.StrIssue(3)) == "StrIssue[3]"
 
     with pytest.raises(TypeError) as excinfo:
-        str(StrIssue("no", "such", "constructor"))
+        str(m.StrIssue("no", "such", "constructor"))
     assert msg(excinfo.value) == """
         __init__(): incompatible constructor arguments. The following argument types are supported:
-            1. m.StrIssue(arg0: int)
-            2. m.StrIssue()
+            1. m.methods_and_attributes.StrIssue(arg0: int)
+            2. m.methods_and_attributes.StrIssue()
 
         Invoked with: 'no', 'such', 'constructor'
     """
+
+
+def test_unregistered_base_implementations():
+    a = m.RegisteredDerived()
+    a.do_nothing()
+    assert a.rw_value == 42
+    assert a.ro_value == 1.25
+    a.rw_value += 5
+    assert a.sum() == 48.25
+    a.increase_value()
+    assert a.rw_value == 48
+    assert a.ro_value == 1.5
+    assert a.sum() == 49.5
+    assert a.rw_value_prop == 48
+    a.rw_value_prop += 1
+    assert a.rw_value_prop == 49
+    a.increase_value()
+    assert a.ro_value_prop == 1.75
+
+
+def test_custom_caster_destruction():
+    """Tests that returning a pointer to a type that gets converted with a custom type caster gets
+    destroyed when the function has py::return_value_policy::take_ownership policy applied."""
+
+    cstats = m.destruction_tester_cstats()
+    # This one *doesn't* have take_ownership: the pointer should be used but not destroyed:
+    z = m.custom_caster_no_destroy()
+    assert cstats.alive() == 1 and cstats.default_constructions == 1
+    assert z
+
+    # take_ownership applied: this constructs a new object, casts it, then destroys it:
+    z = m.custom_caster_destroy()
+    assert z
+    assert cstats.default_constructions == 2
+
+    # Same, but with a const pointer return (which should *not* inhibit destruction):
+    z = m.custom_caster_destroy_const()
+    assert z
+    assert cstats.default_constructions == 3
+
+    # Make sure we still only have the original object (from ..._no_destroy()) alive:
+    assert cstats.alive() == 1
diff --git a/src/pybind11/tests/test_modules.cpp b/src/pybind11/tests/test_modules.cpp
index 555ae07..c1475fa 100644
--- a/src/pybind11/tests/test_modules.cpp
+++ b/src/pybind11/tests/test_modules.cpp
@@ -11,42 +11,38 @@
 #include "pybind11_tests.h"
 #include "constructor_stats.h"
 
-std::string submodule_func() {
-    return "submodule_func()";
-}
-
-class A {
-public:
-    A(int v) : v(v) { print_created(this, v); }
-    ~A() { print_destroyed(this); }
-    A(const A&) { print_copy_created(this); }
-    A& operator=(const A &copy) { print_copy_assigned(this); v = copy.v; return *this; }
-    std::string toString() { return "A[" + std::to_string(v) + "]"; }
-private:
-    int v;
-};
-
-class B {
-public:
-    B() { print_default_created(this); }
-    ~B() { print_destroyed(this); }
-    B(const B&) { print_copy_created(this); }
-    B& operator=(const B &copy) { print_copy_assigned(this); a1 = copy.a1; a2 = copy.a2; return *this; }
-    A &get_a1() { return a1; }
-    A &get_a2() { return a2; }
-
-    A a1{1};
-    A a2{2};
-};
-
-test_initializer modules([](py::module &m) {
-    py::module m_sub = m.def_submodule("submodule");
-    m_sub.def("submodule_func", &submodule_func);
-
+TEST_SUBMODULE(modules, m) {
+    // test_nested_modules
+    py::module m_sub = m.def_submodule("subsubmodule");
+    m_sub.def("submodule_func", []() { return "submodule_func()"; });
+
+    // test_reference_internal
+    class A {
+    public:
+        A(int v) : v(v) { print_created(this, v); }
+        ~A() { print_destroyed(this); }
+        A(const A&) { print_copy_created(this); }
+        A& operator=(const A &copy) { print_copy_assigned(this); v = copy.v; return *this; }
+        std::string toString() { return "A[" + std::to_string(v) + "]"; }
+    private:
+        int v;
+    };
     py::class_<A>(m_sub, "A")
         .def(py::init<int>())
         .def("__repr__", &A::toString);
 
+    class B {
+    public:
+        B() { print_default_created(this); }
+        ~B() { print_destroyed(this); }
+        B(const B&) { print_copy_created(this); }
+        B& operator=(const B &copy) { print_copy_assigned(this); a1 = copy.a1; a2 = copy.a2; return *this; }
+        A &get_a1() { return a1; }
+        A &get_a2() { return a2; }
+
+        A a1{1};
+        A a2{2};
+    };
     py::class_<B>(m_sub, "B")
         .def(py::init<>())
         .def("get_a1", &B::get_a1, "Return the internal A 1", py::return_value_policy::reference_internal)
@@ -56,6 +52,7 @@ test_initializer modules([](py::module &m) {
 
     m.attr("OD") = py::module::import("collections").attr("OrderedDict");
 
+    // test_duplicate_registration
     // Registering two things with the same name
     m.def("duplicate_registration", []() {
         class Dupe1 { };
@@ -98,4 +95,4 @@ test_initializer modules([](py::module &m) {
 
         return failures;
     });
-});
+}
diff --git a/src/pybind11/tests/test_modules.py b/src/pybind11/tests/test_modules.py
index 17c00c8..2552838 100644
--- a/src/pybind11/tests/test_modules.py
+++ b/src/pybind11/tests/test_modules.py
@@ -1,32 +1,34 @@
+from pybind11_tests import modules as m
+from pybind11_tests.modules import subsubmodule as ms
+from pybind11_tests import ConstructorStats
+
 
 def test_nested_modules():
     import pybind11_tests
-    from pybind11_tests.submodule import submodule_func
-
     assert pybind11_tests.__name__ == "pybind11_tests"
-    assert pybind11_tests.submodule.__name__ == "pybind11_tests.submodule"
+    assert pybind11_tests.modules.__name__ == "pybind11_tests.modules"
+    assert pybind11_tests.modules.subsubmodule.__name__ == "pybind11_tests.modules.subsubmodule"
+    assert m.__name__ == "pybind11_tests.modules"
+    assert ms.__name__ == "pybind11_tests.modules.subsubmodule"
 
-    assert submodule_func() == "submodule_func()"
+    assert ms.submodule_func() == "submodule_func()"
 
 
 def test_reference_internal():
-    from pybind11_tests import ConstructorStats
-    from pybind11_tests.submodule import A, B
-
-    b = B()
+    b = ms.B()
     assert str(b.get_a1()) == "A[1]"
     assert str(b.a1) == "A[1]"
     assert str(b.get_a2()) == "A[2]"
     assert str(b.a2) == "A[2]"
 
-    b.a1 = A(42)
-    b.a2 = A(43)
+    b.a1 = ms.A(42)
+    b.a2 = ms.A(43)
     assert str(b.get_a1()) == "A[42]"
     assert str(b.a1) == "A[42]"
     assert str(b.get_a2()) == "A[43]"
     assert str(b.a2) == "A[43]"
 
-    astats, bstats = ConstructorStats.get(A), ConstructorStats.get(B)
+    astats, bstats = ConstructorStats.get(ms.A), ConstructorStats.get(ms.B)
     assert astats.alive() == 2
     assert bstats.alive() == 1
     del b
@@ -47,7 +49,7 @@ def test_reference_internal():
 
 
 def test_importing():
-    from pybind11_tests import OD
+    from pybind11_tests.modules import OD
     from collections import OrderedDict
 
     assert OD is OrderedDict
@@ -66,6 +68,5 @@ def test_pydoc():
 
 def test_duplicate_registration():
     """Registering two things with the same name"""
-    from pybind11_tests import duplicate_registration
 
-    assert duplicate_registration() == []
+    assert m.duplicate_registration() == []
diff --git a/src/pybind11/tests/test_multiple_inheritance.cpp b/src/pybind11/tests/test_multiple_inheritance.cpp
index 2fbe112..ba1674f 100644
--- a/src/pybind11/tests/test_multiple_inheritance.cpp
+++ b/src/pybind11/tests/test_multiple_inheritance.cpp
@@ -11,47 +11,74 @@
 #include "pybind11_tests.h"
 #include "constructor_stats.h"
 
-struct Base1 {
-    Base1(int i) : i(i) { }
-    int foo() { return i; }
-    int i;
-};
-
-struct Base2 {
-    Base2(int i) : i(i) { }
-    int bar() { return i; }
-    int i;
-};
-
+// Many bases for testing that multiple inheritance from many classes (i.e. requiring extra
+// space for holder constructed flags) works.
 template <int N> struct BaseN {
     BaseN(int i) : i(i) { }
     int i;
 };
 
-struct Base12 : Base1, Base2 {
-    Base12(int i, int j) : Base1(i), Base2(j) { }
+// test_mi_static_properties
+struct Vanilla {
+    std::string vanilla() { return "Vanilla"; };
 };
-
-struct MIType : Base12 {
-    MIType(int i, int j) : Base12(i, j) { }
+struct WithStatic1 {
+    static std::string static_func1() { return "WithStatic1"; };
+    static int static_value1;
+};
+struct WithStatic2 {
+    static std::string static_func2() { return "WithStatic2"; };
+    static int static_value2;
+};
+struct VanillaStaticMix1 : Vanilla, WithStatic1, WithStatic2 {
+    static std::string static_func() { return "VanillaStaticMix1"; }
+    static int static_value;
+};
+struct VanillaStaticMix2 : WithStatic1, Vanilla, WithStatic2 {
+    static std::string static_func() { return "VanillaStaticMix2"; }
+    static int static_value;
 };
+int WithStatic1::static_value1 = 1;
+int WithStatic2::static_value2 = 2;
+int VanillaStaticMix1::static_value = 12;
+int VanillaStaticMix2::static_value = 12;
+
+TEST_SUBMODULE(multiple_inheritance, m) {
 
-test_initializer multiple_inheritance([](py::module &m) {
+    // test_multiple_inheritance_mix1
+    // test_multiple_inheritance_mix2
+    struct Base1 {
+        Base1(int i) : i(i) { }
+        int foo() { return i; }
+        int i;
+    };
     py::class_<Base1> b1(m, "Base1");
     b1.def(py::init<int>())
       .def("foo", &Base1::foo);
 
+    struct Base2 {
+        Base2(int i) : i(i) { }
+        int bar() { return i; }
+        int i;
+    };
     py::class_<Base2> b2(m, "Base2");
     b2.def(py::init<int>())
       .def("bar", &Base2::bar);
 
-    py::class_<Base12, Base1, Base2>(m, "Base12");
 
+    // test_multiple_inheritance_cpp
+    struct Base12 : Base1, Base2 {
+        Base12(int i, int j) : Base1(i), Base2(j) { }
+    };
+    struct MIType : Base12 {
+        MIType(int i, int j) : Base12(i, j) { }
+    };
+    py::class_<Base12, Base1, Base2>(m, "Base12");
     py::class_<MIType, Base12>(m, "MIType")
         .def(py::init<int, int>());
 
-    // Many bases for testing that multiple inheritance from many classes (i.e. requiring extra
-    // space for holder constructed flags) works.
+
+    // test_multiple_inheritance_python_many_bases
     #define PYBIND11_BASEN(N) py::class_<BaseN<N>>(m, "BaseN" #N).def(py::init<int>()).def("f" #N, [](BaseN<N> &b) { return b.i + N; })
     PYBIND11_BASEN( 1); PYBIND11_BASEN( 2); PYBIND11_BASEN( 3); PYBIND11_BASEN( 4);
     PYBIND11_BASEN( 5); PYBIND11_BASEN( 6); PYBIND11_BASEN( 7); PYBIND11_BASEN( 8);
@@ -67,55 +94,50 @@ test_initializer multiple_inheritance([](py::module &m) {
 //    };
 //    py::class_<Base12v2>(m, "Base12v2", b1, b2)
 //        .def(py::init<int, int>());
-});
-
-/* Test the case where not all base classes are specified,
-   and where pybind11 requires the py::multiple_inheritance
-   flag to perform proper casting between types */
-
-struct Base1a {
-    Base1a(int i) : i(i) { }
-    int foo() { return i; }
-    int i;
-};
-
-struct Base2a {
-    Base2a(int i) : i(i) { }
-    int bar() { return i; }
-    int i;
-};
 
-struct Base12a : Base1a, Base2a {
-    Base12a(int i, int j) : Base1a(i), Base2a(j) { }
-};
 
-test_initializer multiple_inheritance_nonexplicit([](py::module &m) {
+    // test_multiple_inheritance_virtbase
+    // Test the case where not all base classes are specified, and where pybind11 requires the
+    // py::multiple_inheritance flag to perform proper casting between types.
+    struct Base1a {
+        Base1a(int i) : i(i) { }
+        int foo() { return i; }
+        int i;
+    };
     py::class_<Base1a, std::shared_ptr<Base1a>>(m, "Base1a")
         .def(py::init<int>())
         .def("foo", &Base1a::foo);
 
+    struct Base2a {
+        Base2a(int i) : i(i) { }
+        int bar() { return i; }
+        int i;
+    };
     py::class_<Base2a, std::shared_ptr<Base2a>>(m, "Base2a")
         .def(py::init<int>())
         .def("bar", &Base2a::bar);
 
+    struct Base12a : Base1a, Base2a {
+        Base12a(int i, int j) : Base1a(i), Base2a(j) { }
+    };
     py::class_<Base12a, /* Base1 missing */ Base2a,
                std::shared_ptr<Base12a>>(m, "Base12a", py::multiple_inheritance())
         .def(py::init<int, int>());
 
     m.def("bar_base2a", [](Base2a *b) { return b->bar(); });
     m.def("bar_base2a_sharedptr", [](std::shared_ptr<Base2a> b) { return b->bar(); });
-});
-
-// Issue #801: invalid casting to derived type with MI bases
-struct I801B1 { int a = 1; virtual ~I801B1() = default; };
-struct I801B2 { int b = 2; virtual ~I801B2() = default; };
-struct I801C : I801B1, I801B2 {};
-struct I801D : I801C {}; // Indirect MI
-// Unregistered classes:
-struct I801B3 { int c = 3; virtual ~I801B3() = default; };
-struct I801E : I801B3, I801D {};
-
-test_initializer multiple_inheritance_casting([](py::module &m) {
+
+    // test_mi_unaligned_base
+    // test_mi_base_return
+    // Issue #801: invalid casting to derived type with MI bases
+    struct I801B1 { int a = 1; I801B1() = default; I801B1(const I801B1 &) = default; virtual ~I801B1() = default; };
+    struct I801B2 { int b = 2; I801B2() = default; I801B2(const I801B2 &) = default; virtual ~I801B2() = default; };
+    struct I801C : I801B1, I801B2 {};
+    struct I801D : I801C {}; // Indirect MI
+    // Unregistered classes:
+    struct I801B3 { int c = 3; virtual ~I801B3() = default; };
+    struct I801E : I801B3, I801D {};
+
     py::class_<I801B1, std::shared_ptr<I801B1>>(m, "I801B1").def(py::init<>()).def_readonly("a", &I801B1::a);
     py::class_<I801B2, std::shared_ptr<I801B2>>(m, "I801B2").def(py::init<>()).def_readonly("b", &I801B2::b);
     py::class_<I801C, I801B1, I801B2, std::shared_ptr<I801C>>(m, "I801C").def(py::init<>());
@@ -141,46 +163,9 @@ test_initializer multiple_inheritance_casting([](py::module &m) {
     // isn't pybind-registered (and uses multiple-inheritance to offset the pybind base)
     m.def("i801e_c", []() -> I801C * { return new I801E(); });
     m.def("i801e_b2", []() -> I801B2 * { return new I801E(); });
-});
-
-
-struct Vanilla {
-    std::string vanilla() { return "Vanilla"; };
-};
-
-struct WithStatic1 {
-    static std::string static_func1() { return "WithStatic1"; };
-    static int static_value1;
-};
-
-struct WithStatic2 {
-    static std::string static_func2() { return "WithStatic2"; };
-    static int static_value2;
-};
 
-struct WithDict { };
-
-struct VanillaStaticMix1 : Vanilla, WithStatic1, WithStatic2 {
-    static std::string static_func() { return "VanillaStaticMix1"; }
-    static int static_value;
-};
-
-struct VanillaStaticMix2 : WithStatic1, Vanilla, WithStatic2 {
-    static std::string static_func() { return "VanillaStaticMix2"; }
-    static int static_value;
-};
-
-struct VanillaDictMix1 : Vanilla, WithDict { };
-struct VanillaDictMix2 : WithDict, Vanilla { };
-
-int WithStatic1::static_value1 = 1;
-int WithStatic2::static_value2 = 2;
-int VanillaStaticMix1::static_value = 12;
-int VanillaStaticMix2::static_value = 12;
-
-test_initializer mi_static_properties([](py::module &pm) {
-    auto m = pm.def_submodule("mi");
 
+    // test_mi_static_properties
     py::class_<Vanilla>(m, "Vanilla")
         .def(py::init<>())
         .def("vanilla", &Vanilla::vanilla);
@@ -207,9 +192,29 @@ test_initializer mi_static_properties([](py::module &pm) {
         .def_static("static_func", &VanillaStaticMix2::static_func)
         .def_readwrite_static("static_value", &VanillaStaticMix2::static_value);
 
+
 #if !defined(PYPY_VERSION)
+    struct WithDict { };
+    struct VanillaDictMix1 : Vanilla, WithDict { };
+    struct VanillaDictMix2 : WithDict, Vanilla { };
     py::class_<WithDict>(m, "WithDict", py::dynamic_attr()).def(py::init<>());
     py::class_<VanillaDictMix1, Vanilla, WithDict>(m, "VanillaDictMix1").def(py::init<>());
     py::class_<VanillaDictMix2, WithDict, Vanilla>(m, "VanillaDictMix2").def(py::init<>());
 #endif
-});
+
+    // test_diamond_inheritance
+    // Issue #959: segfault when constructing diamond inheritance instance
+    // All of these have int members so that there will be various unequal pointers involved.
+    struct B { int b; B() = default; B(const B&) = default; virtual ~B() = default; };
+    struct C0 : public virtual B { int c0; };
+    struct C1 : public virtual B { int c1; };
+    struct D : public C0, public C1 { int d; };
+    py::class_<B>(m, "B")
+        .def("b", [](B *self) { return self; });
+    py::class_<C0, B>(m, "C0")
+        .def("c0", [](C0 *self) { return self; });
+    py::class_<C1, B>(m, "C1")
+        .def("c1", [](C1 *self) { return self; });
+    py::class_<D, C0, C1>(m, "D")
+        .def(py::init<>());
+}
diff --git a/src/pybind11/tests/test_multiple_inheritance.py b/src/pybind11/tests/test_multiple_inheritance.py
index 3ed47ad..475dd3b 100644
--- a/src/pybind11/tests/test_multiple_inheritance.py
+++ b/src/pybind11/tests/test_multiple_inheritance.py
@@ -1,19 +1,16 @@
 import pytest
 from pybind11_tests import ConstructorStats
+from pybind11_tests import multiple_inheritance as m
 
 
 def test_multiple_inheritance_cpp():
-    from pybind11_tests import MIType
-
-    mt = MIType(3, 4)
+    mt = m.MIType(3, 4)
 
     assert mt.foo() == 3
     assert mt.bar() == 4
 
 
 def test_multiple_inheritance_mix1():
-    from pybind11_tests import Base2
-
     class Base1:
         def __init__(self, i):
             self.i = i
@@ -21,10 +18,10 @@ def test_multiple_inheritance_mix1():
         def foo(self):
             return self.i
 
-    class MITypePy(Base1, Base2):
+    class MITypePy(Base1, m.Base2):
         def __init__(self, i, j):
             Base1.__init__(self, i)
-            Base2.__init__(self, j)
+            m.Base2.__init__(self, j)
 
     mt = MITypePy(3, 4)
 
@@ -33,7 +30,6 @@ def test_multiple_inheritance_mix1():
 
 
 def test_multiple_inheritance_mix2():
-    from pybind11_tests import Base1
 
     class Base2:
         def __init__(self, i):
@@ -42,9 +38,9 @@ def test_multiple_inheritance_mix2():
         def bar(self):
             return self.i
 
-    class MITypePy(Base1, Base2):
+    class MITypePy(m.Base1, Base2):
         def __init__(self, i, j):
-            Base1.__init__(self, i)
+            m.Base1.__init__(self, i)
             Base2.__init__(self, j)
 
     mt = MITypePy(3, 4)
@@ -54,41 +50,41 @@ def test_multiple_inheritance_mix2():
 
 
 def test_multiple_inheritance_python():
-    from pybind11_tests import Base1, Base2
 
-    class MI1(Base1, Base2):
+    class MI1(m.Base1, m.Base2):
         def __init__(self, i, j):
-            Base1.__init__(self, i)
-            Base2.__init__(self, j)
+            m.Base1.__init__(self, i)
+            m.Base2.__init__(self, j)
 
     class B1(object):
         def v(self):
             return 1
 
-    class MI2(B1, Base1, Base2):
+    class MI2(B1, m.Base1, m.Base2):
         def __init__(self, i, j):
             B1.__init__(self)
-            Base1.__init__(self, i)
-            Base2.__init__(self, j)
+            m.Base1.__init__(self, i)
+            m.Base2.__init__(self, j)
 
     class MI3(MI2):
         def __init__(self, i, j):
             MI2.__init__(self, i, j)
 
-    class MI4(MI3, Base2):
-        def __init__(self, i, j, k):
-            MI2.__init__(self, j, k)
-            Base2.__init__(self, i)
+    class MI4(MI3, m.Base2):
+        def __init__(self, i, j):
+            MI3.__init__(self, i, j)
+            # This should be ignored (Base2 is already initialized via MI2):
+            m.Base2.__init__(self, i + 100)
 
-    class MI5(Base2, B1, Base1):
+    class MI5(m.Base2, B1, m.Base1):
         def __init__(self, i, j):
             B1.__init__(self)
-            Base1.__init__(self, i)
-            Base2.__init__(self, j)
+            m.Base1.__init__(self, i)
+            m.Base2.__init__(self, j)
 
-    class MI6(Base2, B1):
+    class MI6(m.Base2, B1):
         def __init__(self, i):
-            Base2.__init__(self, i)
+            m.Base2.__init__(self, i)
             B1.__init__(self)
 
     class B2(B1):
@@ -132,10 +128,10 @@ def test_multiple_inheritance_python():
     assert mi3.foo() == 5
     assert mi3.bar() == 6
 
-    mi4 = MI4(7, 8, 9)
+    mi4 = MI4(7, 8)
     assert mi4.v() == 1
-    assert mi4.foo() == 8
-    assert mi4.bar() == 7
+    assert mi4.foo() == 7
+    assert mi4.bar() == 8
 
     mi5 = MI5(10, 11)
     assert mi5.v() == 1
@@ -160,47 +156,45 @@ def test_multiple_inheritance_python():
 
 
 def test_multiple_inheritance_python_many_bases():
-    from pybind11_tests import (BaseN1,  BaseN2,  BaseN3,  BaseN4,  BaseN5,  BaseN6,  BaseN7,
-                                BaseN8,  BaseN9,  BaseN10, BaseN11, BaseN12, BaseN13, BaseN14,
-                                BaseN15, BaseN16, BaseN17)
 
-    class MIMany14(BaseN1, BaseN2, BaseN3, BaseN4):
+    class MIMany14(m.BaseN1, m.BaseN2, m.BaseN3, m.BaseN4):
         def __init__(self):
-            BaseN1.__init__(self, 1)
-            BaseN2.__init__(self, 2)
-            BaseN3.__init__(self, 3)
-            BaseN4.__init__(self, 4)
+            m.BaseN1.__init__(self, 1)
+            m.BaseN2.__init__(self, 2)
+            m.BaseN3.__init__(self, 3)
+            m.BaseN4.__init__(self, 4)
 
-    class MIMany58(BaseN5, BaseN6, BaseN7, BaseN8):
+    class MIMany58(m.BaseN5, m.BaseN6, m.BaseN7, m.BaseN8):
         def __init__(self):
-            BaseN5.__init__(self, 5)
-            BaseN6.__init__(self, 6)
-            BaseN7.__init__(self, 7)
-            BaseN8.__init__(self, 8)
+            m.BaseN5.__init__(self, 5)
+            m.BaseN6.__init__(self, 6)
+            m.BaseN7.__init__(self, 7)
+            m.BaseN8.__init__(self, 8)
 
-    class MIMany916(BaseN9, BaseN10, BaseN11, BaseN12, BaseN13, BaseN14, BaseN15, BaseN16):
+    class MIMany916(m.BaseN9, m.BaseN10, m.BaseN11, m.BaseN12, m.BaseN13, m.BaseN14, m.BaseN15,
+                    m.BaseN16):
         def __init__(self):
-            BaseN9.__init__(self, 9)
-            BaseN10.__init__(self, 10)
-            BaseN11.__init__(self, 11)
-            BaseN12.__init__(self, 12)
-            BaseN13.__init__(self, 13)
-            BaseN14.__init__(self, 14)
-            BaseN15.__init__(self, 15)
-            BaseN16.__init__(self, 16)
-
-    class MIMany19(MIMany14, MIMany58, BaseN9):
+            m.BaseN9.__init__(self, 9)
+            m.BaseN10.__init__(self, 10)
+            m.BaseN11.__init__(self, 11)
+            m.BaseN12.__init__(self, 12)
+            m.BaseN13.__init__(self, 13)
+            m.BaseN14.__init__(self, 14)
+            m.BaseN15.__init__(self, 15)
+            m.BaseN16.__init__(self, 16)
+
+    class MIMany19(MIMany14, MIMany58, m.BaseN9):
         def __init__(self):
             MIMany14.__init__(self)
             MIMany58.__init__(self)
-            BaseN9.__init__(self, 9)
+            m.BaseN9.__init__(self, 9)
 
-    class MIMany117(MIMany14, MIMany58, MIMany916, BaseN17):
+    class MIMany117(MIMany14, MIMany58, MIMany916, m.BaseN17):
         def __init__(self):
             MIMany14.__init__(self)
             MIMany58.__init__(self)
             MIMany916.__init__(self)
-            BaseN17.__init__(self, 17)
+            m.BaseN17.__init__(self, 17)
 
     # Inherits from 4 registered C++ classes: can fit in one pointer on any modern arch:
     a = MIMany14()
@@ -224,31 +218,29 @@ def test_multiple_inheritance_python_many_bases():
 
 
 def test_multiple_inheritance_virtbase():
-    from pybind11_tests import Base12a, bar_base2a, bar_base2a_sharedptr
 
-    class MITypePy(Base12a):
+    class MITypePy(m.Base12a):
         def __init__(self, i, j):
-            Base12a.__init__(self, i, j)
+            m.Base12a.__init__(self, i, j)
 
     mt = MITypePy(3, 4)
     assert mt.bar() == 4
-    assert bar_base2a(mt) == 4
-    assert bar_base2a_sharedptr(mt) == 4
+    assert m.bar_base2a(mt) == 4
+    assert m.bar_base2a_sharedptr(mt) == 4
 
 
 def test_mi_static_properties():
     """Mixing bases with and without static properties should be possible
      and the result should be independent of base definition order"""
-    from pybind11_tests import mi
 
-    for d in (mi.VanillaStaticMix1(), mi.VanillaStaticMix2()):
+    for d in (m.VanillaStaticMix1(), m.VanillaStaticMix2()):
         assert d.vanilla() == "Vanilla"
         assert d.static_func1() == "WithStatic1"
         assert d.static_func2() == "WithStatic2"
         assert d.static_func() == d.__class__.__name__
 
-        mi.WithStatic1.static_value1 = 1
-        mi.WithStatic2.static_value2 = 2
+        m.WithStatic1.static_value1 = 1
+        m.WithStatic2.static_value2 = 2
         assert d.static_value1 == 1
         assert d.static_value2 == 2
         assert d.static_value == 12
@@ -264,30 +256,28 @@ def test_mi_static_properties():
 @pytest.unsupported_on_pypy
 def test_mi_dynamic_attributes():
     """Mixing bases with and without dynamic attribute support"""
-    from pybind11_tests import mi
 
-    for d in (mi.VanillaDictMix1(), mi.VanillaDictMix2()):
+    for d in (m.VanillaDictMix1(), m.VanillaDictMix2()):
         d.dynamic = 1
         assert d.dynamic == 1
 
 
 def test_mi_unaligned_base():
     """Returning an offset (non-first MI) base class pointer should recognize the instance"""
-    from pybind11_tests import I801C, I801D, i801b1_c, i801b2_c, i801b1_d, i801b2_d
 
     n_inst = ConstructorStats.detail_reg_inst()
 
-    c = I801C()
-    d = I801D()
+    c = m.I801C()
+    d = m.I801D()
     # + 4 below because we have the two instances, and each instance has offset base I801B2
     assert ConstructorStats.detail_reg_inst() == n_inst + 4
-    b1c = i801b1_c(c)
+    b1c = m.i801b1_c(c)
     assert b1c is c
-    b2c = i801b2_c(c)
+    b2c = m.i801b2_c(c)
     assert b2c is c
-    b1d = i801b1_d(d)
+    b1d = m.i801b1_d(d)
     assert b1d is d
-    b2d = i801b2_d(d)
+    b2d = m.i801b2_d(d)
     assert b2d is d
 
     assert ConstructorStats.detail_reg_inst() == n_inst + 4  # no extra instances
@@ -299,30 +289,28 @@ def test_mi_unaligned_base():
 
 def test_mi_base_return():
     """Tests returning an offset (non-first MI) base class pointer to a derived instance"""
-    from pybind11_tests import (I801B2, I801C, I801D, i801c_b1, i801c_b2, i801d_b1, i801d_b2,
-                                i801e_c, i801e_b2)
 
     n_inst = ConstructorStats.detail_reg_inst()
 
-    c1 = i801c_b1()
-    assert type(c1) is I801C
+    c1 = m.i801c_b1()
+    assert type(c1) is m.I801C
     assert c1.a == 1
     assert c1.b == 2
 
-    d1 = i801d_b1()
-    assert type(d1) is I801D
+    d1 = m.i801d_b1()
+    assert type(d1) is m.I801D
     assert d1.a == 1
     assert d1.b == 2
 
     assert ConstructorStats.detail_reg_inst() == n_inst + 4
 
-    c2 = i801c_b2()
-    assert type(c2) is I801C
+    c2 = m.i801c_b2()
+    assert type(c2) is m.I801C
     assert c2.a == 1
     assert c2.b == 2
 
-    d2 = i801d_b2()
-    assert type(d2) is I801D
+    d2 = m.i801d_b2()
+    assert type(d2) is m.I801D
     assert d2.a == 1
     assert d2.b == 2
 
@@ -336,11 +324,26 @@ def test_mi_base_return():
     # Returning an unregistered derived type with a registered base; we won't
     # pick up the derived type, obviously, but should still work (as an object
     # of whatever type was returned).
-    e1 = i801e_c()
-    assert type(e1) is I801C
+    e1 = m.i801e_c()
+    assert type(e1) is m.I801C
     assert e1.a == 1
     assert e1.b == 2
 
-    e2 = i801e_b2()
-    assert type(e2) is I801B2
+    e2 = m.i801e_b2()
+    assert type(e2) is m.I801B2
     assert e2.b == 2
+
+
+def test_diamond_inheritance():
+    """Tests that diamond inheritance works as expected (issue #959)"""
+
+    # Issue #959: this shouldn't segfault:
+    d = m.D()
+
+    # Make sure all the various distinct pointers are all recognized as registered instances:
+    assert d is d.c0()
+    assert d is d.c1()
+    assert d is d.b()
+    assert d is d.c0().b()
+    assert d is d.c1().b()
+    assert d is d.c0().c1().b().c0().b()
diff --git a/src/pybind11/tests/test_numpy_array.cpp b/src/pybind11/tests/test_numpy_array.cpp
index ea5be79..156a3bf 100644
--- a/src/pybind11/tests/test_numpy_array.cpp
+++ b/src/pybind11/tests/test_numpy_array.cpp
@@ -14,6 +14,67 @@
 
 #include <cstdint>
 
+// Size / dtype checks.
+struct DtypeCheck {
+    py::dtype numpy{};
+    py::dtype pybind11{};
+};
+
+template <typename T>
+DtypeCheck get_dtype_check(const char* name) {
+    py::module np = py::module::import("numpy");
+    DtypeCheck check{};
+    check.numpy = np.attr("dtype")(np.attr(name));
+    check.pybind11 = py::dtype::of<T>();
+    return check;
+}
+
+std::vector<DtypeCheck> get_concrete_dtype_checks() {
+    return {
+        // Normalization
+        get_dtype_check<std::int8_t>("int8"),
+        get_dtype_check<std::uint8_t>("uint8"),
+        get_dtype_check<std::int16_t>("int16"),
+        get_dtype_check<std::uint16_t>("uint16"),
+        get_dtype_check<std::int32_t>("int32"),
+        get_dtype_check<std::uint32_t>("uint32"),
+        get_dtype_check<std::int64_t>("int64"),
+        get_dtype_check<std::uint64_t>("uint64")
+    };
+}
+
+struct DtypeSizeCheck {
+    std::string name{};
+    int size_cpp{};
+    int size_numpy{};
+    // For debugging.
+    py::dtype dtype{};
+};
+
+template <typename T>
+DtypeSizeCheck get_dtype_size_check() {
+    DtypeSizeCheck check{};
+    check.name = py::type_id<T>();
+    check.size_cpp = sizeof(T);
+    check.dtype = py::dtype::of<T>();
+    check.size_numpy = check.dtype.attr("itemsize").template cast<int>();
+    return check;
+}
+
+std::vector<DtypeSizeCheck> get_platform_dtype_size_checks() {
+    return {
+        get_dtype_size_check<short>(),
+        get_dtype_size_check<unsigned short>(),
+        get_dtype_size_check<int>(),
+        get_dtype_size_check<unsigned int>(),
+        get_dtype_size_check<long>(),
+        get_dtype_size_check<unsigned long>(),
+        get_dtype_size_check<long long>(),
+        get_dtype_size_check<unsigned long long>(),
+    };
+}
+
+// Arrays.
 using arr = py::array;
 using arr_t = py::array_t<uint16_t, 0>;
 static_assert(std::is_same<arr_t::value_type, uint16_t>::value, "");
@@ -26,20 +87,6 @@ template<typename... Ix> arr data_t(const arr_t& a, Ix... index) {
     return arr(a.size() - a.index_at(index...), a.data(index...));
 }
 
-arr& mutate_data(arr& a) {
-    auto ptr = (uint8_t *) a.mutable_data();
-    for (ssize_t i = 0; i < a.nbytes(); i++)
-        ptr[i] = (uint8_t) (ptr[i] * 2);
-    return a;
-}
-
-arr_t& mutate_data_t(arr_t& a) {
-    auto ptr = a.mutable_data();
-    for (ssize_t i = 0; i < a.size(); i++)
-        ptr[i]++;
-    return a;
-}
-
 template<typename... Ix> arr& mutate_data(arr& a, Ix... index) {
     auto ptr = (uint8_t *) a.mutable_data(index...);
     for (ssize_t i = 0; i < a.nbytes() - a.offset_at(index...); i++)
@@ -82,9 +129,34 @@ template <typename T, typename T2> py::handle auxiliaries(T &&r, T2 &&r2) {
     return l.release();
 }
 
-test_initializer numpy_array([](py::module &m) {
-    auto sm = m.def_submodule("array");
-
+// note: declaration at local scope would create a dangling reference!
+static int data_i = 42;
+
+TEST_SUBMODULE(numpy_array, sm) {
+    try { py::module::import("numpy"); }
+    catch (...) { return; }
+
+    // test_dtypes
+    py::class_<DtypeCheck>(sm, "DtypeCheck")
+        .def_readonly("numpy", &DtypeCheck::numpy)
+        .def_readonly("pybind11", &DtypeCheck::pybind11)
+        .def("__repr__", [](const DtypeCheck& self) {
+            return py::str("<DtypeCheck numpy={} pybind11={}>").format(
+                self.numpy, self.pybind11);
+        });
+    sm.def("get_concrete_dtype_checks", &get_concrete_dtype_checks);
+
+    py::class_<DtypeSizeCheck>(sm, "DtypeSizeCheck")
+        .def_readonly("name", &DtypeSizeCheck::name)
+        .def_readonly("size_cpp", &DtypeSizeCheck::size_cpp)
+        .def_readonly("size_numpy", &DtypeSizeCheck::size_numpy)
+        .def("__repr__", [](const DtypeSizeCheck& self) {
+            return py::str("<DtypeSizeCheck name='{}' size_cpp={} size_numpy={} dtype={}>").format(
+                self.name, self.size_cpp, self.size_numpy, self.dtype);
+        });
+    sm.def("get_platform_dtype_size_checks", &get_platform_dtype_size_checks);
+
+    // test_array_attributes
     sm.def("ndim", [](const arr& a) { return a.ndim(); });
     sm.def("shape", [](const arr& a) { return arr(a.ndim(), a.shape()); });
     sm.def("shape", [](const arr& a, ssize_t dim) { return a.shape(dim); });
@@ -96,25 +168,30 @@ test_initializer numpy_array([](py::module &m) {
     sm.def("nbytes", [](const arr& a) { return a.nbytes(); });
     sm.def("owndata", [](const arr& a) { return a.owndata(); });
 
-    def_index_fn(data, const arr&);
-    def_index_fn(data_t, const arr_t&);
+    // test_index_offset
     def_index_fn(index_at, const arr&);
     def_index_fn(index_at_t, const arr_t&);
     def_index_fn(offset_at, const arr&);
     def_index_fn(offset_at_t, const arr_t&);
+    // test_data
+    def_index_fn(data, const arr&);
+    def_index_fn(data_t, const arr_t&);
+    // test_mutate_data, test_mutate_readonly
     def_index_fn(mutate_data, arr&);
     def_index_fn(mutate_data_t, arr_t&);
     def_index_fn(at_t, const arr_t&);
     def_index_fn(mutate_at_t, arr_t&);
 
-    sm.def("make_f_array", [] {
-        return py::array_t<float>({ 2, 2 }, { 4, 8 });
-    });
+    // test_make_c_f_array
+    sm.def("make_f_array", [] { return py::array_t<float>({ 2, 2 }, { 4, 8 }); });
+    sm.def("make_c_array", [] { return py::array_t<float>({ 2, 2 }, { 8, 4 }); });
 
-    sm.def("make_c_array", [] {
-        return py::array_t<float>({ 2, 2 }, { 8, 4 });
-    });
+    // test_empty_shaped_array
+    sm.def("make_empty_shaped_array", [] { return py::array(py::dtype("f"), {}, {}); });
+    // test numpy scalars (empty shape, ndim==0)
+    sm.def("scalar_int", []() { return py::array(py::dtype("i"), {}, {}, &data_i); });
 
+    // test_wrap
     sm.def("wrap", [](py::array a) {
         return py::array(
             a.dtype(),
@@ -125,12 +202,12 @@ test_initializer numpy_array([](py::module &m) {
         );
     });
 
+    // test_numpy_view
     struct ArrayClass {
         int data[2] = { 1, 2 };
         ArrayClass() { py::print("ArrayClass()"); }
         ~ArrayClass() { py::print("~ArrayClass()"); }
     };
-
     py::class_<ArrayClass>(sm, "ArrayClass")
         .def(py::init<>())
         .def("numpy_view", [](py::object &obj) {
@@ -140,16 +217,18 @@ test_initializer numpy_array([](py::module &m) {
         }
     );
 
+    // test_cast_numpy_int64_to_uint64
     sm.def("function_taking_uint64", [](uint64_t) { });
 
+    // test_isinstance
     sm.def("isinstance_untyped", [](py::object yes, py::object no) {
         return py::isinstance<py::array>(yes) && !py::isinstance<py::array>(no);
     });
-
     sm.def("isinstance_typed", [](py::object o) {
         return py::isinstance<py::array_t<double>>(o) && !py::isinstance<py::array_t<int>>(o);
     });
 
+    // test_constructors
     sm.def("default_constructors", []() {
         return py::dict(
             "array"_a=py::array(),
@@ -157,7 +236,6 @@ test_initializer numpy_array([](py::module &m) {
             "array_t<double>"_a=py::array_t<double>()
         );
     });
-
     sm.def("converting_constructors", [](py::object o) {
         return py::dict(
             "array"_a=py::array(o),
@@ -166,7 +244,7 @@ test_initializer numpy_array([](py::module &m) {
         );
     });
 
-    // Overload resolution tests:
+    // test_overload_resolution
     sm.def("overloaded", [](py::array_t<double>) { return "double"; });
     sm.def("overloaded", [](py::array_t<float>) { return "float"; });
     sm.def("overloaded", [](py::array_t<int>) { return "int"; });
@@ -194,11 +272,13 @@ test_initializer numpy_array([](py::module &m) {
     sm.def("overloaded5", [](py::array_t<unsigned int>) { return "unsigned int"; });
     sm.def("overloaded5", [](py::array_t<double>) { return "double"; });
 
+    // test_greedy_string_overload
     // Issue 685: ndarray shouldn't go to std::string overload
     sm.def("issue685", [](std::string) { return "string"; });
     sm.def("issue685", [](py::array) { return "array"; });
     sm.def("issue685", [](py::object) { return "other"; });
 
+    // test_array_unchecked_fixed_dims
     sm.def("proxy_add2", [](py::array_t<double> a, double v) {
         auto r = a.mutable_unchecked<2>();
         for (ssize_t i = 0; i < r.shape(0); i++)
@@ -238,6 +318,7 @@ test_initializer numpy_array([](py::module &m) {
         return auxiliaries(r, r2);
     });
 
+    // test_array_unchecked_dyn_dims
     // Same as the above, but without a compile-time dimensions specification:
     sm.def("proxy_add2_dyn", [](py::array_t<double> a, double v) {
         auto r = a.mutable_unchecked();
@@ -264,19 +345,21 @@ test_initializer numpy_array([](py::module &m) {
         return auxiliaries(a, a);
     });
 
+    // test_array_failures
     // Issue #785: Uninformative "Unknown internal error" exception when constructing array from empty object:
     sm.def("array_fail_test", []() { return py::array(py::object()); });
     sm.def("array_t_fail_test", []() { return py::array_t<double>(py::object()); });
-
     // Make sure the error from numpy is being passed through:
     sm.def("array_fail_test_negative_size", []() { int c = 0; return py::array(-1, &c); });
 
+    // test_initializer_list
     // Issue (unnumbered; reported in #788): regression: initializer lists can be ambiguous
-    sm.def("array_initializer_list", []() { return py::array_t<float>(1); }); // { 1 } also works, but clang warns about it
-    sm.def("array_initializer_list", []() { return py::array_t<float>({ 1, 2 }); });
-    sm.def("array_initializer_list", []() { return py::array_t<float>({ 1, 2, 3 }); });
-    sm.def("array_initializer_list", []() { return py::array_t<float>({ 1, 2, 3, 4 }); });
+    sm.def("array_initializer_list1", []() { return py::array_t<float>(1); }); // { 1 } also works, but clang warns about it
+    sm.def("array_initializer_list2", []() { return py::array_t<float>({ 1, 2 }); });
+    sm.def("array_initializer_list3", []() { return py::array_t<float>({ 1, 2, 3 }); });
+    sm.def("array_initializer_list4", []() { return py::array_t<float>({ 1, 2, 3, 4 }); });
 
+    // test_array_resize
     // reshape array to 2D without changing size
     sm.def("array_reshape2", [](py::array_t<double> a) {
         const ssize_t dim_sz = (ssize_t)std::sqrt(a.size());
@@ -290,6 +373,7 @@ test_initializer numpy_array([](py::module &m) {
         a.resize({N, N, N}, refcheck);
     });
 
+    // test_array_create_and_resize
     // return 2D array with Nrows = Ncols = N
     sm.def("create_and_resize", [](size_t N) {
         py::array_t<double> a;
@@ -297,4 +381,10 @@ test_initializer numpy_array([](py::module &m) {
         std::fill(a.mutable_data(), a.mutable_data() + a.size(), 42.);
         return a;
     });
-});
+
+#if PY_MAJOR_VERSION >= 3
+        sm.def("index_using_ellipsis", [](py::array a) {
+            return a[py::make_tuple(0, py::ellipsis(), 0)];
+        });
+#endif
+}
diff --git a/src/pybind11/tests/test_numpy_array.py b/src/pybind11/tests/test_numpy_array.py
index 90fa142..d0a6324 100644
--- a/src/pybind11/tests/test_numpy_array.py
+++ b/src/pybind11/tests/test_numpy_array.py
@@ -1,4 +1,5 @@
 import pytest
+from pybind11_tests import numpy_array as m
 
 pytestmark = pytest.requires_numpy
 
@@ -6,68 +7,76 @@ with pytest.suppress(ImportError):
     import numpy as np
 
 
+def test_dtypes():
+    # See issue #1328.
+    # - Platform-dependent sizes.
+    for size_check in m.get_platform_dtype_size_checks():
+        print(size_check)
+        assert size_check.size_cpp == size_check.size_numpy, size_check
+    # - Concrete sizes.
+    for check in m.get_concrete_dtype_checks():
+        print(check)
+        assert check.numpy == check.pybind11, check
+        if check.numpy.num != check.pybind11.num:
+            print("NOTE: typenum mismatch for {}: {} != {}".format(
+                check, check.numpy.num, check.pybind11.num))
+
+
 @pytest.fixture(scope='function')
 def arr():
     return np.array([[1, 2, 3], [4, 5, 6]], '=u2')
 
 
 def test_array_attributes():
-    from pybind11_tests.array import (
-        ndim, shape, strides, writeable, size, itemsize, nbytes, owndata
-    )
-
     a = np.array(0, 'f8')
-    assert ndim(a) == 0
-    assert all(shape(a) == [])
-    assert all(strides(a) == [])
+    assert m.ndim(a) == 0
+    assert all(m.shape(a) == [])
+    assert all(m.strides(a) == [])
     with pytest.raises(IndexError) as excinfo:
-        shape(a, 0)
+        m.shape(a, 0)
     assert str(excinfo.value) == 'invalid axis: 0 (ndim = 0)'
     with pytest.raises(IndexError) as excinfo:
-        strides(a, 0)
+        m.strides(a, 0)
     assert str(excinfo.value) == 'invalid axis: 0 (ndim = 0)'
-    assert writeable(a)
-    assert size(a) == 1
-    assert itemsize(a) == 8
-    assert nbytes(a) == 8
-    assert owndata(a)
+    assert m.writeable(a)
+    assert m.size(a) == 1
+    assert m.itemsize(a) == 8
+    assert m.nbytes(a) == 8
+    assert m.owndata(a)
 
     a = np.array([[1, 2, 3], [4, 5, 6]], 'u2').view()
     a.flags.writeable = False
-    assert ndim(a) == 2
-    assert all(shape(a) == [2, 3])
-    assert shape(a, 0) == 2
-    assert shape(a, 1) == 3
-    assert all(strides(a) == [6, 2])
-    assert strides(a, 0) == 6
-    assert strides(a, 1) == 2
+    assert m.ndim(a) == 2
+    assert all(m.shape(a) == [2, 3])
+    assert m.shape(a, 0) == 2
+    assert m.shape(a, 1) == 3
+    assert all(m.strides(a) == [6, 2])
+    assert m.strides(a, 0) == 6
+    assert m.strides(a, 1) == 2
     with pytest.raises(IndexError) as excinfo:
-        shape(a, 2)
+        m.shape(a, 2)
     assert str(excinfo.value) == 'invalid axis: 2 (ndim = 2)'
     with pytest.raises(IndexError) as excinfo:
-        strides(a, 2)
+        m.strides(a, 2)
     assert str(excinfo.value) == 'invalid axis: 2 (ndim = 2)'
-    assert not writeable(a)
-    assert size(a) == 6
-    assert itemsize(a) == 2
-    assert nbytes(a) == 12
-    assert not owndata(a)
+    assert not m.writeable(a)
+    assert m.size(a) == 6
+    assert m.itemsize(a) == 2
+    assert m.nbytes(a) == 12
+    assert not m.owndata(a)
 
 
 @pytest.mark.parametrize('args, ret', [([], 0), ([0], 0), ([1], 3), ([0, 1], 1), ([1, 2], 5)])
 def test_index_offset(arr, args, ret):
-    from pybind11_tests.array import index_at, index_at_t, offset_at, offset_at_t
-    assert index_at(arr, *args) == ret
-    assert index_at_t(arr, *args) == ret
-    assert offset_at(arr, *args) == ret * arr.dtype.itemsize
-    assert offset_at_t(arr, *args) == ret * arr.dtype.itemsize
+    assert m.index_at(arr, *args) == ret
+    assert m.index_at_t(arr, *args) == ret
+    assert m.offset_at(arr, *args) == ret * arr.dtype.itemsize
+    assert m.offset_at_t(arr, *args) == ret * arr.dtype.itemsize
 
 
 def test_dim_check_fail(arr):
-    from pybind11_tests.array import (index_at, index_at_t, offset_at, offset_at_t, data, data_t,
-                                      mutate_data, mutate_data_t)
-    for func in (index_at, index_at_t, offset_at, offset_at_t, data, data_t,
-                 mutate_data, mutate_data_t):
+    for func in (m.index_at, m.index_at_t, m.offset_at, m.offset_at_t, m.data, m.data_t,
+                 m.mutate_data, m.mutate_data_t):
         with pytest.raises(IndexError) as excinfo:
             func(arr, 1, 2, 3)
         assert str(excinfo.value) == 'too many indices for an array: 3 (ndim = 2)'
@@ -79,63 +88,53 @@ def test_dim_check_fail(arr):
                           ([0, 1], [2, 3, 4, 5, 6]),
                           ([1, 2], [6])])
 def test_data(arr, args, ret):
-    from pybind11_tests.array import data, data_t
     from sys import byteorder
-    assert all(data_t(arr, *args) == ret)
-    assert all(data(arr, *args)[(0 if byteorder == 'little' else 1)::2] == ret)
-    assert all(data(arr, *args)[(1 if byteorder == 'little' else 0)::2] == 0)
-
-
-def test_mutate_readonly(arr):
-    from pybind11_tests.array import mutate_data, mutate_data_t, mutate_at_t
-    arr.flags.writeable = False
-    for func, args in (mutate_data, ()), (mutate_data_t, ()), (mutate_at_t, (0, 0)):
-        with pytest.raises(ValueError) as excinfo:
-            func(arr, *args)
-        assert str(excinfo.value) == 'array is not writeable'
+    assert all(m.data_t(arr, *args) == ret)
+    assert all(m.data(arr, *args)[(0 if byteorder == 'little' else 1)::2] == ret)
+    assert all(m.data(arr, *args)[(1 if byteorder == 'little' else 0)::2] == 0)
 
 
 @pytest.mark.parametrize('dim', [0, 1, 3])
 def test_at_fail(arr, dim):
-    from pybind11_tests.array import at_t, mutate_at_t
-    for func in at_t, mutate_at_t:
+    for func in m.at_t, m.mutate_at_t:
         with pytest.raises(IndexError) as excinfo:
             func(arr, *([0] * dim))
         assert str(excinfo.value) == 'index dimension mismatch: {} (ndim = 2)'.format(dim)
 
 
 def test_at(arr):
-    from pybind11_tests.array import at_t, mutate_at_t
+    assert m.at_t(arr, 0, 2) == 3
+    assert m.at_t(arr, 1, 0) == 4
+
+    assert all(m.mutate_at_t(arr, 0, 2).ravel() == [1, 2, 4, 4, 5, 6])
+    assert all(m.mutate_at_t(arr, 1, 0).ravel() == [1, 2, 4, 5, 5, 6])
 
-    assert at_t(arr, 0, 2) == 3
-    assert at_t(arr, 1, 0) == 4
 
-    assert all(mutate_at_t(arr, 0, 2).ravel() == [1, 2, 4, 4, 5, 6])
-    assert all(mutate_at_t(arr, 1, 0).ravel() == [1, 2, 4, 5, 5, 6])
+def test_mutate_readonly(arr):
+    arr.flags.writeable = False
+    for func, args in (m.mutate_data, ()), (m.mutate_data_t, ()), (m.mutate_at_t, (0, 0)):
+        with pytest.raises(ValueError) as excinfo:
+            func(arr, *args)
+        assert str(excinfo.value) == 'array is not writeable'
 
 
 def test_mutate_data(arr):
-    from pybind11_tests.array import mutate_data, mutate_data_t
-
-    assert all(mutate_data(arr).ravel() == [2, 4, 6, 8, 10, 12])
-    assert all(mutate_data(arr).ravel() == [4, 8, 12, 16, 20, 24])
-    assert all(mutate_data(arr, 1).ravel() == [4, 8, 12, 32, 40, 48])
-    assert all(mutate_data(arr, 0, 1).ravel() == [4, 16, 24, 64, 80, 96])
-    assert all(mutate_data(arr, 1, 2).ravel() == [4, 16, 24, 64, 80, 192])
+    assert all(m.mutate_data(arr).ravel() == [2, 4, 6, 8, 10, 12])
+    assert all(m.mutate_data(arr).ravel() == [4, 8, 12, 16, 20, 24])
+    assert all(m.mutate_data(arr, 1).ravel() == [4, 8, 12, 32, 40, 48])
+    assert all(m.mutate_data(arr, 0, 1).ravel() == [4, 16, 24, 64, 80, 96])
+    assert all(m.mutate_data(arr, 1, 2).ravel() == [4, 16, 24, 64, 80, 192])
 
-    assert all(mutate_data_t(arr).ravel() == [5, 17, 25, 65, 81, 193])
-    assert all(mutate_data_t(arr).ravel() == [6, 18, 26, 66, 82, 194])
-    assert all(mutate_data_t(arr, 1).ravel() == [6, 18, 26, 67, 83, 195])
-    assert all(mutate_data_t(arr, 0, 1).ravel() == [6, 19, 27, 68, 84, 196])
-    assert all(mutate_data_t(arr, 1, 2).ravel() == [6, 19, 27, 68, 84, 197])
+    assert all(m.mutate_data_t(arr).ravel() == [5, 17, 25, 65, 81, 193])
+    assert all(m.mutate_data_t(arr).ravel() == [6, 18, 26, 66, 82, 194])
+    assert all(m.mutate_data_t(arr, 1).ravel() == [6, 18, 26, 67, 83, 195])
+    assert all(m.mutate_data_t(arr, 0, 1).ravel() == [6, 19, 27, 68, 84, 196])
+    assert all(m.mutate_data_t(arr, 1, 2).ravel() == [6, 19, 27, 68, 84, 197])
 
 
 def test_bounds_check(arr):
-    from pybind11_tests.array import (index_at, index_at_t, data, data_t,
-                                      mutate_data, mutate_data_t, at_t, mutate_at_t)
-    funcs = (index_at, index_at_t, data, data_t,
-             mutate_data, mutate_data_t, at_t, mutate_at_t)
-    for func in funcs:
+    for func in (m.index_at, m.index_at_t, m.data, m.data_t,
+                 m.mutate_data, m.mutate_data_t, m.at_t, m.mutate_at_t):
         with pytest.raises(IndexError) as excinfo:
             func(arr, 2, 0)
         assert str(excinfo.value) == 'index 2 is out of bounds for axis 0 with size 2'
@@ -145,19 +144,24 @@ def test_bounds_check(arr):
 
 
 def test_make_c_f_array():
-    from pybind11_tests.array import (
-        make_c_array, make_f_array
-    )
-    assert make_c_array().flags.c_contiguous
-    assert not make_c_array().flags.f_contiguous
-    assert make_f_array().flags.f_contiguous
-    assert not make_f_array().flags.c_contiguous
+    assert m.make_c_array().flags.c_contiguous
+    assert not m.make_c_array().flags.f_contiguous
+    assert m.make_f_array().flags.f_contiguous
+    assert not m.make_f_array().flags.c_contiguous
 
 
-def test_wrap():
-    from pybind11_tests.array import wrap
+def test_make_empty_shaped_array():
+    m.make_empty_shaped_array()
+
+    # empty shape means numpy scalar, PEP 3118
+    assert m.scalar_int().ndim == 0
+    assert m.scalar_int().shape == ()
+    assert m.scalar_int() == 42
+
 
+def test_wrap():
     def assert_references(a, b, base=None):
+        from distutils.version import LooseVersion
         if base is None:
             base = a
         assert a is not b
@@ -168,7 +172,10 @@ def test_wrap():
         assert a.flags.f_contiguous == b.flags.f_contiguous
         assert a.flags.writeable == b.flags.writeable
         assert a.flags.aligned == b.flags.aligned
-        assert a.flags.updateifcopy == b.flags.updateifcopy
+        if LooseVersion(np.__version__) >= LooseVersion("1.14.0"):
+            assert a.flags.writebackifcopy == b.flags.writebackifcopy
+        else:
+            assert a.flags.updateifcopy == b.flags.updateifcopy
         assert np.all(a == b)
         assert not b.flags.owndata
         assert b.base is base
@@ -178,40 +185,39 @@ def test_wrap():
 
     a1 = np.array([1, 2], dtype=np.int16)
     assert a1.flags.owndata and a1.base is None
-    a2 = wrap(a1)
+    a2 = m.wrap(a1)
     assert_references(a1, a2)
 
     a1 = np.array([[1, 2], [3, 4]], dtype=np.float32, order='F')
     assert a1.flags.owndata and a1.base is None
-    a2 = wrap(a1)
+    a2 = m.wrap(a1)
     assert_references(a1, a2)
 
     a1 = np.array([[1, 2], [3, 4]], dtype=np.float32, order='C')
     a1.flags.writeable = False
-    a2 = wrap(a1)
+    a2 = m.wrap(a1)
     assert_references(a1, a2)
 
     a1 = np.random.random((4, 4, 4))
-    a2 = wrap(a1)
+    a2 = m.wrap(a1)
     assert_references(a1, a2)
 
     a1t = a1.transpose()
-    a2 = wrap(a1t)
+    a2 = m.wrap(a1t)
     assert_references(a1t, a2, a1)
 
     a1d = a1.diagonal()
-    a2 = wrap(a1d)
+    a2 = m.wrap(a1d)
     assert_references(a1d, a2, a1)
 
     a1m = a1[::-1, ::-1, ::-1]
-    a2 = wrap(a1m)
+    a2 = m.wrap(a1m)
     assert_references(a1m, a2, a1)
 
 
 def test_numpy_view(capture):
-    from pybind11_tests.array import ArrayClass
     with capture:
-        ac = ArrayClass()
+        ac = m.ArrayClass()
         ac_view_1 = ac.numpy_view()
         ac_view_2 = ac.numpy_view()
         assert np.all(ac_view_1 == np.array([1, 2], dtype=np.int32))
@@ -238,29 +244,24 @@ def test_numpy_view(capture):
 
 @pytest.unsupported_on_pypy
 def test_cast_numpy_int64_to_uint64():
-    from pybind11_tests.array import function_taking_uint64
-    function_taking_uint64(123)
-    function_taking_uint64(np.uint64(123))
+    m.function_taking_uint64(123)
+    m.function_taking_uint64(np.uint64(123))
 
 
 def test_isinstance():
-    from pybind11_tests.array import isinstance_untyped, isinstance_typed
-
-    assert isinstance_untyped(np.array([1, 2, 3]), "not an array")
-    assert isinstance_typed(np.array([1.0, 2.0, 3.0]))
+    assert m.isinstance_untyped(np.array([1, 2, 3]), "not an array")
+    assert m.isinstance_typed(np.array([1.0, 2.0, 3.0]))
 
 
 def test_constructors():
-    from pybind11_tests.array import default_constructors, converting_constructors
-
-    defaults = default_constructors()
+    defaults = m.default_constructors()
     for a in defaults.values():
         assert a.size == 0
     assert defaults["array"].dtype == np.array([]).dtype
     assert defaults["array_t<int32>"].dtype == np.int32
     assert defaults["array_t<double>"].dtype == np.float64
 
-    results = converting_constructors([1, 2, 3])
+    results = m.converting_constructors([1, 2, 3])
     for a in results.values():
         np.testing.assert_array_equal(a, [1, 2, 3])
     assert results["array"].dtype == np.int_
@@ -269,22 +270,20 @@ def test_constructors():
 
 
 def test_overload_resolution(msg):
-    from pybind11_tests.array import overloaded, overloaded2, overloaded3, overloaded4, overloaded5
-
     # Exact overload matches:
-    assert overloaded(np.array([1], dtype='float64')) == 'double'
-    assert overloaded(np.array([1], dtype='float32')) == 'float'
-    assert overloaded(np.array([1], dtype='ushort')) == 'unsigned short'
-    assert overloaded(np.array([1], dtype='intc')) == 'int'
-    assert overloaded(np.array([1], dtype='longlong')) == 'long long'
-    assert overloaded(np.array([1], dtype='complex')) == 'double complex'
-    assert overloaded(np.array([1], dtype='csingle')) == 'float complex'
+    assert m.overloaded(np.array([1], dtype='float64')) == 'double'
+    assert m.overloaded(np.array([1], dtype='float32')) == 'float'
+    assert m.overloaded(np.array([1], dtype='ushort')) == 'unsigned short'
+    assert m.overloaded(np.array([1], dtype='intc')) == 'int'
+    assert m.overloaded(np.array([1], dtype='longlong')) == 'long long'
+    assert m.overloaded(np.array([1], dtype='complex')) == 'double complex'
+    assert m.overloaded(np.array([1], dtype='csingle')) == 'float complex'
 
     # No exact match, should call first convertible version:
-    assert overloaded(np.array([1], dtype='uint8')) == 'double'
+    assert m.overloaded(np.array([1], dtype='uint8')) == 'double'
 
     with pytest.raises(TypeError) as excinfo:
-        overloaded("not an array")
+        m.overloaded("not an array")
     assert msg(excinfo.value) == """
         overloaded(): incompatible function arguments. The following argument types are supported:
             1. (arg0: numpy.ndarray[float64]) -> str
@@ -298,138 +297,151 @@ def test_overload_resolution(msg):
         Invoked with: 'not an array'
     """
 
-    assert overloaded2(np.array([1], dtype='float64')) == 'double'
-    assert overloaded2(np.array([1], dtype='float32')) == 'float'
-    assert overloaded2(np.array([1], dtype='complex64')) == 'float complex'
-    assert overloaded2(np.array([1], dtype='complex128')) == 'double complex'
-    assert overloaded2(np.array([1], dtype='float32')) == 'float'
+    assert m.overloaded2(np.array([1], dtype='float64')) == 'double'
+    assert m.overloaded2(np.array([1], dtype='float32')) == 'float'
+    assert m.overloaded2(np.array([1], dtype='complex64')) == 'float complex'
+    assert m.overloaded2(np.array([1], dtype='complex128')) == 'double complex'
+    assert m.overloaded2(np.array([1], dtype='float32')) == 'float'
 
-    assert overloaded3(np.array([1], dtype='float64')) == 'double'
-    assert overloaded3(np.array([1], dtype='intc')) == 'int'
+    assert m.overloaded3(np.array([1], dtype='float64')) == 'double'
+    assert m.overloaded3(np.array([1], dtype='intc')) == 'int'
     expected_exc = """
         overloaded3(): incompatible function arguments. The following argument types are supported:
             1. (arg0: numpy.ndarray[int32]) -> str
             2. (arg0: numpy.ndarray[float64]) -> str
 
-        Invoked with:"""
+        Invoked with: """
 
     with pytest.raises(TypeError) as excinfo:
-        overloaded3(np.array([1], dtype='uintc'))
-    assert msg(excinfo.value) == expected_exc + " array([1], dtype=uint32)"
+        m.overloaded3(np.array([1], dtype='uintc'))
+    assert msg(excinfo.value) == expected_exc + repr(np.array([1], dtype='uint32'))
     with pytest.raises(TypeError) as excinfo:
-        overloaded3(np.array([1], dtype='float32'))
-    assert msg(excinfo.value) == expected_exc + " array([ 1.], dtype=float32)"
+        m.overloaded3(np.array([1], dtype='float32'))
+    assert msg(excinfo.value) == expected_exc + repr(np.array([1.], dtype='float32'))
     with pytest.raises(TypeError) as excinfo:
-        overloaded3(np.array([1], dtype='complex'))
-    assert msg(excinfo.value) == expected_exc + " array([ 1.+0.j])"
+        m.overloaded3(np.array([1], dtype='complex'))
+    assert msg(excinfo.value) == expected_exc + repr(np.array([1. + 0.j]))
 
     # Exact matches:
-    assert overloaded4(np.array([1], dtype='double')) == 'double'
-    assert overloaded4(np.array([1], dtype='longlong')) == 'long long'
+    assert m.overloaded4(np.array([1], dtype='double')) == 'double'
+    assert m.overloaded4(np.array([1], dtype='longlong')) == 'long long'
     # Non-exact matches requiring conversion.  Since float to integer isn't a
     # save conversion, it should go to the double overload, but short can go to
     # either (and so should end up on the first-registered, the long long).
-    assert overloaded4(np.array([1], dtype='float32')) == 'double'
-    assert overloaded4(np.array([1], dtype='short')) == 'long long'
+    assert m.overloaded4(np.array([1], dtype='float32')) == 'double'
+    assert m.overloaded4(np.array([1], dtype='short')) == 'long long'
 
-    assert overloaded5(np.array([1], dtype='double')) == 'double'
-    assert overloaded5(np.array([1], dtype='uintc')) == 'unsigned int'
-    assert overloaded5(np.array([1], dtype='float32')) == 'unsigned int'
+    assert m.overloaded5(np.array([1], dtype='double')) == 'double'
+    assert m.overloaded5(np.array([1], dtype='uintc')) == 'unsigned int'
+    assert m.overloaded5(np.array([1], dtype='float32')) == 'unsigned int'
 
 
-def test_greedy_string_overload():  # issue 685
-    from pybind11_tests.array import issue685
+def test_greedy_string_overload():
+    """Tests fix for #685 - ndarray shouldn't go to std::string overload"""
 
-    assert issue685("abc") == "string"
-    assert issue685(np.array([97, 98, 99], dtype='b')) == "array"
-    assert issue685(123) == "other"
+    assert m.issue685("abc") == "string"
+    assert m.issue685(np.array([97, 98, 99], dtype='b')) == "array"
+    assert m.issue685(123) == "other"
 
 
 def test_array_unchecked_fixed_dims(msg):
-    from pybind11_tests.array import (proxy_add2, proxy_init3F, proxy_init3, proxy_squared_L2_norm,
-                                      proxy_auxiliaries2, array_auxiliaries2)
-
     z1 = np.array([[1, 2], [3, 4]], dtype='float64')
-    proxy_add2(z1, 10)
+    m.proxy_add2(z1, 10)
     assert np.all(z1 == [[11, 12], [13, 14]])
 
     with pytest.raises(ValueError) as excinfo:
-        proxy_add2(np.array([1., 2, 3]), 5.0)
+        m.proxy_add2(np.array([1., 2, 3]), 5.0)
     assert msg(excinfo.value) == "array has incorrect number of dimensions: 1; expected 2"
 
     expect_c = np.ndarray(shape=(3, 3, 3), buffer=np.array(range(3, 30)), dtype='int')
-    assert np.all(proxy_init3(3.0) == expect_c)
+    assert np.all(m.proxy_init3(3.0) == expect_c)
     expect_f = np.transpose(expect_c)
-    assert np.all(proxy_init3F(3.0) == expect_f)
+    assert np.all(m.proxy_init3F(3.0) == expect_f)
 
-    assert proxy_squared_L2_norm(np.array(range(6))) == 55
-    assert proxy_squared_L2_norm(np.array(range(6), dtype="float64")) == 55
+    assert m.proxy_squared_L2_norm(np.array(range(6))) == 55
+    assert m.proxy_squared_L2_norm(np.array(range(6), dtype="float64")) == 55
 
-    assert proxy_auxiliaries2(z1) == [11, 11, True, 2, 8, 2, 2, 4, 32]
-    assert proxy_auxiliaries2(z1) == array_auxiliaries2(z1)
+    assert m.proxy_auxiliaries2(z1) == [11, 11, True, 2, 8, 2, 2, 4, 32]
+    assert m.proxy_auxiliaries2(z1) == m.array_auxiliaries2(z1)
 
 
 def test_array_unchecked_dyn_dims(msg):
-    from pybind11_tests.array import (proxy_add2_dyn, proxy_init3_dyn, proxy_auxiliaries2_dyn,
-                                      array_auxiliaries2)
     z1 = np.array([[1, 2], [3, 4]], dtype='float64')
-    proxy_add2_dyn(z1, 10)
+    m.proxy_add2_dyn(z1, 10)
     assert np.all(z1 == [[11, 12], [13, 14]])
 
     expect_c = np.ndarray(shape=(3, 3, 3), buffer=np.array(range(3, 30)), dtype='int')
-    assert np.all(proxy_init3_dyn(3.0) == expect_c)
+    assert np.all(m.proxy_init3_dyn(3.0) == expect_c)
 
-    assert proxy_auxiliaries2_dyn(z1) == [11, 11, True, 2, 8, 2, 2, 4, 32]
-    assert proxy_auxiliaries2_dyn(z1) == array_auxiliaries2(z1)
+    assert m.proxy_auxiliaries2_dyn(z1) == [11, 11, True, 2, 8, 2, 2, 4, 32]
+    assert m.proxy_auxiliaries2_dyn(z1) == m.array_auxiliaries2(z1)
 
 
 def test_array_failure():
-    from pybind11_tests.array import (array_fail_test, array_t_fail_test,
-                                      array_fail_test_negative_size)
-
     with pytest.raises(ValueError) as excinfo:
-        array_fail_test()
+        m.array_fail_test()
     assert str(excinfo.value) == 'cannot create a pybind11::array from a nullptr'
 
     with pytest.raises(ValueError) as excinfo:
-        array_t_fail_test()
+        m.array_t_fail_test()
     assert str(excinfo.value) == 'cannot create a pybind11::array_t from a nullptr'
 
     with pytest.raises(ValueError) as excinfo:
-        array_fail_test_negative_size()
+        m.array_fail_test_negative_size()
     assert str(excinfo.value) == 'negative dimensions are not allowed'
 
 
-def test_array_resize(msg):
-    from pybind11_tests.array import (array_reshape2, array_resize3)
+def test_initializer_list():
+    assert m.array_initializer_list1().shape == (1,)
+    assert m.array_initializer_list2().shape == (1, 2)
+    assert m.array_initializer_list3().shape == (1, 2, 3)
+    assert m.array_initializer_list4().shape == (1, 2, 3, 4)
+
 
+def test_array_resize(msg):
     a = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9], dtype='float64')
-    array_reshape2(a)
+    m.array_reshape2(a)
     assert(a.size == 9)
     assert(np.all(a == [[1, 2, 3], [4, 5, 6], [7, 8, 9]]))
 
     # total size change should succced with refcheck off
-    array_resize3(a, 4, False)
+    m.array_resize3(a, 4, False)
     assert(a.size == 64)
     # ... and fail with refcheck on
     try:
-        array_resize3(a, 3, True)
+        m.array_resize3(a, 3, True)
     except ValueError as e:
         assert(str(e).startswith("cannot resize an array"))
     # transposed array doesn't own data
     b = a.transpose()
     try:
-        array_resize3(b, 3, False)
+        m.array_resize3(b, 3, False)
     except ValueError as e:
         assert(str(e).startswith("cannot resize this array: it does not own its data"))
     # ... but reshape should be fine
-    array_reshape2(b)
+    m.array_reshape2(b)
     assert(b.shape == (8, 8))
 
 
 @pytest.unsupported_on_pypy
 def test_array_create_and_resize(msg):
-    from pybind11_tests.array import create_and_resize
-    a = create_and_resize(2)
+    a = m.create_and_resize(2)
     assert(a.size == 4)
     assert(np.all(a == 42.))
+
+
+@pytest.unsupported_on_py2
+def test_index_using_ellipsis():
+    a = m.index_using_ellipsis(np.zeros((5, 6, 7)))
+    assert a.shape == (6,)
+
+
+@pytest.unsupported_on_pypy
+def test_dtype_refcount_leak():
+    from sys import getrefcount
+    dtype = np.dtype(np.float_)
+    a = np.array([1], dtype=dtype)
+    before = getrefcount(dtype)
+    m.ndim(a)
+    after = getrefcount(dtype)
+    assert after == before
diff --git a/src/pybind11/tests/test_numpy_dtypes.cpp b/src/pybind11/tests/test_numpy_dtypes.cpp
index 5f987a8..467e025 100644
--- a/src/pybind11/tests/test_numpy_dtypes.cpp
+++ b/src/pybind11/tests/test_numpy_dtypes.cpp
@@ -29,6 +29,13 @@ std::ostream& operator<<(std::ostream& os, const SimpleStruct& v) {
     return os << "s:" << v.bool_ << "," << v.uint_ << "," << v.float_ << "," << v.ldbl_;
 }
 
+struct SimpleStructReordered {
+    bool bool_;
+    float float_;
+    uint32_t uint_;
+    long double ldbl_;
+};
+
 PYBIND11_PACKED(struct PackedStruct {
     bool bool_;
     uint32_t uint_;
@@ -156,90 +163,6 @@ py::array_t<S, 0> create_recarray(size_t n) {
     return arr;
 }
 
-std::string get_format_unbound() {
-    return py::format_descriptor<UnboundStruct>::format();
-}
-
-py::array_t<NestedStruct, 0> create_nested(size_t n) {
-    auto arr = mkarray_via_buffer<NestedStruct>(n);
-    auto req = arr.request();
-    auto ptr = static_cast<NestedStruct*>(req.ptr);
-    for (size_t i = 0; i < n; i++) {
-        SET_TEST_VALS(ptr[i].a, i);
-        SET_TEST_VALS(ptr[i].b, i + 1);
-    }
-    return arr;
-}
-
-py::array_t<PartialNestedStruct, 0> create_partial_nested(size_t n) {
-    auto arr = mkarray_via_buffer<PartialNestedStruct>(n);
-    auto req = arr.request();
-    auto ptr = static_cast<PartialNestedStruct*>(req.ptr);
-    for (size_t i = 0; i < n; i++) {
-        SET_TEST_VALS(ptr[i].a, i);
-    }
-    return arr;
-}
-
-py::array_t<StringStruct, 0> create_string_array(bool non_empty) {
-    auto arr = mkarray_via_buffer<StringStruct>(non_empty ? 4 : 0);
-    if (non_empty) {
-        auto req = arr.request();
-        auto ptr = static_cast<StringStruct*>(req.ptr);
-        for (ssize_t i = 0; i < req.size * req.itemsize; i++)
-            static_cast<char*>(req.ptr)[i] = 0;
-        ptr[1].a[0] = 'a'; ptr[1].b[0] = 'a';
-        ptr[2].a[0] = 'a'; ptr[2].b[0] = 'a';
-        ptr[3].a[0] = 'a'; ptr[3].b[0] = 'a';
-
-        ptr[2].a[1] = 'b'; ptr[2].b[1] = 'b';
-        ptr[3].a[1] = 'b'; ptr[3].b[1] = 'b';
-
-        ptr[3].a[2] = 'c'; ptr[3].b[2] = 'c';
-    }
-    return arr;
-}
-
-py::array_t<ArrayStruct, 0> create_array_array(size_t n) {
-    auto arr = mkarray_via_buffer<ArrayStruct>(n);
-    auto ptr = (ArrayStruct *) arr.mutable_data();
-    for (size_t i = 0; i < n; i++) {
-        for (size_t j = 0; j < 3; j++)
-            for (size_t k = 0; k < 4; k++)
-                ptr[i].a[j][k] = char('A' + (i * 100 + j * 10 + k) % 26);
-        for (size_t j = 0; j < 2; j++)
-            ptr[i].b[j] = int32_t(i * 1000 + j);
-        for (size_t j = 0; j < 3; j++)
-            ptr[i].c[j] = uint8_t(i * 10 + j);
-        for (size_t j = 0; j < 4; j++)
-            for (size_t k = 0; k < 2; k++)
-                ptr[i].d[j][k] = float(i) * 100.0f + float(j) * 10.0f + float(k);
-    }
-    return arr;
-}
-
-py::array_t<EnumStruct, 0> create_enum_array(size_t n) {
-    auto arr = mkarray_via_buffer<EnumStruct>(n);
-    auto ptr = (EnumStruct *) arr.mutable_data();
-    for (size_t i = 0; i < n; i++) {
-        ptr[i].e1 = static_cast<E1>(-1 + ((int) i % 2) * 2);
-        ptr[i].e2 = static_cast<E2>(1 + (i % 2));
-    }
-    return arr;
-}
-
-py::array_t<ComplexStruct, 0> create_complex_array(size_t n) {
-    auto arr = mkarray_via_buffer<ComplexStruct>(n);
-    auto ptr = (ComplexStruct *) arr.mutable_data();
-    for (size_t i = 0; i < n; i++) {
-        ptr[i].cflt.real(float(i));
-        ptr[i].cflt.imag(float(i) + 0.25f);
-        ptr[i].cdbl.real(double(i) + 0.5);
-        ptr[i].cdbl.imag(double(i) + 0.75);
-    }
-    return arr;
-}
-
 template <typename S>
 py::list print_recarray(py::array_t<S, 0> arr) {
     const auto req = arr.request();
@@ -253,45 +176,6 @@ py::list print_recarray(py::array_t<S, 0> arr) {
     return l;
 }
 
-py::list print_format_descriptors() {
-    const auto fmts = {
-        py::format_descriptor<SimpleStruct>::format(),
-        py::format_descriptor<PackedStruct>::format(),
-        py::format_descriptor<NestedStruct>::format(),
-        py::format_descriptor<PartialStruct>::format(),
-        py::format_descriptor<PartialNestedStruct>::format(),
-        py::format_descriptor<StringStruct>::format(),
-        py::format_descriptor<ArrayStruct>::format(),
-        py::format_descriptor<EnumStruct>::format(),
-        py::format_descriptor<ComplexStruct>::format()
-    };
-    auto l = py::list();
-    for (const auto &fmt : fmts) {
-        l.append(py::cast(fmt));
-    }
-    return l;
-}
-
-py::list print_dtypes() {
-    const auto dtypes = {
-        py::str(py::dtype::of<SimpleStruct>()),
-        py::str(py::dtype::of<PackedStruct>()),
-        py::str(py::dtype::of<NestedStruct>()),
-        py::str(py::dtype::of<PartialStruct>()),
-        py::str(py::dtype::of<PartialNestedStruct>()),
-        py::str(py::dtype::of<StringStruct>()),
-        py::str(py::dtype::of<ArrayStruct>()),
-        py::str(py::dtype::of<EnumStruct>()),
-        py::str(py::dtype::of<StructWithUglyNames>()),
-        py::str(py::dtype::of<ComplexStruct>())
-    };
-    auto l = py::list();
-    for (const auto &s : dtypes) {
-        l.append(s);
-    }
-    return l;
-}
-
 py::array_t<int32_t, 0> test_array_ctors(int i) {
     using arr_t = py::array_t<int32_t, 0>;
 
@@ -367,56 +251,18 @@ py::list test_dtype_ctors() {
     return list;
 }
 
-struct TrailingPaddingStruct {
-    int32_t a;
-    char b;
-};
-
-py::dtype trailing_padding_dtype() {
-    return py::dtype::of<TrailingPaddingStruct>();
-}
-
-py::dtype buffer_to_dtype(py::buffer& buf) {
-    return py::dtype(buf.request());
-}
-
-py::list test_dtype_methods() {
-    py::list list;
-    auto dt1 = py::dtype::of<int32_t>();
-    auto dt2 = py::dtype::of<SimpleStruct>();
-    list.append(dt1); list.append(dt2);
-    list.append(py::bool_(dt1.has_fields())); list.append(py::bool_(dt2.has_fields()));
-    list.append(py::int_(dt1.itemsize())); list.append(py::int_(dt2.itemsize()));
-    return list;
-}
-
-struct CompareStruct {
-    bool x;
-    uint32_t y;
-    float z;
-};
-
-py::list test_compare_buffer_info() {
-    py::list list;
-    list.append(py::bool_(py::detail::compare_buffer_info<float>::compare(py::buffer_info(nullptr, sizeof(float), "f", 1))));
-    list.append(py::bool_(py::detail::compare_buffer_info<unsigned>::compare(py::buffer_info(nullptr, sizeof(int), "I", 1))));
-    list.append(py::bool_(py::detail::compare_buffer_info<long>::compare(py::buffer_info(nullptr, sizeof(long), "l", 1))));
-    list.append(py::bool_(py::detail::compare_buffer_info<long>::compare(py::buffer_info(nullptr, sizeof(long), sizeof(long) == sizeof(int) ? "i" : "q", 1))));
-    list.append(py::bool_(py::detail::compare_buffer_info<CompareStruct>::compare(py::buffer_info(nullptr, sizeof(CompareStruct), "T{?:x:3xI:y:f:z:}", 1))));
-    return list;
-}
+struct A {};
+struct B {};
 
-test_initializer numpy_dtypes([](py::module &m) {
-    try {
-        py::module::import("numpy");
-    } catch (...) {
-        return;
-    }
+TEST_SUBMODULE(numpy_dtypes, m) {
+    try { py::module::import("numpy"); }
+    catch (...) { return; }
 
     // typeinfo may be registered before the dtype descriptor for scalar casts to work...
     py::class_<SimpleStruct>(m, "SimpleStruct");
 
     PYBIND11_NUMPY_DTYPE(SimpleStruct, bool_, uint_, float_, ldbl_);
+    PYBIND11_NUMPY_DTYPE(SimpleStructReordered, bool_, uint_, float_, ldbl_);
     PYBIND11_NUMPY_DTYPE(PackedStruct, bool_, uint_, float_, ldbl_);
     PYBIND11_NUMPY_DTYPE(NestedStruct, a, b);
     PYBIND11_NUMPY_DTYPE(PartialStruct, bool_, uint_, float_, ldbl_);
@@ -425,8 +271,6 @@ test_initializer numpy_dtypes([](py::module &m) {
     PYBIND11_NUMPY_DTYPE(ArrayStruct, a, b, c, d);
     PYBIND11_NUMPY_DTYPE(EnumStruct, e1, e2);
     PYBIND11_NUMPY_DTYPE(ComplexStruct, cflt, cdbl);
-    PYBIND11_NUMPY_DTYPE(TrailingPaddingStruct, a, b);
-    PYBIND11_NUMPY_DTYPE(CompareStruct, x, y, z);
 
     // ... or after
     py::class_<PackedStruct>(m, "PackedStruct");
@@ -438,35 +282,193 @@ test_initializer numpy_dtypes([](py::module &m) {
 //    struct NotPOD { std::string v; NotPOD() : v("hi") {}; };
 //    PYBIND11_NUMPY_DTYPE(NotPOD, v);
 
+    // Check that dtypes can be registered programmatically, both from
+    // initializer lists of field descriptors and from other containers.
+    py::detail::npy_format_descriptor<A>::register_dtype(
+        {}
+    );
+    py::detail::npy_format_descriptor<B>::register_dtype(
+        std::vector<py::detail::field_descriptor>{}
+    );
+
+    // test_recarray, test_scalar_conversion
     m.def("create_rec_simple", &create_recarray<SimpleStruct>);
     m.def("create_rec_packed", &create_recarray<PackedStruct>);
-    m.def("create_rec_nested", &create_nested);
+    m.def("create_rec_nested", [](size_t n) { // test_signature
+        py::array_t<NestedStruct, 0> arr = mkarray_via_buffer<NestedStruct>(n);
+        auto req = arr.request();
+        auto ptr = static_cast<NestedStruct*>(req.ptr);
+        for (size_t i = 0; i < n; i++) {
+            SET_TEST_VALS(ptr[i].a, i);
+            SET_TEST_VALS(ptr[i].b, i + 1);
+        }
+        return arr;
+    });
     m.def("create_rec_partial", &create_recarray<PartialStruct>);
-    m.def("create_rec_partial_nested", &create_partial_nested);
-    m.def("print_format_descriptors", &print_format_descriptors);
+    m.def("create_rec_partial_nested", [](size_t n) {
+        py::array_t<PartialNestedStruct, 0> arr = mkarray_via_buffer<PartialNestedStruct>(n);
+        auto req = arr.request();
+        auto ptr = static_cast<PartialNestedStruct*>(req.ptr);
+        for (size_t i = 0; i < n; i++) {
+            SET_TEST_VALS(ptr[i].a, i);
+        }
+        return arr;
+    });
     m.def("print_rec_simple", &print_recarray<SimpleStruct>);
     m.def("print_rec_packed", &print_recarray<PackedStruct>);
     m.def("print_rec_nested", &print_recarray<NestedStruct>);
-    m.def("print_dtypes", &print_dtypes);
-    m.def("get_format_unbound", &get_format_unbound);
-    m.def("create_string_array", &create_string_array);
+
+    // test_format_descriptors
+    m.def("get_format_unbound", []() { return py::format_descriptor<UnboundStruct>::format(); });
+    m.def("print_format_descriptors", []() {
+        py::list l;
+        for (const auto &fmt : {
+            py::format_descriptor<SimpleStruct>::format(),
+            py::format_descriptor<PackedStruct>::format(),
+            py::format_descriptor<NestedStruct>::format(),
+            py::format_descriptor<PartialStruct>::format(),
+            py::format_descriptor<PartialNestedStruct>::format(),
+            py::format_descriptor<StringStruct>::format(),
+            py::format_descriptor<ArrayStruct>::format(),
+            py::format_descriptor<EnumStruct>::format(),
+            py::format_descriptor<ComplexStruct>::format()
+        }) {
+            l.append(py::cast(fmt));
+        }
+        return l;
+    });
+
+    // test_dtype
+    m.def("print_dtypes", []() {
+        py::list l;
+        for (const py::handle &d : {
+            py::dtype::of<SimpleStruct>(),
+            py::dtype::of<PackedStruct>(),
+            py::dtype::of<NestedStruct>(),
+            py::dtype::of<PartialStruct>(),
+            py::dtype::of<PartialNestedStruct>(),
+            py::dtype::of<StringStruct>(),
+            py::dtype::of<ArrayStruct>(),
+            py::dtype::of<EnumStruct>(),
+            py::dtype::of<StructWithUglyNames>(),
+            py::dtype::of<ComplexStruct>()
+        })
+            l.append(py::str(d));
+        return l;
+    });
+    m.def("test_dtype_ctors", &test_dtype_ctors);
+    m.def("test_dtype_methods", []() {
+        py::list list;
+        auto dt1 = py::dtype::of<int32_t>();
+        auto dt2 = py::dtype::of<SimpleStruct>();
+        list.append(dt1); list.append(dt2);
+        list.append(py::bool_(dt1.has_fields())); list.append(py::bool_(dt2.has_fields()));
+        list.append(py::int_(dt1.itemsize())); list.append(py::int_(dt2.itemsize()));
+        return list;
+    });
+    struct TrailingPaddingStruct {
+        int32_t a;
+        char b;
+    };
+    PYBIND11_NUMPY_DTYPE(TrailingPaddingStruct, a, b);
+    m.def("trailing_padding_dtype", []() { return py::dtype::of<TrailingPaddingStruct>(); });
+
+    // test_string_array
+    m.def("create_string_array", [](bool non_empty) {
+        py::array_t<StringStruct, 0> arr = mkarray_via_buffer<StringStruct>(non_empty ? 4 : 0);
+        if (non_empty) {
+            auto req = arr.request();
+            auto ptr = static_cast<StringStruct*>(req.ptr);
+            for (ssize_t i = 0; i < req.size * req.itemsize; i++)
+                static_cast<char*>(req.ptr)[i] = 0;
+            ptr[1].a[0] = 'a'; ptr[1].b[0] = 'a';
+            ptr[2].a[0] = 'a'; ptr[2].b[0] = 'a';
+            ptr[3].a[0] = 'a'; ptr[3].b[0] = 'a';
+
+            ptr[2].a[1] = 'b'; ptr[2].b[1] = 'b';
+            ptr[3].a[1] = 'b'; ptr[3].b[1] = 'b';
+
+            ptr[3].a[2] = 'c'; ptr[3].b[2] = 'c';
+        }
+        return arr;
+    });
     m.def("print_string_array", &print_recarray<StringStruct>);
-    m.def("create_array_array", &create_array_array);
+
+    // test_array_array
+    m.def("create_array_array", [](size_t n) {
+        py::array_t<ArrayStruct, 0> arr = mkarray_via_buffer<ArrayStruct>(n);
+        auto ptr = (ArrayStruct *) arr.mutable_data();
+        for (size_t i = 0; i < n; i++) {
+            for (size_t j = 0; j < 3; j++)
+                for (size_t k = 0; k < 4; k++)
+                    ptr[i].a[j][k] = char('A' + (i * 100 + j * 10 + k) % 26);
+            for (size_t j = 0; j < 2; j++)
+                ptr[i].b[j] = int32_t(i * 1000 + j);
+            for (size_t j = 0; j < 3; j++)
+                ptr[i].c[j] = uint8_t(i * 10 + j);
+            for (size_t j = 0; j < 4; j++)
+                for (size_t k = 0; k < 2; k++)
+                    ptr[i].d[j][k] = float(i) * 100.0f + float(j) * 10.0f + float(k);
+        }
+        return arr;
+    });
     m.def("print_array_array", &print_recarray<ArrayStruct>);
-    m.def("create_enum_array", &create_enum_array);
+
+    // test_enum_array
+    m.def("create_enum_array", [](size_t n) {
+        py::array_t<EnumStruct, 0> arr = mkarray_via_buffer<EnumStruct>(n);
+        auto ptr = (EnumStruct *) arr.mutable_data();
+        for (size_t i = 0; i < n; i++) {
+            ptr[i].e1 = static_cast<E1>(-1 + ((int) i % 2) * 2);
+            ptr[i].e2 = static_cast<E2>(1 + (i % 2));
+        }
+        return arr;
+    });
     m.def("print_enum_array", &print_recarray<EnumStruct>);
-    m.def("create_complex_array", &create_complex_array);
+
+    // test_complex_array
+    m.def("create_complex_array", [](size_t n) {
+        py::array_t<ComplexStruct, 0> arr = mkarray_via_buffer<ComplexStruct>(n);
+        auto ptr = (ComplexStruct *) arr.mutable_data();
+        for (size_t i = 0; i < n; i++) {
+            ptr[i].cflt.real(float(i));
+            ptr[i].cflt.imag(float(i) + 0.25f);
+            ptr[i].cdbl.real(double(i) + 0.5);
+            ptr[i].cdbl.imag(double(i) + 0.75);
+        }
+        return arr;
+    });
     m.def("print_complex_array", &print_recarray<ComplexStruct>);
+
+    // test_array_constructors
     m.def("test_array_ctors", &test_array_ctors);
-    m.def("test_dtype_ctors", &test_dtype_ctors);
-    m.def("test_dtype_methods", &test_dtype_methods);
-    m.def("compare_buffer_info", &test_compare_buffer_info);
-    m.def("trailing_padding_dtype", &trailing_padding_dtype);
-    m.def("buffer_to_dtype", &buffer_to_dtype);
+
+    // test_compare_buffer_info
+    struct CompareStruct {
+        bool x;
+        uint32_t y;
+        float z;
+    };
+    PYBIND11_NUMPY_DTYPE(CompareStruct, x, y, z);
+    m.def("compare_buffer_info", []() {
+        py::list list;
+        list.append(py::bool_(py::detail::compare_buffer_info<float>::compare(py::buffer_info(nullptr, sizeof(float), "f", 1))));
+        list.append(py::bool_(py::detail::compare_buffer_info<unsigned>::compare(py::buffer_info(nullptr, sizeof(int), "I", 1))));
+        list.append(py::bool_(py::detail::compare_buffer_info<long>::compare(py::buffer_info(nullptr, sizeof(long), "l", 1))));
+        list.append(py::bool_(py::detail::compare_buffer_info<long>::compare(py::buffer_info(nullptr, sizeof(long), sizeof(long) == sizeof(int) ? "i" : "q", 1))));
+        list.append(py::bool_(py::detail::compare_buffer_info<CompareStruct>::compare(py::buffer_info(nullptr, sizeof(CompareStruct), "T{?:x:3xI:y:f:z:}", 1))));
+        return list;
+    });
+    m.def("buffer_to_dtype", [](py::buffer& buf) { return py::dtype(buf.request()); });
+
+    // test_scalar_conversion
     m.def("f_simple", [](SimpleStruct s) { return s.uint_ * 10; });
     m.def("f_packed", [](PackedStruct s) { return s.uint_ * 10; });
     m.def("f_nested", [](NestedStruct s) { return s.a.uint_ * 10; });
+
+    // test_register_dtype
     m.def("register_dtype", []() { PYBIND11_NUMPY_DTYPE(SimpleStruct, bool_, uint_, float_, ldbl_); });
-});
 
-#undef PYBIND11_PACKED
+    // test_str_leak
+    m.def("dtype_wrapper", [](py::object d) { return py::dtype::from_args(std::move(d)); });
+}
diff --git a/src/pybind11/tests/test_numpy_dtypes.py b/src/pybind11/tests/test_numpy_dtypes.py
index 24803a9..2e63885 100644
--- a/src/pybind11/tests/test_numpy_dtypes.py
+++ b/src/pybind11/tests/test_numpy_dtypes.py
@@ -1,5 +1,6 @@
 import re
 import pytest
+from pybind11_tests import numpy_dtypes as m
 
 pytestmark = pytest.requires_numpy
 
@@ -65,10 +66,8 @@ def assert_equal(actual, expected_data, expected_dtype):
 
 
 def test_format_descriptors():
-    from pybind11_tests import get_format_unbound, print_format_descriptors
-
     with pytest.raises(RuntimeError) as excinfo:
-        get_format_unbound()
+        m.get_format_unbound()
     assert re.match('^NumPy type info missing for .*UnboundStruct.*$', str(excinfo.value))
 
     ld = np.dtype('longdouble')
@@ -79,7 +78,7 @@ def test_format_descriptors():
                    str(4 * (dbl.alignment > 4) + dbl.itemsize + 8 * (ld.alignment > 8)) +
                    "xg:ldbl_:}")
     nested_extra = str(max(8, ld.alignment))
-    assert print_format_descriptors() == [
+    assert m.print_format_descriptors() == [
         ss_fmt,
         "^T{?:bool_:I:uint_:f:float_:g:ldbl_:}",
         "^T{" + ss_fmt + ":a:^T{?:bool_:I:uint_:f:float_:g:ldbl_:}:b:}",
@@ -93,12 +92,10 @@ def test_format_descriptors():
 
 
 def test_dtype(simple_dtype):
-    from pybind11_tests import (print_dtypes, test_dtype_ctors, test_dtype_methods,
-                                trailing_padding_dtype, buffer_to_dtype)
     from sys import byteorder
     e = '<' if byteorder == 'little' else '>'
 
-    assert print_dtypes() == [
+    assert m.print_dtypes() == [
         simple_dtype_fmt(),
         packed_dtype_fmt(),
         "[('a', {}), ('b', {})]".format(simple_dtype_fmt(), packed_dtype_fmt()),
@@ -106,7 +103,7 @@ def test_dtype(simple_dtype):
         partial_nested_fmt(),
         "[('a', 'S3'), ('b', 'S3')]",
         ("{{'names':['a','b','c','d'], " +
-         "'formats':[('S4', (3,)),('<i4', (2,)),('u1', (3,)),('<f4', (4, 2))], " +
+         "'formats':[('S4', (3,)),('" + e + "i4', (2,)),('u1', (3,)),('" + e + "f4', (4, 2))], " +
          "'offsets':[0,12,20,24], 'itemsize':56}}").format(e=e),
         "[('e1', '" + e + "i8'), ('e2', 'u1')]",
         "[('x', 'i1'), ('y', '" + e + "u8')]",
@@ -116,23 +113,19 @@ def test_dtype(simple_dtype):
     d1 = np.dtype({'names': ['a', 'b'], 'formats': ['int32', 'float64'],
                    'offsets': [1, 10], 'itemsize': 20})
     d2 = np.dtype([('a', 'i4'), ('b', 'f4')])
-    assert test_dtype_ctors() == [np.dtype('int32'), np.dtype('float64'),
-                                  np.dtype('bool'), d1, d1, np.dtype('uint32'), d2]
+    assert m.test_dtype_ctors() == [np.dtype('int32'), np.dtype('float64'),
+                                    np.dtype('bool'), d1, d1, np.dtype('uint32'), d2]
 
-    assert test_dtype_methods() == [np.dtype('int32'), simple_dtype, False, True,
-                                    np.dtype('int32').itemsize, simple_dtype.itemsize]
+    assert m.test_dtype_methods() == [np.dtype('int32'), simple_dtype, False, True,
+                                      np.dtype('int32').itemsize, simple_dtype.itemsize]
 
-    assert trailing_padding_dtype() == buffer_to_dtype(np.zeros(1, trailing_padding_dtype()))
+    assert m.trailing_padding_dtype() == m.buffer_to_dtype(np.zeros(1, m.trailing_padding_dtype()))
 
 
 def test_recarray(simple_dtype, packed_dtype):
-    from pybind11_tests import (create_rec_simple, create_rec_packed, create_rec_nested,
-                                print_rec_simple, print_rec_packed, print_rec_nested,
-                                create_rec_partial, create_rec_partial_nested)
-
     elements = [(False, 0, 0.0, -0.0), (True, 1, 1.5, -2.5), (False, 2, 3.0, -5.0)]
 
-    for func, dtype in [(create_rec_simple, simple_dtype), (create_rec_packed, packed_dtype)]:
+    for func, dtype in [(m.create_rec_simple, simple_dtype), (m.create_rec_packed, packed_dtype)]:
         arr = func(0)
         assert arr.dtype == dtype
         assert_equal(arr, [], simple_dtype)
@@ -144,13 +137,13 @@ def test_recarray(simple_dtype, packed_dtype):
         assert_equal(arr, elements, packed_dtype)
 
         if dtype == simple_dtype:
-            assert print_rec_simple(arr) == [
+            assert m.print_rec_simple(arr) == [
                 "s:0,0,0,-0",
                 "s:1,1,1.5,-2.5",
                 "s:0,2,3,-5"
             ]
         else:
-            assert print_rec_packed(arr) == [
+            assert m.print_rec_packed(arr) == [
                 "p:0,0,0,-0",
                 "p:1,1,1.5,-2.5",
                 "p:0,2,3,-5"
@@ -158,22 +151,22 @@ def test_recarray(simple_dtype, packed_dtype):
 
     nested_dtype = np.dtype([('a', simple_dtype), ('b', packed_dtype)])
 
-    arr = create_rec_nested(0)
+    arr = m.create_rec_nested(0)
     assert arr.dtype == nested_dtype
     assert_equal(arr, [], nested_dtype)
 
-    arr = create_rec_nested(3)
+    arr = m.create_rec_nested(3)
     assert arr.dtype == nested_dtype
     assert_equal(arr, [((False, 0, 0.0, -0.0), (True, 1, 1.5, -2.5)),
                        ((True, 1, 1.5, -2.5), (False, 2, 3.0, -5.0)),
                        ((False, 2, 3.0, -5.0), (True, 3, 4.5, -7.5))], nested_dtype)
-    assert print_rec_nested(arr) == [
+    assert m.print_rec_nested(arr) == [
         "n:a=s:0,0,0,-0;b=p:1,1,1.5,-2.5",
         "n:a=s:1,1,1.5,-2.5;b=p:0,2,3,-5",
         "n:a=s:0,2,3,-5;b=p:1,3,4.5,-7.5"
     ]
 
-    arr = create_rec_partial(3)
+    arr = m.create_rec_partial(3)
     assert str(arr.dtype) == partial_dtype_fmt()
     partial_dtype = arr.dtype
     assert '' not in arr.dtype.fields
@@ -181,32 +174,28 @@ def test_recarray(simple_dtype, packed_dtype):
     assert_equal(arr, elements, simple_dtype)
     assert_equal(arr, elements, packed_dtype)
 
-    arr = create_rec_partial_nested(3)
+    arr = m.create_rec_partial_nested(3)
     assert str(arr.dtype) == partial_nested_fmt()
     assert '' not in arr.dtype.fields
     assert '' not in arr.dtype.fields['a'][0].fields
     assert arr.dtype.itemsize > partial_dtype.itemsize
-    np.testing.assert_equal(arr['a'], create_rec_partial(3))
+    np.testing.assert_equal(arr['a'], m.create_rec_partial(3))
 
 
 def test_array_constructors():
-    from pybind11_tests import test_array_ctors
-
     data = np.arange(1, 7, dtype='int32')
     for i in range(8):
-        np.testing.assert_array_equal(test_array_ctors(10 + i), data.reshape((3, 2)))
-        np.testing.assert_array_equal(test_array_ctors(20 + i), data.reshape((3, 2)))
+        np.testing.assert_array_equal(m.test_array_ctors(10 + i), data.reshape((3, 2)))
+        np.testing.assert_array_equal(m.test_array_ctors(20 + i), data.reshape((3, 2)))
     for i in range(5):
-        np.testing.assert_array_equal(test_array_ctors(30 + i), data)
-        np.testing.assert_array_equal(test_array_ctors(40 + i), data)
+        np.testing.assert_array_equal(m.test_array_ctors(30 + i), data)
+        np.testing.assert_array_equal(m.test_array_ctors(40 + i), data)
 
 
 def test_string_array():
-    from pybind11_tests import create_string_array, print_string_array
-
-    arr = create_string_array(True)
+    arr = m.create_string_array(True)
     assert str(arr.dtype) == "[('a', 'S3'), ('b', 'S3')]"
-    assert print_string_array(arr) == [
+    assert m.print_string_array(arr) == [
         "a='',b=''",
         "a='a',b='a'",
         "a='ab',b='ab'",
@@ -215,21 +204,20 @@ def test_string_array():
     dtype = arr.dtype
     assert arr['a'].tolist() == [b'', b'a', b'ab', b'abc']
     assert arr['b'].tolist() == [b'', b'a', b'ab', b'abc']
-    arr = create_string_array(False)
+    arr = m.create_string_array(False)
     assert dtype == arr.dtype
 
 
 def test_array_array():
-    from pybind11_tests import create_array_array, print_array_array
     from sys import byteorder
     e = '<' if byteorder == 'little' else '>'
 
-    arr = create_array_array(3)
+    arr = m.create_array_array(3)
     assert str(arr.dtype) == (
         "{{'names':['a','b','c','d'], " +
-        "'formats':[('S4', (3,)),('<i4', (2,)),('u1', (3,)),('{e}f4', (4, 2))], " +
+        "'formats':[('S4', (3,)),('" + e + "i4', (2,)),('u1', (3,)),('{e}f4', (4, 2))], " +
         "'offsets':[0,12,20,24], 'itemsize':56}}").format(e=e)
-    assert print_array_array(arr) == [
+    assert m.print_array_array(arr) == [
         "a={{A,B,C,D},{K,L,M,N},{U,V,W,X}},b={0,1}," +
         "c={0,1,2},d={{0,1},{10,11},{20,21},{30,31}}",
         "a={{W,X,Y,Z},{G,H,I,J},{Q,R,S,T}},b={1000,1001}," +
@@ -241,61 +229,53 @@ def test_array_array():
                                  [b'WXYZ', b'GHIJ', b'QRST'],
                                  [b'STUV', b'CDEF', b'MNOP']]
     assert arr['b'].tolist() == [[0, 1], [1000, 1001], [2000, 2001]]
-    assert create_array_array(0).dtype == arr.dtype
+    assert m.create_array_array(0).dtype == arr.dtype
 
 
 def test_enum_array():
-    from pybind11_tests import create_enum_array, print_enum_array
     from sys import byteorder
     e = '<' if byteorder == 'little' else '>'
 
-    arr = create_enum_array(3)
+    arr = m.create_enum_array(3)
     dtype = arr.dtype
     assert dtype == np.dtype([('e1', e + 'i8'), ('e2', 'u1')])
-    assert print_enum_array(arr) == [
+    assert m.print_enum_array(arr) == [
         "e1=A,e2=X",
         "e1=B,e2=Y",
         "e1=A,e2=X"
     ]
     assert arr['e1'].tolist() == [-1, 1, -1]
     assert arr['e2'].tolist() == [1, 2, 1]
-    assert create_enum_array(0).dtype == dtype
+    assert m.create_enum_array(0).dtype == dtype
 
 
 def test_complex_array():
-    from pybind11_tests import create_complex_array, print_complex_array
     from sys import byteorder
     e = '<' if byteorder == 'little' else '>'
 
-    arr = create_complex_array(3)
+    arr = m.create_complex_array(3)
     dtype = arr.dtype
     assert dtype == np.dtype([('cflt', e + 'c8'), ('cdbl', e + 'c16')])
-    assert print_complex_array(arr) == [
+    assert m.print_complex_array(arr) == [
         "c:(0,0.25),(0.5,0.75)",
         "c:(1,1.25),(1.5,1.75)",
         "c:(2,2.25),(2.5,2.75)"
     ]
     assert arr['cflt'].tolist() == [0.0 + 0.25j, 1.0 + 1.25j, 2.0 + 2.25j]
     assert arr['cdbl'].tolist() == [0.5 + 0.75j, 1.5 + 1.75j, 2.5 + 2.75j]
-    assert create_complex_array(0).dtype == dtype
+    assert m.create_complex_array(0).dtype == dtype
 
 
 def test_signature(doc):
-    from pybind11_tests import create_rec_nested
-
-    assert doc(create_rec_nested) == "create_rec_nested(arg0: int) -> numpy.ndarray[NestedStruct]"
+    assert doc(m.create_rec_nested) == \
+        "create_rec_nested(arg0: int) -> numpy.ndarray[NestedStruct]"
 
 
 def test_scalar_conversion():
-    from pybind11_tests import (create_rec_simple, f_simple,
-                                create_rec_packed, f_packed,
-                                create_rec_nested, f_nested,
-                                create_enum_array)
-
     n = 3
-    arrays = [create_rec_simple(n), create_rec_packed(n),
-              create_rec_nested(n), create_enum_array(n)]
-    funcs = [f_simple, f_packed, f_nested]
+    arrays = [m.create_rec_simple(n), m.create_rec_packed(n),
+              m.create_rec_nested(n), m.create_enum_array(n)]
+    funcs = [m.f_simple, m.f_packed, m.f_nested]
 
     for i, func in enumerate(funcs):
         for j, arr in enumerate(arrays):
@@ -308,14 +288,23 @@ def test_scalar_conversion():
 
 
 def test_register_dtype():
-    from pybind11_tests import register_dtype
-
     with pytest.raises(RuntimeError) as excinfo:
-        register_dtype()
+        m.register_dtype()
     assert 'dtype is already registered' in str(excinfo.value)
 
 
-@pytest.requires_numpy
+@pytest.unsupported_on_pypy
+def test_str_leak():
+    from sys import getrefcount
+    fmt = "f4"
+    pytest.gc_collect()
+    start = getrefcount(fmt)
+    d = m.dtype_wrapper(fmt)
+    assert d is np.dtype("f4")
+    del d
+    pytest.gc_collect()
+    assert getrefcount(fmt) == start
+
+
 def test_compare_buffer_info():
-    from pybind11_tests import compare_buffer_info
-    assert all(compare_buffer_info())
+    assert all(m.compare_buffer_info())
diff --git a/src/pybind11/tests/test_numpy_vectorize.cpp b/src/pybind11/tests/test_numpy_vectorize.cpp
index b1f8208..a875a74 100644
--- a/src/pybind11/tests/test_numpy_vectorize.cpp
+++ b/src/pybind11/tests/test_numpy_vectorize.cpp
@@ -16,22 +16,11 @@ double my_func(int x, float y, double z) {
     return (float) x*y*z;
 }
 
-std::complex<double> my_func3(std::complex<double> c) {
-    return c * std::complex<double>(2.f);
-}
-
-struct VectorizeTestClass {
-    VectorizeTestClass(int v) : value{v} {};
-    float method(int x, float y) { return y + (float) (x + value); }
-    int value = 0;
-};
-
-struct NonPODClass {
-    NonPODClass(int v) : value{v} {}
-    int value;
-};
+TEST_SUBMODULE(numpy_vectorize, m) {
+    try { py::module::import("numpy"); }
+    catch (...) { return; }
 
-test_initializer numpy_vectorize([](py::module &m) {
+    // test_vectorize, test_docs, test_array_collapse
     // Vectorize all arguments of a function (though non-vector arguments are also allowed)
     m.def("vectorized_func", py::vectorize(my_func));
 
@@ -43,16 +32,24 @@ test_initializer numpy_vectorize([](py::module &m) {
     );
 
     // Vectorize a complex-valued function
-    m.def("vectorized_func3", py::vectorize(my_func3));
+    m.def("vectorized_func3", py::vectorize(
+        [](std::complex<double> c) { return c * std::complex<double>(2.f); }
+    ));
 
-    /// Numpy function which only accepts specific data types
+    // test_type_selection
+    // Numpy function which only accepts specific data types
     m.def("selective_func", [](py::array_t<int, py::array::c_style>) { return "Int branch taken."; });
     m.def("selective_func", [](py::array_t<float, py::array::c_style>) { return "Float branch taken."; });
     m.def("selective_func", [](py::array_t<std::complex<float>, py::array::c_style>) { return "Complex float branch taken."; });
 
 
+    // test_passthrough_arguments
     // Passthrough test: references and non-pod types should be automatically passed through (in the
     // function definition below, only `b`, `d`, and `g` are vectorized):
+    struct NonPODClass {
+        NonPODClass(int v) : value{v} {}
+        int value;
+    };
     py::class_<NonPODClass>(m, "NonPODClass").def(py::init<int>());
     m.def("vec_passthrough", py::vectorize(
         [](double *a, double b, py::array_t<double> c, const int &d, int &e, NonPODClass f, const double g) {
@@ -60,6 +57,12 @@ test_initializer numpy_vectorize([](py::module &m) {
         }
     ));
 
+    // test_method_vectorization
+    struct VectorizeTestClass {
+        VectorizeTestClass(int v) : value{v} {};
+        float method(int x, float y) { return y + (float) (x + value); }
+        int value = 0;
+    };
     py::class_<VectorizeTestClass> vtc(m, "VectorizeTestClass");
     vtc .def(py::init<int>())
         .def_readwrite("value", &VectorizeTestClass::value);
@@ -67,6 +70,7 @@ test_initializer numpy_vectorize([](py::module &m) {
     // Automatic vectorizing of methods
     vtc.def("method", py::vectorize(&VectorizeTestClass::method));
 
+    // test_trivial_broadcasting
     // Internal optimization test for whether the input is trivially broadcastable:
     py::enum_<py::detail::broadcast_trivial>(m, "trivial")
         .value("f_trivial", py::detail::broadcast_trivial::f_trivial)
@@ -82,4 +86,4 @@ test_initializer numpy_vectorize([](py::module &m) {
         std::array<py::buffer_info, 3> buffers {{ arg1.request(), arg2.request(), arg3.request() }};
         return py::detail::broadcast(buffers, ndim, shape);
     });
-});
+}
diff --git a/src/pybind11/tests/test_numpy_vectorize.py b/src/pybind11/tests/test_numpy_vectorize.py
index 362b036..0e9c883 100644
--- a/src/pybind11/tests/test_numpy_vectorize.py
+++ b/src/pybind11/tests/test_numpy_vectorize.py
@@ -1,4 +1,5 @@
 import pytest
+from pybind11_tests import numpy_vectorize as m
 
 pytestmark = pytest.requires_numpy
 
@@ -7,11 +8,9 @@ with pytest.suppress(ImportError):
 
 
 def test_vectorize(capture):
-    from pybind11_tests import vectorized_func, vectorized_func2, vectorized_func3
+    assert np.isclose(m.vectorized_func3(np.array(3 + 7j)), [6 + 14j])
 
-    assert np.isclose(vectorized_func3(np.array(3 + 7j)), [6 + 14j])
-
-    for f in [vectorized_func, vectorized_func2]:
+    for f in [m.vectorized_func, m.vectorized_func2]:
         with capture:
             assert np.isclose(f(1, 2, 3), 6)
         assert capture == "my_func(x:int=1, y:float=2, z:float=3)"
@@ -103,23 +102,19 @@ def test_vectorize(capture):
 
 
 def test_type_selection():
-    from pybind11_tests import selective_func
-
-    assert selective_func(np.array([1], dtype=np.int32)) == "Int branch taken."
-    assert selective_func(np.array([1.0], dtype=np.float32)) == "Float branch taken."
-    assert selective_func(np.array([1.0j], dtype=np.complex64)) == "Complex float branch taken."
+    assert m.selective_func(np.array([1], dtype=np.int32)) == "Int branch taken."
+    assert m.selective_func(np.array([1.0], dtype=np.float32)) == "Float branch taken."
+    assert m.selective_func(np.array([1.0j], dtype=np.complex64)) == "Complex float branch taken."
 
 
 def test_docs(doc):
-    from pybind11_tests import vectorized_func
-
-    assert doc(vectorized_func) == """
+    assert doc(m.vectorized_func) == """
         vectorized_func(arg0: numpy.ndarray[int32], arg1: numpy.ndarray[float32], arg2: numpy.ndarray[float64]) -> object
     """  # noqa: E501 line too long
 
 
 def test_trivial_broadcasting():
-    from pybind11_tests import vectorized_is_trivial, trivial, vectorized_func
+    trivial, vectorized_is_trivial = m.trivial, m.vectorized_is_trivial
 
     assert vectorized_is_trivial(1, 2, 3) == trivial.c_trivial
     assert vectorized_is_trivial(np.array(1), np.array(2), 3) == trivial.c_trivial
@@ -153,51 +148,49 @@ def test_trivial_broadcasting():
     assert vectorized_is_trivial(z1[1::4, 1::4], y2, 1) == trivial.f_trivial
     assert vectorized_is_trivial(y1[1::4, 1::4], z2, 1) == trivial.c_trivial
 
-    assert vectorized_func(z1, z2, z3).flags.c_contiguous
-    assert vectorized_func(y1, y2, y3).flags.f_contiguous
-    assert vectorized_func(z1, 1, 1).flags.c_contiguous
-    assert vectorized_func(1, y2, 1).flags.f_contiguous
-    assert vectorized_func(z1[1::4, 1::4], y2, 1).flags.f_contiguous
-    assert vectorized_func(y1[1::4, 1::4], z2, 1).flags.c_contiguous
+    assert m.vectorized_func(z1, z2, z3).flags.c_contiguous
+    assert m.vectorized_func(y1, y2, y3).flags.f_contiguous
+    assert m.vectorized_func(z1, 1, 1).flags.c_contiguous
+    assert m.vectorized_func(1, y2, 1).flags.f_contiguous
+    assert m.vectorized_func(z1[1::4, 1::4], y2, 1).flags.f_contiguous
+    assert m.vectorized_func(y1[1::4, 1::4], z2, 1).flags.c_contiguous
 
 
 def test_passthrough_arguments(doc):
-    from pybind11_tests import vec_passthrough, NonPODClass
-
-    assert doc(vec_passthrough) == (
-        "vec_passthrough("
-        "arg0: float, arg1: numpy.ndarray[float64], arg2: numpy.ndarray[float64], "
-        "arg3: numpy.ndarray[int32], arg4: int, arg5: m.NonPODClass, arg6: numpy.ndarray[float64]"
-        ") -> object")
+    assert doc(m.vec_passthrough) == (
+        "vec_passthrough(" + ", ".join([
+            "arg0: float",
+            "arg1: numpy.ndarray[float64]",
+            "arg2: numpy.ndarray[float64]",
+            "arg3: numpy.ndarray[int32]",
+            "arg4: int",
+            "arg5: m.numpy_vectorize.NonPODClass",
+            "arg6: numpy.ndarray[float64]"]) + ") -> object")
 
     b = np.array([[10, 20, 30]], dtype='float64')
     c = np.array([100, 200])  # NOT a vectorized argument
     d = np.array([[1000], [2000], [3000]], dtype='int')
     g = np.array([[1000000, 2000000, 3000000]], dtype='int')  # requires casting
     assert np.all(
-        vec_passthrough(1, b, c, d, 10000, NonPODClass(100000), g) ==
+        m.vec_passthrough(1, b, c, d, 10000, m.NonPODClass(100000), g) ==
         np.array([[1111111, 2111121, 3111131],
                   [1112111, 2112121, 3112131],
                   [1113111, 2113121, 3113131]]))
 
 
 def test_method_vectorization():
-    from pybind11_tests import VectorizeTestClass
-
-    o = VectorizeTestClass(3)
+    o = m.VectorizeTestClass(3)
     x = np.array([1, 2], dtype='int')
     y = np.array([[10], [20]], dtype='float32')
     assert np.all(o.method(x, y) == [[14, 15], [24, 25]])
 
 
 def test_array_collapse():
-    from pybind11_tests import vectorized_func
-
-    assert not isinstance(vectorized_func(1, 2, 3), np.ndarray)
-    assert not isinstance(vectorized_func(np.array(1), 2, 3), np.ndarray)
-    z = vectorized_func([1], 2, 3)
+    assert not isinstance(m.vectorized_func(1, 2, 3), np.ndarray)
+    assert not isinstance(m.vectorized_func(np.array(1), 2, 3), np.ndarray)
+    z = m.vectorized_func([1], 2, 3)
     assert isinstance(z, np.ndarray)
     assert z.shape == (1, )
-    z = vectorized_func(1, [[[2]]], 3)
+    z = m.vectorized_func(1, [[[2]]], 3)
     assert isinstance(z, np.ndarray)
     assert z.shape == (1, 1, 1)
diff --git a/src/pybind11/tests/test_opaque_types.cpp b/src/pybind11/tests/test_opaque_types.cpp
index 54f4dc7..0d20d9a 100644
--- a/src/pybind11/tests/test_opaque_types.cpp
+++ b/src/pybind11/tests/test_opaque_types.cpp
@@ -11,17 +11,17 @@
 #include <pybind11/stl.h>
 #include <vector>
 
-typedef std::vector<std::string> StringList;
+// IMPORTANT: Disable internal pybind11 translation mechanisms for STL data structures
+//
+// This also deliberately doesn't use the below StringList type alias to test
+// that MAKE_OPAQUE can handle a type containing a `,`.  (The `std::allocator`
+// bit is just the default `std::vector` allocator).
+PYBIND11_MAKE_OPAQUE(std::vector<std::string, std::allocator<std::string>>);
 
-class ClassWithSTLVecProperty {
-public:
-    StringList stringList;
-};
+using StringList = std::vector<std::string, std::allocator<std::string>>;
 
-/* IMPORTANT: Disable internal pybind11 translation mechanisms for STL data structures */
-PYBIND11_MAKE_OPAQUE(StringList);
-
-test_initializer opaque_types([](py::module &m) {
+TEST_SUBMODULE(opaque_types, m) {
+    // test_string_list
     py::class_<StringList>(m, "StringList")
         .def(py::init<>())
         .def("pop_back", &StringList::pop_back)
@@ -33,6 +33,10 @@ test_initializer opaque_types([](py::module &m) {
            return py::make_iterator(v.begin(), v.end());
         }, py::keep_alive<0, 1>());
 
+    class ClassWithSTLVecProperty {
+    public:
+        StringList stringList;
+    };
     py::class_<ClassWithSTLVecProperty>(m, "ClassWithSTLVecProperty")
         .def(py::init<>())
         .def_readwrite("stringList", &ClassWithSTLVecProperty::stringList);
@@ -49,6 +53,7 @@ test_initializer opaque_types([](py::module &m) {
         return ret + "]";
     });
 
+    // test_pointers
     m.def("return_void_ptr", []() { return (void *) 0x1234; });
     m.def("get_void_ptr_value", [](void *ptr) { return reinterpret_cast<std::intptr_t>(ptr); });
     m.def("return_null_str", []() { return (char *) nullptr; });
@@ -59,4 +64,4 @@ test_initializer opaque_types([](py::module &m) {
         result->push_back("some value");
         return std::unique_ptr<StringList>(result);
     });
-});
+}
diff --git a/src/pybind11/tests/test_opaque_types.py b/src/pybind11/tests/test_opaque_types.py
index 1cd4102..6b3802f 100644
--- a/src/pybind11/tests/test_opaque_types.py
+++ b/src/pybind11/tests/test_opaque_types.py
@@ -1,40 +1,36 @@
 import pytest
+from pybind11_tests import opaque_types as m
+from pybind11_tests import ConstructorStats, UserType
 
 
 def test_string_list():
-    from pybind11_tests import StringList, ClassWithSTLVecProperty, print_opaque_list
+    lst = m.StringList()
+    lst.push_back("Element 1")
+    lst.push_back("Element 2")
+    assert m.print_opaque_list(lst) == "Opaque list: [Element 1, Element 2]"
+    assert lst.back() == "Element 2"
 
-    l = StringList()
-    l.push_back("Element 1")
-    l.push_back("Element 2")
-    assert print_opaque_list(l) == "Opaque list: [Element 1, Element 2]"
-    assert l.back() == "Element 2"
-
-    for i, k in enumerate(l, start=1):
+    for i, k in enumerate(lst, start=1):
         assert k == "Element {}".format(i)
-    l.pop_back()
-    assert print_opaque_list(l) == "Opaque list: [Element 1]"
+    lst.pop_back()
+    assert m.print_opaque_list(lst) == "Opaque list: [Element 1]"
 
-    cvp = ClassWithSTLVecProperty()
-    assert print_opaque_list(cvp.stringList) == "Opaque list: []"
+    cvp = m.ClassWithSTLVecProperty()
+    assert m.print_opaque_list(cvp.stringList) == "Opaque list: []"
 
-    cvp.stringList = l
+    cvp.stringList = lst
     cvp.stringList.push_back("Element 3")
-    assert print_opaque_list(cvp.stringList) == "Opaque list: [Element 1, Element 3]"
+    assert m.print_opaque_list(cvp.stringList) == "Opaque list: [Element 1, Element 3]"
 
 
 def test_pointers(msg):
-    from pybind11_tests import (return_void_ptr, get_void_ptr_value, ExampleMandA,
-                                print_opaque_list, return_null_str, get_null_str_value,
-                                return_unique_ptr, ConstructorStats)
-
-    living_before = ConstructorStats.get(ExampleMandA).alive()
-    assert get_void_ptr_value(return_void_ptr()) == 0x1234
-    assert get_void_ptr_value(ExampleMandA())  # Should also work for other C++ types
-    assert ConstructorStats.get(ExampleMandA).alive() == living_before
+    living_before = ConstructorStats.get(UserType).alive()
+    assert m.get_void_ptr_value(m.return_void_ptr()) == 0x1234
+    assert m.get_void_ptr_value(UserType())  # Should also work for other C++ types
+    assert ConstructorStats.get(UserType).alive() == living_before
 
     with pytest.raises(TypeError) as excinfo:
-        get_void_ptr_value([1, 2, 3])  # This should not work
+        m.get_void_ptr_value([1, 2, 3])  # This should not work
     assert msg(excinfo.value) == """
         get_void_ptr_value(): incompatible function arguments. The following argument types are supported:
             1. (arg0: capsule) -> int
@@ -42,9 +38,9 @@ def test_pointers(msg):
         Invoked with: [1, 2, 3]
     """  # noqa: E501 line too long
 
-    assert return_null_str() is None
-    assert get_null_str_value(return_null_str()) is not None
+    assert m.return_null_str() is None
+    assert m.get_null_str_value(m.return_null_str()) is not None
 
-    ptr = return_unique_ptr()
+    ptr = m.return_unique_ptr()
     assert "StringList" in repr(ptr)
-    assert print_opaque_list(ptr) == "Opaque list: [some value]"
+    assert m.print_opaque_list(ptr) == "Opaque list: [some value]"
diff --git a/src/pybind11/tests/test_operator_overloading.cpp b/src/pybind11/tests/test_operator_overloading.cpp
index cb22b12..7b11170 100644
--- a/src/pybind11/tests/test_operator_overloading.cpp
+++ b/src/pybind11/tests/test_operator_overloading.cpp
@@ -10,29 +10,20 @@
 #include "pybind11_tests.h"
 #include "constructor_stats.h"
 #include <pybind11/operators.h>
+#include <functional>
 
 class Vector2 {
 public:
     Vector2(float x, float y) : x(x), y(y) { print_created(this, toString()); }
     Vector2(const Vector2 &v) : x(v.x), y(v.y) { print_copy_created(this); }
     Vector2(Vector2 &&v) : x(v.x), y(v.y) { print_move_created(this); v.x = v.y = 0; }
+    Vector2 &operator=(const Vector2 &v) { x = v.x; y = v.y; print_copy_assigned(this); return *this; }
+    Vector2 &operator=(Vector2 &&v) { x = v.x; y = v.y; v.x = v.y = 0; print_move_assigned(this); return *this; }
     ~Vector2() { print_destroyed(this); }
 
-    std::string toString() const {
-        return "[" + std::to_string(x) + ", " + std::to_string(y) + "]";
-    }
-
-    void operator=(const Vector2 &v) {
-        print_copy_assigned(this);
-        x = v.x;
-        y = v.y;
-    }
-
-    void operator=(Vector2 &&v) {
-        print_move_assigned(this);
-        x = v.x; y = v.y; v.x = v.y = 0;
-    }
+    std::string toString() const { return "[" + std::to_string(x) + ", " + std::to_string(y) + "]"; }
 
+    Vector2 operator-() const { return Vector2(-x, -y); }
     Vector2 operator+(const Vector2 &v) const { return Vector2(x + v.x, y + v.y); }
     Vector2 operator-(const Vector2 &v) const { return Vector2(x - v.x, y - v.y); }
     Vector2 operator-(float value) const { return Vector2(x - value, y - value); }
@@ -64,30 +55,36 @@ int operator+(const C2 &, const C2 &) { return 22; }
 int operator+(const C2 &, const C1 &) { return 21; }
 int operator+(const C1 &, const C2 &) { return 12; }
 
-struct NestABase {
-    int value = -2;
-};
-
-struct NestA : NestABase {
-    int value = 3;
-    NestA& operator+=(int i) { value += i; return *this; }
-};
-
-struct NestB {
-    NestA a;
-    int value = 4;
-    NestB& operator-=(int i) { value -= i; return *this; }
-};
-
-struct NestC {
-    NestB b;
-    int value = 5;
-    NestC& operator*=(int i) { value *= i; return *this; }
-};
-
-test_initializer operator_overloading([](py::module &pm) {
-    auto m = pm.def_submodule("operators");
-
+namespace std {
+    template<>
+    struct hash<Vector2> {
+        // Not a good hash function, but easy to test
+        size_t operator()(const Vector2 &) { return 4; }
+    };
+}
+
+// MSVC warns about unknown pragmas, and warnings are errors.
+#ifndef _MSC_VER
+  #pragma GCC diagnostic push
+  // clang 7.0.0 and Apple LLVM 10.0.1 introduce `-Wself-assign-overloaded` to
+  // `-Wall`, which is used here for overloading (e.g. `py::self += py::self `).
+  // Here, we suppress the warning using `#pragma diagnostic`.
+  // Taken from: https://github.com/RobotLocomotion/drake/commit/aaf84b46
+  // TODO(eric): This could be resolved using a function / functor (e.g. `py::self()`).
+  #if (__APPLE__) && (__clang__)
+    #if (__clang_major__ >= 10) && (__clang_minor__ >= 0) && (__clang_patchlevel__ >= 1)
+      #pragma GCC diagnostic ignored "-Wself-assign-overloaded"
+    #endif
+  #elif (__clang__)
+    #if (__clang_major__ >= 7)
+      #pragma GCC diagnostic ignored "-Wself-assign-overloaded"
+    #endif
+  #endif
+#endif
+
+TEST_SUBMODULE(operators, m) {
+
+    // test_operator_overloading
     py::class_<Vector2>(m, "Vector2")
         .def(py::init<float, float>())
         .def(py::self + py::self)
@@ -108,11 +105,14 @@ test_initializer operator_overloading([](py::module &pm) {
         .def(float() - py::self)
         .def(float() * py::self)
         .def(float() / py::self)
+        .def(-py::self)
         .def("__str__", &Vector2::toString)
+        .def(hash(py::self))
         ;
 
     m.attr("Vector") = m.attr("Vector2");
 
+    // test_operators_notimplemented
     // #393: need to return NotSupported to ensure correct arithmetic operator behavior
     py::class_<C1>(m, "C1")
         .def(py::init<>())
@@ -124,29 +124,48 @@ test_initializer operator_overloading([](py::module &pm) {
         .def("__add__", [](const C2& c2, const C1& c1) { return c2 + c1; })
         .def("__radd__", [](const C2& c2, const C1& c1) { return c1 + c2; });
 
+    // test_nested
     // #328: first member in a class can't be used in operators
+    struct NestABase { int value = -2; };
     py::class_<NestABase>(m, "NestABase")
         .def(py::init<>())
         .def_readwrite("value", &NestABase::value);
 
+    struct NestA : NestABase {
+        int value = 3;
+        NestA& operator+=(int i) { value += i; return *this; }
+    };
     py::class_<NestA>(m, "NestA")
         .def(py::init<>())
         .def(py::self += int())
         .def("as_base", [](NestA &a) -> NestABase& {
             return (NestABase&) a;
         }, py::return_value_policy::reference_internal);
+    m.def("get_NestA", [](const NestA &a) { return a.value; });
 
+    struct NestB {
+        NestA a;
+        int value = 4;
+        NestB& operator-=(int i) { value -= i; return *this; }
+    };
     py::class_<NestB>(m, "NestB")
         .def(py::init<>())
         .def(py::self -= int())
         .def_readwrite("a", &NestB::a);
+    m.def("get_NestB", [](const NestB &b) { return b.value; });
 
+    struct NestC {
+        NestB b;
+        int value = 5;
+        NestC& operator*=(int i) { value *= i; return *this; }
+    };
     py::class_<NestC>(m, "NestC")
         .def(py::init<>())
         .def(py::self *= int())
         .def_readwrite("b", &NestC::b);
-
-    m.def("get_NestA", [](const NestA &a) { return a.value; });
-    m.def("get_NestB", [](const NestB &b) { return b.value; });
     m.def("get_NestC", [](const NestC &c) { return c.value; });
-});
+}
+
+#ifndef _MSC_VER
+  #pragma GCC diagnostic pop
+#endif
diff --git a/src/pybind11/tests/test_operator_overloading.py b/src/pybind11/tests/test_operator_overloading.py
index 63dd546..bd36ac2 100644
--- a/src/pybind11/tests/test_operator_overloading.py
+++ b/src/pybind11/tests/test_operator_overloading.py
@@ -1,15 +1,16 @@
 import pytest
+from pybind11_tests import operators as m
 from pybind11_tests import ConstructorStats
 
 
 def test_operator_overloading():
-    from pybind11_tests.operators import Vector2, Vector
-
-    v1 = Vector2(1, 2)
-    v2 = Vector(3, -1)
+    v1 = m.Vector2(1, 2)
+    v2 = m.Vector(3, -1)
     assert str(v1) == "[1.000000, 2.000000]"
     assert str(v2) == "[3.000000, -1.000000]"
 
+    assert str(-v2) == "[-3.000000, 1.000000]"
+
     assert str(v1 + v2) == "[4.000000, 1.000000]"
     assert str(v1 - v2) == "[-2.000000, 3.000000]"
     assert str(v1 - 8) == "[-7.000000, -6.000000]"
@@ -36,20 +37,22 @@ def test_operator_overloading():
     v2 /= v1
     assert str(v2) == "[2.000000, 8.000000]"
 
-    cstats = ConstructorStats.get(Vector2)
+    assert hash(v1) == 4
+
+    cstats = ConstructorStats.get(m.Vector2)
     assert cstats.alive() == 2
     del v1
     assert cstats.alive() == 1
     del v2
     assert cstats.alive() == 0
     assert cstats.values() == ['[1.000000, 2.000000]', '[3.000000, -1.000000]',
-                               '[4.000000, 1.000000]', '[-2.000000, 3.000000]',
-                               '[-7.000000, -6.000000]', '[9.000000, 10.000000]',
-                               '[8.000000, 16.000000]', '[0.125000, 0.250000]',
-                               '[7.000000, 6.000000]', '[9.000000, 10.000000]',
-                               '[8.000000, 16.000000]', '[8.000000, 4.000000]',
-                               '[3.000000, -2.000000]', '[3.000000, -0.500000]',
-                               '[6.000000, -2.000000]']
+                               '[-3.000000, 1.000000]', '[4.000000, 1.000000]',
+                               '[-2.000000, 3.000000]', '[-7.000000, -6.000000]',
+                               '[9.000000, 10.000000]', '[8.000000, 16.000000]',
+                               '[0.125000, 0.250000]', '[7.000000, 6.000000]',
+                               '[9.000000, 10.000000]', '[8.000000, 16.000000]',
+                               '[8.000000, 4.000000]', '[3.000000, -2.000000]',
+                               '[3.000000, -0.500000]', '[6.000000, -2.000000]']
     assert cstats.default_constructions == 0
     assert cstats.copy_constructions == 0
     assert cstats.move_constructions >= 10
@@ -59,9 +62,8 @@ def test_operator_overloading():
 
 def test_operators_notimplemented():
     """#393: need to return NotSupported to ensure correct arithmetic operator behavior"""
-    from pybind11_tests.operators import C1, C2
 
-    c1, c2 = C1(), C2()
+    c1, c2 = m.C1(), m.C2()
     assert c1 + c1 == 11
     assert c2 + c2 == 22
     assert c2 + c1 == 21
@@ -70,24 +72,23 @@ def test_operators_notimplemented():
 
 def test_nested():
     """#328: first member in a class can't be used in operators"""
-    from pybind11_tests.operators import NestA, NestB, NestC, get_NestA, get_NestB, get_NestC
 
-    a = NestA()
-    b = NestB()
-    c = NestC()
+    a = m.NestA()
+    b = m.NestB()
+    c = m.NestC()
 
     a += 10
-    assert get_NestA(a) == 13
+    assert m.get_NestA(a) == 13
     b.a += 100
-    assert get_NestA(b.a) == 103
+    assert m.get_NestA(b.a) == 103
     c.b.a += 1000
-    assert get_NestA(c.b.a) == 1003
+    assert m.get_NestA(c.b.a) == 1003
     b -= 1
-    assert get_NestB(b) == 3
+    assert m.get_NestB(b) == 3
     c.b -= 3
-    assert get_NestB(c.b) == 1
+    assert m.get_NestB(c.b) == 1
     c *= 7
-    assert get_NestC(c) == 35
+    assert m.get_NestC(c) == 35
 
     abase = a.as_base()
     assert abase.value == -2
@@ -99,7 +100,7 @@ def test_nested():
 
     del c
     pytest.gc_collect()
-    del a  # Should't delete while abase is still alive
+    del a  # Shouldn't delete while abase is still alive
     pytest.gc_collect()
 
     assert abase.value == 42
diff --git a/src/pybind11/tests/test_pickling.cpp b/src/pybind11/tests/test_pickling.cpp
index 52b1dbc..9dc63bd 100644
--- a/src/pybind11/tests/test_pickling.cpp
+++ b/src/pybind11/tests/test_pickling.cpp
@@ -9,30 +9,28 @@
 
 #include "pybind11_tests.h"
 
-class Pickleable {
-public:
-    Pickleable(const std::string &value) : m_value(value) { }
-    const std::string &value() const { return m_value; }
-
-    void setExtra1(int extra1) { m_extra1 = extra1; }
-    void setExtra2(int extra2) { m_extra2 = extra2; }
-    int extra1() const { return m_extra1; }
-    int extra2() const { return m_extra2; }
-private:
-    std::string m_value;
-    int m_extra1 = 0;
-    int m_extra2 = 0;
-};
-
-class PickleableWithDict {
-public:
-    PickleableWithDict(const std::string &value) : value(value) { }
-
-    std::string value;
-    int extra;
-};
-
-test_initializer pickling([](py::module &m) {
+TEST_SUBMODULE(pickling, m) {
+    // test_roundtrip
+    class Pickleable {
+    public:
+        Pickleable(const std::string &value) : m_value(value) { }
+        const std::string &value() const { return m_value; }
+
+        void setExtra1(int extra1) { m_extra1 = extra1; }
+        void setExtra2(int extra2) { m_extra2 = extra2; }
+        int extra1() const { return m_extra1; }
+        int extra2() const { return m_extra2; }
+    private:
+        std::string m_value;
+        int m_extra1 = 0;
+        int m_extra2 = 0;
+    };
+
+    class PickleableNew : public Pickleable {
+    public:
+        using Pickleable::Pickleable;
+    };
+
     py::class_<Pickleable>(m, "Pickleable")
         .def(py::init<std::string>())
         .def("value", &Pickleable::value)
@@ -57,7 +55,38 @@ test_initializer pickling([](py::module &m) {
             p.setExtra2(t[2].cast<int>());
         });
 
+    py::class_<PickleableNew, Pickleable>(m, "PickleableNew")
+        .def(py::init<std::string>())
+        .def(py::pickle(
+            [](const PickleableNew &p) {
+                return py::make_tuple(p.value(), p.extra1(), p.extra2());
+            },
+            [](py::tuple t) {
+                if (t.size() != 3)
+                    throw std::runtime_error("Invalid state!");
+                auto p = PickleableNew(t[0].cast<std::string>());
+
+                p.setExtra1(t[1].cast<int>());
+                p.setExtra2(t[2].cast<int>());
+                return p;
+            }
+        ));
+
 #if !defined(PYPY_VERSION)
+    // test_roundtrip_with_dict
+    class PickleableWithDict {
+    public:
+        PickleableWithDict(const std::string &value) : value(value) { }
+
+        std::string value;
+        int extra;
+    };
+
+    class PickleableWithDictNew : public PickleableWithDict {
+    public:
+        using PickleableWithDict::PickleableWithDict;
+    };
+
     py::class_<PickleableWithDict>(m, "PickleableWithDict", py::dynamic_attr())
         .def(py::init<std::string>())
         .def_readwrite("value", &PickleableWithDict::value)
@@ -79,5 +108,23 @@ test_initializer pickling([](py::module &m) {
             /* Assign Python state */
             self.attr("__dict__") = t[2];
         });
+
+    py::class_<PickleableWithDictNew, PickleableWithDict>(m, "PickleableWithDictNew")
+        .def(py::init<std::string>())
+        .def(py::pickle(
+            [](py::object self) {
+                return py::make_tuple(self.attr("value"), self.attr("extra"), self.attr("__dict__"));
+            },
+            [](const py::tuple &t) {
+                if (t.size() != 3)
+                    throw std::runtime_error("Invalid state!");
+
+                auto cpp_state = PickleableWithDictNew(t[0].cast<std::string>());
+                cpp_state.extra = t[1].cast<int>();
+
+                auto py_state = t[2].cast<py::dict>();
+                return std::make_pair(cpp_state, py_state);
+            }
+        ));
 #endif
-});
+}
diff --git a/src/pybind11/tests/test_pickling.py b/src/pybind11/tests/test_pickling.py
index 548c618..5ae05aa 100644
--- a/src/pybind11/tests/test_pickling.py
+++ b/src/pybind11/tests/test_pickling.py
@@ -1,4 +1,5 @@
 import pytest
+from pybind11_tests import pickling as m
 
 try:
     import cPickle as pickle  # Use cPickle on Python 2.7
@@ -6,10 +7,10 @@ except ImportError:
     import pickle
 
 
-def test_roundtrip():
-    from pybind11_tests import Pickleable
-
-    p = Pickleable("test_value")
+@pytest.mark.parametrize("cls_name", ["Pickleable", "PickleableNew"])
+def test_roundtrip(cls_name):
+    cls = getattr(m, cls_name)
+    p = cls("test_value")
     p.setExtra1(15)
     p.setExtra2(48)
 
@@ -21,10 +22,10 @@ def test_roundtrip():
 
 
 @pytest.unsupported_on_pypy
-def test_roundtrip_with_dict():
-    from pybind11_tests import PickleableWithDict
-
-    p = PickleableWithDict("test_value")
+@pytest.mark.parametrize("cls_name", ["PickleableWithDict", "PickleableWithDictNew"])
+def test_roundtrip_with_dict(cls_name):
+    cls = getattr(m, cls_name)
+    p = cls("test_value")
     p.extra = 15
     p.dynamic = "Attribute"
 
@@ -33,3 +34,9 @@ def test_roundtrip_with_dict():
     assert p2.value == p.value
     assert p2.extra == p.extra
     assert p2.dynamic == p.dynamic
+
+
+def test_enum_pickle():
+    from pybind11_tests import enums as e
+    data = pickle.dumps(e.EOne, 2)
+    assert e.EOne == pickle.loads(data)
diff --git a/src/pybind11/tests/test_pytypes.cpp b/src/pybind11/tests/test_pytypes.cpp
index edc1e99..244e1db 100644
--- a/src/pybind11/tests/test_pytypes.cpp
+++ b/src/pybind11/tests/test_pytypes.cpp
@@ -17,6 +17,8 @@ TEST_SUBMODULE(pytypes, m) {
         list.append("value");
         py::print("Entry at position 0:", list[0]);
         list[0] = py::str("overwritten");
+        list.insert(0, "inserted-0");
+        list.insert(2, "inserted-2");
         return list;
     });
     m.def("print_list", [](py::list list) {
@@ -37,6 +39,12 @@ TEST_SUBMODULE(pytypes, m) {
         for (auto item : set)
             py::print("key:", item);
     });
+    m.def("set_contains", [](py::set set, py::object key) {
+        return set.contains(key);
+    });
+    m.def("set_contains", [](py::set set, const char* key) {
+        return set.contains(key);
+    });
 
     // test_dict
     m.def("get_dict", []() { return py::dict("key"_a="value"); });
@@ -49,6 +57,12 @@ TEST_SUBMODULE(pytypes, m) {
         auto d2 = py::dict("z"_a=3, **d1);
         return d2;
     });
+    m.def("dict_contains", [](py::dict dict, py::object val) {
+        return dict.contains(val);
+    });
+    m.def("dict_contains", [](py::dict dict, const char* val) {
+        return dict.contains(val);
+    });
 
     // test_str
     m.def("str_from_string", []() { return py::str(std::string("baz")); });
@@ -128,6 +142,12 @@ TEST_SUBMODULE(pytypes, m) {
         d["operator()"] = o.attr("func")(1);
         d["operator*"] = o.attr("func")(*o.attr("begin_end"));
 
+        // Test implicit conversion
+        py::list implicit_list = o.attr("begin_end");
+        d["implicit_list"] = implicit_list;
+        py::dict implicit_dict = o.attr("__dict__");
+        d["implicit_dict"] = implicit_dict;
+
         return d;
     });
 
@@ -261,4 +281,30 @@ TEST_SUBMODULE(pytypes, m) {
     });
 
     m.def("print_failure", []() { py::print(42, UnregisteredType()); });
+
+    m.def("hash_function", [](py::object obj) { return py::hash(obj); });
+
+    m.def("test_number_protocol", [](py::object a, py::object b) {
+        py::list l;
+        l.append(a.equal(b));
+        l.append(a.not_equal(b));
+        l.append(a < b);
+        l.append(a <= b);
+        l.append(a > b);
+        l.append(a >= b);
+        l.append(a + b);
+        l.append(a - b);
+        l.append(a * b);
+        l.append(a / b);
+        l.append(a | b);
+        l.append(a & b);
+        l.append(a ^ b);
+        l.append(a >> b);
+        l.append(a << b);
+        return l;
+    });
+
+    m.def("test_list_slicing", [](py::list a) {
+        return a[py::slice(0, -1, 2)];
+    });
 }
diff --git a/src/pybind11/tests/test_pytypes.py b/src/pybind11/tests/test_pytypes.py
index 1c75c47..0e8d6c3 100644
--- a/src/pybind11/tests/test_pytypes.py
+++ b/src/pybind11/tests/test_pytypes.py
@@ -1,3 +1,4 @@
+from __future__ import division
 import pytest
 import sys
 
@@ -7,15 +8,17 @@ from pybind11_tests import debug_enabled
 
 def test_list(capture, doc):
     with capture:
-        l = m.get_list()
-        assert l == ["overwritten"]
+        lst = m.get_list()
+        assert lst == ["inserted-0", "overwritten", "inserted-2"]
 
-        l.append("value2")
-        m.print_list(l)
+        lst.append("value2")
+        m.print_list(lst)
     assert capture.unordered == """
         Entry at position 0: value
-        list item 0: overwritten
-        list item 1: value2
+        list item 0: inserted-0
+        list item 1: overwritten
+        list item 2: inserted-2
+        list item 3: value2
     """
 
     assert doc(m.get_list) == "get_list() -> list"
@@ -36,6 +39,10 @@ def test_set(capture, doc):
         key: key4
     """
 
+    assert not m.set_contains(set([]), 42)
+    assert m.set_contains({42}, 42)
+    assert m.set_contains({"foo"}, "foo")
+
     assert doc(m.get_list) == "get_list() -> list"
     assert doc(m.print_list) == "print_list(arg0: list) -> None"
 
@@ -52,6 +59,10 @@ def test_dict(capture, doc):
         key: key2, value=value2
     """
 
+    assert not m.dict_contains({}, 42)
+    assert m.dict_contains({42: None}, 42)
+    assert m.dict_contains({"foo": None}, "foo")
+
     assert doc(m.get_dict) == "get_dict() -> dict"
     assert doc(m.print_dict) == "print_dict(arg0: dict) -> None"
 
@@ -144,6 +155,8 @@ def test_accessors():
     assert d["is_none"] is False
     assert d["operator()"] == 2
     assert d["operator*"] == 7
+    assert d["implicit_list"] == [1, 2, 3]
+    assert all(x in TestObject.__dict__ for x in d["implicit_dict"])
 
     assert m.tuple_accessor(tuple()) == (0, 1, 2)
 
@@ -174,9 +187,20 @@ def test_constructors():
     }
     inputs = {k.__name__: v for k, v in data.items()}
     expected = {k.__name__: k(v) for k, v in data.items()}
+
     assert m.converting_constructors(inputs) == expected
     assert m.cast_functions(inputs) == expected
 
+    # Converting constructors and cast functions should just reference rather
+    # than copy when no conversion is needed:
+    noconv1 = m.converting_constructors(expected)
+    for k in noconv1:
+        assert noconv1[k] is expected[k]
+
+    noconv2 = m.cast_functions(expected)
+    for k in noconv2:
+        assert noconv2[k] is expected[k]
+
 
 def test_implicit_casting():
     """Tests implicit casting when assigning or appending to dicts and lists."""
@@ -209,3 +233,31 @@ def test_print(capture):
         if debug_enabled else
         "arguments to Python object (compile in debug mode for details)"
     )
+
+
+def test_hash():
+    class Hashable(object):
+        def __init__(self, value):
+            self.value = value
+
+        def __hash__(self):
+            return self.value
+
+    class Unhashable(object):
+        __hash__ = None
+
+    assert m.hash_function(Hashable(42)) == 42
+    with pytest.raises(TypeError):
+        m.hash_function(Unhashable())
+
+
+def test_number_protocol():
+    for a, b in [(1, 1), (3, 5)]:
+        li = [a == b, a != b, a < b, a <= b, a > b, a >= b, a + b,
+              a - b, a * b, a / b, a | b, a & b, a ^ b, a >> b, a << b]
+        assert m.test_number_protocol(a, b) == li
+
+
+def test_list_slicing():
+    li = list(range(100))
+    assert li[::2] == m.test_list_slicing(li)
diff --git a/src/pybind11/tests/test_sequences_and_iterators.cpp b/src/pybind11/tests/test_sequences_and_iterators.cpp
index 89fde8f..87ccf99 100644
--- a/src/pybind11/tests/test_sequences_and_iterators.cpp
+++ b/src/pybind11/tests/test_sequences_and_iterators.cpp
@@ -13,146 +13,6 @@
 #include <pybind11/operators.h>
 #include <pybind11/stl.h>
 
-class Sequence {
-public:
-    Sequence(size_t size) : m_size(size) {
-        print_created(this, "of size", m_size);
-        m_data = new float[size];
-        memset(m_data, 0, sizeof(float) * size);
-    }
-
-    Sequence(const std::vector<float> &value) : m_size(value.size()) {
-        print_created(this, "of size", m_size, "from std::vector");
-        m_data = new float[m_size];
-        memcpy(m_data, &value[0], sizeof(float) * m_size);
-    }
-
-    Sequence(const Sequence &s) : m_size(s.m_size) {
-        print_copy_created(this);
-        m_data = new float[m_size];
-        memcpy(m_data, s.m_data, sizeof(float)*m_size);
-    }
-
-    Sequence(Sequence &&s) : m_size(s.m_size), m_data(s.m_data) {
-        print_move_created(this);
-        s.m_size = 0;
-        s.m_data = nullptr;
-    }
-
-    ~Sequence() {
-        print_destroyed(this);
-        delete[] m_data;
-    }
-
-    Sequence &operator=(const Sequence &s) {
-        if (&s != this) {
-            delete[] m_data;
-            m_size = s.m_size;
-            m_data = new float[m_size];
-            memcpy(m_data, s.m_data, sizeof(float)*m_size);
-        }
-
-        print_copy_assigned(this);
-
-        return *this;
-    }
-
-    Sequence &operator=(Sequence &&s) {
-        if (&s != this) {
-            delete[] m_data;
-            m_size = s.m_size;
-            m_data = s.m_data;
-            s.m_size = 0;
-            s.m_data = nullptr;
-        }
-
-        print_move_assigned(this);
-
-        return *this;
-    }
-
-    bool operator==(const Sequence &s) const {
-        if (m_size != s.size())
-            return false;
-        for (size_t i=0; i<m_size; ++i)
-            if (m_data[i] != s[i])
-                return false;
-        return true;
-    }
-
-    bool operator!=(const Sequence &s) const {
-        return !operator==(s);
-    }
-
-    float operator[](size_t index) const {
-        return m_data[index];
-    }
-
-    float &operator[](size_t index) {
-        return m_data[index];
-    }
-
-    bool contains(float v) const {
-        for (size_t i=0; i<m_size; ++i)
-            if (v == m_data[i])
-                return true;
-        return false;
-    }
-
-    Sequence reversed() const {
-        Sequence result(m_size);
-        for (size_t i=0; i<m_size; ++i)
-            result[m_size-i-1] = m_data[i];
-        return result;
-    }
-
-    size_t size() const { return m_size; }
-
-    const float *begin() const { return m_data; }
-    const float *end() const { return m_data+m_size; }
-
-private:
-    size_t m_size;
-    float *m_data;
-};
-
-class IntPairs {
-public:
-    IntPairs(std::vector<std::pair<int, int>> data) : data_(std::move(data)) {}
-    const std::pair<int, int>* begin() const { return data_.data(); }
-
-private:
-    std::vector<std::pair<int, int>> data_;
-};
-
-// Interface of a map-like object that isn't (directly) an unordered_map, but provides some basic
-// map-like functionality.
-class StringMap {
-public:
-    StringMap() = default;
-    StringMap(std::unordered_map<std::string, std::string> init)
-        : map(std::move(init)) {}
-
-    void set(std::string key, std::string val) {
-        map[key] = val;
-    }
-
-    std::string get(std::string key) const {
-        return map.at(key);
-    }
-
-    size_t size() const {
-        return map.size();
-    }
-
-private:
-    std::unordered_map<std::string, std::string> map;
-
-public:
-    decltype(map.cbegin()) begin() const { return map.cbegin(); }
-    decltype(map.cend()) end() const { return map.cend(); }
-};
-
 template<typename T>
 class NonZeroIterator {
     const T* ptr_;
@@ -210,66 +70,183 @@ py::list test_random_access_iterator(PythonType x) {
     return checks;
 }
 
-test_initializer sequences_and_iterators([](py::module &pm) {
-    auto m = pm.def_submodule("sequences_and_iterators");
+TEST_SUBMODULE(sequences_and_iterators, m) {
+    // test_sliceable
+    class Sliceable{
+    public:
+      Sliceable(int n): size(n) {}
+      int start,stop,step;
+      int size;
+    };
+    py::class_<Sliceable>(m,"Sliceable")
+        .def(py::init<int>())
+        .def("__getitem__",[](const Sliceable &s, py::slice slice) {
+          ssize_t start, stop, step, slicelength;
+          if (!slice.compute(s.size, &start, &stop, &step, &slicelength))
+              throw py::error_already_set();
+          int istart = static_cast<int>(start);
+          int istop =  static_cast<int>(stop);
+          int istep =  static_cast<int>(step);
+          return std::make_tuple(istart,istop,istep);
+        })
+        ;
+
+    // test_sequence
+    class Sequence {
+    public:
+        Sequence(size_t size) : m_size(size) {
+            print_created(this, "of size", m_size);
+            m_data = new float[size];
+            memset(m_data, 0, sizeof(float) * size);
+        }
+        Sequence(const std::vector<float> &value) : m_size(value.size()) {
+            print_created(this, "of size", m_size, "from std::vector");
+            m_data = new float[m_size];
+            memcpy(m_data, &value[0], sizeof(float) * m_size);
+        }
+        Sequence(const Sequence &s) : m_size(s.m_size) {
+            print_copy_created(this);
+            m_data = new float[m_size];
+            memcpy(m_data, s.m_data, sizeof(float)*m_size);
+        }
+        Sequence(Sequence &&s) : m_size(s.m_size), m_data(s.m_data) {
+            print_move_created(this);
+            s.m_size = 0;
+            s.m_data = nullptr;
+        }
 
-    py::class_<Sequence> seq(m, "Sequence");
+        ~Sequence() { print_destroyed(this); delete[] m_data; }
+
+        Sequence &operator=(const Sequence &s) {
+            if (&s != this) {
+                delete[] m_data;
+                m_size = s.m_size;
+                m_data = new float[m_size];
+                memcpy(m_data, s.m_data, sizeof(float)*m_size);
+            }
+            print_copy_assigned(this);
+            return *this;
+        }
+
+        Sequence &operator=(Sequence &&s) {
+            if (&s != this) {
+                delete[] m_data;
+                m_size = s.m_size;
+                m_data = s.m_data;
+                s.m_size = 0;
+                s.m_data = nullptr;
+            }
+            print_move_assigned(this);
+            return *this;
+        }
+
+        bool operator==(const Sequence &s) const {
+            if (m_size != s.size()) return false;
+            for (size_t i = 0; i < m_size; ++i)
+                if (m_data[i] != s[i])
+                    return false;
+            return true;
+        }
+        bool operator!=(const Sequence &s) const { return !operator==(s); }
 
-    seq.def(py::init<size_t>())
-       .def(py::init<const std::vector<float>&>())
-       /// Bare bones interface
-       .def("__getitem__", [](const Sequence &s, size_t i) {
-            if (i >= s.size())
-                throw py::index_error();
+        float operator[](size_t index) const { return m_data[index]; }
+        float &operator[](size_t index) { return m_data[index]; }
+
+        bool contains(float v) const {
+            for (size_t i = 0; i < m_size; ++i)
+                if (v == m_data[i])
+                    return true;
+            return false;
+        }
+
+        Sequence reversed() const {
+            Sequence result(m_size);
+            for (size_t i = 0; i < m_size; ++i)
+                result[m_size - i - 1] = m_data[i];
+            return result;
+        }
+
+        size_t size() const { return m_size; }
+
+        const float *begin() const { return m_data; }
+        const float *end() const { return m_data+m_size; }
+
+    private:
+        size_t m_size;
+        float *m_data;
+    };
+    py::class_<Sequence>(m, "Sequence")
+        .def(py::init<size_t>())
+        .def(py::init<const std::vector<float>&>())
+        /// Bare bones interface
+        .def("__getitem__", [](const Sequence &s, size_t i) {
+            if (i >= s.size()) throw py::index_error();
             return s[i];
         })
-       .def("__setitem__", [](Sequence &s, size_t i, float v) {
-            if (i >= s.size())
-                throw py::index_error();
+        .def("__setitem__", [](Sequence &s, size_t i, float v) {
+            if (i >= s.size()) throw py::index_error();
             s[i] = v;
         })
-       .def("__len__", &Sequence::size)
-       /// Optional sequence protocol operations
-       .def("__iter__", [](const Sequence &s) { return py::make_iterator(s.begin(), s.end()); },
-                        py::keep_alive<0, 1>() /* Essential: keep object alive while iterator exists */)
-       .def("__contains__", [](const Sequence &s, float v) { return s.contains(v); })
-       .def("__reversed__", [](const Sequence &s) -> Sequence { return s.reversed(); })
-       /// Slicing protocol (optional)
-       .def("__getitem__", [](const Sequence &s, py::slice slice) -> Sequence* {
+        .def("__len__", &Sequence::size)
+        /// Optional sequence protocol operations
+        .def("__iter__", [](const Sequence &s) { return py::make_iterator(s.begin(), s.end()); },
+                         py::keep_alive<0, 1>() /* Essential: keep object alive while iterator exists */)
+        .def("__contains__", [](const Sequence &s, float v) { return s.contains(v); })
+        .def("__reversed__", [](const Sequence &s) -> Sequence { return s.reversed(); })
+        /// Slicing protocol (optional)
+        .def("__getitem__", [](const Sequence &s, py::slice slice) -> Sequence* {
             size_t start, stop, step, slicelength;
             if (!slice.compute(s.size(), &start, &stop, &step, &slicelength))
                 throw py::error_already_set();
             Sequence *seq = new Sequence(slicelength);
-            for (size_t i=0; i<slicelength; ++i) {
+            for (size_t i = 0; i < slicelength; ++i) {
                 (*seq)[i] = s[start]; start += step;
             }
             return seq;
         })
-       .def("__setitem__", [](Sequence &s, py::slice slice, const Sequence &value) {
+        .def("__setitem__", [](Sequence &s, py::slice slice, const Sequence &value) {
             size_t start, stop, step, slicelength;
             if (!slice.compute(s.size(), &start, &stop, &step, &slicelength))
                 throw py::error_already_set();
             if (slicelength != value.size())
                 throw std::runtime_error("Left and right hand size of slice assignment have different sizes!");
-            for (size_t i=0; i<slicelength; ++i) {
+            for (size_t i = 0; i < slicelength; ++i) {
                 s[start] = value[i]; start += step;
             }
         })
-       /// Comparisons
-       .def(py::self == py::self)
-       .def(py::self != py::self);
-       // Could also define py::self + py::self for concatenation, etc.
-
-    py::class_<StringMap> map(m, "StringMap");
+        /// Comparisons
+        .def(py::self == py::self)
+        .def(py::self != py::self)
+        // Could also define py::self + py::self for concatenation, etc.
+        ;
 
-    map .def(py::init<>())
+    // test_map_iterator
+    // Interface of a map-like object that isn't (directly) an unordered_map, but provides some basic
+    // map-like functionality.
+    class StringMap {
+    public:
+        StringMap() = default;
+        StringMap(std::unordered_map<std::string, std::string> init)
+            : map(std::move(init)) {}
+
+        void set(std::string key, std::string val) { map[key] = val; }
+        std::string get(std::string key) const { return map.at(key); }
+        size_t size() const { return map.size(); }
+    private:
+        std::unordered_map<std::string, std::string> map;
+    public:
+        decltype(map.cbegin()) begin() const { return map.cbegin(); }
+        decltype(map.cend()) end() const { return map.cend(); }
+    };
+    py::class_<StringMap>(m, "StringMap")
+        .def(py::init<>())
         .def(py::init<std::unordered_map<std::string, std::string>>())
         .def("__getitem__", [](const StringMap &map, std::string key) {
                 try { return map.get(key); }
                 catch (const std::out_of_range&) {
                     throw py::key_error("key '" + key + "' does not exist");
                 }
-                })
+        })
         .def("__setitem__", &StringMap::set)
         .def("__len__", &StringMap::size)
         .def("__iter__", [](const StringMap &map) { return py::make_key_iterator(map.begin(), map.end()); },
@@ -278,14 +255,23 @@ test_initializer sequences_and_iterators([](py::module &pm) {
                 py::keep_alive<0, 1>())
         ;
 
+    // test_generalized_iterators
+    class IntPairs {
+    public:
+        IntPairs(std::vector<std::pair<int, int>> data) : data_(std::move(data)) {}
+        const std::pair<int, int>* begin() const { return data_.data(); }
+    private:
+        std::vector<std::pair<int, int>> data_;
+    };
     py::class_<IntPairs>(m, "IntPairs")
         .def(py::init<std::vector<std::pair<int, int>>>())
         .def("nonzero", [](const IntPairs& s) {
                 return py::make_iterator(NonZeroIterator<std::pair<int, int>>(s.begin()), NonZeroSentinel());
-            }, py::keep_alive<0, 1>())
+        }, py::keep_alive<0, 1>())
         .def("nonzero_keys", [](const IntPairs& s) {
             return py::make_key_iterator(NonZeroIterator<std::pair<int, int>>(s.begin()), NonZeroSentinel());
-        }, py::keep_alive<0, 1>());
+        }, py::keep_alive<0, 1>())
+        ;
 
 
 #if 0
@@ -315,6 +301,7 @@ test_initializer sequences_and_iterators([](py::module &pm) {
     .def("__iter__", [](py::object s) { return PySequenceIterator(s.cast<const Sequence &>(), s); })
 #endif
 
+    // test_python_iterator_in_cpp
     m.def("object_to_list", [](py::object o) {
         auto l = py::list();
         for (auto item : o) {
@@ -348,17 +335,19 @@ test_initializer sequences_and_iterators([](py::module &pm) {
        });
     });
 
-    m.def("tuple_iterator", [](py::tuple x) { return test_random_access_iterator(x); });
-    m.def("list_iterator", [](py::list x) { return test_random_access_iterator(x); });
-    m.def("sequence_iterator", [](py::sequence x) { return test_random_access_iterator(x); });
+    m.def("tuple_iterator", &test_random_access_iterator<py::tuple>);
+    m.def("list_iterator", &test_random_access_iterator<py::list>);
+    m.def("sequence_iterator", &test_random_access_iterator<py::sequence>);
 
+    // test_iterator_passthrough
     // #181: iterator passthrough did not compile
     m.def("iterator_passthrough", [](py::iterator s) -> py::iterator {
         return py::make_iterator(std::begin(s), std::end(s));
     });
 
+    // test_iterator_rvp
     // #388: Can't make iterators via make_iterator() with different r/v policies
     static std::vector<int> list = { 1, 2, 3 };
     m.def("make_iterator_1", []() { return py::make_iterator<py::return_value_policy::copy>(list); });
     m.def("make_iterator_2", []() { return py::make_iterator<py::return_value_policy::automatic>(list); });
-});
+}
diff --git a/src/pybind11/tests/test_sequences_and_iterators.py b/src/pybind11/tests/test_sequences_and_iterators.py
index 2ce2e60..6bd1606 100644
--- a/src/pybind11/tests/test_sequences_and_iterators.py
+++ b/src/pybind11/tests/test_sequences_and_iterators.py
@@ -1,4 +1,6 @@
 import pytest
+from pybind11_tests import sequences_and_iterators as m
+from pybind11_tests import ConstructorStats
 
 
 def isclose(a, b, rel_tol=1e-05, abs_tol=0.0):
@@ -11,35 +13,43 @@ def allclose(a_list, b_list, rel_tol=1e-05, abs_tol=0.0):
 
 
 def test_generalized_iterators():
-    from pybind11_tests.sequences_and_iterators import IntPairs
+    assert list(m.IntPairs([(1, 2), (3, 4), (0, 5)]).nonzero()) == [(1, 2), (3, 4)]
+    assert list(m.IntPairs([(1, 2), (2, 0), (0, 3), (4, 5)]).nonzero()) == [(1, 2)]
+    assert list(m.IntPairs([(0, 3), (1, 2), (3, 4)]).nonzero()) == []
 
-    assert list(IntPairs([(1, 2), (3, 4), (0, 5)]).nonzero()) == [(1, 2), (3, 4)]
-    assert list(IntPairs([(1, 2), (2, 0), (0, 3), (4, 5)]).nonzero()) == [(1, 2)]
-    assert list(IntPairs([(0, 3), (1, 2), (3, 4)]).nonzero()) == []
-
-    assert list(IntPairs([(1, 2), (3, 4), (0, 5)]).nonzero_keys()) == [1, 3]
-    assert list(IntPairs([(1, 2), (2, 0), (0, 3), (4, 5)]).nonzero_keys()) == [1]
-    assert list(IntPairs([(0, 3), (1, 2), (3, 4)]).nonzero_keys()) == []
+    assert list(m.IntPairs([(1, 2), (3, 4), (0, 5)]).nonzero_keys()) == [1, 3]
+    assert list(m.IntPairs([(1, 2), (2, 0), (0, 3), (4, 5)]).nonzero_keys()) == [1]
+    assert list(m.IntPairs([(0, 3), (1, 2), (3, 4)]).nonzero_keys()) == []
 
     # __next__ must continue to raise StopIteration
-    it = IntPairs([(0, 0)]).nonzero()
+    it = m.IntPairs([(0, 0)]).nonzero()
     for _ in range(3):
         with pytest.raises(StopIteration):
             next(it)
 
-    it = IntPairs([(0, 0)]).nonzero_keys()
+    it = m.IntPairs([(0, 0)]).nonzero_keys()
     for _ in range(3):
         with pytest.raises(StopIteration):
             next(it)
 
 
-def test_sequence():
-    from pybind11_tests import ConstructorStats
-    from pybind11_tests.sequences_and_iterators import Sequence
+def test_sliceable():
+    sliceable = m.Sliceable(100)
+    assert sliceable[::] == (0, 100, 1)
+    assert sliceable[10::] == (10, 100, 1)
+    assert sliceable[:10:] == (0, 10, 1)
+    assert sliceable[::10] == (0, 100, 10)
+    assert sliceable[-10::] == (90, 100, 1)
+    assert sliceable[:-10:] == (0, 90, 1)
+    assert sliceable[::-10] == (99, -1, -10)
+    assert sliceable[50:60:1] == (50, 60, 1)
+    assert sliceable[50:60:-1] == (50, 60, -1)
 
-    cstats = ConstructorStats.get(Sequence)
 
-    s = Sequence(5)
+def test_sequence():
+    cstats = ConstructorStats.get(m.Sequence)
+
+    s = m.Sequence(5)
     assert cstats.values() == ['of size', '5']
 
     assert "Sequence" in repr(s)
@@ -56,7 +66,7 @@ def test_sequence():
     rev2 = s[::-1]
     assert cstats.values() == ['of size', '5']
 
-    it = iter(Sequence(0))
+    it = iter(m.Sequence(0))
     for _ in range(3):  # __next__ must continue to raise StopIteration
         with pytest.raises(StopIteration):
             next(it)
@@ -67,7 +77,7 @@ def test_sequence():
     assert allclose(rev2, expected)
     assert rev == rev2
 
-    rev[0::2] = Sequence([2.0, 2.0, 2.0])
+    rev[0::2] = m.Sequence([2.0, 2.0, 2.0])
     assert cstats.values() == ['of size', '3', 'from std::vector']
 
     assert allclose(rev, [2, 56.78, 2, 0, 2])
@@ -91,33 +101,29 @@ def test_sequence():
 
 
 def test_map_iterator():
-    from pybind11_tests.sequences_and_iterators import StringMap
-
-    m = StringMap({'hi': 'bye', 'black': 'white'})
-    assert m['hi'] == 'bye'
-    assert len(m) == 2
-    assert m['black'] == 'white'
+    sm = m.StringMap({'hi': 'bye', 'black': 'white'})
+    assert sm['hi'] == 'bye'
+    assert len(sm) == 2
+    assert sm['black'] == 'white'
 
     with pytest.raises(KeyError):
-        assert m['orange']
-    m['orange'] = 'banana'
-    assert m['orange'] == 'banana'
+        assert sm['orange']
+    sm['orange'] = 'banana'
+    assert sm['orange'] == 'banana'
 
     expected = {'hi': 'bye', 'black': 'white', 'orange': 'banana'}
-    for k in m:
-        assert m[k] == expected[k]
-    for k, v in m.items():
+    for k in sm:
+        assert sm[k] == expected[k]
+    for k, v in sm.items():
         assert v == expected[k]
 
-    it = iter(StringMap({}))
+    it = iter(m.StringMap({}))
     for _ in range(3):  # __next__ must continue to raise StopIteration
         with pytest.raises(StopIteration):
             next(it)
 
 
 def test_python_iterator_in_cpp():
-    import pybind11_tests.sequences_and_iterators as m
-
     t = (1, 2, 3)
     assert m.object_to_list(t) == [1, 2, 3]
     assert m.object_to_list(iter(t)) == [1, 2, 3]
@@ -138,9 +144,9 @@ def test_python_iterator_in_cpp():
         m.iterator_to_list(iter(bad_next_call, None))
     assert str(excinfo.value) == "py::iterator::advance() should propagate errors"
 
-    l = [1, None, 0, None]
-    assert m.count_none(l) == 2
-    assert m.find_none(l) is True
+    lst = [1, None, 0, None]
+    assert m.count_none(lst) == 2
+    assert m.find_none(lst) is True
     assert m.count_nonzeros({"a": 0, "b": 1, "c": 2}) == 2
 
     r = range(5)
diff --git a/src/pybind11/tests/test_smart_ptr.cpp b/src/pybind11/tests/test_smart_ptr.cpp
index 91239e8..87c9be8 100644
--- a/src/pybind11/tests/test_smart_ptr.cpp
+++ b/src/pybind11/tests/test_smart_ptr.cpp
@@ -8,111 +8,19 @@
     BSD-style license that can be found in the LICENSE file.
 */
 
+#if defined(_MSC_VER) && _MSC_VER < 1910
+#  pragma warning(disable: 4702) // unreachable code in system header
+#endif
+
 #include "pybind11_tests.h"
 #include "object.h"
 
-/// Custom object with builtin reference counting (see 'object.h' for the implementation)
-class MyObject1 : public Object {
-public:
-    MyObject1(int value) : value(value) {
-        print_created(this, toString());
-    }
-
-    std::string toString() const {
-        return "MyObject1[" + std::to_string(value) + "]";
-    }
-
-protected:
-    virtual ~MyObject1() {
-        print_destroyed(this);
-    }
-
-private:
-    int value;
-};
-
-/// Object managed by a std::shared_ptr<>
-class MyObject2 {
-public:
-    MyObject2(int value) : value(value) {
-        print_created(this, toString());
-    }
-
-    std::string toString() const {
-        return "MyObject2[" + std::to_string(value) + "]";
-    }
-
-    virtual ~MyObject2() {
-        print_destroyed(this);
-    }
-
-private:
-    int value;
-};
-
-/// Object managed by a std::shared_ptr<>, additionally derives from std::enable_shared_from_this<>
-class MyObject3 : public std::enable_shared_from_this<MyObject3> {
-public:
-    MyObject3(int value) : value(value) {
-        print_created(this, toString());
-    }
-
-    std::string toString() const {
-        return "MyObject3[" + std::to_string(value) + "]";
-    }
-
-    virtual ~MyObject3() {
-        print_destroyed(this);
-    }
-
-private:
-    int value;
-};
-
-class MyObject4 {
-public:
-    MyObject4(int value) : value{value} {
-        print_created(this);
-    }
-    int value;
-private:
-    ~MyObject4() {
-        print_destroyed(this);
-    }
-};
-
-/// This is just a wrapper around unique_ptr, but with extra fields to deliberately bloat up the
-/// holder size to trigger the non-simple-layout internal instance layout for single inheritance with
-/// large holder type.
-template <typename T> class huge_unique_ptr {
-    std::unique_ptr<T> ptr;
-    uint64_t padding[10];
-public:
-    huge_unique_ptr(T *p) : ptr(p) {};
-    T *get() { return ptr.get(); }
-};
-
-class MyObject5 { // managed by huge_unique_ptr
-public:
-    MyObject5(int value) : value{value} {
-        print_created(this);
-    }
-    int value;
-    ~MyObject5() {
-        print_destroyed(this);
-    }
-};
-
-/// Make pybind aware of the ref-counted wrapper type (s)
+// Make pybind aware of the ref-counted wrapper type (s):
 
 // ref<T> is a wrapper for 'Object' which uses intrusive reference counting
 // It is always possible to construct a ref<T> from an Object* pointer without
-// possible incosistencies, hence the 'true' argument at the end.
+// possible inconsistencies, hence the 'true' argument at the end.
 PYBIND11_DECLARE_HOLDER_TYPE(T, ref<T>, true);
-PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>); // Not required any more for std::shared_ptr,
-                                                     // but it should compile without error
-PYBIND11_DECLARE_HOLDER_TYPE(T, huge_unique_ptr<T>);
-
 // Make pybind11 aware of the non-standard getter member function
 namespace pybind11 { namespace detail {
     template <typename T>
@@ -121,162 +29,214 @@ namespace pybind11 { namespace detail {
     };
 }}
 
-Object *make_object_1() { return new MyObject1(1); }
-ref<Object> make_object_2() { return new MyObject1(2); }
+// The following is not required anymore for std::shared_ptr, but it should compile without error:
+PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>);
 
-MyObject1 *make_myobject1_1() { return new MyObject1(4); }
-ref<MyObject1> make_myobject1_2() { return new MyObject1(5); }
+// This is just a wrapper around unique_ptr, but with extra fields to deliberately bloat up the
+// holder size to trigger the non-simple-layout internal instance layout for single inheritance with
+// large holder type:
+template <typename T> class huge_unique_ptr {
+    std::unique_ptr<T> ptr;
+    uint64_t padding[10];
+public:
+    huge_unique_ptr(T *p) : ptr(p) {};
+    T *get() { return ptr.get(); }
+};
+PYBIND11_DECLARE_HOLDER_TYPE(T, huge_unique_ptr<T>);
 
-MyObject2 *make_myobject2_1() { return new MyObject2(6); }
-std::shared_ptr<MyObject2> make_myobject2_2() { return std::make_shared<MyObject2>(7); }
+// Simple custom holder that works like unique_ptr
+template <typename T>
+class custom_unique_ptr {
+    std::unique_ptr<T> impl;
+public:
+    custom_unique_ptr(T* p) : impl(p) { }
+    T* get() const { return impl.get(); }
+    T* release_ptr() { return impl.release(); }
+};
+PYBIND11_DECLARE_HOLDER_TYPE(T, custom_unique_ptr<T>);
 
-MyObject3 *make_myobject3_1() { return new MyObject3(8); }
-std::shared_ptr<MyObject3> make_myobject3_2() { return std::make_shared<MyObject3>(9); }
+// Simple custom holder that works like shared_ptr and has operator& overload
+// To obtain address of an instance of this holder pybind should use std::addressof
+// Attempt to get address via operator& may leads to segmentation fault
+template <typename T>
+class shared_ptr_with_addressof_operator {
+    std::shared_ptr<T> impl;
+public:
+    shared_ptr_with_addressof_operator( ) = default;
+    shared_ptr_with_addressof_operator(T* p) : impl(p) { }
+    T* get() const { return impl.get(); }
+    T** operator&() { throw std::logic_error("Call of overloaded operator& is not expected"); }
+};
+PYBIND11_DECLARE_HOLDER_TYPE(T, shared_ptr_with_addressof_operator<T>);
 
-void print_object_1(const Object *obj) { py::print(obj->toString()); }
-void print_object_2(ref<Object> obj) { py::print(obj->toString()); }
-void print_object_3(const ref<Object> &obj) { py::print(obj->toString()); }
-void print_object_4(const ref<Object> *obj) { py::print((*obj)->toString()); }
+// Simple custom holder that works like unique_ptr and has operator& overload
+// To obtain address of an instance of this holder pybind should use std::addressof
+// Attempt to get address via operator& may leads to segmentation fault
+template <typename T>
+class unique_ptr_with_addressof_operator {
+    std::unique_ptr<T> impl;
+public:
+    unique_ptr_with_addressof_operator() = default;
+    unique_ptr_with_addressof_operator(T* p) : impl(p) { }
+    T* get() const { return impl.get(); }
+    T* release_ptr() { return impl.release(); }
+    T** operator&() { throw std::logic_error("Call of overloaded operator& is not expected"); }
+};
+PYBIND11_DECLARE_HOLDER_TYPE(T, unique_ptr_with_addressof_operator<T>);
 
-void print_myobject1_1(const MyObject1 *obj) { py::print(obj->toString()); }
-void print_myobject1_2(ref<MyObject1> obj) { py::print(obj->toString()); }
-void print_myobject1_3(const ref<MyObject1> &obj) { py::print(obj->toString()); }
-void print_myobject1_4(const ref<MyObject1> *obj) { py::print((*obj)->toString()); }
 
-void print_myobject2_1(const MyObject2 *obj) { py::print(obj->toString()); }
-void print_myobject2_2(std::shared_ptr<MyObject2> obj) { py::print(obj->toString()); }
-void print_myobject2_3(const std::shared_ptr<MyObject2> &obj) { py::print(obj->toString()); }
-void print_myobject2_4(const std::shared_ptr<MyObject2> *obj) { py::print((*obj)->toString()); }
+TEST_SUBMODULE(smart_ptr, m) {
 
-void print_myobject3_1(const MyObject3 *obj) { py::print(obj->toString()); }
-void print_myobject3_2(std::shared_ptr<MyObject3> obj) { py::print(obj->toString()); }
-void print_myobject3_3(const std::shared_ptr<MyObject3> &obj) { py::print(obj->toString()); }
-void print_myobject3_4(const std::shared_ptr<MyObject3> *obj) { py::print((*obj)->toString()); }
+    // test_smart_ptr
 
-test_initializer smart_ptr([](py::module &m) {
+    // Object implementation in `object.h`
     py::class_<Object, ref<Object>> obj(m, "Object");
     obj.def("getRefCount", &Object::getRefCount);
 
+    // Custom object with builtin reference counting (see 'object.h' for the implementation)
+    class MyObject1 : public Object {
+    public:
+        MyObject1(int value) : value(value) { print_created(this, toString()); }
+        std::string toString() const { return "MyObject1[" + std::to_string(value) + "]"; }
+    protected:
+        virtual ~MyObject1() { print_destroyed(this); }
+    private:
+        int value;
+    };
     py::class_<MyObject1, ref<MyObject1>>(m, "MyObject1", obj)
         .def(py::init<int>());
+    py::implicitly_convertible<py::int_, MyObject1>();
+
+    m.def("make_object_1", []() -> Object * { return new MyObject1(1); });
+    m.def("make_object_2", []() -> ref<Object> { return new MyObject1(2); });
+    m.def("make_myobject1_1", []() -> MyObject1 * { return new MyObject1(4); });
+    m.def("make_myobject1_2", []() -> ref<MyObject1> { return new MyObject1(5); });
+    m.def("print_object_1", [](const Object *obj) { py::print(obj->toString()); });
+    m.def("print_object_2", [](ref<Object> obj) { py::print(obj->toString()); });
+    m.def("print_object_3", [](const ref<Object> &obj) { py::print(obj->toString()); });
+    m.def("print_object_4", [](const ref<Object> *obj) { py::print((*obj)->toString()); });
+    m.def("print_myobject1_1", [](const MyObject1 *obj) { py::print(obj->toString()); });
+    m.def("print_myobject1_2", [](ref<MyObject1> obj) { py::print(obj->toString()); });
+    m.def("print_myobject1_3", [](const ref<MyObject1> &obj) { py::print(obj->toString()); });
+    m.def("print_myobject1_4", [](const ref<MyObject1> *obj) { py::print((*obj)->toString()); });
+
+    // Expose constructor stats for the ref type
+    m.def("cstats_ref", &ConstructorStats::get<ref_tag>);
 
-    m.def("test_object1_refcounting",
-        []() -> bool {
-            ref<MyObject1> o = new MyObject1(0);
-            bool good = o->getRefCount() == 1;
-            py::object o2 = py::cast(o, py::return_value_policy::reference);
-            // always request (partial) ownership for objects with intrusive
-            // reference counting even when using the 'reference' RVP
-            good &= o->getRefCount() == 2;
-            return good;
-        }
-    );
-
-    m.def("make_object_1", &make_object_1);
-    m.def("make_object_2", &make_object_2);
-    m.def("make_myobject1_1", &make_myobject1_1);
-    m.def("make_myobject1_2", &make_myobject1_2);
-    m.def("print_object_1", &print_object_1);
-    m.def("print_object_2", &print_object_2);
-    m.def("print_object_3", &print_object_3);
-    m.def("print_object_4", &print_object_4);
-    m.def("print_myobject1_1", &print_myobject1_1);
-    m.def("print_myobject1_2", &print_myobject1_2);
-    m.def("print_myobject1_3", &print_myobject1_3);
-    m.def("print_myobject1_4", &print_myobject1_4);
 
+    // Object managed by a std::shared_ptr<>
+    class MyObject2 {
+    public:
+        MyObject2(const MyObject2 &) = default;
+        MyObject2(int value) : value(value) { print_created(this, toString()); }
+        std::string toString() const { return "MyObject2[" + std::to_string(value) + "]"; }
+        virtual ~MyObject2() { print_destroyed(this); }
+    private:
+        int value;
+    };
     py::class_<MyObject2, std::shared_ptr<MyObject2>>(m, "MyObject2")
         .def(py::init<int>());
-    m.def("make_myobject2_1", &make_myobject2_1);
-    m.def("make_myobject2_2", &make_myobject2_2);
-    m.def("print_myobject2_1", &print_myobject2_1);
-    m.def("print_myobject2_2", &print_myobject2_2);
-    m.def("print_myobject2_3", &print_myobject2_3);
-    m.def("print_myobject2_4", &print_myobject2_4);
-
+    m.def("make_myobject2_1", []() { return new MyObject2(6); });
+    m.def("make_myobject2_2", []() { return std::make_shared<MyObject2>(7); });
+    m.def("print_myobject2_1", [](const MyObject2 *obj) { py::print(obj->toString()); });
+    m.def("print_myobject2_2", [](std::shared_ptr<MyObject2> obj) { py::print(obj->toString()); });
+    m.def("print_myobject2_3", [](const std::shared_ptr<MyObject2> &obj) { py::print(obj->toString()); });
+    m.def("print_myobject2_4", [](const std::shared_ptr<MyObject2> *obj) { py::print((*obj)->toString()); });
+
+    // Object managed by a std::shared_ptr<>, additionally derives from std::enable_shared_from_this<>
+    class MyObject3 : public std::enable_shared_from_this<MyObject3> {
+    public:
+        MyObject3(const MyObject3 &) = default;
+        MyObject3(int value) : value(value) { print_created(this, toString()); }
+        std::string toString() const { return "MyObject3[" + std::to_string(value) + "]"; }
+        virtual ~MyObject3() { print_destroyed(this); }
+    private:
+        int value;
+    };
     py::class_<MyObject3, std::shared_ptr<MyObject3>>(m, "MyObject3")
         .def(py::init<int>());
-    m.def("make_myobject3_1", &make_myobject3_1);
-    m.def("make_myobject3_2", &make_myobject3_2);
-    m.def("print_myobject3_1", &print_myobject3_1);
-    m.def("print_myobject3_2", &print_myobject3_2);
-    m.def("print_myobject3_3", &print_myobject3_3);
-    m.def("print_myobject3_4", &print_myobject3_4);
-
+    m.def("make_myobject3_1", []() { return new MyObject3(8); });
+    m.def("make_myobject3_2", []() { return std::make_shared<MyObject3>(9); });
+    m.def("print_myobject3_1", [](const MyObject3 *obj) { py::print(obj->toString()); });
+    m.def("print_myobject3_2", [](std::shared_ptr<MyObject3> obj) { py::print(obj->toString()); });
+    m.def("print_myobject3_3", [](const std::shared_ptr<MyObject3> &obj) { py::print(obj->toString()); });
+    m.def("print_myobject3_4", [](const std::shared_ptr<MyObject3> *obj) { py::print((*obj)->toString()); });
+
+    // test_smart_ptr_refcounting
+    m.def("test_object1_refcounting", []() {
+        ref<MyObject1> o = new MyObject1(0);
+        bool good = o->getRefCount() == 1;
+        py::object o2 = py::cast(o, py::return_value_policy::reference);
+        // always request (partial) ownership for objects with intrusive
+        // reference counting even when using the 'reference' RVP
+        good &= o->getRefCount() == 2;
+        return good;
+    });
+
+    // test_unique_nodelete
+    // Object with a private destructor
+    class MyObject4 {
+    public:
+        MyObject4(int value) : value{value} { print_created(this); }
+        int value;
+    private:
+        ~MyObject4() { print_destroyed(this); }
+    };
     py::class_<MyObject4, std::unique_ptr<MyObject4, py::nodelete>>(m, "MyObject4")
         .def(py::init<int>())
         .def_readwrite("value", &MyObject4::value);
 
-    py::class_<MyObject5, huge_unique_ptr<MyObject5>>(m, "MyObject5")
+    // test_unique_deleter
+    // Object with std::unique_ptr<T, D> where D is not matching the base class
+    // Object with a protected destructor
+    class MyObject4a {
+    public:
+        MyObject4a(int i) {
+            value = i;
+            print_created(this);
+        };
+        int value;
+    protected:
+        virtual ~MyObject4a() { print_destroyed(this); }
+    };
+    py::class_<MyObject4a, std::unique_ptr<MyObject4a, py::nodelete>>(m, "MyObject4a")
         .def(py::init<int>())
-        .def_readwrite("value", &MyObject5::value);
-
-    py::implicitly_convertible<py::int_, MyObject1>();
+        .def_readwrite("value", &MyObject4a::value);
 
-    // Expose constructor stats for the ref type
-    m.def("cstats_ref", &ConstructorStats::get<ref_tag>);
-});
-
-struct SharedPtrRef {
-    struct A {
-        A() { print_created(this); }
-        A(const A &) { print_copy_created(this); }
-        A(A &&) { print_move_created(this); }
-        ~A() { print_destroyed(this); }
+    // Object derived but with public destructor and no Deleter in default holder
+    class MyObject4b : public MyObject4a {
+    public:
+        MyObject4b(int i) : MyObject4a(i) { print_created(this); }
+        ~MyObject4b() { print_destroyed(this); }
     };
+    py::class_<MyObject4b, MyObject4a>(m, "MyObject4b")
+        .def(py::init<int>());
 
-    A value = {};
-    std::shared_ptr<A> shared = std::make_shared<A>();
-};
-
-struct SharedFromThisRef {
-    struct B : std::enable_shared_from_this<B> {
-        B() { print_created(this); }
-        B(const B &) : std::enable_shared_from_this<B>() { print_copy_created(this); }
-        B(B &&) : std::enable_shared_from_this<B>() { print_move_created(this); }
-        ~B() { print_destroyed(this); }
+    // test_large_holder
+    class MyObject5 { // managed by huge_unique_ptr
+    public:
+        MyObject5(int value) : value{value} { print_created(this); }
+        ~MyObject5() { print_destroyed(this); }
+        int value;
     };
+    py::class_<MyObject5, huge_unique_ptr<MyObject5>>(m, "MyObject5")
+        .def(py::init<int>())
+        .def_readwrite("value", &MyObject5::value);
 
-    B value = {};
-    std::shared_ptr<B> shared = std::make_shared<B>();
-};
-
-// Issue #865: shared_from_this doesn't work with virtual inheritance
-struct SharedFromThisVBase : std::enable_shared_from_this<SharedFromThisVBase> {
-    virtual ~SharedFromThisVBase() = default;
-};
-struct SharedFromThisVirt : virtual SharedFromThisVBase {};
-
-template <typename T>
-class CustomUniquePtr {
-    std::unique_ptr<T> impl;
-
-public:
-    CustomUniquePtr(T* p) : impl(p) { }
-    T* get() const { return impl.get(); }
-    T* release_ptr() { return impl.release(); }
-};
-
-PYBIND11_DECLARE_HOLDER_TYPE(T, CustomUniquePtr<T>);
-
-struct ElementBase { virtual void foo() { } /* Force creation of virtual table */ };
-struct ElementA : ElementBase {
-    ElementA(int v) : v(v) { }
-    int value() { return v; }
-    int v;
-};
-
-struct ElementList {
-    void add(std::shared_ptr<ElementBase> e) { l.push_back(e); }
-    std::vector<std::shared_ptr<ElementBase>> l;
-};
-
-test_initializer smart_ptr_and_references([](py::module &pm) {
-    auto m = pm.def_submodule("smart_ptr");
-
+    // test_shared_ptr_and_references
+    struct SharedPtrRef {
+        struct A {
+            A() { print_created(this); }
+            A(const A &) { print_copy_created(this); }
+            A(A &&) { print_move_created(this); }
+            ~A() { print_destroyed(this); }
+        };
+
+        A value = {};
+        std::shared_ptr<A> shared = std::make_shared<A>();
+    };
     using A = SharedPtrRef::A;
     py::class_<A, std::shared_ptr<A>>(m, "A");
-
     py::class_<SharedPtrRef>(m, "SharedPtrRef")
         .def(py::init<>())
         .def_readonly("ref", &SharedPtrRef::value)
@@ -288,9 +248,20 @@ test_initializer smart_ptr_and_references([](py::module &pm) {
         .def("set_ref", [](SharedPtrRef &, const A &) { return true; })
         .def("set_holder", [](SharedPtrRef &, std::shared_ptr<A>) { return true; });
 
+    // test_shared_ptr_from_this_and_references
+    struct SharedFromThisRef {
+        struct B : std::enable_shared_from_this<B> {
+            B() { print_created(this); }
+            B(const B &) : std::enable_shared_from_this<B>() { print_copy_created(this); }
+            B(B &&) : std::enable_shared_from_this<B>() { print_move_created(this); }
+            ~B() { print_destroyed(this); }
+        };
+
+        B value = {};
+        std::shared_ptr<B> shared = std::make_shared<B>();
+    };
     using B = SharedFromThisRef::B;
     py::class_<B, std::shared_ptr<B>>(m, "B");
-
     py::class_<SharedFromThisRef>(m, "SharedFromThisRef")
         .def(py::init<>())
         .def_readonly("bad_wp", &SharedFromThisRef::value)
@@ -304,31 +275,85 @@ test_initializer smart_ptr_and_references([](py::module &pm) {
         .def("set_holder", [](SharedFromThisRef &, std::shared_ptr<B>) { return true; });
 
     // Issue #865: shared_from_this doesn't work with virtual inheritance
+    struct SharedFromThisVBase : std::enable_shared_from_this<SharedFromThisVBase> {
+        SharedFromThisVBase() = default;
+        SharedFromThisVBase(const SharedFromThisVBase &) = default;
+        virtual ~SharedFromThisVBase() = default;
+    };
+    struct SharedFromThisVirt : virtual SharedFromThisVBase {};
     static std::shared_ptr<SharedFromThisVirt> sft(new SharedFromThisVirt());
     py::class_<SharedFromThisVirt, std::shared_ptr<SharedFromThisVirt>>(m, "SharedFromThisVirt")
         .def_static("get", []() { return sft.get(); });
 
+    // test_move_only_holder
     struct C {
         C() { print_created(this); }
         ~C() { print_destroyed(this); }
     };
+    py::class_<C, custom_unique_ptr<C>>(m, "TypeWithMoveOnlyHolder")
+        .def_static("make", []() { return custom_unique_ptr<C>(new C); });
+
+    // test_holder_with_addressof_operator
+    struct TypeForHolderWithAddressOf {
+        TypeForHolderWithAddressOf() { print_created(this); }
+        TypeForHolderWithAddressOf(const TypeForHolderWithAddressOf &) { print_copy_created(this); }
+        TypeForHolderWithAddressOf(TypeForHolderWithAddressOf &&) { print_move_created(this); }
+        ~TypeForHolderWithAddressOf() { print_destroyed(this); }
+        std::string toString() const {
+            return "TypeForHolderWithAddressOf[" + std::to_string(value) + "]";
+        }
+        int value = 42;
+    };
+    using HolderWithAddressOf = shared_ptr_with_addressof_operator<TypeForHolderWithAddressOf>;
+    py::class_<TypeForHolderWithAddressOf, HolderWithAddressOf>(m, "TypeForHolderWithAddressOf")
+        .def_static("make", []() { return HolderWithAddressOf(new TypeForHolderWithAddressOf); })
+        .def("get", [](const HolderWithAddressOf &self) { return self.get(); })
+        .def("print_object_1", [](const TypeForHolderWithAddressOf *obj) { py::print(obj->toString()); })
+        .def("print_object_2", [](HolderWithAddressOf obj) { py::print(obj.get()->toString()); })
+        .def("print_object_3", [](const HolderWithAddressOf &obj) { py::print(obj.get()->toString()); })
+        .def("print_object_4", [](const HolderWithAddressOf *obj) { py::print((*obj).get()->toString()); });
+
+    // test_move_only_holder_with_addressof_operator
+    struct TypeForMoveOnlyHolderWithAddressOf {
+        TypeForMoveOnlyHolderWithAddressOf(int value) : value{value} { print_created(this); }
+        ~TypeForMoveOnlyHolderWithAddressOf() { print_destroyed(this); }
+        std::string toString() const {
+            return "MoveOnlyHolderWithAddressOf[" + std::to_string(value) + "]";
+        }
+        int value;
+    };
+    using MoveOnlyHolderWithAddressOf = unique_ptr_with_addressof_operator<TypeForMoveOnlyHolderWithAddressOf>;
+    py::class_<TypeForMoveOnlyHolderWithAddressOf, MoveOnlyHolderWithAddressOf>(m, "TypeForMoveOnlyHolderWithAddressOf")
+        .def_static("make", []() { return MoveOnlyHolderWithAddressOf(new TypeForMoveOnlyHolderWithAddressOf(0)); })
+        .def_readwrite("value", &TypeForMoveOnlyHolderWithAddressOf::value)
+        .def("print_object", [](const TypeForMoveOnlyHolderWithAddressOf *obj) { py::print(obj->toString()); });
 
-    py::class_<C, CustomUniquePtr<C>>(m, "TypeWithMoveOnlyHolder")
-        .def_static("make", []() { return CustomUniquePtr<C>(new C); });
-
+    // test_smart_ptr_from_default
     struct HeldByDefaultHolder { };
-
     py::class_<HeldByDefaultHolder>(m, "HeldByDefaultHolder")
         .def(py::init<>())
         .def_static("load_shared_ptr", [](std::shared_ptr<HeldByDefaultHolder>) {});
 
+    // test_shared_ptr_gc
     // #187: issue involving std::shared_ptr<> return value policy & garbage collection
+    struct ElementBase {
+        virtual ~ElementBase() { } /* Force creation of virtual table */
+    };
     py::class_<ElementBase, std::shared_ptr<ElementBase>>(m, "ElementBase");
 
+    struct ElementA : ElementBase {
+        ElementA(int v) : v(v) { }
+        int value() { return v; }
+        int v;
+    };
     py::class_<ElementA, ElementBase, std::shared_ptr<ElementA>>(m, "ElementA")
         .def(py::init<int>())
         .def("value", &ElementA::value);
 
+    struct ElementList {
+        void add(std::shared_ptr<ElementBase> e) { l.push_back(e); }
+        std::vector<std::shared_ptr<ElementBase>> l;
+    };
     py::class_<ElementList, std::shared_ptr<ElementList>>(m, "ElementList")
         .def(py::init<>())
         .def("add", &ElementList::add)
@@ -338,4 +363,4 @@ test_initializer smart_ptr_and_references([](py::module &pm) {
                 list.append(py::cast(e));
             return list;
         });
-});
+}
diff --git a/src/pybind11/tests/test_smart_ptr.py b/src/pybind11/tests/test_smart_ptr.py
index 144180d..c662704 100644
--- a/src/pybind11/tests/test_smart_ptr.py
+++ b/src/pybind11/tests/test_smart_ptr.py
@@ -1,40 +1,35 @@
 import pytest
+from pybind11_tests import smart_ptr as m
 from pybind11_tests import ConstructorStats
 
 
 def test_smart_ptr(capture):
     # Object1
-    from pybind11_tests import (MyObject1, make_object_1, make_object_2,
-                                print_object_1, print_object_2, print_object_3, print_object_4)
-
-    for i, o in enumerate([make_object_1(), make_object_2(), MyObject1(3)], start=1):
+    for i, o in enumerate([m.make_object_1(), m.make_object_2(), m.MyObject1(3)], start=1):
         assert o.getRefCount() == 1
         with capture:
-            print_object_1(o)
-            print_object_2(o)
-            print_object_3(o)
-            print_object_4(o)
+            m.print_object_1(o)
+            m.print_object_2(o)
+            m.print_object_3(o)
+            m.print_object_4(o)
         assert capture == "MyObject1[{i}]\n".format(i=i) * 4
 
-    from pybind11_tests import (make_myobject1_1, make_myobject1_2,
-                                print_myobject1_1, print_myobject1_2,
-                                print_myobject1_3, print_myobject1_4)
-
-    for i, o in enumerate([make_myobject1_1(), make_myobject1_2(), MyObject1(6), 7], start=4):
+    for i, o in enumerate([m.make_myobject1_1(), m.make_myobject1_2(), m.MyObject1(6), 7],
+                          start=4):
         print(o)
         with capture:
             if not isinstance(o, int):
-                print_object_1(o)
-                print_object_2(o)
-                print_object_3(o)
-                print_object_4(o)
-            print_myobject1_1(o)
-            print_myobject1_2(o)
-            print_myobject1_3(o)
-            print_myobject1_4(o)
+                m.print_object_1(o)
+                m.print_object_2(o)
+                m.print_object_3(o)
+                m.print_object_4(o)
+            m.print_myobject1_1(o)
+            m.print_myobject1_2(o)
+            m.print_myobject1_3(o)
+            m.print_myobject1_4(o)
         assert capture == "MyObject1[{i}]\n".format(i=i) * (4 if isinstance(o, int) else 8)
 
-    cstats = ConstructorStats.get(MyObject1)
+    cstats = ConstructorStats.get(m.MyObject1)
     assert cstats.alive() == 0
     expected_values = ['MyObject1[{}]'.format(i) for i in range(1, 7)] + ['MyObject1[7]'] * 4
     assert cstats.values() == expected_values
@@ -45,21 +40,16 @@ def test_smart_ptr(capture):
     assert cstats.move_assignments == 0
 
     # Object2
-    from pybind11_tests import (MyObject2, make_myobject2_1, make_myobject2_2,
-                                make_myobject3_1, make_myobject3_2,
-                                print_myobject2_1, print_myobject2_2,
-                                print_myobject2_3, print_myobject2_4)
-
-    for i, o in zip([8, 6, 7], [MyObject2(8), make_myobject2_1(), make_myobject2_2()]):
+    for i, o in zip([8, 6, 7], [m.MyObject2(8), m.make_myobject2_1(), m.make_myobject2_2()]):
         print(o)
         with capture:
-            print_myobject2_1(o)
-            print_myobject2_2(o)
-            print_myobject2_3(o)
-            print_myobject2_4(o)
+            m.print_myobject2_1(o)
+            m.print_myobject2_2(o)
+            m.print_myobject2_3(o)
+            m.print_myobject2_4(o)
         assert capture == "MyObject2[{i}]\n".format(i=i) * 4
 
-    cstats = ConstructorStats.get(MyObject2)
+    cstats = ConstructorStats.get(m.MyObject2)
     assert cstats.alive() == 1
     o = None
     assert cstats.alive() == 0
@@ -71,19 +61,16 @@ def test_smart_ptr(capture):
     assert cstats.move_assignments == 0
 
     # Object3
-    from pybind11_tests import (MyObject3, print_myobject3_1, print_myobject3_2,
-                                print_myobject3_3, print_myobject3_4)
-
-    for i, o in zip([9, 8, 9], [MyObject3(9), make_myobject3_1(), make_myobject3_2()]):
+    for i, o in zip([9, 8, 9], [m.MyObject3(9), m.make_myobject3_1(), m.make_myobject3_2()]):
         print(o)
         with capture:
-            print_myobject3_1(o)
-            print_myobject3_2(o)
-            print_myobject3_3(o)
-            print_myobject3_4(o)
+            m.print_myobject3_1(o)
+            m.print_myobject3_2(o)
+            m.print_myobject3_3(o)
+            m.print_myobject3_4(o)
         assert capture == "MyObject3[{i}]\n".format(i=i) * 4
 
-    cstats = ConstructorStats.get(MyObject3)
+    cstats = ConstructorStats.get(m.MyObject3)
     assert cstats.alive() == 1
     o = None
     assert cstats.alive() == 0
@@ -94,10 +81,8 @@ def test_smart_ptr(capture):
     assert cstats.copy_assignments == 0
     assert cstats.move_assignments == 0
 
-    # Object and ref
-    from pybind11_tests import Object, cstats_ref
-
-    cstats = ConstructorStats.get(Object)
+    # Object
+    cstats = ConstructorStats.get(m.Object)
     assert cstats.alive() == 0
     assert cstats.values() == []
     assert cstats.default_constructions == 10
@@ -106,7 +91,8 @@ def test_smart_ptr(capture):
     assert cstats.copy_assignments == 0
     assert cstats.move_assignments == 0
 
-    cstats = cstats_ref()
+    # ref<>
+    cstats = m.cstats_ref()
     assert cstats.alive() == 0
     assert cstats.values() == ['from pointer'] * 10
     assert cstats.default_constructions == 30
@@ -117,36 +103,51 @@ def test_smart_ptr(capture):
 
 
 def test_smart_ptr_refcounting():
-    from pybind11_tests import test_object1_refcounting
-    assert test_object1_refcounting()
+    assert m.test_object1_refcounting()
 
 
 def test_unique_nodelete():
-    from pybind11_tests import MyObject4
-    o = MyObject4(23)
+    o = m.MyObject4(23)
+    assert o.value == 23
+    cstats = ConstructorStats.get(m.MyObject4)
+    assert cstats.alive() == 1
+    del o
+    assert cstats.alive() == 1  # Leak, but that's intentional
+
+
+def test_unique_nodelete4a():
+    o = m.MyObject4a(23)
     assert o.value == 23
-    cstats = ConstructorStats.get(MyObject4)
+    cstats = ConstructorStats.get(m.MyObject4a)
     assert cstats.alive() == 1
     del o
-    cstats = ConstructorStats.get(MyObject4)
     assert cstats.alive() == 1  # Leak, but that's intentional
 
 
+def test_unique_deleter():
+    o = m.MyObject4b(23)
+    assert o.value == 23
+    cstats4a = ConstructorStats.get(m.MyObject4a)
+    assert cstats4a.alive() == 2  # Two because of previous test
+    cstats4b = ConstructorStats.get(m.MyObject4b)
+    assert cstats4b.alive() == 1
+    del o
+    assert cstats4a.alive() == 1  # Should now only be one leftover from previous test
+    assert cstats4b.alive() == 0  # Should be deleted
+
+
 def test_large_holder():
-    from pybind11_tests import MyObject5
-    o = MyObject5(5)
+    o = m.MyObject5(5)
     assert o.value == 5
-    cstats = ConstructorStats.get(MyObject5)
+    cstats = ConstructorStats.get(m.MyObject5)
     assert cstats.alive() == 1
     del o
     assert cstats.alive() == 0
 
 
 def test_shared_ptr_and_references():
-    from pybind11_tests.smart_ptr import SharedPtrRef, A
-
-    s = SharedPtrRef()
-    stats = ConstructorStats.get(A)
+    s = m.SharedPtrRef()
+    stats = ConstructorStats.get(m.A)
     assert stats.alive() == 2
 
     ref = s.ref  # init_holder_helper(holder_ptr=false, owned=false)
@@ -176,10 +177,8 @@ def test_shared_ptr_and_references():
 
 
 def test_shared_ptr_from_this_and_references():
-    from pybind11_tests.smart_ptr import SharedFromThisRef, B, SharedFromThisVirt
-
-    s = SharedFromThisRef()
-    stats = ConstructorStats.get(B)
+    s = m.SharedFromThisRef()
+    stats = ConstructorStats.get(m.B)
     assert stats.alive() == 2
 
     ref = s.ref  # init_holder_helper(holder_ptr=false, owned=false, bad_wp=false)
@@ -212,37 +211,76 @@ def test_shared_ptr_from_this_and_references():
     del ref, bad_wp, copy, holder_ref, holder_copy, s
     assert stats.alive() == 0
 
-    z = SharedFromThisVirt.get()
-    y = SharedFromThisVirt.get()
+    z = m.SharedFromThisVirt.get()
+    y = m.SharedFromThisVirt.get()
     assert y is z
 
 
 def test_move_only_holder():
-    from pybind11_tests.smart_ptr import TypeWithMoveOnlyHolder
+    a = m.TypeWithMoveOnlyHolder.make()
+    stats = ConstructorStats.get(m.TypeWithMoveOnlyHolder)
+    assert stats.alive() == 1
+    del a
+    assert stats.alive() == 0
+
 
-    a = TypeWithMoveOnlyHolder.make()
-    stats = ConstructorStats.get(TypeWithMoveOnlyHolder)
+def test_holder_with_addressof_operator():
+    # this test must not throw exception from c++
+    a = m.TypeForHolderWithAddressOf.make()
+    a.print_object_1()
+    a.print_object_2()
+    a.print_object_3()
+    a.print_object_4()
+
+    stats = ConstructorStats.get(m.TypeForHolderWithAddressOf)
     assert stats.alive() == 1
+
+    np = m.TypeForHolderWithAddressOf.make()
+    assert stats.alive() == 2
     del a
+    assert stats.alive() == 1
+    del np
     assert stats.alive() == 0
 
+    b = m.TypeForHolderWithAddressOf.make()
+    c = b
+    assert b.get() is c.get()
+    assert stats.alive() == 1
+
+    del b
+    assert stats.alive() == 1
+
+    del c
+    assert stats.alive() == 0
 
-def test_smart_ptr_from_default():
-    from pybind11_tests.smart_ptr import HeldByDefaultHolder
 
-    instance = HeldByDefaultHolder()
+def test_move_only_holder_with_addressof_operator():
+    a = m.TypeForMoveOnlyHolderWithAddressOf.make()
+    a.print_object()
+
+    stats = ConstructorStats.get(m.TypeForMoveOnlyHolderWithAddressOf)
+    assert stats.alive() == 1
+
+    a.value = 42
+    assert a.value == 42
+
+    del a
+    assert stats.alive() == 0
+
+
+def test_smart_ptr_from_default():
+    instance = m.HeldByDefaultHolder()
     with pytest.raises(RuntimeError) as excinfo:
-        HeldByDefaultHolder.load_shared_ptr(instance)
-    assert "Unable to load a custom holder type from a default-holder instance" in str(excinfo)
+        m.HeldByDefaultHolder.load_shared_ptr(instance)
+    assert "Unable to load a custom holder type from a " \
+           "default-holder instance" in str(excinfo.value)
 
 
 def test_shared_ptr_gc():
     """#187: issue involving std::shared_ptr<> return value policy & garbage collection"""
-    from pybind11_tests.smart_ptr import ElementList, ElementA
-
-    el = ElementList()
+    el = m.ElementList()
     for i in range(10):
-        el.add(ElementA(i))
+        el.add(m.ElementA(i))
     pytest.gc_collect()
     for i, v in enumerate(el.get()):
         assert i == v.value()
diff --git a/src/pybind11/tests/test_stl.cpp b/src/pybind11/tests/test_stl.cpp
index 9762fb9..207c9fb 100644
--- a/src/pybind11/tests/test_stl.cpp
+++ b/src/pybind11/tests/test_stl.cpp
@@ -8,19 +8,35 @@
 */
 
 #include "pybind11_tests.h"
+#include "constructor_stats.h"
 #include <pybind11/stl.h>
 
-// Class that can be move- and copy-constructed, but not assigned
-struct NoAssign {
-    int value;
+#include <vector>
+#include <string>
 
-    explicit NoAssign(int value = 0) : value(value) { }
-    NoAssign(const NoAssign &) = default;
-    NoAssign(NoAssign &&) = default;
+// Test with `std::variant` in C++17 mode, or with `boost::variant` in C++11/14
+#if PYBIND11_HAS_VARIANT
+using std::variant;
+#elif defined(PYBIND11_TEST_BOOST) && (!defined(_MSC_VER) || _MSC_VER >= 1910)
+#  include <boost/variant.hpp>
+#  define PYBIND11_HAS_VARIANT 1
+using boost::variant;
 
-    NoAssign &operator=(const NoAssign &) = delete;
-    NoAssign &operator=(NoAssign &&) = delete;
+namespace pybind11 { namespace detail {
+template <typename... Ts>
+struct type_caster<boost::variant<Ts...>> : variant_caster<boost::variant<Ts...>> {};
+
+template <>
+struct visit_helper<boost::variant> {
+    template <typename... Args>
+    static auto call(Args &&...args) -> decltype(boost::apply_visitor(args...)) {
+        return boost::apply_visitor(args...);
+    }
 };
+}} // namespace pybind11::detail
+#endif
+
+PYBIND11_MAKE_OPAQUE(std::vector<std::string, std::allocator<std::string>>);
 
 /// Issue #528: templated constructor
 struct TplCtorClass {
@@ -38,6 +54,18 @@ TEST_SUBMODULE(stl, m) {
     // test_vector
     m.def("cast_vector", []() { return std::vector<int>{1}; });
     m.def("load_vector", [](const std::vector<int> &v) { return v.at(0) == 1 && v.at(1) == 2; });
+    // `std::vector<bool>` is special because it returns proxy objects instead of references
+    m.def("cast_bool_vector", []() { return std::vector<bool>{true, false}; });
+    m.def("load_bool_vector", [](const std::vector<bool> &v) {
+        return v.at(0) == true && v.at(1) == false;
+    });
+    // Unnumbered regression (caused by #936): pointers to stl containers aren't castable
+    static std::vector<RValueCaster> lvv{2};
+    m.def("cast_ptr_vector", []() { return &lvv; });
+
+    // test_deque
+    m.def("cast_deque", []() { return std::deque<int>{1}; });
+    m.def("load_deque", [](const std::deque<int> &v) { return v.at(0) == 1 && v.at(1) == 2; });
 
     // test_array
     m.def("cast_array", []() { return std::array<int, 2> {{1 , 2}}; });
@@ -61,24 +89,73 @@ TEST_SUBMODULE(stl, m) {
         return set.count("key1") && set.count("key2") && set.count("key3");
     });
 
+    // test_recursive_casting
+    m.def("cast_rv_vector", []() { return std::vector<RValueCaster>{2}; });
+    m.def("cast_rv_array", []() { return std::array<RValueCaster, 3>(); });
+    // NB: map and set keys are `const`, so while we technically do move them (as `const Type &&`),
+    // casters don't typically do anything with that, which means they fall to the `const Type &`
+    // caster.
+    m.def("cast_rv_map", []() { return std::unordered_map<std::string, RValueCaster>{{"a", RValueCaster{}}}; });
+    m.def("cast_rv_nested", []() {
+        std::vector<std::array<std::list<std::unordered_map<std::string, RValueCaster>>, 2>> v;
+        v.emplace_back(); // add an array
+        v.back()[0].emplace_back(); // add a map to the array
+        v.back()[0].back().emplace("b", RValueCaster{});
+        v.back()[0].back().emplace("c", RValueCaster{});
+        v.back()[1].emplace_back(); // add a map to the array
+        v.back()[1].back().emplace("a", RValueCaster{});
+        return v;
+    });
+    static std::array<RValueCaster, 2> lva;
+    static std::unordered_map<std::string, RValueCaster> lvm{{"a", RValueCaster{}}, {"b", RValueCaster{}}};
+    static std::unordered_map<std::string, std::vector<std::list<std::array<RValueCaster, 2>>>> lvn;
+    lvn["a"].emplace_back(); // add a list
+    lvn["a"].back().emplace_back(); // add an array
+    lvn["a"].emplace_back(); // another list
+    lvn["a"].back().emplace_back(); // add an array
+    lvn["b"].emplace_back(); // add a list
+    lvn["b"].back().emplace_back(); // add an array
+    lvn["b"].back().emplace_back(); // add another array
+    m.def("cast_lv_vector", []() -> const decltype(lvv) & { return lvv; });
+    m.def("cast_lv_array", []() -> const decltype(lva) & { return lva; });
+    m.def("cast_lv_map", []() -> const decltype(lvm) & { return lvm; });
+    m.def("cast_lv_nested", []() -> const decltype(lvn) & { return lvn; });
+    // #853:
+    m.def("cast_unique_ptr_vector", []() {
+        std::vector<std::unique_ptr<UserType>> v;
+        v.emplace_back(new UserType{7});
+        v.emplace_back(new UserType{42});
+        return v;
+    });
+
+    // test_move_out_container
     struct MoveOutContainer {
         struct Value { int value; };
-
         std::list<Value> move_list() const { return {{0}, {1}, {2}}; }
     };
-
     py::class_<MoveOutContainer::Value>(m, "MoveOutContainerValue")
         .def_readonly("value", &MoveOutContainer::Value::value);
-
     py::class_<MoveOutContainer>(m, "MoveOutContainer")
         .def(py::init<>())
         .def_property_readonly("move_list", &MoveOutContainer::move_list);
 
+    // Class that can be move- and copy-constructed, but not assigned
+    struct NoAssign {
+        int value;
+
+        explicit NoAssign(int value = 0) : value(value) { }
+        NoAssign(const NoAssign &) = default;
+        NoAssign(NoAssign &&) = default;
+
+        NoAssign &operator=(const NoAssign &) = delete;
+        NoAssign &operator=(NoAssign &&) = delete;
+    };
     py::class_<NoAssign>(m, "NoAssign", "Class with no C++ assignment operators")
         .def(py::init<>())
         .def(py::init<int>());
 
 #ifdef PYBIND11_HAS_OPTIONAL
+    // test_optional
     m.attr("has_optional") = true;
 
     using opt_int = std::optional<int>;
@@ -101,6 +178,7 @@ TEST_SUBMODULE(stl, m) {
 #endif
 
 #ifdef PYBIND11_HAS_EXP_OPTIONAL
+    // test_exp_optional
     m.attr("has_exp_optional") = true;
 
     using exp_opt_int = std::experimental::optional<int>;
@@ -120,28 +198,33 @@ TEST_SUBMODULE(stl, m) {
 #endif
 
 #ifdef PYBIND11_HAS_VARIANT
+    static_assert(std::is_same<py::detail::variant_caster_visitor::result_type, py::handle>::value,
+                  "visitor::result_type is required by boost::variant in C++11 mode");
+
     struct visitor {
-        const char *operator()(int) { return "int"; }
-        const char *operator()(std::string) { return "std::string"; }
-        const char *operator()(double) { return "double"; }
-        const char *operator()(std::nullptr_t) { return "std::nullptr_t"; }
+        using result_type = const char *;
+
+        result_type operator()(int) { return "int"; }
+        result_type operator()(std::string) { return "std::string"; }
+        result_type operator()(double) { return "double"; }
+        result_type operator()(std::nullptr_t) { return "std::nullptr_t"; }
     };
 
-    m.def("load_variant", [](std::variant<int, std::string, double, std::nullptr_t> v) {
-        return std::visit(visitor(), v);
+    // test_variant
+    m.def("load_variant", [](variant<int, std::string, double, std::nullptr_t> v) {
+        return py::detail::visit_helper<variant>::call(visitor(), v);
     });
-
-    m.def("load_variant_2pass", [](std::variant<double, int> v) {
-        return std::visit(visitor(), v);
+    m.def("load_variant_2pass", [](variant<double, int> v) {
+        return py::detail::visit_helper<variant>::call(visitor(), v);
     });
-
     m.def("cast_variant", []() {
-        using V = std::variant<int, std::string>;
+        using V = variant<int, std::string>;
         return py::make_tuple(V(5), V("Hello"));
     });
 #endif
 
-    /// #528: templated constructor
+    // #528: templated constructor
+    // (no python tests: the test here is that this compiles)
     m.def("tpl_ctor_vector", [](std::vector<TplCtorClass> &) {});
     m.def("tpl_ctor_map", [](std::unordered_map<TplCtorClass, TplCtorClass> &) {});
     m.def("tpl_ctor_set", [](std::unordered_set<TplCtorClass> &) {});
@@ -162,4 +245,40 @@ TEST_SUBMODULE(stl, m) {
 
     // test_stl_pass_by_pointer
     m.def("stl_pass_by_pointer", [](std::vector<int>* v) { return *v; }, "v"_a=nullptr);
+
+    // #1258: pybind11/stl.h converts string to vector<string>
+    m.def("func_with_string_or_vector_string_arg_overload", [](std::vector<std::string>) { return 1; });
+    m.def("func_with_string_or_vector_string_arg_overload", [](std::list<std::string>) { return 2; });
+    m.def("func_with_string_or_vector_string_arg_overload", [](std::string) { return 3; });
+
+    class Placeholder {
+    public:
+        Placeholder() { print_created(this); }
+        Placeholder(const Placeholder &) = delete;
+        ~Placeholder() { print_destroyed(this); }
+    };
+    py::class_<Placeholder>(m, "Placeholder");
+
+    /// test_stl_vector_ownership
+    m.def("test_stl_ownership",
+          []() {
+              std::vector<Placeholder *> result;
+              result.push_back(new Placeholder());
+              return result;
+          },
+          py::return_value_policy::take_ownership);
+
+    m.def("array_cast_sequence", [](std::array<int, 3> x) { return x; });
+
+    /// test_issue_1561
+    struct Issue1561Inner { std::string data; };
+    struct Issue1561Outer { std::vector<Issue1561Inner> list; };
+
+    py::class_<Issue1561Inner>(m, "Issue1561Inner")
+        .def(py::init<std::string>())
+        .def_readwrite("data", &Issue1561Inner::data);
+
+    py::class_<Issue1561Outer>(m, "Issue1561Outer")
+        .def(py::init<>())
+        .def_readwrite("list", &Issue1561Outer::list);
 }
diff --git a/src/pybind11/tests/test_stl.py b/src/pybind11/tests/test_stl.py
index fdbca0d..2335cb9 100644
--- a/src/pybind11/tests/test_stl.py
+++ b/src/pybind11/tests/test_stl.py
@@ -2,25 +2,41 @@ import pytest
 
 from pybind11_tests import stl as m
 from pybind11_tests import UserType
+from pybind11_tests import ConstructorStats
 
 
 def test_vector(doc):
     """std::vector <-> list"""
-    l = m.cast_vector()
-    assert l == [1]
-    l.append(2)
-    assert m.load_vector(l)
-    assert m.load_vector(tuple(l))
+    lst = m.cast_vector()
+    assert lst == [1]
+    lst.append(2)
+    assert m.load_vector(lst)
+    assert m.load_vector(tuple(lst))
+
+    assert m.cast_bool_vector() == [True, False]
+    assert m.load_bool_vector([True, False])
 
     assert doc(m.cast_vector) == "cast_vector() -> List[int]"
     assert doc(m.load_vector) == "load_vector(arg0: List[int]) -> bool"
 
+    # Test regression caused by 936: pointers to stl containers weren't castable
+    assert m.cast_ptr_vector() == ["lvalue", "lvalue"]
+
+
+def test_deque(doc):
+    """std::deque <-> list"""
+    lst = m.cast_deque()
+    assert lst == [1]
+    lst.append(2)
+    assert m.load_deque(lst)
+    assert m.load_deque(tuple(lst))
+
 
 def test_array(doc):
     """std::array <-> list"""
-    l = m.cast_array()
-    assert l == [1, 2]
-    assert m.load_array(l)
+    lst = m.cast_array()
+    assert lst == [1, 2]
+    assert m.load_array(lst)
 
     assert doc(m.cast_array) == "cast_array() -> List[int[2]]"
     assert doc(m.load_array) == "load_array(arg0: List[int[2]]) -> bool"
@@ -28,9 +44,9 @@ def test_array(doc):
 
 def test_valarray(doc):
     """std::valarray <-> list"""
-    l = m.cast_valarray()
-    assert l == [1, 4, 9]
-    assert m.load_valarray(l)
+    lst = m.cast_valarray()
+    assert lst == [1, 4, 9]
+    assert m.load_valarray(lst)
 
     assert doc(m.cast_valarray) == "cast_valarray() -> List[int]"
     assert doc(m.load_valarray) == "load_valarray(arg0: List[int]) -> bool"
@@ -40,7 +56,9 @@ def test_map(doc):
     """std::map <-> dict"""
     d = m.cast_map()
     assert d == {"key": "value"}
+    assert "key" in d
     d["key2"] = "value2"
+    assert "key2" in d
     assert m.load_map(d)
 
     assert doc(m.cast_map) == "cast_map() -> Dict[str, str]"
@@ -58,6 +76,25 @@ def test_set(doc):
     assert doc(m.load_set) == "load_set(arg0: Set[str]) -> bool"
 
 
+def test_recursive_casting():
+    """Tests that stl casters preserve lvalue/rvalue context for container values"""
+    assert m.cast_rv_vector() == ["rvalue", "rvalue"]
+    assert m.cast_lv_vector() == ["lvalue", "lvalue"]
+    assert m.cast_rv_array() == ["rvalue", "rvalue", "rvalue"]
+    assert m.cast_lv_array() == ["lvalue", "lvalue"]
+    assert m.cast_rv_map() == {"a": "rvalue"}
+    assert m.cast_lv_map() == {"a": "lvalue", "b": "lvalue"}
+    assert m.cast_rv_nested() == [[[{"b": "rvalue", "c": "rvalue"}], [{"a": "rvalue"}]]]
+    assert m.cast_lv_nested() == {
+        "a": [[["lvalue", "lvalue"]], [["lvalue", "lvalue"]]],
+        "b": [[["lvalue", "lvalue"], ["lvalue", "lvalue"]]]
+    }
+
+    # Issue #853 test case:
+    z = m.cast_unique_ptr_vector()
+    assert z[0].value == 7 and z[1].value == 42
+
+
 def test_move_out_container():
     """Properties use the `reference_internal` policy by default. If the underlying function
     returns an rvalue, the policy is automatically changed to `move` to avoid referencing
@@ -139,7 +176,7 @@ def test_stl_pass_by_pointer(msg):
         m.stl_pass_by_pointer()  # default value is `nullptr`
     assert msg(excinfo.value) == """
         stl_pass_by_pointer(): incompatible function arguments. The following argument types are supported:
-            1. (v: List[int]=None) -> List[int]
+            1. (v: List[int] = None) -> List[int]
 
         Invoked with:
     """  # noqa: E501 line too long
@@ -148,9 +185,57 @@ def test_stl_pass_by_pointer(msg):
         m.stl_pass_by_pointer(None)
     assert msg(excinfo.value) == """
         stl_pass_by_pointer(): incompatible function arguments. The following argument types are supported:
-            1. (v: List[int]=None) -> List[int]
+            1. (v: List[int] = None) -> List[int]
 
         Invoked with: None
     """  # noqa: E501 line too long
 
     assert m.stl_pass_by_pointer([1, 2, 3]) == [1, 2, 3]
+
+
+def test_missing_header_message():
+    """Trying convert `list` to a `std::vector`, or vice versa, without including
+    <pybind11/stl.h> should result in a helpful suggestion in the error message"""
+    import pybind11_cross_module_tests as cm
+
+    expected_message = ("Did you forget to `#include <pybind11/stl.h>`? Or <pybind11/complex.h>,\n"
+                        "<pybind11/functional.h>, <pybind11/chrono.h>, etc. Some automatic\n"
+                        "conversions are optional and require extra headers to be included\n"
+                        "when compiling your pybind11 module.")
+
+    with pytest.raises(TypeError) as excinfo:
+        cm.missing_header_arg([1.0, 2.0, 3.0])
+    assert expected_message in str(excinfo.value)
+
+    with pytest.raises(TypeError) as excinfo:
+        cm.missing_header_return()
+    assert expected_message in str(excinfo.value)
+
+
+def test_function_with_string_and_vector_string_arg():
+    """Check if a string is NOT implicitly converted to a list, which was the
+    behavior before fix of issue #1258"""
+    assert m.func_with_string_or_vector_string_arg_overload(('A', 'B', )) == 2
+    assert m.func_with_string_or_vector_string_arg_overload(['A', 'B']) == 2
+    assert m.func_with_string_or_vector_string_arg_overload('A') == 3
+
+
+def test_stl_ownership():
+    cstats = ConstructorStats.get(m.Placeholder)
+    assert cstats.alive() == 0
+    r = m.test_stl_ownership()
+    assert len(r) == 1
+    del r
+    assert cstats.alive() == 0
+
+
+def test_array_cast_sequence():
+    assert m.array_cast_sequence((1, 2, 3)) == [1, 2, 3]
+
+
+def test_issue_1561():
+    """ check fix for issue #1561 """
+    bar = m.Issue1561Outer()
+    bar.list = [m.Issue1561Inner('bar')]
+    bar.list
+    assert bar.list[0].data == 'bar'
diff --git a/src/pybind11/tests/test_stl_binders.cpp b/src/pybind11/tests/test_stl_binders.cpp
index f636c0b..8688874 100644
--- a/src/pybind11/tests/test_stl_binders.cpp
+++ b/src/pybind11/tests/test_stl_binders.cpp
@@ -15,11 +15,6 @@
 #include <deque>
 #include <unordered_map>
 
-#ifdef _MSC_VER
-// We get some really long type names here which causes MSVC to emit warnings
-#  pragma warning(disable: 4503) // warning C4503: decorated name length exceeded, name was truncated
-#endif
-
 class El {
 public:
     El() = delete;
@@ -59,70 +54,76 @@ template <class Map> Map *times_ten(int n) {
     return m;
 }
 
-struct VStruct {
-    bool w;
-    uint32_t x;
-    double y;
-    bool z;
-};
+template <class NestMap> NestMap *times_hundred(int n) {
+    auto m = new NestMap();
+    for (int i = 1; i <= n; i++)
+        for (int j = 1; j <= n; j++)
+            (*m)[i].emplace(int(j*10), E_nc(100*j));
+    return m;
+}
 
-struct VUndeclStruct { //dtype not declared for this version
-    bool w;
-    uint32_t x;
-    double y;
-    bool z;
-};
+TEST_SUBMODULE(stl_binders, m) {
+    // test_vector_int
+    py::bind_vector<std::vector<unsigned int>>(m, "VectorInt", py::buffer_protocol());
 
-test_initializer stl_binder_vector([](py::module &m) {
+    // test_vector_custom
     py::class_<El>(m, "El")
         .def(py::init<int>());
-
-    py::bind_vector<std::vector<unsigned char>>(m, "VectorUChar", py::buffer_protocol());
-    py::bind_vector<std::vector<unsigned int>>(m, "VectorInt", py::buffer_protocol());
-    py::bind_vector<std::vector<bool>>(m, "VectorBool");
-
     py::bind_vector<std::vector<El>>(m, "VectorEl");
-
     py::bind_vector<std::vector<std::vector<El>>>(m, "VectorVectorEl");
 
-    m.def("create_undeclstruct", [m] () mutable {
-        py::bind_vector<std::vector<VUndeclStruct>>(m, "VectorUndeclStruct", py::buffer_protocol());
-    });
-
-    try {
-        py::module::import("numpy");
-    } catch (...) {
-        return;
-    }
-    PYBIND11_NUMPY_DTYPE(VStruct, w, x, y, z);
-    py::class_<VStruct>(m, "VStruct").def_readwrite("x", &VStruct::x);
-    py::bind_vector<std::vector<VStruct>>(m, "VectorStruct", py::buffer_protocol());
-    m.def("get_vectorstruct", [] {return std::vector<VStruct> {{0, 5, 3.0, 1}, {1, 30, -1e4, 0}};});
-});
-
-test_initializer stl_binder_map([](py::module &m) {
+    // test_map_string_double
     py::bind_map<std::map<std::string, double>>(m, "MapStringDouble");
     py::bind_map<std::unordered_map<std::string, double>>(m, "UnorderedMapStringDouble");
 
+    // test_map_string_double_const
     py::bind_map<std::map<std::string, double const>>(m, "MapStringDoubleConst");
     py::bind_map<std::unordered_map<std::string, double const>>(m, "UnorderedMapStringDoubleConst");
 
-});
-
-test_initializer stl_binder_noncopyable([](py::module &m) {
     py::class_<E_nc>(m, "ENC")
         .def(py::init<int>())
         .def_readwrite("value", &E_nc::value);
 
+    // test_noncopyable_containers
     py::bind_vector<std::vector<E_nc>>(m, "VectorENC");
     m.def("get_vnc", &one_to_n<std::vector<E_nc>>, py::return_value_policy::reference);
-
     py::bind_vector<std::deque<E_nc>>(m, "DequeENC");
     m.def("get_dnc", &one_to_n<std::deque<E_nc>>, py::return_value_policy::reference);
-
     py::bind_map<std::map<int, E_nc>>(m, "MapENC");
     m.def("get_mnc", &times_ten<std::map<int, E_nc>>, py::return_value_policy::reference);
-
     py::bind_map<std::unordered_map<int, E_nc>>(m, "UmapENC");
     m.def("get_umnc", &times_ten<std::unordered_map<int, E_nc>>, py::return_value_policy::reference);
-});
+    // Issue #1885: binding nested std::map<X, Container<E>> with E non-copyable
+    py::bind_map<std::map<int, std::vector<E_nc>>>(m, "MapVecENC");
+    m.def("get_nvnc", [](int n)
+        {
+            auto m = new std::map<int, std::vector<E_nc>>();
+            for (int i = 1; i <= n; i++)
+                for (int j = 1; j <= n; j++)
+                    (*m)[i].emplace_back(j);
+            return m;
+        }, py::return_value_policy::reference);
+    py::bind_map<std::map<int, std::map<int, E_nc>>>(m, "MapMapENC");
+    m.def("get_nmnc", &times_hundred<std::map<int, std::map<int, E_nc>>>, py::return_value_policy::reference);
+    py::bind_map<std::unordered_map<int, std::unordered_map<int, E_nc>>>(m, "UmapUmapENC");
+    m.def("get_numnc", &times_hundred<std::unordered_map<int, std::unordered_map<int, E_nc>>>, py::return_value_policy::reference);
+
+    // test_vector_buffer
+    py::bind_vector<std::vector<unsigned char>>(m, "VectorUChar", py::buffer_protocol());
+    // no dtype declared for this version:
+    struct VUndeclStruct { bool w; uint32_t x; double y; bool z; };
+    m.def("create_undeclstruct", [m] () mutable {
+        py::bind_vector<std::vector<VUndeclStruct>>(m, "VectorUndeclStruct", py::buffer_protocol());
+    });
+
+    // The rest depends on numpy:
+    try { py::module::import("numpy"); }
+    catch (...) { return; }
+
+    // test_vector_buffer_numpy
+    struct VStruct { bool w; uint32_t x; double y; bool z; };
+    PYBIND11_NUMPY_DTYPE(VStruct, w, x, y, z);
+    py::class_<VStruct>(m, "VStruct").def_readwrite("x", &VStruct::x);
+    py::bind_vector<std::vector<VStruct>>(m, "VectorStruct", py::buffer_protocol());
+    m.def("get_vectorstruct", [] {return std::vector<VStruct> {{0, 5, 3.0, 1}, {1, 30, -1e4, 0}};});
+}
diff --git a/src/pybind11/tests/test_stl_binders.py b/src/pybind11/tests/test_stl_binders.py
index 1d52b8b..c7b7e85 100644
--- a/src/pybind11/tests/test_stl_binders.py
+++ b/src/pybind11/tests/test_stl_binders.py
@@ -1,18 +1,21 @@
 import pytest
 import sys
+from pybind11_tests import stl_binders as m
 
 with pytest.suppress(ImportError):
     import numpy as np
 
 
 def test_vector_int():
-    from pybind11_tests import VectorInt
-
-    v_int = VectorInt([0, 0])
+    v_int = m.VectorInt([0, 0])
     assert len(v_int) == 2
     assert bool(v_int) is True
 
-    v_int2 = VectorInt([0, 0])
+    # test construction from a generator
+    v_int1 = m.VectorInt(x for x in range(5))
+    assert v_int1 == m.VectorInt([0, 1, 2, 3, 4])
+
+    v_int2 = m.VectorInt([0, 0])
     assert v_int == v_int2
     v_int2[1] = 1
     assert v_int != v_int2
@@ -28,85 +31,97 @@ def test_vector_int():
 
     v_int.append(99)
     v_int2[2:-2] = v_int
-    assert v_int2 == VectorInt([3, 2, 0, 0, 99, 2, 3])
+    assert v_int2 == m.VectorInt([3, 2, 0, 0, 99, 2, 3])
     del v_int2[1:3]
-    assert v_int2 == VectorInt([3, 0, 99, 2, 3])
+    assert v_int2 == m.VectorInt([3, 0, 99, 2, 3])
     del v_int2[0]
-    assert v_int2 == VectorInt([0, 99, 2, 3])
+    assert v_int2 == m.VectorInt([0, 99, 2, 3])
+
+    v_int2.extend(m.VectorInt([4, 5]))
+    assert v_int2 == m.VectorInt([0, 99, 2, 3, 4, 5])
+
+    v_int2.extend([6, 7])
+    assert v_int2 == m.VectorInt([0, 99, 2, 3, 4, 5, 6, 7])
+
+    # test error handling, and that the vector is unchanged
+    with pytest.raises(RuntimeError):
+        v_int2.extend([8, 'a'])
+
+    assert v_int2 == m.VectorInt([0, 99, 2, 3, 4, 5, 6, 7])
+
+    # test extending from a generator
+    v_int2.extend(x for x in range(5))
+    assert v_int2 == m.VectorInt([0, 99, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4])
 
+    # test negative indexing
+    assert v_int2[-1] == 4
+
+    # insert with negative index
+    v_int2.insert(-1, 88)
+    assert v_int2 == m.VectorInt([0, 99, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 88, 4])
+
+    # delete negative index
+    del v_int2[-1]
+    assert v_int2 == m.VectorInt([0, 99, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 88])
+
+    v_int2.clear()
+    assert len(v_int2) == 0
 
-# As of pypy 5.7.1, running this and the next test seems to trigger a segfault
 # related to the PyPy's buffer protocol.
 @pytest.unsupported_on_pypy
 def test_vector_buffer():
-    from pybind11_tests import VectorUChar, create_undeclstruct
     b = bytearray([1, 2, 3, 4])
-    v = VectorUChar(b)
+    v = m.VectorUChar(b)
     assert v[1] == 2
     v[2] = 5
-    m = memoryview(v)  # We expose the buffer interface
+    mv = memoryview(v)  # We expose the buffer interface
     if sys.version_info.major > 2:
-        assert m[2] == 5
-        m[2] = 6
+        assert mv[2] == 5
+        mv[2] = 6
     else:
-        assert m[2] == '\x05'
-        m[2] = '\x06'
+        assert mv[2] == '\x05'
+        mv[2] = '\x06'
     assert v[2] == 6
 
-    with pytest.raises(RuntimeError):
-        create_undeclstruct()  # Undeclared struct contents, no buffer interface
+    with pytest.raises(RuntimeError) as excinfo:
+        m.create_undeclstruct()  # Undeclared struct contents, no buffer interface
+    assert "NumPy type info missing for " in str(excinfo.value)
 
 
 @pytest.unsupported_on_pypy
 @pytest.requires_numpy
 def test_vector_buffer_numpy():
-    from pybind11_tests import VectorInt, VectorStruct, get_vectorstruct
-
     a = np.array([1, 2, 3, 4], dtype=np.int32)
     with pytest.raises(TypeError):
-        VectorInt(a)
+        m.VectorInt(a)
 
     a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]], dtype=np.uintc)
-    v = VectorInt(a[0, :])
+    v = m.VectorInt(a[0, :])
     assert len(v) == 4
     assert v[2] == 3
-    m = np.asarray(v)
-    m[2] = 5
+    ma = np.asarray(v)
+    ma[2] = 5
     assert v[2] == 5
 
-    v = VectorInt(a[:, 1])
+    v = m.VectorInt(a[:, 1])
     assert len(v) == 3
     assert v[2] == 10
 
-    v = get_vectorstruct()
+    v = m.get_vectorstruct()
     assert v[0].x == 5
-    m = np.asarray(v)
-    m[1]['x'] = 99
+    ma = np.asarray(v)
+    ma[1]['x'] = 99
     assert v[1].x == 99
 
-    v = VectorStruct(np.zeros(3, dtype=np.dtype([('w', 'bool'), ('x', 'I'),
-                                                 ('y', 'float64'), ('z', 'bool')], align=True)))
+    v = m.VectorStruct(np.zeros(3, dtype=np.dtype([('w', 'bool'), ('x', 'I'),
+                                                   ('y', 'float64'), ('z', 'bool')], align=True)))
     assert len(v) == 3
 
 
-def test_vector_custom():
-    from pybind11_tests import El, VectorEl, VectorVectorEl
-
-    v_a = VectorEl()
-    v_a.append(El(1))
-    v_a.append(El(2))
-    assert str(v_a) == "VectorEl[El{1}, El{2}]"
-
-    vv_a = VectorVectorEl()
-    vv_a.append(v_a)
-    vv_b = vv_a[0]
-    assert str(vv_b) == "VectorEl[El{1}, El{2}]"
-
-
 def test_vector_bool():
-    from pybind11_tests import VectorBool
+    import pybind11_cross_module_tests as cm
 
-    vv_c = VectorBool()
+    vv_c = cm.VectorBool()
     for i in range(10):
         vv_c.append(i % 2 == 0)
     for i in range(10):
@@ -114,18 +129,28 @@ def test_vector_bool():
     assert str(vv_c) == "VectorBool[1, 0, 1, 0, 1, 0, 1, 0, 1, 0]"
 
 
-def test_map_string_double():
-    from pybind11_tests import MapStringDouble, UnorderedMapStringDouble
+def test_vector_custom():
+    v_a = m.VectorEl()
+    v_a.append(m.El(1))
+    v_a.append(m.El(2))
+    assert str(v_a) == "VectorEl[El{1}, El{2}]"
 
-    m = MapStringDouble()
-    m['a'] = 1
-    m['b'] = 2.5
+    vv_a = m.VectorVectorEl()
+    vv_a.append(v_a)
+    vv_b = vv_a[0]
+    assert str(vv_b) == "VectorEl[El{1}, El{2}]"
+
+
+def test_map_string_double():
+    mm = m.MapStringDouble()
+    mm['a'] = 1
+    mm['b'] = 2.5
 
-    assert list(m) == ['a', 'b']
-    assert list(m.items()) == [('a', 1), ('b', 2.5)]
-    assert str(m) == "MapStringDouble{a: 1, b: 2.5}"
+    assert list(mm) == ['a', 'b']
+    assert list(mm.items()) == [('a', 1), ('b', 2.5)]
+    assert str(mm) == "MapStringDouble{a: 1, b: 2.5}"
 
-    um = UnorderedMapStringDouble()
+    um = m.UnorderedMapStringDouble()
     um['ua'] = 1.1
     um['ub'] = 2.6
 
@@ -135,35 +160,29 @@ def test_map_string_double():
 
 
 def test_map_string_double_const():
-    from pybind11_tests import MapStringDoubleConst, UnorderedMapStringDoubleConst
-
-    mc = MapStringDoubleConst()
+    mc = m.MapStringDoubleConst()
     mc['a'] = 10
     mc['b'] = 20.5
     assert str(mc) == "MapStringDoubleConst{a: 10, b: 20.5}"
 
-    umc = UnorderedMapStringDoubleConst()
+    umc = m.UnorderedMapStringDoubleConst()
     umc['a'] = 11
     umc['b'] = 21.5
 
     str(umc)
 
 
-def test_noncopyable_vector():
-    from pybind11_tests import get_vnc
-
-    vnc = get_vnc(5)
+def test_noncopyable_containers():
+    # std::vector
+    vnc = m.get_vnc(5)
     for i in range(0, 5):
         assert vnc[i].value == i + 1
 
     for i, j in enumerate(vnc, start=1):
         assert j.value == i
 
-
-def test_noncopyable_deque():
-    from pybind11_tests import get_dnc
-
-    dnc = get_dnc(5)
+    # std::deque
+    dnc = m.get_dnc(5)
     for i in range(0, 5):
         assert dnc[i].value == i + 1
 
@@ -172,11 +191,8 @@ def test_noncopyable_deque():
         assert(j.value == i)
         i += 1
 
-
-def test_noncopyable_map():
-    from pybind11_tests import get_mnc
-
-    mnc = get_mnc(5)
+    # std::map
+    mnc = m.get_mnc(5)
     for i in range(1, 6):
         assert mnc[i].value == 10 * i
 
@@ -187,11 +203,8 @@ def test_noncopyable_map():
 
     assert vsum == 150
 
-
-def test_noncopyable_unordered_map():
-    from pybind11_tests import get_umnc
-
-    mnc = get_umnc(5)
+    # std::unordered_map
+    mnc = m.get_umnc(5)
     for i in range(1, 6):
         assert mnc[i].value == 10 * i
 
@@ -201,3 +214,63 @@ def test_noncopyable_unordered_map():
         vsum += v.value
 
     assert vsum == 150
+
+    # nested std::map<std::vector>
+    nvnc = m.get_nvnc(5)
+    for i in range(1, 6):
+        for j in range(0, 5):
+            assert nvnc[i][j].value == j + 1
+
+    for k, v in nvnc.items():
+        for i, j in enumerate(v, start=1):
+            assert j.value == i
+
+    # nested std::map<std::map>
+    nmnc = m.get_nmnc(5)
+    for i in range(1, 6):
+        for j in range(10, 60, 10):
+            assert nmnc[i][j].value == 10 * j
+
+    vsum = 0
+    for k_o, v_o in nmnc.items():
+        for k_i, v_i in v_o.items():
+            assert v_i.value == 10 * k_i
+            vsum += v_i.value
+
+    assert vsum == 7500
+
+    # nested std::unordered_map<std::unordered_map>
+    numnc = m.get_numnc(5)
+    for i in range(1, 6):
+        for j in range(10, 60, 10):
+            assert numnc[i][j].value == 10 * j
+
+    vsum = 0
+    for k_o, v_o in numnc.items():
+        for k_i, v_i in v_o.items():
+            assert v_i.value == 10 * k_i
+            vsum += v_i.value
+
+    assert vsum == 7500
+
+
+def test_map_delitem():
+    mm = m.MapStringDouble()
+    mm['a'] = 1
+    mm['b'] = 2.5
+
+    assert list(mm) == ['a', 'b']
+    assert list(mm.items()) == [('a', 1), ('b', 2.5)]
+    del mm['a']
+    assert list(mm) == ['b']
+    assert list(mm.items()) == [('b', 2.5)]
+
+    um = m.UnorderedMapStringDouble()
+    um['ua'] = 1.1
+    um['ub'] = 2.6
+
+    assert sorted(list(um)) == ['ua', 'ub']
+    assert sorted(list(um.items())) == [('ua', 1.1), ('ub', 2.6)]
+    del um['ua']
+    assert sorted(list(um)) == ['ub']
+    assert sorted(list(um.items())) == [('ub', 2.6)]
diff --git a/src/pybind11/tests/test_tagbased_polymorphic.cpp b/src/pybind11/tests/test_tagbased_polymorphic.cpp
new file mode 100644
index 0000000..272e460
--- /dev/null
+++ b/src/pybind11/tests/test_tagbased_polymorphic.cpp
@@ -0,0 +1,136 @@
+/*
+    tests/test_tagbased_polymorphic.cpp -- test of polymorphic_type_hook
+
+    Copyright (c) 2018 Hudson River Trading LLC <opensource@hudson-trading.com>
+
+    All rights reserved. Use of this source code is governed by a
+    BSD-style license that can be found in the LICENSE file.
+*/
+
+#include "pybind11_tests.h"
+#include <pybind11/stl.h>
+
+struct Animal
+{
+    enum class Kind {
+        Unknown = 0,
+        Dog = 100, Labrador, Chihuahua, LastDog = 199,
+        Cat = 200, Panther, LastCat = 299
+    };
+    static const std::type_info* type_of_kind(Kind kind);
+    static std::string name_of_kind(Kind kind);
+
+    const Kind kind;
+    const std::string name;
+
+  protected:
+    Animal(const std::string& _name, Kind _kind)
+        : kind(_kind), name(_name)
+    {}
+};
+
+struct Dog : Animal
+{
+    Dog(const std::string& _name, Kind _kind = Kind::Dog) : Animal(_name, _kind) {}
+    std::string bark() const { return name_of_kind(kind) + " " + name + " goes " + sound; }
+    std::string sound = "WOOF!";
+};
+
+struct Labrador : Dog
+{
+    Labrador(const std::string& _name, int _excitement = 9001)
+        : Dog(_name, Kind::Labrador), excitement(_excitement) {}
+    int excitement;
+};
+
+struct Chihuahua : Dog
+{
+    Chihuahua(const std::string& _name) : Dog(_name, Kind::Chihuahua) { sound = "iyiyiyiyiyi"; }
+    std::string bark() const { return Dog::bark() + " and runs in circles"; }
+};
+
+struct Cat : Animal
+{
+    Cat(const std::string& _name, Kind _kind = Kind::Cat) : Animal(_name, _kind) {}
+    std::string purr() const { return "mrowr"; }
+};
+
+struct Panther : Cat
+{
+    Panther(const std::string& _name) : Cat(_name, Kind::Panther) {}
+    std::string purr() const { return "mrrrRRRRRR"; }
+};
+
+std::vector<std::unique_ptr<Animal>> create_zoo()
+{
+    std::vector<std::unique_ptr<Animal>> ret;
+    ret.emplace_back(new Labrador("Fido", 15000));
+
+    // simulate some new type of Dog that the Python bindings
+    // haven't been updated for; it should still be considered
+    // a Dog, not just an Animal.
+    ret.emplace_back(new Dog("Ginger", Dog::Kind(150)));
+
+    ret.emplace_back(new Chihuahua("Hertzl"));
+    ret.emplace_back(new Cat("Tiger", Cat::Kind::Cat));
+    ret.emplace_back(new Panther("Leo"));
+    return ret;
+}
+
+const std::type_info* Animal::type_of_kind(Kind kind)
+{
+    switch (kind) {
+        case Kind::Unknown: break;
+
+        case Kind::Dog: break;
+        case Kind::Labrador: return &typeid(Labrador);
+        case Kind::Chihuahua: return &typeid(Chihuahua);
+        case Kind::LastDog: break;
+
+        case Kind::Cat: break;
+        case Kind::Panther: return &typeid(Panther);
+        case Kind::LastCat: break;
+    }
+
+    if (kind >= Kind::Dog && kind <= Kind::LastDog) return &typeid(Dog);
+    if (kind >= Kind::Cat && kind <= Kind::LastCat) return &typeid(Cat);
+    return nullptr;
+}
+
+std::string Animal::name_of_kind(Kind kind)
+{
+    std::string raw_name = type_of_kind(kind)->name();
+    py::detail::clean_type_id(raw_name);
+    return raw_name;
+}
+
+namespace pybind11 {
+    template <typename itype>
+    struct polymorphic_type_hook<itype, detail::enable_if_t<std::is_base_of<Animal, itype>::value>>
+    {
+        static const void *get(const itype *src, const std::type_info*& type)
+        { type = src ? Animal::type_of_kind(src->kind) : nullptr; return src; }
+    };
+}
+
+TEST_SUBMODULE(tagbased_polymorphic, m) {
+    py::class_<Animal>(m, "Animal")
+        .def_readonly("name", &Animal::name);
+    py::class_<Dog, Animal>(m, "Dog")
+        .def(py::init<std::string>())
+        .def_readwrite("sound", &Dog::sound)
+        .def("bark", &Dog::bark);
+    py::class_<Labrador, Dog>(m, "Labrador")
+        .def(py::init<std::string, int>(), "name"_a, "excitement"_a = 9001)
+        .def_readwrite("excitement", &Labrador::excitement);
+    py::class_<Chihuahua, Dog>(m, "Chihuahua")
+        .def(py::init<std::string>())
+        .def("bark", &Chihuahua::bark);
+    py::class_<Cat, Animal>(m, "Cat")
+        .def(py::init<std::string>())
+        .def("purr", &Cat::purr);
+    py::class_<Panther, Cat>(m, "Panther")
+        .def(py::init<std::string>())
+        .def("purr", &Panther::purr);
+    m.def("create_zoo", &create_zoo);
+};
diff --git a/src/pybind11/tests/test_tagbased_polymorphic.py b/src/pybind11/tests/test_tagbased_polymorphic.py
new file mode 100644
index 0000000..2574d7d
--- /dev/null
+++ b/src/pybind11/tests/test_tagbased_polymorphic.py
@@ -0,0 +1,20 @@
+from pybind11_tests import tagbased_polymorphic as m
+
+
+def test_downcast():
+    zoo = m.create_zoo()
+    assert [type(animal) for animal in zoo] == [
+        m.Labrador, m.Dog, m.Chihuahua, m.Cat, m.Panther
+    ]
+    assert [animal.name for animal in zoo] == [
+        "Fido", "Ginger", "Hertzl", "Tiger", "Leo"
+    ]
+    zoo[1].sound = "woooooo"
+    assert [dog.bark() for dog in zoo[:3]] == [
+        "Labrador Fido goes WOOF!",
+        "Dog Ginger goes woooooo",
+        "Chihuahua Hertzl goes iyiyiyiyiyi and runs in circles"
+    ]
+    assert [cat.purr() for cat in zoo[3:]] == ["mrowr", "mrrrRRRRRR"]
+    zoo[0].excitement -= 1000
+    assert zoo[0].excitement == 14000
diff --git a/src/pybind11/tests/test_union.cpp b/src/pybind11/tests/test_union.cpp
new file mode 100644
index 0000000..7b98ea2
--- /dev/null
+++ b/src/pybind11/tests/test_union.cpp
@@ -0,0 +1,22 @@
+/*
+    tests/test_class.cpp -- test py::class_ definitions and basic functionality
+
+    Copyright (c) 2019 Roland Dreier <roland.dreier@gmail.com>
+
+    All rights reserved. Use of this source code is governed by a
+    BSD-style license that can be found in the LICENSE file.
+*/
+
+#include "pybind11_tests.h"
+
+TEST_SUBMODULE(union_, m) {
+    union TestUnion {
+        int value_int;
+        unsigned value_uint;
+    };
+
+    py::class_<TestUnion>(m, "TestUnion")
+        .def(py::init<>())
+        .def_readonly("as_int", &TestUnion::value_int)
+        .def_readwrite("as_uint", &TestUnion::value_uint);
+}
diff --git a/src/pybind11/tests/test_union.py b/src/pybind11/tests/test_union.py
new file mode 100644
index 0000000..e1866e7
--- /dev/null
+++ b/src/pybind11/tests/test_union.py
@@ -0,0 +1,8 @@
+from pybind11_tests import union_ as m
+
+
+def test_union():
+    instance = m.TestUnion()
+
+    instance.as_uint = 10
+    assert instance.as_int == 10
diff --git a/src/pybind11/tests/test_virtual_functions.cpp b/src/pybind11/tests/test_virtual_functions.cpp
index 899bba6..ccf018d 100644
--- a/src/pybind11/tests/test_virtual_functions.cpp
+++ b/src/pybind11/tests/test_virtual_functions.cpp
@@ -10,6 +10,7 @@
 #include "pybind11_tests.h"
 #include "constructor_stats.h"
 #include <pybind11/functional.h>
+#include <thread>
 
 /* This is an example class that we'll want to be able to extend from Python */
 class ExampleVirt  {
@@ -17,7 +18,7 @@ public:
     ExampleVirt(int state) : state(state) { print_created(this, state); }
     ExampleVirt(const ExampleVirt &e) : state(e.state) { print_copy_created(this); }
     ExampleVirt(ExampleVirt &&e) : state(e.state) { print_move_created(this); e.state = 0; }
-    ~ExampleVirt() { print_destroyed(this); }
+    virtual ~ExampleVirt() { print_destroyed(this); }
 
     virtual int run(int value) {
         py::print("Original implementation of "
@@ -128,6 +129,7 @@ private:
 
 class NCVirt {
 public:
+    virtual ~NCVirt() { }
     virtual NonCopyable get_noncopyable(int a, int b) { return NonCopyable(a, b); }
     virtual Movable get_movable(int a, int b) = 0;
 
@@ -145,16 +147,174 @@ class NCVirtTrampoline : public NCVirt {
     }
 };
 
-int runExampleVirt(ExampleVirt *ex, int value) {
-    return ex->run(value);
+struct Base {
+    /* for some reason MSVC2015 can't compile this if the function is pure virtual */
+    virtual std::string dispatch() const { return {}; };
+    virtual ~Base() = default;
+};
+
+struct DispatchIssue : Base {
+    virtual std::string dispatch() const {
+        PYBIND11_OVERLOAD_PURE(std::string, Base, dispatch, /* no arguments */);
+    }
+};
+
+static void test_gil() {
+    {
+        py::gil_scoped_acquire lock;
+        py::print("1st lock acquired");
+
+    }
+
+    {
+        py::gil_scoped_acquire lock;
+        py::print("2nd lock acquired");
+    }
+
 }
 
-bool runExampleVirtBool(ExampleVirt* ex) {
-    return ex->run_bool();
+static void test_gil_from_thread() {
+    py::gil_scoped_release release;
+
+    std::thread t(test_gil);
+    t.join();
 }
 
-void runExampleVirtVirtual(ExampleVirt *ex) {
-    ex->pure_virtual();
+
+// Forward declaration (so that we can put the main tests here; the inherited virtual approaches are
+// rather long).
+void initialize_inherited_virtuals(py::module &m);
+
+TEST_SUBMODULE(virtual_functions, m) {
+    // test_override
+    py::class_<ExampleVirt, PyExampleVirt>(m, "ExampleVirt")
+        .def(py::init<int>())
+        /* Reference original class in function definitions */
+        .def("run", &ExampleVirt::run)
+        .def("run_bool", &ExampleVirt::run_bool)
+        .def("pure_virtual", &ExampleVirt::pure_virtual);
+
+    py::class_<NonCopyable>(m, "NonCopyable")
+        .def(py::init<int, int>());
+
+    py::class_<Movable>(m, "Movable")
+        .def(py::init<int, int>());
+
+    // test_move_support
+#if !defined(__INTEL_COMPILER)
+    py::class_<NCVirt, NCVirtTrampoline>(m, "NCVirt")
+        .def(py::init<>())
+        .def("get_noncopyable", &NCVirt::get_noncopyable)
+        .def("get_movable", &NCVirt::get_movable)
+        .def("print_nc", &NCVirt::print_nc)
+        .def("print_movable", &NCVirt::print_movable);
+#endif
+
+    m.def("runExampleVirt", [](ExampleVirt *ex, int value) { return ex->run(value); });
+    m.def("runExampleVirtBool", [](ExampleVirt* ex) { return ex->run_bool(); });
+    m.def("runExampleVirtVirtual", [](ExampleVirt *ex) { ex->pure_virtual(); });
+
+    m.def("cstats_debug", &ConstructorStats::get<ExampleVirt>);
+    initialize_inherited_virtuals(m);
+
+    // test_alias_delay_initialization1
+    // don't invoke Python dispatch classes by default when instantiating C++ classes
+    // that were not extended on the Python side
+    struct A {
+        virtual ~A() {}
+        virtual void f() { py::print("A.f()"); }
+    };
+
+    struct PyA : A {
+        PyA() { py::print("PyA.PyA()"); }
+        ~PyA() { py::print("PyA.~PyA()"); }
+
+        void f() override {
+            py::print("PyA.f()");
+            // This convolution just gives a `void`, but tests that PYBIND11_TYPE() works to protect
+            // a type containing a ,
+            PYBIND11_OVERLOAD(PYBIND11_TYPE(typename std::enable_if<true, void>::type), A, f);
+        }
+    };
+
+    py::class_<A, PyA>(m, "A")
+        .def(py::init<>())
+        .def("f", &A::f);
+
+    m.def("call_f", [](A *a) { a->f(); });
+
+    // test_alias_delay_initialization2
+    // ... unless we explicitly request it, as in this example:
+    struct A2 {
+        virtual ~A2() {}
+        virtual void f() { py::print("A2.f()"); }
+    };
+
+    struct PyA2 : A2 {
+        PyA2() { py::print("PyA2.PyA2()"); }
+        ~PyA2() { py::print("PyA2.~PyA2()"); }
+        void f() override {
+            py::print("PyA2.f()");
+            PYBIND11_OVERLOAD(void, A2, f);
+        }
+    };
+
+    py::class_<A2, PyA2>(m, "A2")
+        .def(py::init_alias<>())
+        .def(py::init([](int) { return new PyA2(); }))
+        .def("f", &A2::f);
+
+    m.def("call_f", [](A2 *a2) { a2->f(); });
+
+    // test_dispatch_issue
+    // #159: virtual function dispatch has problems with similar-named functions
+    py::class_<Base, DispatchIssue>(m, "DispatchIssue")
+        .def(py::init<>())
+        .def("dispatch", &Base::dispatch);
+
+    m.def("dispatch_issue_go", [](const Base * b) { return b->dispatch(); });
+
+    // test_override_ref
+    // #392/397: overriding reference-returning functions
+    class OverrideTest {
+    public:
+        struct A { std::string value = "hi"; };
+        std::string v;
+        A a;
+        explicit OverrideTest(const std::string &v) : v{v} {}
+        virtual std::string str_value() { return v; }
+        virtual std::string &str_ref() { return v; }
+        virtual A A_value() { return a; }
+        virtual A &A_ref() { return a; }
+        virtual ~OverrideTest() = default;
+    };
+
+    class PyOverrideTest : public OverrideTest {
+    public:
+        using OverrideTest::OverrideTest;
+        std::string str_value() override { PYBIND11_OVERLOAD(std::string, OverrideTest, str_value); }
+        // Not allowed (uncommenting should hit a static_assert failure): we can't get a reference
+        // to a python numeric value, since we only copy values in the numeric type caster:
+//      std::string &str_ref() override { PYBIND11_OVERLOAD(std::string &, OverrideTest, str_ref); }
+        // But we can work around it like this:
+    private:
+        std::string _tmp;
+        std::string str_ref_helper() { PYBIND11_OVERLOAD(std::string, OverrideTest, str_ref); }
+    public:
+        std::string &str_ref() override { return _tmp = str_ref_helper(); }
+
+        A A_value() override { PYBIND11_OVERLOAD(A, OverrideTest, A_value); }
+        A &A_ref() override { PYBIND11_OVERLOAD(A &, OverrideTest, A_ref); }
+    };
+
+    py::class_<OverrideTest::A>(m, "OverrideTest_A")
+        .def_readwrite("value", &OverrideTest::A::value);
+    py::class_<OverrideTest, PyOverrideTest>(m, "OverrideTest")
+        .def(py::init<const std::string &>())
+        .def("str_value", &OverrideTest::str_value)
+//      .def("str_ref", &OverrideTest::str_ref)
+        .def("A_value", &OverrideTest::A_value)
+        .def("A_ref", &OverrideTest::A_ref);
 }
 
 
@@ -179,6 +339,7 @@ public: \
         return say_something(1) + " " + std::to_string(unlucky_number()); \
     }
 A_METHODS
+    virtual ~A_Repeat() = default;
 };
 class B_Repeat : public A_Repeat {
 #define B_METHODS \
@@ -203,7 +364,7 @@ D_METHODS
 };
 
 // Base classes for templated inheritance trampolines.  Identical to the repeat-everything version:
-class A_Tpl { A_METHODS };
+class A_Tpl { A_METHODS; virtual ~A_Tpl() = default; };
 class B_Tpl : public A_Tpl { B_METHODS };
 class C_Tpl : public B_Tpl { C_METHODS };
 class D_Tpl : public C_Tpl { D_METHODS };
@@ -279,8 +440,9 @@ public:
 };
 */
 
-
 void initialize_inherited_virtuals(py::module &m) {
+    // test_inherited_virtuals
+
     // Method 1: repeat
     py::class_<A_Repeat, PyA_Repeat>(m, "A_Repeat")
         .def(py::init<>())
@@ -295,6 +457,7 @@ void initialize_inherited_virtuals(py::module &m) {
     py::class_<D_Repeat, C_Repeat, PyD_Repeat>(m, "D_Repeat")
         .def(py::init<>());
 
+    // test_
     // Method 2: Templated trampolines
     py::class_<A_Tpl, PyA_Tpl<>>(m, "A_Tpl")
         .def(py::init<>())
@@ -309,139 +472,8 @@ void initialize_inherited_virtuals(py::module &m) {
     py::class_<D_Tpl, C_Tpl, PyB_Tpl<D_Tpl>>(m, "D_Tpl")
         .def(py::init<>());
 
-};
 
-struct Base {
-    /* for some reason MSVC2015 can't compile this if the function is pure virtual */
-    virtual std::string dispatch() const { return {}; };
+    // Fix issue #1454 (crash when acquiring/releasing GIL on another thread in Python 2.7)
+    m.def("test_gil", &test_gil);
+    m.def("test_gil_from_thread", &test_gil_from_thread);
 };
-
-struct DispatchIssue : Base {
-    virtual std::string dispatch() const {
-        PYBIND11_OVERLOAD_PURE(std::string, Base, dispatch, /* no arguments */);
-    }
-};
-
-TEST_SUBMODULE(virtual_functions, m) {
-    py::class_<ExampleVirt, PyExampleVirt>(m, "ExampleVirt")
-        .def(py::init<int>())
-        /* Reference original class in function definitions */
-        .def("run", &ExampleVirt::run)
-        .def("run_bool", &ExampleVirt::run_bool)
-        .def("pure_virtual", &ExampleVirt::pure_virtual);
-
-    py::class_<NonCopyable>(m, "NonCopyable")
-        .def(py::init<int, int>());
-
-    py::class_<Movable>(m, "Movable")
-        .def(py::init<int, int>());
-
-#if !defined(__INTEL_COMPILER)
-    py::class_<NCVirt, NCVirtTrampoline>(m, "NCVirt")
-        .def(py::init<>())
-        .def("get_noncopyable", &NCVirt::get_noncopyable)
-        .def("get_movable", &NCVirt::get_movable)
-        .def("print_nc", &NCVirt::print_nc)
-        .def("print_movable", &NCVirt::print_movable);
-#endif
-
-    m.def("runExampleVirt", &runExampleVirt);
-    m.def("runExampleVirtBool", &runExampleVirtBool);
-    m.def("runExampleVirtVirtual", &runExampleVirtVirtual);
-
-    m.def("cstats_debug", &ConstructorStats::get<ExampleVirt>);
-    initialize_inherited_virtuals(m);
-
-    // test_alias_delay_initialization1
-    // don't invoke Python dispatch classes by default when instantiating C++ classes
-    // that were not extended on the Python side
-    struct A {
-        virtual ~A() {}
-        virtual void f() { py::print("A.f()"); }
-    };
-
-    struct PyA : A {
-        PyA() { py::print("PyA.PyA()"); }
-        ~PyA() { py::print("PyA.~PyA()"); }
-
-        void f() override {
-            py::print("PyA.f()");
-            PYBIND11_OVERLOAD(void, A, f);
-        }
-    };
-
-    py::class_<A, PyA>(m, "A")
-        .def(py::init<>())
-        .def("f", &A::f);
-
-    m.def("call_f", [](A *a) { a->f(); });
-
-    // test_alias_delay_initialization2
-    // ... unless we explicitly request it, as in this example:
-    struct A2 {
-        virtual ~A2() {}
-        virtual void f() { py::print("A2.f()"); }
-    };
-
-    struct PyA2 : A2 {
-        PyA2() { py::print("PyA2.PyA2()"); }
-        ~PyA2() { py::print("PyA2.~PyA2()"); }
-        void f() override {
-            py::print("PyA2.f()");
-            PYBIND11_OVERLOAD(void, A2, f);
-        }
-    };
-
-    py::class_<A2, PyA2>(m, "A2")
-        .def(py::init_alias<>())
-        .def("f", &A2::f);
-
-    m.def("call_f", [](A2 *a2) { a2->f(); });
-
-    // #159: virtual function dispatch has problems with similar-named functions
-    py::class_<Base, DispatchIssue>(m, "DispatchIssue")
-        .def(py::init<>())
-        .def("dispatch", &Base::dispatch);
-
-    m.def("dispatch_issue_go", [](const Base * b) { return b->dispatch(); });
-
-    // #392/397: overridding reference-returning functions
-    class OverrideTest {
-    public:
-        struct A { std::string value = "hi"; };
-        std::string v;
-        A a;
-        explicit OverrideTest(const std::string &v) : v{v} {}
-        virtual std::string str_value() { return v; }
-        virtual std::string &str_ref() { return v; }
-        virtual A A_value() { return a; }
-        virtual A &A_ref() { return a; }
-    };
-
-    class PyOverrideTest : public OverrideTest {
-    public:
-        using OverrideTest::OverrideTest;
-        std::string str_value() override { PYBIND11_OVERLOAD(std::string, OverrideTest, str_value); }
-        // Not allowed (uncommenting should hit a static_assert failure): we can't get a reference
-        // to a python numeric value, since we only copy values in the numeric type caster:
-//      std::string &str_ref() override { PYBIND11_OVERLOAD(std::string &, OverrideTest, str_ref); }
-        // But we can work around it like this:
-    private:
-        std::string _tmp;
-        std::string str_ref_helper() { PYBIND11_OVERLOAD(std::string, OverrideTest, str_ref); }
-    public:
-        std::string &str_ref() override { return _tmp = str_ref_helper(); }
-
-        A A_value() override { PYBIND11_OVERLOAD(A, OverrideTest, A_value); }
-        A &A_ref() override { PYBIND11_OVERLOAD(A &, OverrideTest, A_ref); }
-    };
-
-    py::class_<OverrideTest::A>(m, "OverrideTest_A")
-        .def_readwrite("value", &OverrideTest::A::value);
-    py::class_<OverrideTest, PyOverrideTest>(m, "OverrideTest")
-        .def(py::init<const std::string &>())
-        .def("str_value", &OverrideTest::str_value)
-//      .def("str_ref", &OverrideTest::str_ref)
-        .def("A_value", &OverrideTest::A_value)
-        .def("A_ref", &OverrideTest::A_ref);
-}
diff --git a/src/pybind11/tests/test_virtual_functions.py b/src/pybind11/tests/test_virtual_functions.py
index 7d1698d..5ce9abd 100644
--- a/src/pybind11/tests/test_virtual_functions.py
+++ b/src/pybind11/tests/test_virtual_functions.py
@@ -128,11 +128,19 @@ def test_alias_delay_initialization2(capture):
         m.call_f(a2)
         del a2
         pytest.gc_collect()
+        a3 = m.A2(1)
+        m.call_f(a3)
+        del a3
+        pytest.gc_collect()
     assert capture == """
         PyA2.PyA2()
         PyA2.f()
         A2.f()
         PyA2.~PyA2()
+        PyA2.PyA2()
+        PyA2.f()
+        A2.f()
+        PyA2.~PyA2()
     """
 
     # Python subclass version
@@ -149,7 +157,92 @@ def test_alias_delay_initialization2(capture):
     """
 
 
-def test_inheriting_repeat():
+# PyPy: Reference count > 1 causes call with noncopyable instance
+# to fail in ncv1.print_nc()
+@pytest.unsupported_on_pypy
+@pytest.mark.skipif(not hasattr(m, "NCVirt"), reason="NCVirt test broken on ICPC")
+def test_move_support():
+    class NCVirtExt(m.NCVirt):
+        def get_noncopyable(self, a, b):
+            # Constructs and returns a new instance:
+            nc = m.NonCopyable(a * a, b * b)
+            return nc
+
+        def get_movable(self, a, b):
+            # Return a referenced copy
+            self.movable = m.Movable(a, b)
+            return self.movable
+
+    class NCVirtExt2(m.NCVirt):
+        def get_noncopyable(self, a, b):
+            # Keep a reference: this is going to throw an exception
+            self.nc = m.NonCopyable(a, b)
+            return self.nc
+
+        def get_movable(self, a, b):
+            # Return a new instance without storing it
+            return m.Movable(a, b)
+
+    ncv1 = NCVirtExt()
+    assert ncv1.print_nc(2, 3) == "36"
+    assert ncv1.print_movable(4, 5) == "9"
+    ncv2 = NCVirtExt2()
+    assert ncv2.print_movable(7, 7) == "14"
+    # Don't check the exception message here because it differs under debug/non-debug mode
+    with pytest.raises(RuntimeError):
+        ncv2.print_nc(9, 9)
+
+    nc_stats = ConstructorStats.get(m.NonCopyable)
+    mv_stats = ConstructorStats.get(m.Movable)
+    assert nc_stats.alive() == 1
+    assert mv_stats.alive() == 1
+    del ncv1, ncv2
+    assert nc_stats.alive() == 0
+    assert mv_stats.alive() == 0
+    assert nc_stats.values() == ['4', '9', '9', '9']
+    assert mv_stats.values() == ['4', '5', '7', '7']
+    assert nc_stats.copy_constructions == 0
+    assert mv_stats.copy_constructions == 1
+    assert nc_stats.move_constructions >= 0
+    assert mv_stats.move_constructions >= 0
+
+
+def test_dispatch_issue(msg):
+    """#159: virtual function dispatch has problems with similar-named functions"""
+    class PyClass1(m.DispatchIssue):
+        def dispatch(self):
+            return "Yay.."
+
+    class PyClass2(m.DispatchIssue):
+        def dispatch(self):
+            with pytest.raises(RuntimeError) as excinfo:
+                super(PyClass2, self).dispatch()
+            assert msg(excinfo.value) == 'Tried to call pure virtual function "Base::dispatch"'
+
+            p = PyClass1()
+            return m.dispatch_issue_go(p)
+
+    b = PyClass2()
+    assert m.dispatch_issue_go(b) == "Yay.."
+
+
+def test_override_ref():
+    """#392/397: overriding reference-returning functions"""
+    o = m.OverrideTest("asdf")
+
+    # Not allowed (see associated .cpp comment)
+    # i = o.str_ref()
+    # assert o.str_ref() == "asdf"
+    assert o.str_value() == "asdf"
+
+    assert o.A_value().value == "hi"
+    a = o.A_ref()
+    assert a.value == "hi"
+    a.value = "bye"
+    assert a.value == "bye"
+
+
+def test_inherited_virtuals():
     class AR(m.A_Repeat):
         def unlucky_number(self):
             return 99
@@ -278,86 +371,7 @@ def test_inheriting_repeat():
     assert obj.say_everything() == "BT -7"
 
 
-# PyPy: Reference count > 1 causes call with noncopyable instance
-# to fail in ncv1.print_nc()
-@pytest.unsupported_on_pypy
-@pytest.mark.skipif(not hasattr(m, "NCVirt"), reason="NCVirt test broken on ICPC")
-def test_move_support():
-    class NCVirtExt(m.NCVirt):
-        def get_noncopyable(self, a, b):
-            # Constructs and returns a new instance:
-            nc = m.NonCopyable(a * a, b * b)
-            return nc
-
-        def get_movable(self, a, b):
-            # Return a referenced copy
-            self.movable = m.Movable(a, b)
-            return self.movable
-
-    class NCVirtExt2(m.NCVirt):
-        def get_noncopyable(self, a, b):
-            # Keep a reference: this is going to throw an exception
-            self.nc = m.NonCopyable(a, b)
-            return self.nc
-
-        def get_movable(self, a, b):
-            # Return a new instance without storing it
-            return m.Movable(a, b)
-
-    ncv1 = NCVirtExt()
-    assert ncv1.print_nc(2, 3) == "36"
-    assert ncv1.print_movable(4, 5) == "9"
-    ncv2 = NCVirtExt2()
-    assert ncv2.print_movable(7, 7) == "14"
-    # Don't check the exception message here because it differs under debug/non-debug mode
-    with pytest.raises(RuntimeError):
-        ncv2.print_nc(9, 9)
-
-    nc_stats = ConstructorStats.get(m.NonCopyable)
-    mv_stats = ConstructorStats.get(m.Movable)
-    assert nc_stats.alive() == 1
-    assert mv_stats.alive() == 1
-    del ncv1, ncv2
-    assert nc_stats.alive() == 0
-    assert mv_stats.alive() == 0
-    assert nc_stats.values() == ['4', '9', '9', '9']
-    assert mv_stats.values() == ['4', '5', '7', '7']
-    assert nc_stats.copy_constructions == 0
-    assert mv_stats.copy_constructions == 1
-    assert nc_stats.move_constructions >= 0
-    assert mv_stats.move_constructions >= 0
-
-
-def test_dispatch_issue(msg):
-    """#159: virtual function dispatch has problems with similar-named functions"""
-    class PyClass1(m.DispatchIssue):
-        def dispatch(self):
-            return "Yay.."
-
-    class PyClass2(m.DispatchIssue):
-        def dispatch(self):
-            with pytest.raises(RuntimeError) as excinfo:
-                super(PyClass2, self).dispatch()
-            assert msg(excinfo.value) == 'Tried to call pure virtual function "Base::dispatch"'
-
-            p = PyClass1()
-            return m.dispatch_issue_go(p)
-
-    b = PyClass2()
-    assert m.dispatch_issue_go(b) == "Yay.."
-
-
-def test_override_ref():
-    """#392/397: overridding reference-returning functions"""
-    o = m.OverrideTest("asdf")
-
-    # Not allowed (see associated .cpp comment)
-    # i = o.str_ref()
-    # assert o.str_ref() == "asdf"
-    assert o.str_value() == "asdf"
-
-    assert o.A_value().value == "hi"
-    a = o.A_ref()
-    assert a.value == "hi"
-    a.value = "bye"
-    assert a.value == "bye"
+def test_issue_1454():
+    # Fix issue #1454 (crash when acquiring/releasing GIL on another thread in Python 2.7)
+    m.test_gil()
+    m.test_gil_from_thread()
diff --git a/src/pybind11/tools/FindPythonLibsNew.cmake b/src/pybind11/tools/FindPythonLibsNew.cmake
index dc44a9d..9ea6036 100644
--- a/src/pybind11/tools/FindPythonLibsNew.cmake
+++ b/src/pybind11/tools/FindPythonLibsNew.cmake
@@ -1,5 +1,5 @@
 # - Find python libraries
-# This module finds the libraries corresponding to the Python interpeter
+# This module finds the libraries corresponding to the Python interpreter
 # FindPythonInterp provides.
 # This code sets the following variables:
 #
@@ -50,7 +50,8 @@
 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #=============================================================================
 
-if(PYTHONLIBS_FOUND)
+# Checking for the extension makes sure that `LibsNew` was found and not just `Libs`.
+if(PYTHONLIBS_FOUND AND PYTHON_MODULE_EXTENSION)
     return()
 endif()
 
@@ -63,6 +64,7 @@ endif()
 
 if(NOT PYTHONINTERP_FOUND)
     set(PYTHONLIBS_FOUND FALSE)
+    set(PythonLibsNew_FOUND FALSE)
     return()
 endif()
 
@@ -95,10 +97,14 @@ if(NOT _PYTHON_SUCCESS MATCHES 0)
             "Python config failure:\n${_PYTHON_ERROR_VALUE}")
     endif()
     set(PYTHONLIBS_FOUND FALSE)
+    set(PythonLibsNew_FOUND FALSE)
     return()
 endif()
 
 # Convert the process output into a list
+if(WIN32)
+    string(REGEX REPLACE "\\\\" "/" _PYTHON_VALUES ${_PYTHON_VALUES})
+endif()
 string(REGEX REPLACE ";" "\\\\;" _PYTHON_VALUES ${_PYTHON_VALUES})
 string(REGEX REPLACE "\n" ";" _PYTHON_VALUES ${_PYTHON_VALUES})
 list(GET _PYTHON_VALUES 0 _PYTHON_VERSION_LIST)
@@ -123,6 +129,7 @@ if(CMAKE_SIZEOF_VOID_P AND (NOT "${PYTHON_SIZEOF_VOID_P}" STREQUAL "${CMAKE_SIZE
             "chosen compiler is  ${_CMAKE_BITS}-bit")
     endif()
     set(PYTHONLIBS_FOUND FALSE)
+    set(PythonLibsNew_FOUND FALSE)
     return()
 endif()
 
@@ -133,11 +140,11 @@ list(GET _PYTHON_VERSION_LIST 1 PYTHON_VERSION_MINOR)
 list(GET _PYTHON_VERSION_LIST 2 PYTHON_VERSION_PATCH)
 
 # Make sure all directory separators are '/'
-string(REGEX REPLACE "\\\\" "/" PYTHON_PREFIX ${PYTHON_PREFIX})
-string(REGEX REPLACE "\\\\" "/" PYTHON_INCLUDE_DIR ${PYTHON_INCLUDE_DIR})
-string(REGEX REPLACE "\\\\" "/" PYTHON_SITE_PACKAGES ${PYTHON_SITE_PACKAGES})
+string(REGEX REPLACE "\\\\" "/" PYTHON_PREFIX "${PYTHON_PREFIX}")
+string(REGEX REPLACE "\\\\" "/" PYTHON_INCLUDE_DIR "${PYTHON_INCLUDE_DIR}")
+string(REGEX REPLACE "\\\\" "/" PYTHON_SITE_PACKAGES "${PYTHON_SITE_PACKAGES}")
 
-if(CMAKE_HOST_WIN32)
+if(CMAKE_HOST_WIN32 AND NOT (MINGW AND DEFINED ENV{MSYSTEM}))
     set(PYTHON_LIBRARY
         "${PYTHON_PREFIX}/libs/Python${PYTHON_LIBRARY_SUFFIX}.lib")
 
@@ -192,3 +199,4 @@ find_package_message(PYTHON
     "${PYTHON_EXECUTABLE}${PYTHON_VERSION}")
 
 set(PYTHONLIBS_FOUND TRUE)
+set(PythonLibsNew_FOUND TRUE)
diff --git a/src/pybind11/tools/check-style.sh b/src/pybind11/tools/check-style.sh
index 050482d..0a9f7d2 100755
--- a/src/pybind11/tools/check-style.sh
+++ b/src/pybind11/tools/check-style.sh
@@ -1,7 +1,7 @@
 #!/bin/bash
-# 
+#
 # Script to check include/test code for common pybind11 code style errors.
-# 
+#
 # This script currently checks for
 #
 # 1. use of tabs instead of spaces
@@ -10,73 +10,61 @@
 # 4. missing space between keyword and parenthesis, e.g.: for(, if(, while(
 # 5. Missing space between right parenthesis and brace, e.g. 'for (...){'
 # 6. opening brace on its own line. It should always be on the same line as the
-#    if/while/for/do statment.
-# 
+#    if/while/for/do statement.
+#
 # Invoke as: tools/check-style.sh
 #
 
-errors=0
+check_style_errors=0
 IFS=$'\n'
-found=
-# The mt=41 sets a red background for matched tabs:
-GREP_COLORS='mt=41' GREP_COLOR='41' grep $'\t' include tests/*.{cpp,py,h} docs/*.rst -rn --color=always |
-        while read f; do
-    if [ -z "$found" ]; then
-        echo -e '\033[31m\033[01mError: found tabs instead of spaces in the following files:\033[0m'
-        found=1
-        errors=1
-    fi
-
-    echo "    $f"
-done
-
-found=
-grep -IUlr $'\r' include tests/*.{cpp,py,h} docs/*.rst --color=always |
-        while read f; do
-    if [ -z "$found" ]; then
-        echo -e '\033[31m\033[01mError: found CRLF characters in the following files:\033[0m'
-        found=1
-        errors=1
-    fi
-
-    echo "    $f"
-done
 
-found=
-# The mt=41 sets a red background for matched trailing spaces
-GREP_COLORS='mt=41' GREP_COLOR='41' grep '[[:blank:]]\+$' include tests/*.{cpp,py,h} docs/*.rst -rn --color=always |
-        while read f; do
-    if [ -z "$found" ]; then
-        echo -e '\033[31m\033[01mError: found trailing spaces in the following files:\033[0m'
-        found=1
-        errors=1
-    fi
+found="$( GREP_COLORS='mt=41' GREP_COLOR='41' grep $'\t' include tests/*.{cpp,py,h} docs/*.rst -rn --color=always )"
+if [ -n "$found" ]; then
+    # The mt=41 sets a red background for matched tabs:
+    echo -e '\033[31;01mError: found tab characters in the following files:\033[0m'
+    check_style_errors=1
+    echo "$found" | sed -e 's/^/    /'
+fi
 
-    echo "    $f"
-done
 
-found=
-grep '\<\(if\|for\|while\|catch\)(\|){' include tests/*.{cpp,py,h} -rn --color=always |
-        while read line; do
-    if [ -z "$found" ]; then
-        echo -e '\033[31m\033[01mError: found the following coding style problems:\033[0m'
-        found=1
-        errors=1
-    fi
+found="$( grep -IUlr $'\r' include tests/*.{cpp,py,h} docs/*.rst --color=always )"
+if [ -n "$found" ]; then
+    echo -e '\033[31;01mError: found CRLF characters in the following files:\033[0m'
+    check_style_errors=1
+    echo "$found" | sed -e 's/^/    /'
+fi
 
-    echo "    $line"
-done
+found="$(GREP_COLORS='mt=41' GREP_COLOR='41' grep '[[:blank:]]\+$' include tests/*.{cpp,py,h} docs/*.rst -rn --color=always )"
+if [ -n "$found" ]; then
+    # The mt=41 sets a red background for matched trailing spaces
+    echo -e '\033[31;01mError: found trailing spaces in the following files:\033[0m'
+    check_style_errors=1
+    echo "$found" | sed -e 's/^/    /'
+fi
 
-found=
-GREP_COLORS='mt=41' GREP_COLOR='41' grep '^\s*{\s*$' include docs/*.rst -rn --color=always |
-        while read f; do
-    if [ -z "$found" ]; then
-        echo -e '\033[31m\033[01mError: braces should occur on the same line as the if/while/.. statement. Found issues in the following files: \033[0m'
-        found=1
-        errors=1
-    fi
+found="$(grep '\<\(if\|for\|while\|catch\)(\|){' include tests/*.{cpp,h} -rn --color=always)"
+if [ -n "$found" ]; then
+    echo -e '\033[31;01mError: found the following coding style problems:\033[0m'
+    check_style_errors=1
+    echo "$found" | sed -e 's/^/    /'
+fi
 
-    echo "    $f"
-done
+found="$(awk '
+function prefix(filename, lineno) {
+    return "    \033[35m" filename "\033[36m:\033[32m" lineno "\033[36m:\033[0m"
+}
+function mark(pattern, string) { sub(pattern, "\033[01;31m&\033[0m", string); return string }
+last && /^\s*{/ {
+    print prefix(FILENAME, FNR-1) mark("\\)\\s*$", last)
+    print prefix(FILENAME, FNR)   mark("^\\s*{", $0)
+    last=""
+}
+{ last = /(if|for|while|catch|switch)\s*\(.*\)\s*$/ ? $0 : "" }
+' $(find include -type f) tests/*.{cpp,h} docs/*.rst)"
+if [ -n "$found" ]; then
+    check_style_errors=1
+    echo -e '\033[31;01mError: braces should occur on the same line as the if/while/.. statement. Found issues in the following files:\033[0m'
+    echo "$found"
+fi
 
-exit $errors
+exit $check_style_errors
diff --git a/src/pybind11/tools/mkdoc.py b/src/pybind11/tools/mkdoc.py
old mode 100644
new mode 100755
index 1fd8cce..44164af
--- a/src/pybind11/tools/mkdoc.py
+++ b/src/pybind11/tools/mkdoc.py
@@ -14,6 +14,7 @@ import textwrap
 from clang import cindex
 from clang.cindex import CursorKind
 from collections import OrderedDict
+from glob import glob
 from threading import Thread, Semaphore
 from multiprocessing import cpu_count
 
@@ -40,6 +41,10 @@ PRINT_LIST = [
     CursorKind.FIELD_DECL
 ]
 
+PREFIX_BLACKLIST = [
+    CursorKind.TRANSLATION_UNIT
+]
+
 CPP_OPERATORS = {
     '<=': 'le', '>=': 'ge', '==': 'eq', '!=': 'ne', '[]': 'array',
     '+=': 'iadd', '-=': 'isub', '*=': 'imul', '/=': 'idiv', '%=':
@@ -56,10 +61,13 @@ CPP_OPERATORS = OrderedDict(
 job_count = cpu_count()
 job_semaphore = Semaphore(job_count)
 
-output = []
+
+class NoFilenamesError(ValueError):
+    pass
+
 
 def d(s):
-    return s.decode('utf8')
+    return s if isinstance(s, str) else s.decode('utf8')
 
 
 def sanitize_name(name):
@@ -182,18 +190,18 @@ def process_comment(comment):
     return result.rstrip().lstrip('\n')
 
 
-def extract(filename, node, prefix):
+def extract(filename, node, prefix, output):
     if not (node.location.file is None or
             os.path.samefile(d(node.location.file.name), filename)):
         return 0
     if node.kind in RECURSE_LIST:
         sub_prefix = prefix
-        if node.kind != CursorKind.TRANSLATION_UNIT:
+        if node.kind not in PREFIX_BLACKLIST:
             if len(sub_prefix) > 0:
                 sub_prefix += '_'
             sub_prefix += d(node.spelling)
         for i in node.get_children():
-            extract(filename, i, sub_prefix)
+            extract(filename, i, sub_prefix, output)
     if node.kind in PRINT_LIST:
         comment = d(node.raw_comment) if node.raw_comment is not None else ''
         comment = process_comment(comment)
@@ -202,15 +210,15 @@ def extract(filename, node, prefix):
             sub_prefix += '_'
         if len(node.spelling) > 0:
             name = sanitize_name(sub_prefix + d(node.spelling))
-            global output
             output.append((name, filename, comment))
 
 
 class ExtractionThread(Thread):
-    def __init__(self, filename, parameters):
+    def __init__(self, filename, parameters, output):
         Thread.__init__(self)
         self.filename = filename
         self.parameters = parameters
+        self.output = output
         job_semaphore.acquire()
 
     def run(self):
@@ -219,13 +227,18 @@ class ExtractionThread(Thread):
             index = cindex.Index(
                 cindex.conf.lib.clang_createIndex(False, True))
             tu = index.parse(self.filename, self.parameters)
-            extract(self.filename, tu.cursor, '')
+            extract(self.filename, tu.cursor, '', self.output)
         finally:
             job_semaphore.release()
 
-if __name__ == '__main__':
-    parameters = ['-x', 'c++', '-std=c++11']
+
+def read_args(args):
+    parameters = []
     filenames = []
+    if "-x" not in args:
+        parameters.extend(['-x', 'c++'])
+    if not any(it.startswith("-std=") for it in args):
+        parameters.append('-std=c++11')
 
     if platform.system() == 'Darwin':
         dev_path = '/Applications/Xcode.app/Contents/Developer/'
@@ -240,17 +253,48 @@ if __name__ == '__main__':
             sysroot_dir = os.path.join(sdk_dir, next(os.walk(sdk_dir))[1][0])
             parameters.append('-isysroot')
             parameters.append(sysroot_dir)
-
-    for item in sys.argv[1:]:
+    elif platform.system() == 'Linux':
+        # clang doesn't find its own base includes by default on Linux,
+        # but different distros install them in different paths.
+        # Try to autodetect, preferring the highest numbered version.
+        def clang_folder_version(d):
+            return [int(ver) for ver in re.findall(r'(?<!lib)(?<!\d)\d+', d)]
+        clang_include_dir = max((
+            path
+            for libdir in ['lib64', 'lib', 'lib32']
+            for path in glob('/usr/%s/clang/*/include' % libdir)
+            if os.path.isdir(path)
+        ), default=None, key=clang_folder_version)
+        if clang_include_dir:
+            parameters.extend(['-isystem', clang_include_dir])
+
+    for item in args:
         if item.startswith('-'):
             parameters.append(item)
         else:
             filenames.append(item)
 
     if len(filenames) == 0:
-        print('Syntax: %s [.. a list of header files ..]' % sys.argv[0])
-        exit(-1)
+        raise NoFilenamesError("args parameter did not contain any filenames")
+
+    return parameters, filenames
+
+
+def extract_all(args):
+    parameters, filenames = read_args(args)
+    output = []
+    for filename in filenames:
+        thr = ExtractionThread(filename, parameters, output)
+        thr.start()
+
+    print('Waiting for jobs to finish ..', file=sys.stderr)
+    for i in range(job_count):
+        job_semaphore.acquire()
 
+    return output
+
+
+def write_header(comments, out_file=sys.stdout):
     print('''/*
   This file contains docstrings for the Python bindings.
   Do not edit! These were automatically extracted by mkdoc.py
@@ -274,20 +318,12 @@ if __name__ == '__main__':
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wunused-variable"
 #endif
-''')
+''', file=out_file)
 
-    output.clear()
-    for filename in filenames:
-        thr = ExtractionThread(filename, parameters)
-        thr.start()
-
-    print('Waiting for jobs to finish ..', file=sys.stderr)
-    for i in range(job_count):
-        job_semaphore.acquire()
 
     name_ctr = 1
     name_prev = None
-    for name, _, comment in list(sorted(output, key=lambda x: (x[0], x[1]))):
+    for name, _, comment in list(sorted(comments, key=lambda x: (x[0], x[1]))):
         if name == name_prev:
             name_ctr += 1
             name = name + "_%i" % name_ctr
@@ -295,10 +331,49 @@ if __name__ == '__main__':
             name_prev = name
             name_ctr = 1
         print('\nstatic const char *%s =%sR"doc(%s)doc";' %
-              (name, '\n' if '\n' in comment else ' ', comment))
+              (name, '\n' if '\n' in comment else ' ', comment), file=out_file)
 
     print('''
 #if defined(__GNUG__)
 #pragma GCC diagnostic pop
 #endif
-''')
+''', file=out_file)
+
+
+def mkdoc(args):
+    args = list(args)
+    out_path = None
+    for idx, arg in enumerate(args):
+        if arg.startswith("-o"):
+            args.remove(arg)
+            try:
+                out_path = arg[2:] or args.pop(idx)
+            except IndexError:
+                print("-o flag requires an argument")
+                exit(-1)
+            break
+
+    comments = extract_all(args)
+
+    if out_path:
+        try:
+            with open(out_path, 'w') as out_file:
+                write_header(comments, out_file)
+        except:
+            # In the event of an error, don't leave a partially-written
+            # output file.
+            try:
+                os.unlink(out_path)
+            except:
+                pass
+            raise
+    else:
+        write_header(comments)
+
+
+if __name__ == '__main__':
+    try:
+        mkdoc(sys.argv[1:])
+    except NoFilenamesError:
+        print('Syntax: %s [.. a list of header files ..]' % sys.argv[0])
+        exit(-1)
diff --git a/src/pybind11/tools/pybind11Config.cmake.in b/src/pybind11/tools/pybind11Config.cmake.in
index 6f0a406..8a7272f 100644
--- a/src/pybind11/tools/pybind11Config.cmake.in
+++ b/src/pybind11/tools/pybind11Config.cmake.in
@@ -90,8 +90,11 @@ if(NOT TARGET ${PN}::pybind11)
       set_property(TARGET ${PN}::module APPEND PROPERTY INTERFACE_LINK_LIBRARIES ${PYTHON_LIBRARIES})
     endif()
 
-    select_cxx_standard()
-    set_property(TARGET ${PN}::pybind11 APPEND PROPERTY INTERFACE_COMPILE_OPTIONS "${PYBIND11_CPP_STANDARD}")
+    if(CMAKE_VERSION VERSION_LESS 3.3)
+      set_property(TARGET ${PN}::pybind11 APPEND PROPERTY INTERFACE_COMPILE_OPTIONS "${PYBIND11_CPP_STANDARD}")
+    else()
+      set_property(TARGET ${PN}::pybind11 APPEND PROPERTY INTERFACE_COMPILE_OPTIONS $<$<COMPILE_LANGUAGE:CXX>:${PYBIND11_CPP_STANDARD}>)
+    endif()
 
     get_property(_iid TARGET ${PN}::pybind11 PROPERTY INTERFACE_INCLUDE_DIRECTORIES)
     get_property(_ill TARGET ${PN}::module PROPERTY INTERFACE_LINK_LIBRARIES)
diff --git a/src/pybind11/tools/pybind11Tools.cmake b/src/pybind11/tools/pybind11Tools.cmake
index 62de9c9..508e474 100644
--- a/src/pybind11/tools/pybind11Tools.cmake
+++ b/src/pybind11/tools/pybind11Tools.cmake
@@ -12,33 +12,33 @@ if(NOT PYBIND11_PYTHON_VERSION)
   set(PYBIND11_PYTHON_VERSION "" CACHE STRING "Python version to use for compiling modules")
 endif()
 
-set(Python_ADDITIONAL_VERSIONS 3.7 3.6 3.5 3.4)
+set(Python_ADDITIONAL_VERSIONS 3.9 3.8 3.7 3.6 3.5 3.4)
 find_package(PythonLibsNew ${PYBIND11_PYTHON_VERSION} REQUIRED)
 
 include(CheckCXXCompilerFlag)
 include(CMakeParseArguments)
 
-function(select_cxx_standard)
-  if(NOT PYBIND11_CPP_STANDARD)
-    if(NOT MSVC)
-      check_cxx_compiler_flag("-std=c++14" HAS_CPP14_FLAG)
-      check_cxx_compiler_flag("-std=c++11" HAS_CPP11_FLAG)
+if(NOT PYBIND11_CPP_STANDARD AND NOT CMAKE_CXX_STANDARD)
+  if(NOT MSVC)
+    check_cxx_compiler_flag("-std=c++14" HAS_CPP14_FLAG)
 
-      if (HAS_CPP14_FLAG)
-        set(PYBIND11_CPP_STANDARD -std=c++14)
-      elseif (HAS_CPP11_FLAG)
+    if (HAS_CPP14_FLAG)
+      set(PYBIND11_CPP_STANDARD -std=c++14)
+    else()
+      check_cxx_compiler_flag("-std=c++11" HAS_CPP11_FLAG)
+      if (HAS_CPP11_FLAG)
         set(PYBIND11_CPP_STANDARD -std=c++11)
       else()
         message(FATAL_ERROR "Unsupported compiler -- pybind11 requires C++11 support!")
       endif()
-    elseif(MSVC)
-      set(PYBIND11_CPP_STANDARD /std:c++14)
     endif()
-
-    set(PYBIND11_CPP_STANDARD ${PYBIND11_CPP_STANDARD} CACHE STRING
-        "C++ standard flag, e.g. -std=c++11, -std=c++14, /std:c++14.  Defaults to C++14 mode." FORCE)
+  elseif(MSVC)
+    set(PYBIND11_CPP_STANDARD /std:c++14)
   endif()
-endfunction()
+
+  set(PYBIND11_CPP_STANDARD ${PYBIND11_CPP_STANDARD} CACHE STRING
+      "C++ standard flag, e.g. -std=c++11, -std=c++14, /std:c++14.  Defaults to C++14 mode." FORCE)
+endif()
 
 # Checks whether the given CXX/linker flags can compile and link a cxx file.  cxxflags and
 # linkerflags are lists of flags to use.  The result variable is a unique variable name for each set
@@ -110,10 +110,10 @@ endfunction()
 
 # Build a Python extension module:
 # pybind11_add_module(<name> [MODULE | SHARED] [EXCLUDE_FROM_ALL]
-#                     [NO_EXTRAS] [THIN_LTO] source1 [source2 ...])
+#                     [NO_EXTRAS] [SYSTEM] [THIN_LTO] source1 [source2 ...])
 #
 function(pybind11_add_module target_name)
-  set(options MODULE SHARED EXCLUDE_FROM_ALL NO_EXTRAS THIN_LTO)
+  set(options MODULE SHARED EXCLUDE_FROM_ALL NO_EXTRAS SYSTEM THIN_LTO)
   cmake_parse_arguments(ARG "${options}" "" "" ${ARGN})
 
   if(ARG_MODULE AND ARG_SHARED)
@@ -130,15 +130,34 @@ function(pybind11_add_module target_name)
 
   add_library(${target_name} ${lib_type} ${exclude_from_all} ${ARG_UNPARSED_ARGUMENTS})
 
-  target_include_directories(${target_name}
+  if(ARG_SYSTEM)
+    set(inc_isystem SYSTEM)
+  endif()
+
+  target_include_directories(${target_name} ${inc_isystem}
     PRIVATE ${PYBIND11_INCLUDE_DIR}  # from project CMakeLists.txt
     PRIVATE ${pybind11_INCLUDE_DIR}  # from pybind11Config
     PRIVATE ${PYTHON_INCLUDE_DIRS})
 
+  # Python debug libraries expose slightly different objects
+  # https://docs.python.org/3.6/c-api/intro.html#debugging-builds
+  # https://stackoverflow.com/questions/39161202/how-to-work-around-missing-pymodule-create2-in-amd64-win-python35-d-lib
+  if(PYTHON_IS_DEBUG)
+    target_compile_definitions(${target_name} PRIVATE Py_DEBUG)
+  endif()
+
   # The prefix and extension are provided by FindPythonLibsNew.cmake
   set_target_properties(${target_name} PROPERTIES PREFIX "${PYTHON_MODULE_PREFIX}")
   set_target_properties(${target_name} PROPERTIES SUFFIX "${PYTHON_MODULE_EXTENSION}")
 
+  # -fvisibility=hidden is required to allow multiple modules compiled against
+  # different pybind versions to work properly, and for some features (e.g.
+  # py::module_local).  We force it on everything inside the `pybind11`
+  # namespace; also turning it on for a pybind module compilation here avoids
+  # potential warnings or issues from having mixed hidden/non-hidden types.
+  set_target_properties(${target_name} PROPERTIES CXX_VISIBILITY_PRESET "hidden")
+  set_target_properties(${target_name} PROPERTIES CUDA_VISIBILITY_PRESET "hidden")
+
   if(WIN32 OR CYGWIN)
     # Link against the Python shared library on Windows
     target_link_libraries(${target_name} PRIVATE ${PYTHON_LIBRARIES})
@@ -165,9 +184,12 @@ function(pybind11_add_module target_name)
     endif()
   endif()
 
-  select_cxx_standard()
   # Make sure C++11/14 are enabled
-  target_compile_options(${target_name} PUBLIC ${PYBIND11_CPP_STANDARD})
+  if(CMAKE_VERSION VERSION_LESS 3.3)
+    target_compile_options(${target_name} PUBLIC ${PYBIND11_CPP_STANDARD})
+  else()
+    target_compile_options(${target_name} PUBLIC $<$<COMPILE_LANGUAGE:CXX>:${PYBIND11_CPP_STANDARD}>)
+  endif()
 
   if(ARG_NO_EXTRAS)
     return()
@@ -175,10 +197,7 @@ function(pybind11_add_module target_name)
 
   _pybind11_add_lto_flags(${target_name} ${ARG_THIN_LTO})
 
-  if (NOT MSVC AND NOT ${CMAKE_BUILD_TYPE} MATCHES Debug)
-    # Set the default symbol visibility to hidden (very important to obtain small binaries)
-    target_compile_options(${target_name} PRIVATE "-fvisibility=hidden")
-
+  if (NOT MSVC AND NOT ${CMAKE_BUILD_TYPE} MATCHES Debug|RelWithDebInfo)
     # Strip unnecessary sections of the binary on Linux/Mac OS
     if(CMAKE_STRIP)
       if(APPLE)
@@ -194,6 +213,15 @@ function(pybind11_add_module target_name)
   if(MSVC)
     # /MP enables multithreaded builds (relevant when there are many files), /bigobj is
     # needed for bigger binding projects due to the limit to 64k addressable sections
-    target_compile_options(${target_name} PRIVATE /MP /bigobj)
+    target_compile_options(${target_name} PRIVATE /bigobj)
+    if(CMAKE_VERSION VERSION_LESS 3.11)
+      target_compile_options(${target_name} PRIVATE $<$<NOT:$<CONFIG:Debug>>:/MP>)
+    else()
+      # Only set these options for C++ files.  This is important so that, for
+      # instance, projects that include other types of source files like CUDA
+      # .cu files don't get these options propagated to nvcc since that would
+      # cause the build to fail.
+      target_compile_options(${target_name} PRIVATE $<$<NOT:$<CONFIG:Debug>>:$<$<COMPILE_LANGUAGE:CXX>:/MP>>)
+    endif()
   endif()
 endfunction()
